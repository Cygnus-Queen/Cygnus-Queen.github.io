<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="[课程地址]([Lab: System calls (mit.edu)])_ 本次实验是需要完成一些系统调用功能，在开始前需要先理解进程相关的概念和系统调用的原理 系统调用的原理回顾第二章书本上的知识，我们知道程序一般运行在用户态，只有遇到以下三种情况才会陷入中断进入内核态：  系统调用：当用户程序执行ecall指令要求内核为其做某事时。 异常：一条指令(用户或内核)做了一些非法的事情，如除以零或">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/MIT6.S081/Lab2/Lab2%20system%20calls.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[课程地址]([Lab: System calls (mit.edu)])_ 本次实验是需要完成一些系统调用功能，在开始前需要先理解进程相关的概念和系统调用的原理 系统调用的原理回顾第二章书本上的知识，我们知道程序一般运行在用户态，只有遇到以下三种情况才会陷入中断进入内核态：  系统调用：当用户程序执行ecall指令要求内核为其做某事时。 异常：一条指令(用户或内核)做了一些非法的事情，如除以零或">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-09-04T07:16:50.037Z">
<meta property="article:modified_time" content="2023-09-04T07:16:50.037Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="page-" class="h-entry article article-type-page" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/MIT6.S081/Lab2/Lab2%20system%20calls.html" class="article-date">
  <time class="dt-published" datetime="2023-09-04T07:16:50.037Z" itemprop="datePublished">2023-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[课程地址]([<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2021/labs/syscall.html">Lab: System calls (mit.edu)</a>])_</p>
<p>本次实验是需要完成一些系统调用功能，在开始前需要先理解进程相关的概念和系统调用的原理</p>
<h2 id="系统调用的原理"><a href="#系统调用的原理" class="headerlink" title="系统调用的原理"></a>系统调用的原理</h2><p>回顾第二章书本上的知识，我们知道程序一般运行在用户态，只有遇到以下三种情况才会陷入中断进入内核态：</p>
<ol>
<li><strong>系统调用</strong>：当用户程序执行<strong>ecall</strong>指令要求内核为其做某事时。</li>
<li><strong>异常</strong>：一条指令(用户或内核)做了一些非法的事情，如除以零或使用无效的虚拟地址。</li>
<li><strong>中断</strong>：当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时。</li>
</ol>
<p>所以研究系统调用，其实也就是研究中断（trap）过程是如何发生的。宏观上可分为四个步骤，本文会针对这四个步骤，结合xv6系统进行详细的讲解：</p>
<ol>
<li>中断请求</li>
<li>保护现场</li>
<li>中断处理</li>
<li>中断返回</li>
</ol>
<p>以上过程自然离不开与寄存器打交道，例如<strong>satp寄存器用于控制分页系统</strong>，以下是与trap相关的寄存器概述，这些寄存器可以分为两类：<br><strong>1. 发生中断时，硬件自动写入的寄存器</strong><br>    -  <code>sepc</code>：当trap发生时，RISC-V会将程序计数器保存在这里(因为<code>PC</code>会被<code>stvec</code>覆盖)。<code>sret</code>(从trap中返回)指令将<code>sepc</code>复制到<code>pc</code>中。内核可以写<code>sepc</code>来控制<code>sret</code>的返回到哪里。<br>    -  <code>scause</code>：RISC -V在这里放了一个数字，描述了trap的原因。<br>    -  <code>stval</code>：<code>scause</code> 不足以存下中断所有的必须信息。例如缺页异常，就会将 <code>stval</code> 设置成需要访问但是不在内存中的地址，以便于操作系统将这个地址所在的页面加载进来。</p>
<p><strong>2. 指导硬件处理中断的寄存器</strong><br>    - <code>stvec</code>：保存内核中断处理流程的入口地址，内核在这里写下trap处理程序的地址；RISC-V跳转到这里来处理trap。<br>    - <code>sstatus</code>：具有许多状态位，控制全局中断等。<code>sstatus</code>中的<strong>SIE</strong>位控制设备中断是否被启用，如果内核清除<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核设置<strong>SIE</strong>。<strong>SPP</strong>位表示trap是来自用户模式还是supervisor模式，并控制<code>sret</code>返回到什么模式。<br>    - <code>sie</code>：即 Supervisor Interrupt Enable，用来控制具体类型中断，例如其中的 STIE 控制时钟中断<br>    - <code>sip</code>：即 Supervisor Interrupt Pending，和 <code>sie</code> 相对应，记录每种中断是否被触发。仅当 <code>sie</code> 和 <code>sip</code> 的对应位都为 1 时，意味着开中断且已发生中断，这时中断最终触发。<br>    - <code>sscratch</code>：内核在这里放置了一个值，在trap处理程序开始时可以方便地使用。在用户态保存内核栈的地址，在内核态值为 0。为什么需要内核栈？因此中断处理流程也需要利用内存空间，很可能需要使用栈，而程序当前的用户栈是不安全的（说不定指针不断运行到其他进程的空间，破坏了隔离性）。因此，我们还需要一个预设的安全的栈空间，存放在这里。</p>
<p>有了上述与中断相关的寄存器，自然也就有与中断相关的指令：<br><strong>1. 进入和退出中断</strong><br>    - <code>ecall</code>：触发中断，进入更高一层的中断处理流程之中。用户态进行系统调用进入内核态中断处理流程，内核态进行 SBI 调用进入机器态中断处理流程，使用的都是这条指令。<br>    - <code>sret</code>：从内核态返回用户态，同时将 <code>sepc</code> 的值赋值给 <code>pc</code>。（如果需要返回到 <code>sepc</code> 后一条指令，就需要在 <code>sret</code> 之前修改 <code>sepc</code> 的值）<br>    - <code>ebreak</code>：触发一个断电<br>    - <code>mret</code>：从机器态返回内核态，同时将 <code>pc</code> 的值设置为 <code>mepc</code>。</p>
<p><strong>2. 操作CSR</strong><br>    只有一系列特殊的指令（CSR Instruction）可以读写 CSR<br>    - <code>csrrw dst, csr, src</code>（CSR Read Write）同时读写的原子操作，将指定 CSR 的值写入 <code>dst</code>，同时将 <code>src</code> 的值写入 CSR。<br>    - <code>csrr dst, csr</code>（CSR Read）：仅读取一个 CSR 寄存器。<br>    - <code>csrw csr, src</code>（CSR Write）  ：仅写入一个 CSR 寄存器。</p>
<p>微观上，RISC-V硬件对每一个trap操作（除定时器中断外），都会执行如下步骤：</p>
<ol>
<li>如果该trap是设备中断，且sstatus SIE位为0，则不执行以下任何操作</li>
<li>通过清除 SIE 来禁用中断</li>
<li>复制 pc 到 sepc</li>
<li>将当前模式(用户态或特权态)保存在 sstatus 的 SPP 位</li>
<li>在 scause 设置该次trap的原因</li>
<li>将模式转换为特权态</li>
<li>将 stvec 复制到 pc</li>
<li>从新的pc开始执行</li>
</ol>
<h4 id="中断请求"><a href="#中断请求" class="headerlink" title="中断请求"></a>中断请求</h4><p>当使用到<code>write，read，open</code>等系统调用时，会使用<code>ecall</code>指令发起中断请求</p>
<ul>
<li><code>ecall</code>是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用</li>
</ul>
<p>在xv6中，<code>user/cat.c</code>文件是<code>cat shell</code>指令的源码，其中涉及到了<code>read</code>函数，它声明在<code>user/user.h</code>文件中，但是<code>read</code>函数的实现在<code>kernel/sysfile.c</code>文件中。显然<code>cat</code>并不是直接调用<code>sysfile.c</code>文件中的函数来达成目标的，毕竟一个在用户态，一个在内核态。</p>
<p>既然<code>read</code>在用户态的角度看不见具体的逻辑实现，那它为什么能正常运行呢？只声明不实现的函数是无法正常使用的呀？</p>
<p>仔细观察user文件架，我们可以发现虽然没有<code>read</code>函数的c语言实现，但其实存在汇编实现。用户在c代码中使用<code>read</code>函数时，其实是在运行<code>usys.S</code>文件（由<code>usys.pl</code>文件得来，make指令才能看见）中<code>read</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c语言如何调用汇编函数？步骤：</span><br><span class="line">1、先在汇编程序中声明函数属性为GLOBAL</span><br><span class="line">2、在c文件开头声明该函数</span><br><span class="line">3、按照C语言正常调用函数的方式调用该函数</span><br></pre></td></tr></table></figure>

<p>当然，这个汇编函数虽然名称也叫<code>read</code>，但并不是在执行读取文件的逻辑，而是在建立用户态与内核态的桥梁。<code>usys.pl</code>脚本的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/perl -w  </span><br><span class="line">  </span><br><span class="line"># Generate usys.S, the stubs <span class="keyword">for</span> syscalls.  </span><br><span class="line">  </span><br><span class="line">print <span class="string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">print <span class="string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">sub entry &#123;  </span><br><span class="line">    my $name = shift;  </span><br><span class="line">    print <span class="string">&quot;.global $name\n&quot;</span>;  </span><br><span class="line">    print <span class="string">&quot;$&#123;name&#125;:\n&quot;</span>;  </span><br><span class="line">    print <span class="string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;  </span><br><span class="line">    print <span class="string">&quot; ecall\n&quot;</span>;  </span><br><span class="line">    print <span class="string">&quot; ret\n&quot;</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">     </span><br><span class="line">entry(<span class="string">&quot;fork&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;exit&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;wait&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;pipe&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;read&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;close&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;kill&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;exec&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;open&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;mknod&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;unlink&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;fstat&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;link&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;mkdir&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;chdir&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;dup&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;getpid&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;sbrk&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);  </span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>usys.pl</code>是一个Perl语言文件。即使对Perl语言并没有深入了解，但根据语法规则可以大概了解它的作用：这个脚本文件将根据输入的字符名，通过<code>entry()</code>格式化生成文本文件。</p>
<p><code>usys.pl</code>的输入是系统调用的名称，输出内容则保存为<code>kernel/usys.S</code>。这样每个系统调用都在<code>usys.S</code>文件中都有一个实现，通过<code>global</code>声明后，用户在使用同名的函数时，会执行这里的<code>entry()</code>中的逻辑：</p>
<ol>
<li>将系统调用的ID存入a7寄存器<ul>
<li>虽然输入的是名称（字符串），但是<code>kernel/syscall.h</code>文件下将字符串映射为了编号</li>
</ul>
</li>
<li>执行ecall命令<ul>
<li><code>ecall</code>是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用</li>
</ul>
</li>
</ol>
<p>这样就通过<code>ecall</code>指令（中断请求）将需要的系统调用从用户态传递给了内核态。在ecall调用过程中会发生（和前文中讲到的微观操作一致，但这里只写主要内容）：</p>
<ol>
<li>关中断</li>
<li>代码从<code>user mode</code>改到supervisor mode</li>
<li>程序计数器<code>PC</code>的值保存进 <code>SEPC</code> 寄存器</li>
<li>CPU执行<code>STVEC</code>寄存器指向的指令（<code>PC</code>重置为 <code>STVEC</code> 寄存器的值）</li>
</ol>
<p>问题：那么<code>STVEC</code>寄存器的值到底是多少？<br>答案：<code>STVEC</code>是一个特权寄存器，只能在supervisor mode下执行，每次从内核空间返回到用户空间之前，内核会设置<code>STVEC</code>寄存器指向内核希望中断代码运行的位置（由<code>trap.c</code>中的代码设置）。</p>
<p>Xv6在内核页表和每个用户页表中的<strong>同一个虚拟地址</strong>上映射了 <code>trampoline page</code> 。<code>STVEC</code> 寄存器保存的地址是 <code>trampoline page</code> 的起始位置，主要执行一些保护用户态寄存器的操作。<code>trampoline page</code> 的首地址是 <code>uservec</code> 函数。所以其实<code>STVEC</code>指向了<code>kernel/trampoline.S</code>文件中的<code>uservec</code>函数。</p>
<p><strong>综上，其实操作系统伪装了一个系统调用的实现，当使用<code>read</code>等函数时并没有真正的读写逻辑，而是利用ecall发起中断，并通过寄存器将函数的ID告知内核，方便在内核找到函数真正的实现。</strong></p>
<h4 id="保护现场"><a href="#保护现场" class="headerlink" title="保护现场"></a>保护现场</h4><p>上文讲到CPU将执行<code>uservec</code>函数（<code>kernel/trampoline.S</code>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">.globl uservec  </span><br><span class="line">uservec:      </span><br><span class="line">   #  </span><br><span class="line">        <span class="meta"># trap.c sets stvec to point here, so  </span></span><br><span class="line">        <span class="meta"># traps from user space start here,  </span></span><br><span class="line">        <span class="meta"># in supervisor mode, but with a  </span></span><br><span class="line">        <span class="meta"># user page table.  </span></span><br><span class="line">        #  </span><br><span class="line">        <span class="meta"># sscratch points to where the process<span class="string">&#x27;s p-&gt;trapframe is  </span></span></span><br><span class="line"><span class="string"><span class="meta">        # mapped into user space, at TRAPFRAME.  </span></span></span><br><span class="line"><span class="string"><span class="meta">        #  </span></span></span><br><span class="line"><span class="string"><span class="meta">        # swap a0 and sscratch  </span></span></span><br><span class="line"><span class="string"><span class="meta">        # so that a0 is TRAPFRAME  </span></span></span><br><span class="line"><span class="string"><span class="meta">        csrrw a0, sscratch, a0 </span></span></span><br><span class="line"><span class="string"><span class="meta">  </span></span></span><br><span class="line"><span class="string"><span class="meta">        # save the user registers in TRAPFRAME  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd ra, 40(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd sp, 48(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd gp, 56(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd tp, 64(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t0, 72(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t1, 80(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t2, 88(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s0, 96(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s1, 104(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a1, 120(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a2, 128(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a3, 136(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a4, 144(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a5, 152(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a6, 160(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a7, 168(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s2, 176(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s3, 184(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s4, 192(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s5, 200(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s6, 208(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s7, 216(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s8, 224(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s9, 232(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s10, 240(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s11, 248(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t3, 256(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t4, 264(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t5, 272(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t6, 280(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">  </span></span></span><br><span class="line"><span class="string"><span class="meta">   # save the user a0 in p-&gt;trapframe-&gt;a0  </span></span></span><br><span class="line"><span class="string"><span class="meta">        csrr t0, sscratch  </span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t0, 112(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">  </span></span></span><br><span class="line"><span class="string"><span class="meta">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp  </span></span></span><br><span class="line"><span class="string"><span class="meta">        ld sp, 8(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">  </span></span></span><br><span class="line"><span class="string"><span class="meta">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid  </span></span></span><br><span class="line"><span class="string"><span class="meta">        ld tp, 32(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">  </span></span></span><br><span class="line"><span class="string"><span class="meta">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap  </span></span></span><br><span class="line"><span class="string"><span class="meta">        ld t0, 16(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">  </span></span></span><br><span class="line"><span class="string"><span class="meta">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp  </span></span></span><br><span class="line"><span class="string"><span class="meta">        ld t1, 0(a0)  </span></span></span><br><span class="line"><span class="string"><span class="meta">        csrw satp, t1  //切换到内核页表</span></span></span><br><span class="line"><span class="string"><span class="meta">        sfence.vma zero, zero  </span></span></span><br><span class="line"><span class="string"><span class="meta">  </span></span></span><br><span class="line"><span class="string"><span class="meta">        # a0 is no longer valid, since the kernel page  </span></span></span><br><span class="line"><span class="string"><span class="meta">        # table does not specially map p-&gt;tf.  </span></span></span><br><span class="line"><span class="string"><span class="meta">  </span></span></span><br><span class="line"><span class="string"><span class="meta">        # jump to usertrap(), which does not return  </span></span></span><br><span class="line"><span class="string"><span class="meta">        jr t0</span></span></span><br></pre></td></tr></table></figure>

<p>在进程的结构中有一个结构体变量名为<code>trapframe</code>，它的作用是：</p>
<ol>
<li>发生中断时，保存进程在用户态使用的各种寄存器的值，以便于到时候恢复进程运行状态。</li>
<li>保存完成后，加载进程在内核态运行需要使用的寄存器的值</li>
</ol>
<p>在上面的代码中：</p>
<ol>
<li>先使用<code>csrrw</code>指令，将a0寄存器设置为<code>sscratch</code>寄存器的值，此时a0指向进程的<code>trapframe</code>结构。按照特定的顺序，保存寄存器的值。从偏移量40开始是因为，0到40（5 * 8）之间保存了5个内核态相关的值<code>（kernel_satp，kernel_sp，kernel_trap，epc，kernel_hartid）</code>，具体可参考<code>proc.h</code>文件中<code>trapframe</code>的结构。</li>
<li>恢复内核栈指针，将5个内核态相关的值加载进寄存器中，然后强制跳转执行<code>usertrap</code>函数（地址存储在<code>p-&gt;trapframe-&gt;kernel_trap</code>）。</li>
</ol>
<h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><p>在保存好上下文之后就要开始执行中断处理的逻辑了，这里使用的栈已经从用户栈变成了内核栈<br><code>usertrap</code>函数的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.  </span></span><br><span class="line"><span class="comment">// called from trampoline.S  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="type">void</span>  </span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)   <span class="comment">//判断中断是否合法</span></span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),  </span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.  </span></span><br><span class="line">  w_stvec((uint64)kernelvec);  </span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// save user program counter.  </span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();  <span class="comment">//保存sepc寄存器的值，前文提到了ecall指令执行后会将当前的PC保存到sepc中，因此 p-&gt;trapframe-&gt;epc其实指向ecall的最后一条指令</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;   <span class="comment">//scause记录了发生中断的原因，8是系统调用的代号</span></span><br><span class="line">    <span class="comment">// system call  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)  </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,  </span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.    </span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;   <span class="comment">//此时epc指向ecall，我们恢复上下文后执行下一条指令，因此+4</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,  </span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.    </span></span><br><span class="line">    intr_on();   <span class="comment">//开中断，允许内核在执行系统调用时嵌套中断</span></span><br><span class="line">  </span><br><span class="line">    syscall(); </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;  </span><br><span class="line">    <span class="comment">// ok  </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());  </span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.  </span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)  </span><br><span class="line">    yield();  </span><br><span class="line">  </span><br><span class="line">  usertrapret();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>usertrap</code>负责中断处理，主要通过调用三个函数完成<code>syscall,yield,usertrapret</code></p>
<p><code>yield</code>是在发生时钟中断时的处理逻辑，进程修改自己的状态并自愿放弃CPU使用权</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Give up the CPU for one scheduling round.  </span></span><br><span class="line"><span class="type">void</span>  </span><br><span class="line"><span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();  </span><br><span class="line">  acquire(&amp;p-&gt;lock);  </span><br><span class="line">  p-&gt;state = RUNNABLE;  </span><br><span class="line">  sched();  </span><br><span class="line">  release(&amp;p-&gt;lock);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>syscall()</code>是在发生系统调用时的处理逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  </span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="type">int</span> num;  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();  </span><br><span class="line">  </span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;  </span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;  </span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <span class="comment">//执行系统调用</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,  </span><br><span class="line">            p-&gt;pid, p-&gt;name, num);  </span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前文讲到在使用函数<code>read</code>时，并没有真正的实现代码，而是一步一步走到了这里，现在终于可以开始执行具体的<code>read</code>逻辑了。在<code>syscall</code>函数中，a7寄存器中保存了<code>read</code>的编号，系统调用表提供了一个从编号到对应函数指针的实现，通过函数指针就能找到对应需要执行的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//syscalls是一个函数指针数组</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;  </span><br><span class="line">[SYS_fork]    sys_fork,   <span class="comment">//sys_fork是一个宏定义，其实是数字1</span></span><br><span class="line">[SYS_exit]    sys_exit,   <span class="comment">//同理</span></span><br><span class="line">[SYS_wait]    sys_wait,  </span><br><span class="line">[SYS_pipe]    sys_pipe,  </span><br><span class="line">[SYS_read]    sys_read,  </span><br><span class="line">[SYS_kill]    sys_kill,  </span><br><span class="line">[SYS_exec]    sys_exec,  </span><br><span class="line">[SYS_fstat]   sys_fstat,  </span><br><span class="line">[SYS_chdir]   sys_chdir,  </span><br><span class="line">[SYS_dup]     sys_dup,  </span><br><span class="line">[SYS_getpid]  sys_getpid,  </span><br><span class="line">[SYS_sbrk]    sys_sbrk,  </span><br><span class="line">[SYS_sleep]   sys_sleep,  </span><br><span class="line">[SYS_uptime]  sys_uptime,  </span><br><span class="line">[SYS_open]    sys_open,  </span><br><span class="line">[SYS_write]   sys_write,  </span><br><span class="line">[SYS_mknod]   sys_mknod,  </span><br><span class="line">[SYS_unlink]  sys_unlink,  </span><br><span class="line">[SYS_link]    sys_link,  </span><br><span class="line">[SYS_mkdir]   sys_mkdir,  </span><br><span class="line">[SYS_close]   sys_close,  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sys_read</code>代码如下，此时才执行真正的<code>read</code>逻辑</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64  </span><br><span class="line"><span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span>  </span><br><span class="line">  <span class="type">int</span> n;  </span><br><span class="line">  uint64 p;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;n) &lt; <span class="number">0</span> || argaddr(<span class="number">1</span>, &amp;p) &lt; <span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">  <span class="keyword">return</span> fileread(f, p, n);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code>完成了系统调用过程并将返回值保存在a0寄存器，系统调用逻辑执行完毕，因此需要开始中断返回。</p>
<h4 id="中断返回"><a href="#中断返回" class="headerlink" title="中断返回"></a>中断返回</h4><p><code>usertrapret</code>函数被<code>usertrap</code>调用，用来从内核态返回用户态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// return to user space  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="type">void</span>  </span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();   </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from  </span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until  </span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.  </span></span><br><span class="line">  intr_off();  <span class="comment">//关中断，不能在执行中断恢复过程时嵌套中断</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to trampoline.S  </span></span><br><span class="line">  <span class="comment">// 因为在执行ecall指令后，CPU几哦执行STVEC寄存器指向的指令（PC重置为 STVEC寄存器的值）</span></span><br><span class="line">  <span class="comment">// 所以设置STVEC寄存器的值为我们想要中断发生时执行的代码的地址（前文提到的uservec函数）</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when  </span></span><br><span class="line">  <span class="comment">// the process next re-enters the kernel.  </span></span><br><span class="line">  <span class="comment">// 和发生中断时保存上下文类似，内核使用完毕，即将进入用户态，要将目前的值保存起来，</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table  </span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack  </span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;  </span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()  </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use  // to get to user space.     // set S Previous Privilege mode to User.  </span></span><br><span class="line">  <span class="comment">// 设置CPU特权等级，从supervisor mode 到user mode（也就是将操作系统从内核态修改为用户态）</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();  </span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode  </span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode  </span></span><br><span class="line">  w_sstatus(x);  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.  </span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);   <span class="comment">//修改sepc寄存器的值，在sret指令后，sepc的值会写入pc，此时sepc指向ecall的下一条指令</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.  </span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// jump to trampoline.S at the top of memory, which   </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,  </span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.  </span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//调用userret函数（trampoline.S），userret(TRAPFRAME, pagetable)</span></span><br><span class="line">  ((<span class="type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>userret</code>函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">.globl userret  </span><br><span class="line">userret:  </span><br><span class="line">        <span class="meta"># userret(TRAPFRAME, pagetable)  </span></span><br><span class="line">        <span class="meta"># switch from kernel to user.  </span></span><br><span class="line">        <span class="meta"># usertrapret() calls here.  </span></span><br><span class="line">        # a0: TRAPFRAME, in user page table.   函数传参时使用a0，a1寄存器</span><br><span class="line">        # a1: user page table, <span class="keyword">for</span> satp.  </span><br><span class="line">  </span><br><span class="line">        <span class="meta"># switch to the user page table.  </span></span><br><span class="line">        csrw satp, a1  </span><br><span class="line">        sfence.vma zero, zero  </span><br><span class="line">  </span><br><span class="line">        <span class="meta"># put the saved user a0 in sscratch, so we  </span></span><br><span class="line">        <span class="meta"># can swap it with our a0 (TRAPFRAME) in the last step.  </span></span><br><span class="line">        ld t0, <span class="number">112</span>(a0)  </span><br><span class="line">        csrw sscratch, t0  </span><br><span class="line">  </span><br><span class="line">        <span class="meta"># restore all but a0 from TRAPFRAME  </span></span><br><span class="line">        ld ra, <span class="number">40</span>(a0)  </span><br><span class="line">        ld sp, <span class="number">48</span>(a0)  </span><br><span class="line">        ld gp, <span class="number">56</span>(a0)  </span><br><span class="line">        ld tp, <span class="number">64</span>(a0)  </span><br><span class="line">        ld t0, <span class="number">72</span>(a0)  </span><br><span class="line">        ld t1, <span class="number">80</span>(a0)  </span><br><span class="line">        ld t2, <span class="number">88</span>(a0)  </span><br><span class="line">        ld s0, <span class="number">96</span>(a0)  </span><br><span class="line">        ld s1, <span class="number">104</span>(a0)  </span><br><span class="line">        ld a1, <span class="number">120</span>(a0)  </span><br><span class="line">        ld a2, <span class="number">128</span>(a0)  </span><br><span class="line">        ld a3, <span class="number">136</span>(a0)  </span><br><span class="line">        ld a4, <span class="number">144</span>(a0)  </span><br><span class="line">        ld a5, <span class="number">152</span>(a0)  </span><br><span class="line">        ld a6, <span class="number">160</span>(a0)  </span><br><span class="line">        ld a7, <span class="number">168</span>(a0)  </span><br><span class="line">        ld s2, <span class="number">176</span>(a0)  </span><br><span class="line">        ld s3, <span class="number">184</span>(a0)  </span><br><span class="line">        ld s4, <span class="number">192</span>(a0)  </span><br><span class="line">        ld s5, <span class="number">200</span>(a0)  </span><br><span class="line">        ld s6, <span class="number">208</span>(a0)  </span><br><span class="line">        ld s7, <span class="number">216</span>(a0)  </span><br><span class="line">        ld s8, <span class="number">224</span>(a0)  </span><br><span class="line">        ld s9, <span class="number">232</span>(a0)  </span><br><span class="line">        ld s10, <span class="number">240</span>(a0)  </span><br><span class="line">        ld s11, <span class="number">248</span>(a0)  </span><br><span class="line">        ld t3, <span class="number">256</span>(a0)  </span><br><span class="line">        ld t4, <span class="number">264</span>(a0)  </span><br><span class="line">        ld t5, <span class="number">272</span>(a0)  </span><br><span class="line">        ld t6, <span class="number">280</span>(a0)  </span><br><span class="line">  </span><br><span class="line">   <span class="meta"># restore user a0, and save TRAPFRAME in sscratch  </span></span><br><span class="line">        csrrw a0, sscratch, a0  </span><br><span class="line">          </span><br><span class="line">        <span class="meta"># return to user mode and user pc.  </span></span><br><span class="line">        <span class="meta"># usertrapret() set up sstatus and sepc.  </span></span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<p><code>userret</code>代码的主要功能和<code>uservec</code>正好相反，后者是将用户运行时的寄存器信息保存起来，切换到内核页表；前者是将这些保存起来的寄存器值恢复回去，切换到用户页表</p>
<p>随着<code>sret</code>指令的调用，整个中断过程完成，sepc寄存器中的值填回pc，用户程序恢复正常执行</p>
<h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>参照教程，在实验2前应该：</p>
<ul>
<li>仔细阅读<code>Chapter 2、 Chapter 4 的 Sections 4.3 and 4.4</code></li>
<li>仔细阅读<code>user/user.h</code>,<code>user/usys.pl</code>，学习xv6中工具函数和系统调用原型</li>
<li>仔细阅读<code>kernel/syscall.h</code>,<code>kernel/syscall.c</code>,系统调用实现</li>
<li>仔细阅读<code>kernel/proc.h</code>,<code>kernel/proc.c</code>，进程代码实现</li>
</ul>
<p>如果是从前文一步一步看到这里，那么这些代码相当于已经看过了，下面直接看练习要求：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">实验要求：</span><br><span class="line"></span><br><span class="line">实现一个系统调用追踪的功能：trace mask command命令，</span><br><span class="line">- mask 表示系统调用号的掩码</span><br><span class="line">- command 表示命令</span><br><span class="line">- 能够实现如下效果</span><br><span class="line"></span><br><span class="line"><span class="comment">//因由于read的系统调用号是5，因此（1 &lt;&lt; 5,10000) 如果输入的数字从右往左第六位为1，则需要追踪read，即十进制数字32表示仅需要追踪read系统调用</span></span><br><span class="line">$ trace <span class="number">32</span> grep hello README</span><br><span class="line"><span class="number">3</span>: syscall read -&gt; <span class="number">1023</span></span><br><span class="line"><span class="number">3</span>: syscall read -&gt; <span class="number">966</span></span><br><span class="line"><span class="number">3</span>: syscall read -&gt; <span class="number">70</span></span><br><span class="line"><span class="number">3</span>: syscall read -&gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2147483647的二进制是1111111111111111111111111111111，因为所有位都为1，说明所有系统调用都需要追踪</span></span><br><span class="line">$ trace <span class="number">2147483647</span> grep hello README</span><br><span class="line"><span class="number">4</span>: syscall trace -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">4</span>: syscall exec -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">4</span>: syscall open -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">4</span>: syscall read -&gt; <span class="number">1023</span></span><br><span class="line"><span class="number">4</span>: syscall read -&gt; <span class="number">966</span></span><br><span class="line"><span class="number">4</span>: syscall read -&gt; <span class="number">70</span></span><br><span class="line"><span class="number">4</span>: syscall read -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">4</span>: syscall close -&gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//没有trace指令，不追踪，不能影响其他程序的正常运行</span></span><br><span class="line">$ grep hello README</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line"><span class="comment">//fork的系统调用号是1，因此(1 &lt;&lt; 2，2)如果输入的数字从右往左第二位为1，则仅需要追踪fork，</span></span><br><span class="line">$ trace <span class="number">2</span> usertests forkforkfork</span><br><span class="line">usertests starting</span><br><span class="line">test forkforkfork: <span class="number">407</span>: syscall fork -&gt; <span class="number">408</span></span><br><span class="line"><span class="number">408</span>: syscall fork -&gt; <span class="number">409</span></span><br><span class="line"><span class="number">409</span>: syscall fork -&gt; <span class="number">410</span></span><br><span class="line"><span class="number">410</span>: syscall fork -&gt; <span class="number">411</span></span><br><span class="line"><span class="number">409</span>: syscall fork -&gt; <span class="number">412</span></span><br><span class="line"><span class="number">410</span>: syscall fork -&gt; <span class="number">413</span></span><br><span class="line"><span class="number">409</span>: syscall fork -&gt; <span class="number">414</span></span><br><span class="line"><span class="number">411</span>: syscall fork -&gt; <span class="number">415</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>理解了需求，再结合前文提到的系统调用过程，可以想想我们为了完成任务可以做些什么？<br>首先，一个完整的系统调用从一个用户态的<code>shell</code>函数开始，trace.c文件已经提供给了我们：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span>  </span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="comment">//存储待跟踪程序的名称和参数  </span></span><br><span class="line">    <span class="type">char</span> *nargv[MAXARG];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//保证trace的参数不少于三个，并且跟踪的系统调用号在0-99之间  </span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span> || (argv[<span class="number">1</span>][<span class="number">0</span>] &lt; <span class="string">&#x27;0&#x27;</span> || argv[<span class="number">1</span>][<span class="number">0</span>] &gt; <span class="string">&#x27;9&#x27;</span>))&#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: %s mask command\n&quot;</span>, argv[<span class="number">0</span>]);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//调用trace系统调用，传入待跟踪系统调用号  </span></span><br><span class="line">    <span class="keyword">if</span> (trace(atoi(argv[<span class="number">1</span>])) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="number">0</span>]);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//保存待跟踪程序的名称和参数  </span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;  </span><br><span class="line">        nargv[i<span class="number">-2</span>] = argv[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//运行待跟踪的程序  </span></span><br><span class="line">    exec(nargv[<span class="number">0</span>], nargv);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于trace的语法规定了，第二个参数必须是待追踪系统调用的数字，因此具体的执行逻辑就是通过<code>argv[2]</code>取出这个数字，然后传递到内核态，然后执行一系列的操作。</p>
<p>当我们需要完成一个系统调用，有了用户态的代码，自然需要增加对该系统调用的用户态声明，即在<code>user/user.h</code>文件中新增trace的系统调用声明<code>int trace(int);</code></p>
<p>有了声明就需要有实现，但这个实现不是真正的函数实现，而是凭借<code>ecall</code>指令进入内核态，这个部分是<code>usys.pl</code>负责完成，因此需要在代码中增添<code>entry(trace)</code></p>
<p><code>entry(trace)</code>，将trace的系统调用名称放入a7寄存器，下一步就是通过系统调用名称在系统调用表中找到对应的系统调用编号。因此需要在<code>kernel/syscall.h</code>中新增<code>#define SYS_trace  22</code>，并且在<code>kernel/syscall.c</code>中增添<code>sys_trace</code>的函数声明<code>extern uint64 sys_trace(void);</code>，在系统调用表中新增<code>SYS_trace</code>（即22号调用）到函数实现的映射关系，<code>[SYS_trace]   sys_trace,</code></p>
<p>最后，这是个和进程相关的系统调用，因此在<code>kernel/sysproc.c</code>中新增<code>sys_trace</code>函数的实现。</p>
<p>完成了前面的步骤，看着下面空荡荡的函数代码，我们应该怎么去完成一个trace任务呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint64  </span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们可能会追踪任何一个系统调用，但我们不可能修改所有系统调用的代码，因此可以想到从他们共有的内容下手，<strong>由于所有的系统调用都是通过<code>syscall.c中的syscall</code>函数来执行的，并且所有系统调用的运行参数和结果均保存在<code>proc</code>结构体中的<code>trapframe</code>结构体中，例如a7保存当前进程系统调用的编号，a0表示系统调用执行的结果。因此只需要<code>proc结构体 + syscall函数</code>，我们就可以达成任务目标。</strong></p>
<p>可以考虑先在proc结构体中添加一个标记，作为判断执行trace的判断标准，然后在syscall添加一段逻辑：如果当前proc对应的标记为真，则打印输出当前系统调用的结果。</p>
<p>总结以上过程：</p>
<ol>
<li>在proc结构体中添加标记：<code>int trace_mask;  </code></li>
<li>修改<code>syscall</code>函数：<code>num</code>是系统调用号，如果<code>（1 &lt;&lt; num）与mask（用户输入的值）的&amp;运算结果为1</code>，则说明需要执行<code>trace</code>操作，例如如果<code>mask</code>的第二位和第六位都为1，则<code>num</code>为<code>read</code>和<code>fork</code>时就需要执行<code>trace</code>操作。<br> 注意：由于在内核态只能拿到系统调用编号，但是用户希望在看到的是系统调用的名称，因此还需要一个表格，建立从系统调用编号到系统调用名称的映射，也就是下面代码中的<code>syscalls_name</code> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lab2 trace 添加识别名  </span></span><br><span class="line">   <span class="type">char</span>* syscalls_name[<span class="number">23</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>,                <span class="string">&quot;exec&quot;</span>,  <span class="string">&quot;fstat&quot;</span>, <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>,                   <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;close&quot;</span>, <span class="string">&quot;trace&quot;</span>&#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="type">void</span>  </span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="type">int</span> num;  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();  </span><br><span class="line">  </span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;  </span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;  </span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();  </span><br><span class="line">    <span class="comment">//---------------------添加的部分--------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;trace_mask &amp; (<span class="number">1</span> &lt;&lt; num))&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid,syscalls_name[num],p-&gt;trapframe-&gt;a0);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//--------------------------------------------------------------------</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,  </span><br><span class="line">            p-&gt;pid, p-&gt;name, num);  </span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>由此可见，trace操作的核心代码并不在<code>sys_trace</code>函数中，而是在<code>syscall</code>函数，那么<code>sys_trace</code>函数是干什么用的？</p>
<p>答案：取参数。用户态的trace.c代码中写明，使用trace时会传递一个参数，表示需要监视的系统调用号，而函数传参则是通过寄存器，第一个参数保存在a0寄存器，取参数需要使用<code>syscall.c中的argraw，argaddr，argint</code>三个函数，具体的实现可以看代码，<code>argraw(n)</code>是获取了发生中断时，$a_n$寄存器对应的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> uint64  </span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();  </span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;  </span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:  </span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;  </span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:  </span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;  </span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:  </span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;  </span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:  </span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;  </span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:  </span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;  </span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:  </span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;  </span><br><span class="line">  &#125;  </span><br><span class="line">  panic(<span class="string">&quot;argraw&quot;</span>);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fetch the nth 32-bit system call argument.  </span></span><br><span class="line"><span class="type">int</span>  </span><br><span class="line"><span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  *ip = argraw(n);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>sys_trace</code>代码如下，将取回的参数放入proc结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">uint64  </span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="type">int</span> mask;  </span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">  myproc()-&gt;trace_mask = mask;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，实验要求fork新诞生的子进程执行系统调用时也要打印出来，因此需要修改fork代码，子进程的<code>trace_mask</code>值应与父进程保持一致：<code>np-&gt;trace_mask = p-&gt;trace_mask;</code></p>
<p>这样整个实验就完成了</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/MIT6.S081/Lab2/Lab2%20system%20calls.html" data-id="clomm1vep0003acvyhb3z0rk4" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/11/06/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>