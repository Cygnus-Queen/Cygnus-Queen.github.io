

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Cygnus">
  <meta name="keywords" content="">
  
    <meta name="description" content="redis全程远程字典服务，是一个C语言实现的基于内存的k-v数据库 基础 Redis 与 Memcached 都基于内存，但是redis应用更广，更适合用作缓存，不同点在于：（1）Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet）（2）Redis 支持数据的持久化（3）Redis 原生支持集群模式（4）Redis 支持发布订阅模型、Lua 脚本、事务等功能 为">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis学习总结">
<meta property="og:url" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Cygnus的博客">
<meta property="og:description" content="redis全程远程字典服务，是一个C语言实现的基于内存的k-v数据库 基础 Redis 与 Memcached 都基于内存，但是redis应用更广，更适合用作缓存，不同点在于：（1）Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet）（2）Redis 支持数据的持久化（3）Redis 原生支持集群模式（4）Redis 支持发布订阅模型、Lua 脚本、事务等功能 为">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240412213857.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240413134635.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240412220316.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240412221721.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240413134343.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240413140848.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240413143235.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240413143622.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240420152306.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240422103319.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240425154655.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240425193027.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240425165144.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240426205946.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240426211403.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240426212117.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240426220323.png">
<meta property="og:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240426220639.png">
<meta property="article:published_time" content="2024-04-30T07:28:22.000Z">
<meta property="article:modified_time" content="2024-04-30T07:32:59.922Z">
<meta property="article:author" content="Cygnus">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/04/30/Redis%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240412213857.png">
  
  
  
  <title>Redis学习总结 - Cygnus的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cygnus</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/%E4%BB%99%E5%89%91%E9%97%AE%E6%83%85%E5%A5%B3%E7%A5%9E.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Redis学习总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-30 15:28" pubdate>
          2024年4月30日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          25k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          213 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Redis学习总结</h1>
            
            
              <div class="markdown-body">
                
                <p>redis全程远程字典服务，是一个C语言实现的基于内存的k-v数据库</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p> Redis 与 Memcached 都基于内存，但是redis应用更广，更适合用作缓存，<strong>不同点在于</strong>：<br>（1）Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet）<br>（2）Redis 支持数据的持久化<br>（3）Redis 原生支持集群模式<br>（4）Redis 支持发布订阅模型、Lua 脚本、事务等功能</p>
<h3 id="为什么要使用redis？"><a href="#为什么要使用redis？" class="headerlink" title="为什么要使用redis？"></a>为什么要使用redis？</h3><p>主要是因为<strong>Redis 具备「高性能」和「高并发」两种特性</strong>：<br>（1）高性能：将从mysql读取到的数据缓存在redis中，可以使得之后的访问很快<br>（2）高并发： Redis 单台设备的 QPS 是 MySQL 的 10 倍，可以突破10w，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的</p>
<h3 id="键值对数据库是怎么实现的？"><a href="#键值对数据库是怎么实现的？" class="headerlink" title="键值对数据库是怎么实现的？"></a>键值对数据库是怎么实现的？</h3><p>Redis 的键值对中的 key 就是字符串对象，而 <strong>value 可以是字符串对象，也可以是集合数据类型的对象</strong>（比如 List 对象、Hash 对象、Set 对象和 Zset 对象）</p>
<p>redis保存这些键值对涉及到一系列数据结构：<br><img src="Pasted image 20240412213857.png" srcset="/img/loading.gif" lazyload alt></p>
<p>（1）redisDb 结构<br>    表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；<br>（2）dict 结构<br>    结构体里存放了 2 个哈希表，平时使用哈希表1， rehash 时使用哈希表2<br>（3）ditctht 结构<br>    表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针<br>（4）dictEntry 结构<br>    表示哈希表节点的结构，结构里存放了 <strong>void <em> key 和 void </em> value 指针<br>     key 和 value 指针指向的是 </strong>Redis 对象**（redisObject）</p>
<p>redisObject结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//四种不同的数据结构</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_STRING 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_LIST 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_SET 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_ZSET 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REDIS_HASH 4</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>	<span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;        <span class="hljs-comment">//表示具体的数据类型</span><br>	<span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;    <span class="hljs-comment">//表示当前数据类型使用的编码方式（一种类型有多种可选的编码方式）</span><br>	<span class="hljs-type">unsigned</span> lru:REDIS_LRU_BITS; <span class="hljs-comment">/* lru time (relative to server.lruclock) */</span><br>	<span class="hljs-type">int</span> refcount;           <span class="hljs-comment">//对象的引用计数</span><br>	<span class="hljs-type">void</span> *ptr;              <span class="hljs-comment">//指向真正的存储结构，也就是string，list，hash，zset等等</span><br>&#125; robj;<br><br></code></pre></td></tr></table></figure></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>在具体到每种数据结构之前，我们需要知道所有的键值对其实在redis中都是一个C语言的<br><strong>所以其实下文所讲到的各种数据结构，都是ptr指针指向的结构</strong></p>
<p>目前Redis 提供了丰富的数据类型，常见的有五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。</strong></p>
<p>后来还追加了四种特殊场景的数据结构，<strong>BitMap</strong>、<strong>HyperLogLog</strong>、<strong>GEO</strong>、<strong>Stream</strong></p>
<p>注意，不同的版本的数据类型使用的数据结构是不同的：<br><img src="Pasted image 20240413134635.png" srcset="/img/loading.gif" lazyload alt></p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值最多可以容纳 512M</p>
<p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）</p>
<p>字符串对象的内部编码（encoding）有 3 种 ：<br>（1）<strong>int 编码</strong>：保存long 型的64位有符号整数（基于int）<br>（2）<strong>embstr 编码</strong>：保存长度小于44字节的字符串（基于SDS）<br>（2）<strong>raw 编码</strong>：保存长度大于44字节的字符串（基于SDS）</p>
<h4 id="内部实现（int）"><a href="#内部实现（int）" class="headerlink" title="内部实现（int）"></a>内部实现（int）</h4><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将<code>void*</code>转换成 long），并将字符串对象的编码设置为int<br><img src="Pasted image 20240412220316.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="内部实现（SDS）"><a href="#内部实现（SDS）" class="headerlink" title="内部实现（SDS）"></a>内部实现（SDS）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//sds结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> len;    <span class="hljs-comment">//字符串长度</span><br>    <span class="hljs-type">uint32_t</span> alloc;  <span class="hljs-comment">//字符串容量（包含已经分配但还没使用的部分）</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">//表示sds的类型（8位）</span><br>    <span class="hljs-type">char</span> buf[];  <span class="hljs-comment">//用于存储数据，不仅可以保存字符串，也可以保存二进制数据</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>redis是c语言实现的，但并没有使用char<em> 来表示字符串，而是创造了一个SDS结构，改进在于：<br>（1）保存二进制数据<br>    因为 SDS 不需要用 “\0” 字符来标识字符串结尾，所以<em>*可存储包含 “\0” 的数据</em></em>。SDS 的API 会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。<br>（2）获取字符串长度的时间复杂度为O(1)<br>     C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)<br>（3）API安全，不会因为拼接字符串导致缓冲区溢出<br>     SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题</p>
<p>扩容规则（和Go slice的扩容很相似，go是容量小于 1024则新切片翻倍，否则增加25%）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">hisds <span class="hljs-title function_">hi_sdsMakeRoomFor</span><span class="hljs-params">(hisds s, <span class="hljs-type">size_t</span> addlen)</span><br>&#123;<br>    ... ...<br>    <span class="hljs-comment">// s目前的剩余空间已足够，无需扩展，直接返回</span><br>    <span class="hljs-keyword">if</span> (avail &gt;= addlen)<br>        <span class="hljs-keyword">return</span> s;<br>    <span class="hljs-comment">//获取目前s的长度</span><br>    len = hi_sdslen(s);<br>    sh = (<span class="hljs-type">char</span> *)s - hi_sdsHdrSize(oldtype);<br>    <span class="hljs-comment">//扩展之后 s 至少需要的长度</span><br>    newlen = (len + addlen);<br>    <br>    <span class="hljs-comment">//计算分配的新空间大小，HI_SDS_MAX_PREALLOC默认为1MB</span><br>    <span class="hljs-keyword">if</span> (newlen &lt; HI_SDS_MAX_PREALLOC) <br>        <span class="hljs-comment">//新长度&lt;HI_SDS_MAX_PREALLOC 则翻倍扩容</span><br>        newlen *= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//否则扩容1MB</span><br>        newlen += HI_SDS_MAX_PREALLOC;<br>       ...<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>在扩容 SDS 空间之前，SDS API 会优先检查未使用空间是否足够，如果不够的话，API 不仅会为 SDS 分配修改所必须要的空间，还会给 SDS 分配额外的「未使用空间」，<strong>有效的减少内存分配次数</strong></p>
<p>SDS 结构中有个 flags 成员变量，表示的是 SDS 类型，共五种（ sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，<strong>它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr16</span> &#123;</span> <br>    <span class="hljs-type">uint16_t</span> len;  <span class="hljs-comment">//字符数组长度和分配空间大小不能超过 2 的 16 次方</span><br>    <span class="hljs-type">uint16_t</span> alloc; <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr32</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> len;  <span class="hljs-comment">//字符数组长度和分配空间大小不能超过 2 的 32 次方</span><br>    <span class="hljs-type">uint32_t</span> alloc; <br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags;<br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>设计<strong>不同类型的结构体，是为了节省内存空间</strong>，同时取消内存对齐（attribute__关键字），进一步节省空间。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>（1）缓存对象<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">直接缓存整个对象的 <span class="hljs-type">JSON</span>，命令例子： <br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span> <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18&#125;&#x27;</span><br><br>采用将 key 进行分离为 <span class="hljs-keyword">user</span>:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： <br>MSET <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span>:<span class="hljs-type">name</span> xiaolin <span class="hljs-keyword">user</span>:<span class="hljs-number">1</span>:age <span class="hljs-number">18</span> <span class="hljs-keyword">user</span>:<span class="hljs-number">2</span>:<span class="hljs-type">name</span> xiaomei <span class="hljs-keyword">user</span>:<span class="hljs-number">2</span>:age <span class="hljs-number">20</span>。<br></code></pre></td></tr></table></figure></p>
<p>（2）常规计数<br>Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 初始化文章的阅读量</span><br>&gt; <span class="hljs-built_in">SET</span> aritcle:readcount:1001 0<br>OK<br><br><span class="hljs-comment">#阅读量+1</span><br>&gt; INCR aritcle:readcount:1001<br>(integer) 1<br><br><span class="hljs-comment"># 获取对应文章的阅读量</span><br>&gt; <span class="hljs-built_in">GET</span> aritcle:readcount:1001<br><span class="hljs-string">&quot;3&quot;</span><br></code></pre></td></tr></table></figure>
<p>（3）实现分布式锁<br>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//一般还会对分布式锁加上过期时间</span><br><span class="hljs-keyword">SET</span> lock_key <span class="hljs-comment">unique_value NX PX 10000</span><br></code></pre></td></tr></table></figure></p>
<p>（4）共享 Session 信息</p>
<p>在开发后台管理系统时，会使用 Session 来保存用户的会话登录状态，但是涉及到分布式时就不行了，因为登录业务和后续业务可能不再一个服务器。因此可以借助 Redis 对这些 Session 信息进行统一的存储和管理。（这样做其实也有缺陷，那就是redis的负载过高）</p>
<p><img src="Pasted image 20240412221721.png" srcset="/img/loading.gif" lazyload alt><br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">问题：<span class="hljs-keyword">session</span>共享的方案有哪些？<br>答案：<br>（<span class="hljs-number">1</span>）<span class="hljs-keyword">session</span>复制，，存在大量冗余 ×<br>（<span class="hljs-number">2</span>）客户端存储，不安全 ×<br>（<span class="hljs-number">3</span>）hash一致性，保证同一个客户端每次的请求都会被同一个服务器处理 ✔<br>（<span class="hljs-number">4</span>）统一存储，将用户的信息存储在第三方中间件上，例如redis ✔<br></code></pre></td></tr></table></figure></p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="双向链表（新版本不再使用）"><a href="#双向链表（新版本不再使用）" class="headerlink" title="双向链表（新版本不再使用）"></a>双向链表（新版本不再使用）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br>    <span class="hljs-comment">//链表头节点</span><br>    listNode *head;<br>    <span class="hljs-comment">//链表尾节点</span><br>    listNode *tail;<br>    <span class="hljs-comment">//节点值复制函数</span><br>    <span class="hljs-type">void</span> *(*dup)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-comment">//节点值释放函数</span><br>    <span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>)(<span class="hljs-type">void</span> *ptr);<br>    <span class="hljs-comment">//节点值比较函数</span><br>    <span class="hljs-type">int</span> (*match)(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">void</span> *key);<br>    <span class="hljs-comment">//链表节点数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;<br>&#125; <span class="hljs-built_in">list</span>;<br><br></code></pre></td></tr></table></figure>
<p>当ptr指向list结构体时，redisObject就变成了链表</p>
<p><img src="Pasted image 20240413134343.png" srcset="/img/loading.gif" lazyload alt></p>
<p>链表的优势不用多说，O(1)的复杂度获取节点数量、首位节点<br>缺陷在于：<br>（1）内存不连续，CPU缓存命中率低<br>（2）<strong>内存开销较大</strong></p>
<p>Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现</p>
<h4 id="压缩列表（新版本不再使用）"><a href="#压缩列表（新版本不再使用）" class="headerlink" title="压缩列表（新版本不再使用）"></a>压缩列表（新版本不再使用）</h4><p>压缩列表被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且针对不同长度的数据，进行相应编码，有效地节省内存开销（有点类似数组，但数组存储不同长度的字符时，会选择最大的字符长度作为每个节点的内存大小，浪费空间）</p>
<p><img src="Pasted image 20240413140848.png" srcset="/img/loading.gif" lazyload alt><br>压缩列表中，查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位O(1)</p>
<ul>
<li><strong>zlbytes</strong>，记录整个压缩列表占用对内存字节数；</li>
<li><strong>zltail</strong>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li>
<li><strong>zllen</strong>，记录压缩列表包含的节点数量；</li>
<li><strong>zlend</strong>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li>
</ul>
<p>压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息</p>
<ul>
<li><strong>prevlen</strong>，记录了「前一个节点」的长度（小于254字节占用1字节，否则5字节）；</li>
<li><strong>encoding</strong>，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。</li>
<li><strong>data</strong>，记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定；</li>
</ul>
<p>然而压缩列表在新版本的redis中已经不使用了，原因连锁更新问题：<br>    <strong>当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降</strong><br>    例子：假如整个列表元素的大小都介于250-253字节，prevlen都是1字节，这时候头部插入一个大元素，第二个元素的prevlen需要扩展为5字节，导致元素大小超过254字节，后续元素的prevlen也需要扩展为5字节，<strong>导致连锁反应</strong></p>
<p>因此，压缩列表只会用于保存的节点数量不多的场景，只要节点数量足够小，即使发生连锁更新，也是能接受的</p>
<h4 id="quicklist（新版本不再使用）"><a href="#quicklist（新版本不再使用）" class="headerlink" title="quicklist（新版本不再使用）"></a>quicklist（新版本不再使用）</h4><p>quicklist 就是「双向链表 + 压缩列表」的组合，既然压缩列表只能用于节点数量小的场景，太长会导致连锁更新，那我直接将多个压缩列表组合在一起不就ok了？</p>
<p><img src="Pasted image 20240413143235.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>quicklist通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklist</span> &#123;</span><br>    <span class="hljs-comment">//quicklist的链表头</span><br>    quicklistNode *head;      <span class="hljs-comment">//quicklist的链表头</span><br>    <span class="hljs-comment">//quicklist的链表尾</span><br>    quicklistNode *tail; <br>    <span class="hljs-comment">//所有压缩列表中的总元素个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count;<br>    <span class="hljs-comment">//quicklistNodes的个数，注意，这里体现了和双向链表的区别，节点个数不代表元素的个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;       <br>    ...<br>&#125; quicklist;<br></code></pre></td></tr></table></figure>
<p>节点串成一个双向链表，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> &#123;</span><br>    <span class="hljs-comment">//前一个quicklistNode</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">prev</span>;</span>     <span class="hljs-comment">//前一个quicklistNode</span><br>    <span class="hljs-comment">//下一个quicklistNode</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">next</span>;</span>     <span class="hljs-comment">//后一个quicklistNode</span><br>    <span class="hljs-comment">//quicklistNode指向的压缩列表</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl;              <br>    <span class="hljs-comment">//压缩列表的的字节大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz;                <br>    <span class="hljs-comment">//压缩列表的元素个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count : <span class="hljs-number">16</span>;        <span class="hljs-comment">//ziplist中的元素个数 </span><br>    ....<br>&#125; quicklistNode;<br></code></pre></td></tr></table></figure></p>
<p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p>
<p>缺陷：quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题</p>
<h4 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h4><p> quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，<strong>无法避免</strong>，所以要想彻底解决这个问题，需要设计一个新的数据结构</p>
<p>Redis 在 5.0 新设计一个数据结构叫 listpack用来替代压缩列表，最大特点是 listpack 中每个节点不再包含前一个节点的长度了（这正是压缩列表连锁更新的根源）</p>
<p>但这样话如何划分每个元素的边界呢？</p>
<p><img src="Pasted image 20240413143622.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li>
<li>data，实际存放的数据；</li>
<li>len，encoding+data的总长度；</li>
</ul>
<p><strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong></p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">问题：压缩列表的<span class="hljs-keyword">entry</span>为什么要保存prevlen呢？listpack改成len之后不会影响功能吗？<br>答案：压缩列表的 <span class="hljs-keyword">entry</span> 保存 prevlen 是为了实现节点从后往前遍历，知道前一个节点的长度，就可以计算前一个节点的偏移量。<br></code></pre></td></tr></table></figure>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>Hash 是一个键值对（key - value）集合，其中 value 的形式如： <code>value=[&#123;field1，value1&#125;，...&#123;fieldN，valueN&#125;]</code>。Hash 特别适合用于存储对象</p>
<h4 id="内部实现（listpack）"><a href="#内部实现（listpack）" class="headerlink" title="内部实现（listpack）"></a>内部实现（listpack）</h4><p>这一部分已经在链表的部分讲了</p>
<h4 id="内部实现（hash）"><a href="#内部实现（hash）" class="headerlink" title="内部实现（hash）"></a>内部实现（hash）</h4><p>hash表没什么好讲的</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>（1）缓存对象<br>    Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象（结构体）</p>
<p>（2）购物车<br>    以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 添加商品：<span class="hljs-code">`HSET cart:&#123;用户id&#125; &#123;商品id&#125; 1`</span><br><span class="hljs-bullet">-</span> 添加数量：<span class="hljs-code">`HINCRBY cart:&#123;用户id&#125; &#123;商品id&#125; 1`</span><br><span class="hljs-bullet">-</span> 商品总数：<span class="hljs-code">`HLEN cart:&#123;用户id&#125;`</span><br><span class="hljs-bullet">-</span> 删除商品：<span class="hljs-code">`HDEL cart:&#123;用户id&#125; &#123;商品id&#125;`</span><br><span class="hljs-bullet">-</span> 获取购物车所有商品：<span class="hljs-code">`HGETALL cart:&#123;用户id&#125;`</span><br></code></pre></td></tr></table></figure><br><img src="Pasted image 20240420152306.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-meta"># 存储一个哈希表key的键值</span><br>HSET key <span class="hljs-keyword">field</span> value<span class="hljs-meta">   </span><br><span class="hljs-meta"># 获取哈希表key对应的field键值</span><br>HGET key <span class="hljs-keyword">field</span><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta"># 在一个哈希表key中存储多个键值对</span><br>HMSET key <span class="hljs-keyword">field</span> value [<span class="hljs-keyword">field</span> value...]<span class="hljs-meta"> </span><br><span class="hljs-meta"># 批量获取哈希表key中多个field键值</span><br>HMGET key <span class="hljs-keyword">field</span> [<span class="hljs-keyword">field</span> ...]<span class="hljs-meta">       </span><br><span class="hljs-meta"># 删除哈希表key中的field键值</span><br>HDEL key <span class="hljs-keyword">field</span> [<span class="hljs-keyword">field</span> ...]  <br></code></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储</p>
<p>一个集合最多可以存储 <code>2^32-1</code> 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集</p>
<p>Set 类型和 List 类型的区别在于前者无先后顺序且不能重复，后者元素有先后顺序且可以重复</p>
<h4 id="内部实现（intset-和-hash）"><a href="#内部实现（intset-和-hash）" class="headerlink" title="内部实现（intset 和 hash）"></a>内部实现（intset 和 hash）</h4><ul>
<li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>（intset）作为 Set 类型的底层数据结构；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">intset</span> &#123;<br>    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">uint32_t</span> encoding;<br>    <span class="hljs-comment">// 集合包含的元素数量</span><br>    <span class="hljs-type">uint32_t</span> length;<br>    <span class="hljs-comment">// 保存元素的数组</span><br>    <span class="hljs-type">int8_t</span> contents[];  <br><br>&#125; intset;<br></code></pre></td></tr></table></figure>
<p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 ，contents 数组的真正类型取决于 encoding 属性的值</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56176555">redis 整数集合 - 知乎 (zhihu.com)</a></p>
<ul>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>hash</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>集合的主要几个特性，无序、不可重复、支持并交差等操作</p>
<p>注意：<strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong></p>
<p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计</p>
<p>（1）点赞<br>    Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># uid:1 用户对文章 article:1 点赞</span><br>&gt; SADD article:<span class="hljs-number">1</span> uid:<span class="hljs-number">1</span><br>(integer) <span class="hljs-number">1</span><br><br># 获取 article:<span class="hljs-number">1</span> 文章所有点赞用户 :<br>&gt; SMEMBERS article:<span class="hljs-number">1</span><br> （<span class="hljs-number">1</span>) <span class="hljs-string">&quot;uid:1&quot;</span><br> <br># 获取 article:<span class="hljs-number">1</span> 文章的点赞用户数量：<br>&gt; SCARD article:<span class="hljs-number">1</span><br>(integer) <span class="hljs-number">1</span><br><br><span class="hljs-meta"># uid:1 取消了对 article:1 文章点赞。</span><br>&gt; SREM article:<span class="hljs-number">1</span> uid:<span class="hljs-number">1</span><br>(integer) <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></p>
<p>（2）共同关注<br>    Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。<br>    key 可以是用户id，value 则是已关注的公众号的id</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"># 获取共同关注<br>&gt; SINTER uid:<span class="hljs-number">1</span> uid:<span class="hljs-number">2</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;7&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;8&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;9&quot;</span><br><br># 给uid:<span class="hljs-number">2</span> 推荐 uid:<span class="hljs-number">1</span> 关注的公众号：做差集<br>&gt; SDIFF uid:<span class="hljs-number">1</span> uid:<span class="hljs-number">2</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;5&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;6&quot;</span><br><br># 验证某个公众号是否同时被 uid:<span class="hljs-number">1</span> 或 uid:<span class="hljs-number">2</span> 关注:<br>&gt; SISMEMBER uid:<span class="hljs-number">1</span> <span class="hljs-number">5</span><br>(integer) <span class="hljs-number">1</span> # 返回<span class="hljs-number">0</span>，说明关注了<br>&gt; SISMEMBER uid:<span class="hljs-number">2</span> <span class="hljs-number">5</span><br>(integer) <span class="hljs-number">0</span> # 返回<span class="hljs-number">0</span>，说明没关注<br></code></pre></td></tr></table></figure>
<p>（3）抽奖活动<br><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-variable constant_">SPOP</span> lucky <span class="hljs-number">1</span></span><br>（1) &quot;Sary&quot;<br></code></pre></td></tr></table></figure></p>
<h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。</p>
<h4 id="内部实现（listpack）-1"><a href="#内部实现（listpack）-1" class="headerlink" title="内部实现（listpack）"></a>内部实现（listpack）</h4><p>Zset 类型的底层数据结构原本是由压缩列表或跳表实现的，redis7.0以后交给了<strong>listpack</strong></p>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><p>Zset 类型（Sorted Set，有序集合） 可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大</p>
<p>在面对需要展示<strong>最新列表、排行榜</strong>等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set</p>
<p>（1）排行榜<br>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># arcticle:1 文章获得了200个赞</span><br>&gt; ZADD user:xiaolin:ranking <span class="hljs-number">200</span> arcticle:<span class="hljs-number">1</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-meta"># arcticle:2 文章获得了40个赞</span><br>&gt; ZADD user:xiaolin:ranking <span class="hljs-number">40</span> arcticle:<span class="hljs-number">2</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-meta"># arcticle:3 文章获得了100个赞</span><br>&gt; ZADD user:xiaolin:ranking <span class="hljs-number">100</span> arcticle:<span class="hljs-number">3</span><br>(integer) <span class="hljs-number">1</span><br><br># 文章 arcticle:<span class="hljs-number">3</span> 新增一个赞<br>&gt; ZINCRBY user:xiaolin:ranking <span class="hljs-number">1</span> arcticle:<span class="hljs-number">3</span><br><span class="hljs-string">&quot;101&quot;</span><br><br># 获取小林文章赞数最多的 <span class="hljs-number">3</span> 篇文章，倒序获取有序集合 key 从start下标到stop下标的元<br>&gt; ZREVRANGE user:xiaolin:ranking <span class="hljs-number">0</span> <span class="hljs-number">1</span> WITHSCORES<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;arcticle:1&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;200&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;arcticle:3&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;101&quot;</span><br><br># 获取小林<span class="hljs-number">100</span>赞到<span class="hljs-number">200</span>赞的文章<br>&gt; ZRANGEBYSCORE user:xiaolin:ranking <span class="hljs-number">100</span> <span class="hljs-number">200</span> WITHSCORES<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;arcticle:3&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;101&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;arcticle:1&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;200&quot;</span><br><br></code></pre></td></tr></table></figure></p>
<p>（2）电话、姓名排序</p>
<h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)</p>
<p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong></p>
<h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p>
<p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组</p>
<h4 id="应用场景：二值统计"><a href="#应用场景：二值统计" class="headerlink" title="应用场景：二值统计"></a>应用场景：二值统计</h4><p>Bitmap 类型非常适合二值状态统计的场景，这里的二值状态就是指集合元素的取值就只有 0 和 1 两种，在记录海量数据时，Bitmap 能够有效地节省内存空间</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 设置值，其中value只能是 0 和 1</span><br>SETBIT <span class="hljs-built_in">key</span> offset value<br><br><span class="hljs-meta"># 获取值</span><br>GETBIT <span class="hljs-built_in">key</span> offset<br><br><span class="hljs-meta"># 获取指定范围内值为 1 的个数</span><br><span class="hljs-meta"># start 和 end 以字节为单位</span><br>BITCOUNT <span class="hljs-built_in">key</span> start <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p>（1）签到统计</p>
<p>（2）判断用户登录状态<br>Bitmap 提供了 <code>GETBIT、SETBIT</code> 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始</p>
<p>假如我们要判断 ID = 10086 的用户的登陆情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">GETBIT login_status <span class="hljs-number">10086</span> <span class="hljs-comment">//检查是否登入</span><br><br>SETBIT login_status <span class="hljs-number">10086</span> <span class="hljs-number">0</span> <span class="hljs-comment">//登出</span><br>SETBIT login_status <span class="hljs-number">10086</span> <span class="hljs-number">1</span> <span class="hljs-comment">//登入</span><br></code></pre></td></tr></table></figure>
<p>（3）连续签到用户总数</p>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>一种用于「统计基数」的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%</p>
<p>简单来说 HyperLogLog <strong>提供不精确的去重计数</strong></p>
<p>HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的内存空间总是固定的、并且是很小的</p>
<h4 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h4><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><p>（1）百万级网页的UV计数（独立访客数）</p>
<p>Redis HyperLogLog 优势在于只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间</p>
<p>在统计 UV 时，用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">PFADD</span> page1:uv user1 user2 user3 user4 user5<br></code></pre></td></tr></table></figure></p>
<p>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">PFCOUNT</span> page1:uv<br></code></pre></td></tr></table></figure>
<p>注意：计算可能存在误差，因此不能用于精确计数</p>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>GEO主要用于存储地理位置信息，并对存储的信息进行操作</p>
<p>在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中</p>
<h4 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h4><p>zset，GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数</p>
<p>可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索附近”的需求</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs maxima"># 存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(<span class="hljs-built_in">member</span>)添加到指定的 <span class="hljs-built_in">key</span> 中。<br>GEOADD <span class="hljs-built_in">key</span> longitude latitude <span class="hljs-built_in">member</span> [longitude latitude <span class="hljs-built_in">member</span> ...]<br><br># 从给定的 <span class="hljs-built_in">key</span> 里返回所有指定名称(<span class="hljs-built_in">member</span>)的位置（经度和纬度），不存在的返回 nil。<br>GEOPOS <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...]<br><br># 返回两个给定位置之间的距离。<br>GEODIST <span class="hljs-built_in">key</span> member1 member2 [m|km|ft|mi]<br><br># 根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。<br>GEORADIUS <span class="hljs-built_in">key</span> longitude latitude <span class="hljs-built_in">radius</span> m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE <span class="hljs-built_in">key</span>] [STOREDIST <span class="hljs-built_in">key</span>]<br></code></pre></td></tr></table></figure>
<h4 id="应用场景（基于位置服务，LBS）"><a href="#应用场景（基于位置服务，LBS）" class="headerlink" title="应用场景（基于位置服务，LBS）"></a>应用场景（基于位置服务，LBS）</h4><p>（1）滴滴打车<br>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations</p>
<p>执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GEOADD</span> cars:locations <span class="hljs-number">116</span>.<span class="hljs-number">034579</span> <span class="hljs-number">39</span>.<span class="hljs-number">030452</span> <span class="hljs-number">33</span><br></code></pre></td></tr></table></figure></p>
<p>当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。<br>例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GEORADIUS</span> cars:locations <span class="hljs-number">116</span>.<span class="hljs-number">054579</span> <span class="hljs-number">39</span>.<span class="hljs-number">030452</span> <span class="hljs-number">5</span> km ASC COUNT <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></p>
<h3 id="消息队列stream"><a href="#消息队列stream" class="headerlink" title="消息队列stream"></a>消息队列stream</h3><p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：<br>（1）发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷<br>（2）List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis 是内存数据库，但是它为数据的持久化提供了两个技术，分别是「 AOF 日志和 RDB 快照」</p>
<h3 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h3><p> Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里，然后重启 Redis 的时候，先去读取这个文件里的命令，并且执行它，以达到持久化的目的</p>
<ol>
<li>Redis 执行完写操作命令后，会将命令追加到 <code>server.aof_buf</code> 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>Always，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；<br><span class="hljs-bullet">- </span>Everysec，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；<br><span class="hljs-bullet">- </span>No，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。<br><br>注意：这三种方法的区别在于调用fsync()的时机<br><br></code></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h4><p>AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢</p>
<p>Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件<br>    AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">问题：为什么重写 AOF 的时候，不直接复用现有的 AOF 文件，而是先写到新的 AOF 文件再覆盖过去<br>答案：避免污染，如果 AOF 重写过程失败了，现有的 AOF 文件就会造成污染。<br></code></pre></td></tr></table></figure>
<p>Redis 的<strong>重写 AOF 过程是由后台子进程 <em>bgrewriteaof</em> 来完成的</strong>“：<br>（1）子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；<br>（2）子进程带有主进程的数据副本<br>    这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</p>
<p>在这个过程中有两个阶段会阻塞主进程：<br>（1） 创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；<br>（2）创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">问题：重写 AOF 日志过程中，如果主进程修改了数据，子进程的数据主进程的数据不一致了怎么办？<br>答案：Redis 设置了一个 AOF 重写缓冲区，这个缓冲区在创建 <span class="hljs-keyword">bgrewriteaof </span>子进程之后开始使用，在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」<br></code></pre></td></tr></table></figure>
<p><img src="Pasted image 20240422103319.png" srcset="/img/loading.gif" lazyload alt></p>
<p>总的来说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作：<br>（1）执行客户端发来的命令；<br>（2）将执行后的写命令追加到 「AOF 缓冲区」；<br>（3）将执行后的写命令追加到 「AOF 重写缓冲区」；</p>
<p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p>
<p>主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：<br>（1）将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致<br>（2）新的 AOF 的文件进行改名，覆盖现有的 AOF 文件</p>
<p><strong>在整个 AOF 后台重写过程中，除了发生写时复制会对主进程造成阻塞，还有信号处理函数执行时也会对主进程造成阻塞，在其他时候，AOF 后台重写都不会阻塞主进程</strong></p>
<h3 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a>RDB 快照</h3><p>RDB 快照就是记录某一个瞬间的内存数据，AOF 文件记录的是命令操作的日志，不是实际的数据<br>因此在 Redis 恢复数据时，直接将 RDB 文件读入内存就可以了，效率比AOF高</p>
<h4 id="如何使用快照？"><a href="#如何使用快照？" class="headerlink" title="如何使用快照？"></a>如何使用快照？</h4><p>Redis 提供了两个命令来生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>，他们的区别就在于是否在「主线程」里执行<br>（1）执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong><br>（2）执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong></p>
<p>RDB 文件的加载工作是在服务器启动时自动执行的</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">//通过save指令可以定时触发bgsave命令，只要满足下面条件的任意一个</span><br><span class="hljs-keyword">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>      <span class="hljs-comment">//900 秒之内，对数据库进行了至少 1 次修改；</span><br><span class="hljs-keyword">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span>     <span class="hljs-comment">//300 秒之内，对数据库进行了至少 10 次修改</span><br><span class="hljs-keyword">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span>   <span class="hljs-comment">//60 秒之内，对数据库进行了至少 10000 次修改</span><br></code></pre></td></tr></table></figure>
<p>每次执行快照，都是把内存中的「所有数据」都记录到磁盘中，因此比较<strong>耗时</strong>。通常可能设置至少 5 分钟才保存一次快照，这时如果 Redis 出现宕机等情况，则意味着最多可能丢失 5 分钟数据</p>
<h4 id="执行快照时，数据能被修改吗？"><a href="#执行快照时，数据能被修改吗？" class="headerlink" title="执行快照时，数据能被修改吗？"></a>执行快照时，数据能被修改吗？</h4><p>由于写时复制技术，主进程页表与fork出的子进程的页表映射同一段物理内存。子进程可以大胆的执行读操作，然后写入磁盘。父进程的读操作也不影响。</p>
<p>当主进程出现写操作时，触发中断分配新的物理内存，子进程<strong>RDB 快照保存的是原本的内存数据</strong>。如果这个时候发生故障，那么最新的数据就会丢失。</p>
<h2 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h2><p>缓存的淘汰分为：<br>（1）过期删除<br>（2）内存淘汰<br>前者针对设置了过期时间的key，后者针对内存达到要求之后的情况</p>
<h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><p>设置过期时间的语句<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">- <span class="hljs-keyword">set</span> <span class="hljs-symbol">&lt;key&gt;</span> <span class="hljs-symbol">&lt;value&gt;</span> <span class="hljs-keyword">ex</span> <span class="hljs-symbol">&lt;n&gt;</span> ：设置键值对的时候，同时指定过期时间（精确到秒）；<br></code></pre></td></tr></table></figure></p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss">问题：Redis如何判定<span class="hljs-built_in">Key</span>过期的？<br>答案：每当我们对一个 <span class="hljs-built_in">key</span> 设置了过期时间时，Redis 会把该 <span class="hljs-built_in">key</span> 带上过期时间存储到一个**过期字典**（expires dict）中，也就是说「过期字典」保存了数据库中所有 <span class="hljs-built_in">key</span> 的过期时间<br><br>typedef <span class="hljs-keyword">struct</span> <span class="hljs-type">redisDb</span> &#123;<br>    dict *dict;    <span class="hljs-comment">/* 数据库键空间，存放着所有的键值对 */</span><br>    dict *expires; <span class="hljs-comment">/* 键的过期时间 */</span><br>    ....<br>&#125; redisDb;<br><br></code></pre></td></tr></table></figure>
<p><img src="Pasted image 20240425154655.png" srcset="/img/loading.gif" lazyload alt></p>
<p>当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中，如果不在就正常读取，如果在就获取过期时间与系统时间进行对比，判定是否过期</p>
<p>过期删除策略，是删除已过期的 key</p>
<p>（1）定时删除<br>    <strong>在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作</strong><br>    优点：过期的key能尽快释放，对内存友好<br>    缺点：在Key比较多时会对服务器的响应时间和吞吐量造成影响，对CPU不友好</p>
<p>（2）惰性删除<br>    <strong>不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key</strong><br>    优点：对CPU友好<br>    缺点：对内存不友好，过期 key 一直没有被访问，它所占用的内存就不会释放</p>
<p>（3）定期删除<br>    <strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key</strong><br>    结合了（1）和（3）</p>
<p>Redis采用 <strong>「惰性删除+定期删除」</strong>：<br>（1）每次访问Key之前都要判断是否过期<br>（2）每10s检查20个key，删除过期key，如果占比大于25%则循环</p>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key</p>
<p>在配置文件 redis.conf 中，可以通过参数 <code>maxmemory &lt;bytes&gt;</code> 来设定最大运行内存，只有在 Redis 的运行内存达到了我们设置的最大运行内存，才会触发内存淘汰策略，64位系统默认为0</p>
<h4 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h4><p>（1）不进行数据淘汰<br>    <strong>noeviction</strong>（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作<br>（2）进行数据淘汰的策略<br>    下面的方法都可以指定范围（<strong>从设置了过期时间的淘汰或者在所有数据范围内进行淘汰</strong>）<br>    random（随机淘汰）<br>    lru（淘汰最久没使用的键值）<br>    lfu（淘汰最少使用的键值）</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gauss">问题：Redis的LRU是怎么做的？<br>答案：Redis的LRU是经过优化的，Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间，进行内存淘汰时，会随机取 <span class="hljs-number">5</span> 个值（此值可配置），然后淘汰最久没有使用的那个，避免维护一个大的链表<br><br>追问：LRU不行吗？为什么引入LFU？<br>答案：LRU 算法无法解决缓存污染问题（MySQL的buffer pool也面临这种问题），LFU会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些<br><br>追问：LFU是如何实现的？<br>答案：在 LRU 算法中，Redis对象头的<span class="hljs-number">24</span> bits的 lru字段是用来记录<span class="hljs-built_in">key</span>的访问时间戳，在LFU中，Redis对象头的<span class="hljs-number">24</span> bits的lru字段被分成两段来存储，高<span class="hljs-number">16</span>bit存储ldt，低<span class="hljs-number">8</span>bit存储logc。<br>（<span class="hljs-number">1</span>）ldt 是用来记录 <span class="hljs-built_in">key</span> 的访问时间戳<br>（<span class="hljs-number">2</span>）logc 是用来记录 <span class="hljs-built_in">key</span> 的访问频次（注意不是频率），它的值越小表示使用频率越低，越容易淘汰<br><br>LFU先按照上次访问距离当前的时长，来对 logc 进行衰减，然后，再按照一定概率增加 logc 的值<br></code></pre></td></tr></table></figure>
<h2 id="缓存安全"><a href="#缓存安全" class="headerlink" title="缓存安全"></a>缓存安全</h2><p>用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，如果用户的请求都访问数据库的话，很容易崩溃。为了避免用户直接访问数据库，会用 Redis 作为缓存层。</p>
<p>引入了缓存层，就会有缓存异常的三个问题，分别是<strong>缓存雪崩、缓存击穿、缓存穿透</strong>。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，大量的用户请求无法在 Redis 中处理，都直接访问数据库，导致数据库压力骤增，形成一系列连锁反应，造成整个系统崩溃的情况就是<strong>缓存雪崩</strong></p>
<h4 id="过期导致的缓存雪崩"><a href="#过期导致的缓存雪崩" class="headerlink" title="过期导致的缓存雪崩"></a>过期导致的缓存雪崩</h4><p>如何避免过期导致的缓存雪崩？<br>（1）均匀设置过期时间<br>    缓存数据设置过期时间时加上一个<strong>随机数</strong>，保证数据不会在同一时间过期<br>（2）添加互斥锁<br>    当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>，并通过设置过期时间避免死锁<br>（3）缓存不设置过期时间<br>    让缓存“永久有效”，并将更新缓存的工作交由<strong>后台线程定时更新</strong></p>
<p>还有一种情况就是在业务刚上线的时候，缓存为空导致数据库压力大，解决方案是提前把热点数据缓存起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong></p>
<h4 id="服务器宕机导致的缓存雪崩"><a href="#服务器宕机导致的缓存雪崩" class="headerlink" title="服务器宕机导致的缓存雪崩"></a>服务器宕机导致的缓存雪崩</h4><p>如何避免服务器宕机导致的缓存雪崩？<br>（1）<strong>服务熔断</strong>或<strong>请求限流</strong>机制<br>    Redis 故障宕机而导致缓存雪崩问时，我们可以启动<strong>服务熔断</strong>机制，<strong>暂停业务应用对缓存服务的访问，直接返回错误</strong>，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务<br>    为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，<strong>只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务</strong>，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制<br>（2）构建 Redis 缓存高可靠集群<br>    通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>，如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>我们的业务通常会有几个数据会被频繁地访问，被称为热点数据。<br>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题</p>
<p>可以认为缓存击穿是缓存雪崩的一个子集</p>
<p>如何解决缓存击穿？<br>（1）互斥锁方案<br>    保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值<br>（2）不给热点数据设置过期时间<br>    由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间</p>
<p>注意：xv6实验中的自旋锁就会导致CPU缓存击穿，所有CPU都必须访问内存</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>前两种情况，数据库保存了应用要访问的数据，只是过期了而已，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了</p>
<p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题</p>
<p>解决的方案：<br>（1）<strong>限制非法请求</strong><br>    当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。<br>（2）<strong>缓存空值或者默认值</strong><br>    当线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库（在程序化广告业务的实习中遇到过）<br>（3）使用<strong>布隆过滤器</strong>快速判断数据是否存在，避免查询数据库<br>    我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。<br>布隆过滤器会通过 3 个操作完成标记：<br>（1）使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值<br>（2）将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置<br>（3）将每个哈希值在位图数组的对应位置的值设置为 1</p>
<p><img src="Pasted image 20240425193027.png" srcset="/img/loading.gif" lazyload alt></p>
<p><strong>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p>
<p>注意：布隆过滤器说数据存在不一定真的存在，但说不存在则一定不存在</p>
<h2 id="缓存与数据库一致性"><a href="#缓存与数据库一致性" class="headerlink" title="缓存与数据库一致性"></a>缓存与数据库一致性</h2><p>由于引入了缓存，那么在数据更新时，不仅要更新数据库，而且要更新缓存，这两个更新操作存在前后的问题。</p>
<p><a target="_blank" rel="noopener" href="http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/">http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/</a></p>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>如果Redis服务只在一台服务器上部署，一旦服务器宕机就完蛋了：<br>（1）服务不可用：由于数据恢复是需要点时间，那么这个期间是无法服务新的请求的。<br>（2）数据丢失：如果是服务器硬盘坏了，那么历史数据就都丢失了</p>
<p>要避免这种单点故障，最好的办法是将数据备份到其他服务器上，让这些服务器也可以对外提供服务，这样即使有一台服务器出现了故障，其他服务器依然可以继续提供服务</p>
<p>Redis 提供了<strong>主从复制模式</strong>的功能。这个模式可以保证多台服务器的数据一致性，且主从服务器之间采用的是「读写分离」的方式</p>
<p><img src="Pasted image 20240425165144.png" srcset="/img/loading.gif" lazyload alt></p>
<p>所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的，</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"># 服务器 <span class="hljs-selector-tag">B</span> 执行这条命令可以让自己变成<span class="hljs-selector-tag">A</span>的从服务器<br>replicaof &lt;服务器 <span class="hljs-selector-tag">A</span> 的 IP 地址&gt; &lt;服务器 <span class="hljs-selector-tag">A</span> 的 Redis 端口号&gt;<br></code></pre></td></tr></table></figure>
<h4 id="第一次同步（全量复制）"><a href="#第一次同步（全量复制）" class="headerlink" title="第一次同步（全量复制）"></a>第一次同步（全量复制）</h4><p>主从服务器间的第一次同步的过程可分为三个阶段：<br>（1）建立链接、协商同步；<br>    执行了 replicaof 命令后<br>    从服务器给主服务器发送 <code>psync</code> 命令，并携带两个参数<strong>主服务器的 runID</strong> 和<strong>复制进度 offset</strong>（第一次同步值为-1）<br>    主服务器收到 psync 命令后，会用 <code>FULLRESYNC</code> （全量复制）作为响应命令返回给对方，携带两个参数<strong>主服务器的 runID</strong> 和主服务器目前的<strong>复制进度 offset</strong></p>
<p>（2）主服务器同步数据给从服务器；<br>    主服务器会执行 bgsave 命令来生成 RDB 文件，然后把文件发送给从服务器<br>    为了保证主从服务器的数据一致性，<strong>主服务器在下面这三个时间间隙中将收到的写操作命令，写入到 replication buffer 缓冲区里</strong></p>
<pre><code class="hljs">- 主服务器生成 RDB 文件期间
- 主服务器发送 RDB 文件给从服务器期间
- 从服务器加载 RDB 文件期间
</code></pre><p>（3）主服务器发送新写操作命令给从服务器。<br>    从服务器收到 RDB 文件后，完成 RDB 的载入后回复一个确认消息给主服务器<br>    主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，从服务器执行命令，这时主从服务器的数据就一致了</p>
<p><img src="Pasted image 20240426205946.png" srcset="/img/loading.gif" lazyload alt></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">问题：这样做有什么缺陷？<br>答案：复制都依赖主服务器<span class="hljs-keyword">fork</span>出的线程，<span class="hljs-keyword">fork</span>时是阻塞的，如果从服务器太多，会导致性能问题，同时由于传输RDB文件也消耗主服务器网络带宽，所以这样会对主服务器产生很大的压力<br><br>追问：如何改进<br>答案：分摊主服务器的压力，让一部分从服务器扮演经理的角色，负责部分从服务器的写操作同步，这样就减轻了主服务器的压力，但是代价就是完成数据同步需要的时间更长了<br></code></pre></td></tr></table></figure>
<p><img src="Pasted image 20240426211403.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接</p>
<p>后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同</p>
<p>注意：这是一个TCP长连接（避免频繁的 TCP 连接和断开带来的性能开销）</p>
<p>上面的这个过程被称为<strong>基于长连接的命令传播</strong>，通过这种方式来保证第一次同步后的主从服务器的数据一致性</p>
<h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p>网络是不稳定的，从服务器随时有可能宕机，如果因为各种原因导致从服务器与主服务器之间的数据差距较大时，需要触发增量复制：<br>（1）从服务器发送 psync 命令给主服务器<br>（2）主服务器收到该命令后，然后用 CONTINUE 响应命令告诉从服务器接下来采用<strong>增量复制</strong>的方式同步数据，将主从服务器断线期间，所执行的写命令发送给从服务器<br>（3）从服务器执行这些命令</p>
<p>问题：<strong>主服务器怎么知道要将哪些增量数据发送给从服务器呢？</strong><br>答案：在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会写入到repl_backlog_buffer 缓冲区。因此这个缓冲区里会保存着最近传播的写命令。</p>
<p>网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：<br>（1）如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>增量同步</strong>的方式<br>    当主服务器在 repl_backlog_buffer 中找到主从服务器差异（增量）的数据后，就会将增量的数据写入到 replication buffer 缓冲区，这个缓冲区我们前面也提到过，它是缓存将要传播给从服务器的命令<br>（2）如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>全量同步</strong>的方式</p>
<p><img src="Pasted image 20240426212117.png" srcset="/img/loading.gif" lazyload alt></p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">问题：主从结构什么时候会发生数据丢失？<br>答案：主从切换时发生<br>（<span class="hljs-number">1</span>）异步复制同步丢失。如果异步复制时主服务器宕机，则还未同步到从服务器的数据会丢失；<br>（<span class="hljs-number">2</span>）集群产生脑裂数据丢失。由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了<br><br>追问：如何减少数据丢失？<br>答案：针对情况（<span class="hljs-number">1</span>）主服务器宕机期间的数据写入kafka，等主服务器恢复后再去读取并重新写入。<br>针对情况（<span class="hljs-number">2</span>）当网络延迟太大，可以连接上的从节点小于<span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span>，或者主从同步的延迟超过<span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag秒，主节点禁止写操作，返回错误给客户端。等到新主节点上线时，就只有新主节点能接收和处理客户端请求，此时，新写的数据会被直接写到新主节点中。而原主节点会被哨兵降为从节点，即使它的数据被清空了，也不会有新数据丢失。这个过程中的数据可以先写入kafka。<br><br></code></pre></td></tr></table></figure>
<h3 id="为什么要有哨兵？"><a href="#为什么要有哨兵？" class="headerlink" title="为什么要有哨兵？"></a>为什么要有哨兵？</h3><p>主节点挂了 ，从节点是无法自动升级为主节点的，这个过程需要人工处理，在此期间 Redis 无法对外提供写操作，为了避免这个问题，我们需要哨兵节点，实现<strong>主从节点故障转移</strong></p>
<p>哨兵节点主要负责三件事情：<strong>监控、选主、通知</strong></p>
<h4 id="监控：如何判断主节点真的故障了？"><a href="#监控：如何判断主节点真的故障了？" class="headerlink" title="监控：如何判断主节点真的故障了？"></a>监控：如何判断主节点真的故障了？</h4><p>为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成<strong>哨兵集群</strong>，<strong>通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判节点下线的情况</strong></p>
<p>哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行，如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「<strong>主观下线</strong>」</p>
<p>当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应</p>
<p>当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「<strong>客观下线</strong>」（<strong>quorum 的值建议设置为哨兵个数的二分之一加 1</strong>）</p>
<p>哨兵判断完主节点客观下线后，哨兵就要开始在多个「从节点」中，选出一个从节点来做新主节点。<strong>这个工作交给向其他哨兵发送命令的那个哨兵</strong></p>
<h4 id="主从故障转移的过程是怎样的？"><a href="#主从故障转移的过程是怎样的？" class="headerlink" title="主从故障转移的过程是怎样的？"></a>主从故障转移的过程是怎样的？</h4><p>（1）选出新主节点<br>    第一步：把网络状态不好的从节点过滤掉，根据文件记录把主从断连超过10次的节点过滤掉<br>    第二步：优先级最高的从节点胜出，Redis 有个叫 slave-priority 配置项，我们可以根据服务器性能配置来设置从节点的优先级<br>    第三步：复制进度最靠前的从节点胜出。如果某个从节点的 slave_repl_offset 最接近 master_repl_offset，说明它的复制进度是最靠前的<br>    第四步：ID 号小的从节点胜出。如果发现有两个从节点优先级和复制进度都是一样的，比较ID号，小的从节点胜出</p>
<p><img src="Pasted image 20240426220323.png" srcset="/img/loading.gif" lazyload alt></p>
<p>在选举出从节点后，哨兵 leader 向被选中的从节点发送 <code>SLAVEOF no one</code> 命令，让这个从节点解除从节点的身份，将其变为新主节点</p>
<p>在发送 <code>SLAVEOF no one</code> 命令之后，哨兵 leader 会以每秒一次的频率向被升级的从节点发送 <code>INFO</code> 命令（没进行故障转移之前，<code>INFO</code> 命令的频率是每十秒一次），并观察命令回复中的角色信息，当被升级节点的角色信息从原来的 slave 变为 master 时，哨兵 leader 就知道被选中的从节点已经顺利升级为主节点了</p>
<p>（2）将从节点指向新主节点</p>
<p>当新主节点出现之后，哨兵 leader 下一步要做的就是，让已下线主节点属下的所有「从节点」指向「新主节点」，这一动作可以通过向「从节点」发送 <code>SLAVEOF</code> 命令来实现</p>
<p>（3）通知客户的主节点已更换</p>
<p>新主节点通过<strong>Redis 的发布者/订阅者机制</strong>来告知客户端。</p>
<p>客户端可以从哨兵订阅消息，哨兵提供的消息订阅频道有很多，不同频道包含了主从节点切换过程中的不同关键事件，几个常见的事件如下：<br><img src="Pasted image 20240426220639.png" srcset="/img/loading.gif" lazyload alt></p>
<p>客户端和哨兵建立连接后，客户端会订阅哨兵提供的频道。<strong>主从切换完成后，哨兵就会向 <code>+switch-master</code> 频道发布新主节点的 IP 地址和端口的消息，这个时候客户端就可以收到这条信息，然后用这里面的新主节点的 IP 地址和端口进行通信了</strong></p>
<p>通过发布者/订阅者机制机制，有了这些事件通知，客户端不仅可以在主从切换后得到新主节点的连接信息，还可以监控到主从节点切换过程中发生的各个重要事件，有助于了解切换进度</p>
<p>（4）将旧的主节点变为从节点</p>
<p>继续监视旧主节点，当旧主节点重新上线时，哨兵集群就会向它发送 <code>SLAVEOF</code> 命令，让它成为新主节点的从节点</p>
<h3 id="哨兵集群是如何构成的？"><a href="#哨兵集群是如何构成的？" class="headerlink" title="哨兵集群是如何构成的？"></a>哨兵集群是如何构成的？</h3><p>在配置哨兵的信息时，只需要设置节点名字、节点的 IP 地址和端口号以及 quorum 值。不需要填其他哨兵节点的信息。<strong>哨兵节点之间是通过 Redis 的发布者/订阅者机制来相互发现的</strong></p>
<p>在主从集群中，主节点上有一个名为<code>__sentinel__:hello</code>的频道，不同哨兵就是通过它来相互发现，实现互相通信的。</p>
<p>哨兵通过 INFO 命令，在主节点里获得所有从节点连接信息，然后与从节点建立连接，进行监控</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">问题：哨兵之间如何通信？<br>答案：发布者/订阅者机制<br><br>追问：哨兵如何发现从节点？<br>答案：哨兵从主节点获取下属的从节点列表，然后建立连接<br></code></pre></td></tr></table></figure>
<h2 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h2><p>这篇文章写的非常好<br>使用Redis实现分布式锁和ZK实现分布式锁有什么区别，分别有哪些场景? - Kaito的回答 - 知乎<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/452803310/answer/1931377239">https://www.zhihu.com/question/452803310/answer/1931377239</a></p>
<p>Redis利用setnx + ex指定过期时间可以实现分布式锁（本人在xxl-job中用到过，保证不会重复调度）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">问题：为什么需要分布式锁？<br>答案：现在的业务都是微服务。分布式锁的应用场景在于分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行<br></code></pre></td></tr></table></figure>
<p>想要实现分布式锁需要依赖一个第三方系统，这个系统必须实现互斥的能力，所有进程都去这个系统上加锁，只有一个进程能获取到锁</p>
<p>这个第三方系统有很多选择，用的最多调度是Redis和Zookeeper</p>
<h3 id="单个Redis实例的情况"><a href="#单个Redis实例的情况" class="headerlink" title="单个Redis实例的情况"></a>单个Redis实例的情况</h3><p>通过Redis的setnx+nx可以实现简单的互斥锁<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SET</span> lock <span class="hljs-number">1</span> EX <span class="hljs-number">10</span> NX<br></code></pre></td></tr></table></figure><br>除了第一个客户端，其他的客户端会因为后到达而加锁失败</p>
<p>这条命令是一条原子指令，所以不用担心死锁</p>
<h3 id="锁过期怎么办？"><a href="#锁过期怎么办？" class="headerlink" title="锁过期怎么办？"></a>锁过期怎么办？</h3><p>由于过期时间依赖自己设置，经常可能出现对程序时间预估错误的情况，进而导致客户端2持有的锁被客户端1释放</p>
<p>因此客户端在加锁时需要设置一个ID进去（例如UUID或者线程ID），释放锁时先判断这把锁是否归自己拥有</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">if</span> redis.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;lock&quot;</span>) == <span class="hljs-built_in">uuid</span>:<br>	redis.del(<span class="hljs-string">&quot;lock&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>但是释放锁的操作就从1条变成了两条，不再具有原子性，怎么保证原子性？lua脚本<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&quot;GET&quot;</span>,KEY[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">then</span><br>	<span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&quot;DEL&quot;</span>,EKY[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></p>
<h3 id="锁过期时间不好预估怎么办？"><a href="#锁过期时间不好预估怎么办？" class="headerlink" title="锁过期时间不好预估怎么办？"></a>锁过期时间不好预估怎么办？</h3><p>加锁时，先设置一个过期时间，然后开启一个守护线程，定时去检测这个锁的失效时间，如果锁要过期了操作还未完成，就自动对锁续期，重新设置过期时间</p>
<h3 id="Redis集群的情况：主从切换时锁失效"><a href="#Redis集群的情况：主从切换时锁失效" class="headerlink" title="Redis集群的情况：主从切换时锁失效"></a>Redis集群的情况：主从切换时锁失效</h3><p>在使用redis时一般会采用主从+哨兵的模式。这样的好处在于主库异常时，哨兵可以把从库升级为主库保证可用性</p>
<p>集群模式的主要问题在于如果客户端1上锁之后，主服务器还未同步到从服务器就宕机了，会触发从库升级，原锁就丢失了。</p>
<p><strong>注意：这个问题不仅仅是分布式锁，任何集群系统，都可能存在主库的数据还未同步时就宕机，导致关键数据丢失的问题，核心是主从同步问题</strong></p>
<p>解决方案在于<strong>红锁</strong>（RedLock）：<br>（1）不再需要部署从库和哨兵实例<br>（2）部署多个主库实例（官方推荐至少五个）（也就是说要实现红锁至少要五个主库，它们之间没有什么联系，都是单个的主库）</p>
<p>具体的流程：<br>（1）客户端先获取当前时间戳T1<br>（2）客户端依次向五个Redis实例发起加锁请求，且每个请求都设置超时时间（远小于锁的有效时间），如果一个实例加锁失败（例如网络原因、锁被占用等）就立刻向下一个Redis实例加锁<br>（3）如果客户端从 &gt;= 3个（大多数）redis实例上加锁成功，则再次获取当前时间戳T2，如果T2-T1 &lt; 锁的过期时间，此时认为加锁成功<br>（4）加锁成功后去操作共享资源，例如发起API请求<br>（5）加锁失败，向全部节点发起释放锁的请求（前面提到的lua脚本释放锁）</p>
<p>总结要点：<br>（1）<strong>客户端在多个Redis实例上申请锁</strong><br>    本质上是为了「容错」，部分实例异常宕机，剩余的实例加锁成功，整个锁服务依旧可用</p>
<p>（2）<strong>大多数实例加锁成功</strong><br>    这是一个分布式系统「容错」问题，这个问题的结论是：如果只存在「故障」节点，只要大多数节点正常，那么整个系统依旧是可以提供正确服务的<br>    难道除了故障节点还有别的情况？答案：拜占庭问题，还可能有叛变的节点</p>
<p>（3）<strong>加锁的总耗时 &lt; 锁的过期时间则加锁成功</strong><br>    网络是复杂的，有可能累计的耗时超过了锁的过期时间</p>
<p>（4）<strong>释放锁要向全部节点发起释放锁请求</strong><br>    释放锁时，不管之前有没有加锁成功，需要释放「所有节点」的锁，以保证清理节点上「残留」的锁（可能客户端在一个实例上加锁成功，但在读取结果时，网络问题导致<strong>读取失败</strong>）</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">问题：Zookeeper如何实现分布式锁？<br>答案：<br>（<span class="hljs-number">1</span>）客户端都尝试创建临时节点，例如/<span class="hljs-keyword">lock</span><br>（<span class="hljs-number">2</span>）先到达的客户端加锁成功<br>（<span class="hljs-number">3</span>）操作共享资源<br>（<span class="hljs-number">4</span>）删除临时节点，释放锁<br>Zookeeper不像redis考虑了锁过期问题，会一致持有锁到完成任务。<br><br>追问：如果出现崩溃，没释放锁怎么办？<br>答案：客户端和Zookeeper之间维护了一个<span class="hljs-keyword">Session</span>，会依赖定时心跳来维持连接，如果长时间收不到客户端传过来的心跳，则认为<span class="hljs-keyword">session</span>过期，释放临时节点。<br></code></pre></td></tr></table></figure>
<p>Zookpeer、redis都只是分布式锁的具体实现方案，我们可以得出一个抽象的方案：<br>（1）向一个公关组件申请一个标志，拿到则认为取到了锁<br>（2）维持心跳（redis setnx + ex），心跳断了自动释放标志<br>（3）业务逻辑完成后释放标志</p>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>（1）redis和memcached的区别</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="高可用-1"><a href="#高可用-1" class="headerlink" title="高可用"></a>高可用</h4><p>（1）Redis主从节点时长连接还是短连接？ 长连接<br>（2）怎么判断 Redis 某个节点是否正常工作？<br>    心跳。如果有一半以上的节点去 ping 一个节点的时候没有 pong 回应，集群就会认为这个节点挂掉了，会断开与这个节点的连接<br>（3）主从复制架构中，过期key如何处理？<br>    主节点删除了一个key，则模拟一条del命令发送给从节点，从节点收到该命令后删除key<br>（4）Redis 是同步复制还是异步复制？<br>    Redis 主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点<br>（5）主从复制中两个 Buffer有什么区别？<br>    repl backlog buffer 是在增量复制阶段出现，<strong>一个主节点只分配一个 repl backlog buffer</strong>；<br>    replication buffer 是在全量复制阶段和增量复制阶段都会出现，<strong>主节点会给每个新连接的从节点，分配一个 replication buffer</strong><br>（6）如何应对主从不一致？（强一致性是难以保证的）</p>
<pre><code class="hljs">- 尽量保证网络连接状况良好
- 开发一个外部程序来监控主从节点间的复制进度，差距太大时拒绝从该服务器访问
</code></pre><p>（7）主从结构什么时候会发生数据丢失？如何减少数据丢失？<br>（8）哨兵节点是如何监控节点的？又是如何判断主节点是否真的故障了？心跳+主客观下线<br>（9）哨兵根据什么规则选择一个从节点切换为主节点？优先级+复制进度+ID<br>（10）哨兵怎么把新主节点的相关信息通知给从节点和客户端？发布订阅<br>（11）哨兵之间如何通信？发布订阅<br>（12）哨兵如何发现从节点？通过从主节点获取从节点列表后挨个建立连接</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>（1）Redis如何实现分布式锁？setnx<br>（2）死锁怎么办？set + nx + ex（过期时间）<br>（3）锁过期怎么办？守护线程定期检测，自动续期<br>（4）锁被别的线程释放怎么办？lua脚本释放锁时判断id保证原子性<br>（5）lua脚本为什么可以保证原子性？<br>    当客户端向服务器发送一段带有 Lua 脚本的请求时，Redis会把该 Lua脚本当作一个整体执行，Redis是单线程进而保证了原子性<br>（6）redis.call() 和 redis.pcall() 的区别？前者报错阻断脚本执行，后者报错继续脚本执行<br>（7）如何实现自动续期？</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Redis学习总结</div>
      <div>http://example.com/2024/04/30/Redis学习总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Cygnus</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年4月30日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/05/07/Golang-Context/" title="Golang Context">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Golang Context</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/04/25/%E7%A8%8B%E5%BA%8F%E5%8C%96%E5%B9%BF%E5%91%8A-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%B9%B3%E5%8F%B0%E4%B8%9A%E5%8A%A1%E6%A2%B3%E7%90%86/" title="程序化广告--信息收集平台业务梳理">
                        <span class="hidden-mobile">程序化广告--信息收集平台业务梳理</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
