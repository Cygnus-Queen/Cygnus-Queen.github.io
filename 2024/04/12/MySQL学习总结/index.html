

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Cygnus">
  <meta name="keywords" content="">
  
    <meta name="description" content="市面上的mysql教程要么动则几十个小时，要么就是过于八股文，纯粹为面试而生，各个问题之间不成体系，纯靠记忆，难以理解，于是我通过阅读各种学习笔记，面经，以成体系的方式，结合自己的理解形成了一份mysqk学习总结。 希望通过系统化学习的方式，结合自己以前学过的知识，可以让知识在脑海中的记忆更加牢固。基本上每一个大块都按照是什么，为什么做，怎么做来展开。 基础 什么是数据库三大范式？ http">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL学习总结">
<meta property="og:url" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Cygnus的博客">
<meta property="og:description" content="市面上的mysql教程要么动则几十个小时，要么就是过于八股文，纯粹为面试而生，各个问题之间不成体系，纯靠记忆，难以理解，于是我通过阅读各种学习笔记，面经，以成体系的方式，结合自己的理解形成了一份mysqk学习总结。 希望通过系统化学习的方式，结合自己以前学过的知识，可以让知识在脑海中的记忆更加牢固。基本上每一个大块都按照是什么，为什么做，怎么做来展开。 基础 什么是数据库三大范式？ http">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240408170454.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240408220454.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240408221901.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240409104708.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240409104744.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240409104919.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240409164748.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240409164830.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240412100745.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240412101641.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240412102320.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240409213434.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240409213625.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240410100827.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240410160614.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240408221901.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240410161912.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240410162900.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240410202002.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240410202114.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240410203445.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240410194737.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240411105024.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240411152746.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240411215332.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240411223355.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240411154002.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240411162914.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240411221019.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240411180259.png">
<meta property="og:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240411213234.png">
<meta property="article:published_time" content="2024-04-12T06:09:50.000Z">
<meta property="article:modified_time" content="2024-04-19T09:34:29.670Z">
<meta property="article:author" content="Cygnus">
<meta property="article:tag" content="数据库, mysql">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240408170454.png">
  
  
  
  <title>MySQL学习总结 - Cygnus的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cygnus</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/%E4%BB%99%E5%89%91%E9%97%AE%E6%83%85%E5%A5%B3%E7%A5%9E.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MySQL学习总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-12 14:09" pubdate>
          2024年4月12日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          36k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          297 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">MySQL学习总结</h1>
            
            
              <div class="markdown-body">
                
                <p>市面上的mysql教程要么动则几十个小时，要么就是过于八股文，纯粹为面试而生，各个问题之间不成体系，纯靠记忆，难以理解，于是我通过阅读各种学习笔记，面经，以成体系的方式，结合自己的理解形成了一份mysqk学习总结。</p>
<p>希望通过系统化学习的方式，结合自己以前学过的知识，可以让知识在脑海中的记忆更加牢固。基本上每一个大块都按照是什么，为什么做，怎么做来展开。</p>
<h2 id="基础">基础</h2>
<p>什么是数据库三大范式？ https://zhuanlan.zhihu.com/p/554101160 （1）列不可分 （2）主键依赖（消除部分依赖） <strong>2NF优化发生在联合主键情况下</strong>，即一张表的主键为KEY（A,B），而表中属性C只依赖于A，则成为C对主键的部分依赖。<strong>对于单主键的表，如果优化为1NF后，自然就已经满足2NF了。</strong> （3）表不可分（消除传递依赖） 非主键列必须直接依赖于主键，不能存在传递依赖，比如（A,B,C）三个列，其中A是主键，C依赖于B，B依赖于A，存在传递依赖。将表拆分为（A,B）和（B,C）之后满足第三范式</p>
<h3 id="数据类型">数据类型</h3>
<p>（1）数值类型：tinyint只占一个字节，适合用来存储年龄 （2）时间和日期：date，time，year，datetime，timestamp类型 （3）字符串类型：char和varchar用的多，后者作为边长字符串更节省空间 - <strong>最大长度</strong>：char是255，varchar是65535，单位是字符（而不是字节） - <strong>尾随空格</strong>：char会将尾随空格去掉，而varchar不会 因为存储时，char会用空格填充至指定长度，所以取出时需要去除空格。如果char字段有唯一索引，<code>a</code>和<code>a</code>会提示唯一索引冲突 - <strong>存储空间占用</strong>：varchar会占用额外的1~2字节来存储字符串长度。如果最大长度超过255，就需要2字节，否则1字节 char  适应于固定长度的码值、定值；更新次数多的小长度字段； varchar 适应于不定的字段，如审核意见、理由；更新次数少的字段；系统性能需要； 在绝大多数情况下最好使用varchar</p>
<h3 id="crud操作">CRUD操作</h3>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=199">牛客网在线编程_SQL篇_非技术快速入门 (nowcoder.com)</a></p>
<p>（1）DISTINCT去重 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">&lt;</span>字段名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure> （2）LIMIT 查询结果限制返回行数 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name LIMIT <span class="hljs-number">10</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>MYSQL<br><br><span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">10</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name; <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">SQL</span> Server<br></code></pre></td></tr></table></figure> （3） as 将查询后的列重新命名 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">&lt;</span>字段名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">as</span> <span class="hljs-operator">&lt;</span>字段名<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span>字段名<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">as</span> <span class="hljs-operator">&lt;</span>新名字<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>... <span class="hljs-keyword">from</span> 表名;<br></code></pre></td></tr></table></figure> （4）where 条件查询 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> device_id,university <span class="hljs-keyword">from</span> user_profile <span class="hljs-keyword">where</span> university<span class="hljs-operator">=</span><span class="hljs-string">&#x27;北京大学&#x27;</span>;<br></code></pre></td></tr></table></figure> （5）between and 和 not between and 范围查询 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> device_id,gender,age <span class="hljs-keyword">from</span> user_profile <span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">23</span><br></code></pre></td></tr></table></figure> （6） where in 选出包含条件的字段 和 not in 除条件字段以外的字段 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> device_id,gender,age,university,gpa <span class="hljs-keyword">from</span> user_profile <span class="hljs-keyword">where</span> university <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;北京大学&#x27;</span>,<span class="hljs-string">&#x27;复旦大学&#x27;</span>,<span class="hljs-string">&#x27;山东大学&#x27;</span>);<br></code></pre></td></tr></table></figure> （7）like和通配符实现模糊查询 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">列名 [<span class="hljs-keyword">NOT</span>] <span class="hljs-keyword">LIKE</span><br>匹配串中可包含如下四种通配符：  <br>_：匹配任意一个字符；  <br><span class="hljs-operator">%</span>：匹配<span class="hljs-number">0</span>个或多个字符；  <br>[ ]：匹配[ ]中的任意一个字符(若要比较的字符是连续的，则可以用连字符“<span class="hljs-operator">-</span>”表 达 )；  <br>[<span class="hljs-operator">^</span> ]：不匹配[ ]中的任意一个字符。<br><br>从学生表表中查询学号的最后一位不是<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">5</span>的学生信息。<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 学生表 <span class="hljs-keyword">WHERE</span> 学号 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%[^235]&#x27;</span><br></code></pre></td></tr></table></figure> （8）聚合函数：max、min、avg、count <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(device_id) <span class="hljs-keyword">as</span> male_num, <span class="hljs-built_in">avg</span>(gpa) <span class="hljs-keyword">as</span> avg_gpa <span class="hljs-keyword">from</span> user_profile <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;male&#x27;</span><br></code></pre></td></tr></table></figure> （9）group by分组 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    gender,<br>    university,<br>    <span class="hljs-built_in">count</span>(device_id) <span class="hljs-keyword">as</span> user_num,<br>    <span class="hljs-built_in">avg</span>(active_days_within_30) <span class="hljs-keyword">as</span> avg_active_day,<br>    <span class="hljs-built_in">avg</span>(question_cnt) <span class="hljs-keyword">as</span> avg_question_cnt<br><span class="hljs-keyword">from</span> user_profile<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender, university<br></code></pre></td></tr></table></figure> （10）having分组过滤：聚合函数结果作为筛选条件时，不用where用having <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    university,<br>    <span class="hljs-built_in">avg</span>(question_cnt) <span class="hljs-keyword">as</span> avg_question_cnt,<br>    <span class="hljs-built_in">avg</span>(answer_cnt) <span class="hljs-keyword">as</span> avg_answer_cnt<br><span class="hljs-keyword">from</span> user_profile<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> university<br><span class="hljs-keyword">having</span> avg_question_cnt <span class="hljs-operator">&lt;</span> <span class="hljs-number">5</span> <span class="hljs-keyword">or</span> avg_answer_cnt <span class="hljs-operator">&lt;</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure> （11）order by 对某个列升序排列（asc表示升序，desc表示降序） <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>	university,<br>    <span class="hljs-built_in">avg</span>(question_cnt) <span class="hljs-keyword">as</span> avg_question_cnt<br><span class="hljs-keyword">from</span> user_profile<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> university<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> avg_question_cnt<br><br>语法：<br><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2, ... <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>;（<span class="hljs-keyword">asc</span>表示升序，<span class="hljs-keyword">desc</span>表示降序）<br></code></pre></td></tr></table></figure> （12）等值连接inner join，左连接left join，右连接right join（通过where实现外连接），完全连接full join <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> qpd.device_id, qpd.question_id, qpd.result<br><span class="hljs-keyword">from</span> question_practice_detail <span class="hljs-keyword">as</span> qpd<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> user_profile <span class="hljs-keyword">as</span> up<br><span class="hljs-keyword">on</span> up.device_id<span class="hljs-operator">=</span>qpd.device_id <span class="hljs-keyword">and</span> up.university<span class="hljs-operator">=</span><span class="hljs-string">&#x27;浙江大学&#x27;</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> question_id<br></code></pre></td></tr></table></figure> （13）round(x,4)，保留四位小数 （14）UNION 与 UNION ALL 合并两张表，前者去重后者不去重效率高 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    device_id,<br>    gender,<br>    age,<br>    gpa<br><span class="hljs-keyword">from</span> user_profile<br><span class="hljs-keyword">where</span> university <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;山东大学&#x27;</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span><br>    device_id,<br>    gender,<br>    age,<br>    gpa<br><span class="hljs-keyword">from</span> user_profile<br><span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;male&#x27;</span><br></code></pre></td></tr></table></figure> （14）case..when..then..end函数，放在select后面。end后的为分类后的列名 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">注意<span class="hljs-keyword">when</span>之间没有逗号<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">25</span> <span class="hljs-keyword">OR</span> age <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;25岁以下&#x27;</span> <br>            <span class="hljs-keyword">WHEN</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">25</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;25岁及以上&#x27;</span><br>            <span class="hljs-keyword">END</span> age_cut,<span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)number<br><span class="hljs-keyword">FROM</span> user_profile<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> age_cut<br></code></pre></td></tr></table></figure> （15）限定日期，year(date)=2021 and month(date)=8,day(date)=20 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    <span class="hljs-keyword">day</span>(<span class="hljs-type">date</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">day</span>,<br>    <span class="hljs-built_in">count</span>(question_id) <span class="hljs-keyword">as</span> question_cnt<br><span class="hljs-keyword">from</span> question_practice_detail<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">month</span>(<span class="hljs-type">date</span>)<span class="hljs-operator">=</span><span class="hljs-number">8</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span>(<span class="hljs-type">date</span>)<span class="hljs-operator">=</span><span class="hljs-number">2021</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-type">date</span><br></code></pre></td></tr></table></figure> （16）date_add计算用户的平均次日留存率 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(q2.device_id) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(q1.device_id) <span class="hljs-keyword">as</span> avg_ret<br><span class="hljs-keyword">from</span><br>    (<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> device_id, <span class="hljs-type">date</span><br>    <span class="hljs-keyword">from</span> question_practice_detail) <span class="hljs-keyword">as</span> q1<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span><br>    (<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> device_id, <span class="hljs-type">date</span><br>    <span class="hljs-keyword">from</span> question_practice_detail) <span class="hljs-keyword">as</span> q2<br><span class="hljs-keyword">on</span> q1.device_id <span class="hljs-operator">=</span> q2.device_id <span class="hljs-keyword">and</span> q2.date <span class="hljs-operator">=</span> date_add(q1.date, <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">day</span>)<br><br></code></pre></td></tr></table></figure> （17）字符串截取substring_index(FIELD, sep, n)可以将字段FIELD按照sep分隔： 当n大于0时取第n个分隔符(n从1开始)<strong>左边的全部内容</strong>； 当n小于0时取倒数第n个分隔符(n从-1开始)<strong>右边的全部内容</strong>； <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    substring_index(profile, <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-number">-1</span>) <span class="hljs-keyword">as</span> gender,<br>    <span class="hljs-built_in">count</span>(device_id) <span class="hljs-keyword">as</span> number<br><span class="hljs-keyword">from</span> user_submit<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender<br></code></pre></td></tr></table></figure> （18）截取字符串中间的内容使用嵌套substring_index （19）IF(expr1,expr2,expr3) ，如果如果expr1为TRUE，则IF()返回值为expr2，否则返回值为expr3 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    up.device_id,<br>    university,<br>    <span class="hljs-built_in">count</span>(question_id) <span class="hljs-keyword">as</span> question_cnt,<br>    <span class="hljs-built_in">sum</span>(if(qpd.result<span class="hljs-operator">=</span><span class="hljs-string">&#x27;right&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> right_question_cnt<br><span class="hljs-keyword">from</span><br>    user_profile <span class="hljs-keyword">as</span> up<br>        <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span>  question_practice_detail <span class="hljs-keyword">as</span> qpd  <span class="hljs-keyword">on</span> qpd.device_id <span class="hljs-operator">=</span> up.device_id <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span>(qpd.date) <span class="hljs-operator">=</span> <span class="hljs-number">8</span><br><span class="hljs-keyword">where</span> university <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;复旦大学&#x27;</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> up.device_id<br></code></pre></td></tr></table></figure></p>
<h3 id="理解字符集的重要性utf8和utf8mb4">理解字符集的重要性（utf8和utf8mb4）</h3>
<p>在创建数据库时需要指定字符集，MySQL的“utf8mb4”才是是真正的“UTF-8”，“utf8”只支持每个字符最多三个字节，而真正的UTF-8是每个字符最多四个字节。 utf8mb4 在utf8的基础上扩展了一个字节，<strong>多了emoji编码支持</strong>和和一些不常用的汉字的支持</p>
<h2 id="架构">架构</h2>
<p>图片来自小林coding <img src="Pasted%20image%2020240408170454.png" srcset="/img/loading.gif" lazyload></p>
<p>MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong> （1）<strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现 （2）<strong>存储引擎层负责数据的存储和提取</strong>，索引数据结构是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，默认InnoDB</p>
<p>使用MYSQL的第一件事是连接，涉及到了连接器</p>
<h3 id="连接器">连接器</h3>
<p>连接器主要有三个工作： （1）与客户端进行 TCP 三次握手建立连接； MySQL 是基于 TCP 协议进行传输的，所以计算机网络中学习到的TCP特性，mysql都有。 mysql默认151个连接，也存在长连接和短连结的概念（和http一样）。 <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">问题：怎么解决长连接占用内存的问题？<br>答案：<span class="hljs-number">1</span>. 定期断开长连接 <span class="hljs-number">2</span>. 客户端主动重置连接（客户端可以在代码中调用<span class="hljs-built_in">mysql_reset_connection</span>()）来重置连接<br></code></pre></td></tr></table></figure></p>
<p>（2） 校验客户端的用户名和密码，如果用户名或密码不对，则会报错； 涉及到密码的传输问题，因此mysql可以提供tsl加密传输，</p>
<p>（3）确认用户权限。如果登录成功会读取该用户的权限，<strong>后面的权限逻辑判断都基于此时读取到的权限</strong>；</p>
<h3 id="解析器">解析器</h3>
<p>连上mysql传入sql语句，需要解析器来进行解析： （1）词法分析，MySQL 会根据输入的字符串识别出关键字 （2）语法分析，基于词法分析的结果，语法解析器会根据语法规则，判断这个 SQL 语句是否满足 MySQL 语法。如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等</p>
<p>注意：表不存在或者字段不存在，并不是在解析器里做的</p>
<h3 id="预处理器">预处理器</h3>
<p>从这里开始就进入了SQL执行的流程，第一个阶段是通过预处理器</p>
<p>（1）检查 SQL 查询语句中的表或者字段是否存在； （2）将 select <em> 中的 </em> 符号，扩展为表上的所有列</p>
<h3 id="优化器">优化器</h3>
<p>经过预处理阶段后，还需要为 SQL 查询语句先制定一个<strong>执行计划</strong>，这个工作交由优化器来完成。</p>
<p><strong>优化器主要负责确认 SQL 查询语句的执行方案</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p>
<p>要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 <code>explain</code> 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引</p>
<h3 id="执行器">执行器</h3>
<p>经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。执行的过程，主要是执行器和存储引擎交互的过程</p>
<h4 id="主键索引查询">主键索引查询</h4>
<p>以下面的语句为例，这是一个主键索引 + 等值查询 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure> （1）执行器第一次查询，调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong> （2）存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束 （3）执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录 （4）执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数</p>
<h4 id="全表查询">全表查询</h4>
<p>上面是一个使用了索引的例子，如果是全表扫描（没有用的索引）的话： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;iphone&#x27;</span>;<br></code></pre></td></tr></table></figure></p>
<p>（1）执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong> （2）执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录） （3）执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端 （4）一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息； （5）执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询</p>
<h2 id="存储引擎">存储引擎</h2>
<p>存储引擎负责MySQL的存储行为，InnoDB 是 MySQL 默认的存储引擎</p>
<p>我们每创建一个 database（数据库） 都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里，每创建一个数据库，就会在该目录下多一个以数据库名称为名的文件夹。</p>
<p>该文件夹下有三个文件： （1）db.opt，用来存储当前数据库的默认字符集和字符校验规则 （2）xxx.frm，<strong>表结构</strong>会保存在这个文件。每新建一张表都会生成一个.frm 文件，用来保存每个表的元数据信息 （3）xxx.ibd，<strong>表数据</strong>会保存在这个文件， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。这个文件也被称为<strong>表空间文件</strong></p>
<p>InnoDB存储引擎的逻辑存储结构如下： <img src="Pasted%20image%2020240408220454.png" srcset="/img/loading.gif" lazyload></p>
<p>（1）段（segment），表空间是由各个段（segment）组成的。段一般分为数据段、索引段和回滚段等。 - 索引段：存放 B + 树的非叶子节点的区的集合； - 数据段：存放 B + 树的叶子节点的区的集合； - 回滚段：存放的是回滚数据的区的集合，MVCC 利用了回滚段实现了多版本查询数据（关于这部分的总结在后面）。</p>
<p>（2）区（extent），InnoDB 存储引擎是用 B+ 树来组织数据的，B+ 树中每一层都是通过双向链表连接起来的，以页为单位来分配存储空间可能导致不连续引发随机IO，降低读写效率。因此在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了</p>
<p>（3）页（page），页是 InnoDB 存储引擎磁盘管理的最小单元，默认16KB。意味着数据库一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中</p>
<p>（4）行（row），数据库表中的记录都是按行进行存放的，不同的存储引擎有不同的行格式。</p>
<h3 id="innodb-行格式">InnoDB 行格式</h3>
<p>Compact格式如下：一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分 <img src="Pasted%20image%2020240408221901.png" srcset="/img/loading.gif" lazyload> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_user` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `phone` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB <span class="hljs-keyword">DEFAULT</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> ascii ROW_FORMAT <span class="hljs-operator">=</span> COMPACT;<br></code></pre></td></tr></table></figure></p>
<p>以下面的表为例： <img src="Pasted%20image%2020240409104708.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="记录的额外信息">记录的额外信息</h4>
<p>（1）变长字段长度列表 该部分只在表格存在varchar时才有，<strong>逆序</strong>记录变长字段的大小 <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">逆序使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU <span class="hljs-keyword">Cache</span> Line 中，这样就可以提高 CPU <span class="hljs-keyword">Cache</span> 的命中率<br></code></pre></td></tr></table></figure></p>
<p>表格中的第一行： - name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01； - phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03； - age 列和 id 列不是变长字段，所以这里不用管。 <img src="Pasted%20image%2020240409104744.png" srcset="/img/loading.gif" lazyload> <figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">每个变长字段的「变长字段长度」需要用多少字节表示？<br>（1）如果变长字段允许存储的最大字节数小于等于<span class="hljs-number"> 255 </span>字节，就会用<span class="hljs-number"> 1 </span>字节表示「变长字段长度」<br>（2）如果变长字段允许存储的最大字节数大于<span class="hljs-number"> 255 </span>字节，就会用<span class="hljs-number"> 2 </span>字节表示「变长字段长度」<br></code></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">问题：为什么 <span class="hljs-type">VarChar</span> 建议不要超过<span class="hljs-number">255</span>？<br>答案：变长字段在行格式中会有单独的空间表示变长字段长度，如果长度在<span class="hljs-number">255</span>以内，则只需要<span class="hljs-number">1</span>个字节就可以表示，可以在提供较大的扩展性的同时避免空间浪费。<br></code></pre></td></tr></table></figure>
<p>（2）NULL值列表 该部分只有在<strong>数据表的字段没有全部定义为成NOT NULL 的时候</strong>存在</p>
<p>如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中，该列表中每个字节包含的8位，每一位用来表示一个允许null值的列当前是否位null。记录过程和变长字段长度列表一样是<strong>逆序</strong>的。</p>
<p>以表格中的第一行为例，没有null值，因此每一位都是0： <img src="Pasted%20image%2020240409104919.png" srcset="/img/loading.gif" lazyload> NULL 值列表是默认是 1 字节空间，可以表示8个null字段，如果超过8个字段则会继续扩展占用更大的空间。 <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">问题：每个数据库表的行格式都有「<span class="hljs-literal">NULL</span> 值列表」吗？<br>答案：当数据表的字段都定义成 NOT <span class="hljs-literal">NULL</span> 的时候，这时候表里的行格式就不会有 <span class="hljs-literal">NULL</span> 值列表了，所以如果将表的每个字段都设置位not <span class="hljs-literal">null</span>就可以节省<span class="hljs-number">1</span>字节的空间。<br></code></pre></td></tr></table></figure></p>
<p>（3）记录头信息</p>
<p>记录头信息中包含的内容很多，下面列举几个非常重要的字段： - delete_mask ：标识此条数据是否被删除。在执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</p>
<ul>
<li><p>next_record：指向下一条记录的「记录头信息」和「真实数据」之间的位置（记录与记录之间是通过链表组织的），这样设计的好处在于向左读是记录头信息，向右读是真实数据，很方便。</p></li>
<li><p>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</p></li>
</ul>
<h4 id="记录的真实数据">记录的真实数据</h4>
<p>记录真实数据部分除了包含我们创建表时定义的每个列的数值字段，还有三个别的字段，分别为： （1）row_id。该字段不是必需的，如果我们建表的时候指定了主键或者唯一约束列，就没有 row_id 隐藏字段。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段，占用 6 个字节 （2）trx_id。该字段是必须的，作为事务id表示这个数据是由哪个事务生成的，占用 6 个字节 （3）roll_pointer。该字段是必须的，记录上一个版本的指针，占用7个字节（MVCC 机制使用）</p>
<h4 id="行溢出">行溢出</h4>
<p>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外（Innodb会使用外部页外存储），其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节（MySQL内部使用了2个字节来存储字符串的长度信息）。</p>
<p>也就是除了 TEXT、BLOBs 类型的列，<strong>一行的总长度不能超过65535字节</strong>，因此究竟能保存多少数据还和使用的字符集有关（utf8只占3字节，utf8mb4占4字节） （因此要时刻注意业务根据大表拆分）</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">问题：varchar(<span class="hljs-built_in">n</span>) 中 <span class="hljs-built_in">n</span> 最大取值为多少？<br>答案：根据字符集来确定，varchar(<span class="hljs-built_in">n</span>) 字段类型的 <span class="hljs-built_in">n</span> 代表的是最多存储的字符数量，并不是字节大小。<br><br>单字段情况下：varchar(<span class="hljs-built_in">n</span>) 中 <span class="hljs-built_in">n</span> 最大值 * 一个字符占用字节数 + 「变长字段长度列表」 和 「NULL 值列表」 占用的字节数 &lt;= <span class="hljs-number">65535</span> 即可<br>多字段情况下同理：所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;= <span class="hljs-number">65535</span><br></code></pre></td></tr></table></figure>
<p>一行的最大长度为65535个字节，但是MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 16KB，也就是 16384 字节。因此如果数据量太大，会导致行溢出，<strong>多的数据就会存到另外的「溢出页」中</strong>。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中</p>
<p>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页 <img src="Pasted%20image%2020240409164748.png" srcset="/img/loading.gif" lazyload></p>
<p>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样： <img src="Pasted%20image%2020240409164830.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="innodb-页格式">InnoDB 页格式</h3>
<p><strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，默认大小16KB。数据页的结构如下：</p>
<p><img src="Pasted%20image%2020240412100745.png" srcset="/img/loading.gif" lazyload></p>
<p>具体内容如下：</p>
<p><img src="Pasted%20image%2020240412101641.png" srcset="/img/loading.gif" lazyload></p>
<p>文件头包含上下页的指针，让数据页变成双向链表。在前文我们已经知道行记录通过链表连在一起，所以还需要一个<strong>页目录</strong>，充当记录的索引</p>
<p><img src="Pasted%20image%2020240412102320.png" srcset="/img/loading.gif" lazyload></p>
<p>页目录的创建流程： 1. 将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录； 2. 每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段） 3. 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</p>
<p>因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">问题：为什么数据页是以<span class="hljs-selector-tag">B</span>+树的结构存储，而行记录是链表？<br>答案：因为mysql以页为单位读取，<span class="hljs-selector-tag">B</span>+树主要用来减小磁盘IO，读取行记录时页已经加载到了内存中，不再需要担心磁盘IO问题，因此使用快表即可。（每个分组内部最多只能保存八个记录，因此组内遍历也不会十分耗时）<br></code></pre></td></tr></table></figure>
<h2 id="索引">索引</h2>
<p>索引是一种帮助存储引擎快速获取数据的数据结构</p>
<p>索引和数据都是位于存储引擎中的，在之前的xv6学习中，我们知道文件系统中每个文件结构体都包含了一个inode指针，这个inode本身存储在磁盘的inode块，结构内部包含了指向数据块的指针，它就是一种索引。</p>
<h3 id="索引的分类">索引的分类</h3>
<p>我们可以按照四个角度来分类索引。 （1）按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。 （2）按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。 （3）按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。 （4）按「字段个数」分类：<strong>单列索引、联合索引</strong>。</p>
<p>从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、Hash 索引、Full-Text 索引，不同的存储引擎支持的索引类型不同。innodb支持B+Tree 索引和Full-text索引，MyISAM支持B+索引和Hash索引。</p>
<p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引： （1）如果有主键，默认会使用主键作为聚簇索引的索引键（key）； （2）如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键； （3）在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（这个在之前的行结构中提到了，row_id在没有指定索引时会自动创建），</p>
<p>因此聚簇索引也叫主键索引，其它索引都属于非聚簇索引，也被称为辅助索引（Secondary Index）、二级索引。<strong>innodb创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">问题：普通索引和唯一索引的区别？<br>答案：<br>（<span class="hljs-number">1</span>）普通索引为条件时查询到数据会一直扫描,直到扫完整张表；唯一索引为查询条件时,查到该数据会直接返回,不会继续扫表<br>（<span class="hljs-number">2</span>）普通索引会直接将操作更新到 <span class="hljs-keyword">change</span> <span class="hljs-keyword">buffer</span> 中,然后结束；唯一索引需要判断数据是否冲突<br><br>注意：因此唯一索引更加适合查询，普通索引更适合插入<br></code></pre></td></tr></table></figure>
<h3 id="为什么使用b树作为索引">为什么使用B+树作为索引</h3>
<p>在理解为什么使用B+树之前，我们需要知道<strong>数据结构都是为业务场景服务的</strong>。MySQL的业务场景是什么样的呢？数据库为了避免全表查询一条数据，需要利用索引，而MySQL 的数据是持久化的，意味着数据（索引+记录）是保存到磁盘上</p>
<p>这导致了每次查找索引都需要涉及磁盘IO，所以我们需要一个满足下面条件的数据结构 （1）减少磁盘IO。能在尽可能少的磁盘的 I/O 操作中完成查询工作； （2）高效。要能高效地查询某一个记录，也要能高效地执行范围查找； （3）范围查询。mysql支持范围查询</p>
<p>AVL树，红黑树等结构允许高效，但是会涉及到的磁盘IO次数太高 哈希表难以进行范围查询 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">问题：为什么不使用快表？<br>答案：在写入时<span class="hljs-selector-tag">B</span>+树涉及更新索引层，效率不如快表，但查询时，三层的<span class="hljs-selector-tag">B</span>+Tree就可以存储<span class="hljs-number">2000</span>W的数据，查找数据最多只需要三次磁盘IO即可，快表需要<span class="hljs-number">24</span>层索引，涉及<span class="hljs-number">24</span>次IO。而数据库的应用场景读多写少。<br></code></pre></td></tr></table></figure></p>
<p>B树可以满足前两项但有以下问题： （1）B 树的每个节点都包含索引+记录，读取索引时不可避免的读取到无用的记录数据，这些无用数据占用内存资源的同时还使得磁盘 I/O 操作次数变多 （2）使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题</p>
<p>B+树叶子节点才会存放实际数据，非叶子节点只会存放索引，叶子节点之间构成一个有序链表。这样的结构带来了以下好处： （1）<strong>单点查询比B树更稳定</strong>。虽然B 树最快可以在 O(1) 的时间代价内就查到，但波动大 （2）<strong>范围查询比B树快</strong>。B+树可以在查到第一个节点后向右遍历链表，节省从头开始查找的时间 （3）<strong>插入和删除效率比B树高</strong>。B+树拥有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，删除非常快</p>
<p>Innodb 根据索引类型不同，分为聚集和二级索引。聚集索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚集索引的叶子节点，而二级索引的叶子节点存放的是主键值。根据二级索引查到主键值之后需要进行<strong>回表</strong>（即再根据主键查找）</p>
<p>因为表的数据都是存放在聚集索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚集索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个</p>
<h3 id="索引的适用场景">索引的适用场景</h3>
<p>索引最大的好处是提高查询速度，但也会带来占用物理空间，并且带来维护的开销。因此需要看情况使用。</p>
<h4 id="什么时候需要索引">什么时候需要索引？</h4>
<p>（1）字段有唯一性限制的，比如商品编码、学生ID （2）经常用于 WHERE`查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引 （3）经常用于 GROUP BY和 ORDER BY的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。 <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">当查询语句中包含 <span class="hljs-keyword">group</span> <span class="hljs-title">by</span> 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要尽量避免这种情况出现<br></code></pre></td></tr></table></figure></p>
<p>总结来看就是具有唯一性，具有区分度的字段很适合用来构建索引。</p>
<h4 id="什么时候不需要索引">什么时候不需要索引？</h4>
<p>（1）WHERE、GROUP BY和 ORDER BY用不到的字段 （2）没有区分度的字段，例如性别（优化器发现某个值出现在表的数据行中的百分比很高，即区分度低的时候，它一般会忽略索引，进行全表扫描） （3）表数据太少的时候，不需要创建索引 （4）经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，频繁的重建索引会影响数据库性能</p>
<p>总结来看就是没有区分度的字段没必要构建索引</p>
<h4 id="什么时候会出现索引失效">什么时候会出现索引失效？</h4>
<p>创建了索引并不意味着查询的时候会使用到索引，所以我们心里要清楚有哪些情况会导致索引失效，从而避免写出索引失效的查询语句，否则这样的查询效率是很低的 <strong>（1）当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</strong> <strong>（2）当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效</strong> <strong>（3）联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效</strong> <strong>（4）在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">问题：什么是最左匹配原则？<br>答案：最左匹配原则就是最左优先，在创建多列索引（联合索引）时，要根据业务需求，where子句中使用最频繁的一列放在最左边。<br><br>当你创建了一个联合索引，该索引的任何最左前缀都可以用于查询。比如当你有一个联合索引 <span class="hljs-comment">(col1, col2, col3)</span>，该索引的所有前缀为 <span class="hljs-comment">(col1)</span>、<span class="hljs-comment">(col1, col2)</span>、<span class="hljs-comment">(col1, col2, col3)</span>，包含这些列的所有查询都会使用该索引进行查询<br><br>原因在于索引查询需要有序，而联合索引是先根据最左侧的字段进行排序，剩下的字段在前一个字段相等时再进行排序，因此只能保证局部有序，所以建立联合索引时要把最常用的放在最左侧，避免索引失效<br></code></pre></td></tr></table></figure>
<p>在之前mysql架构中提到了执行器会根据优化器给出的方案进行查询，其中type指的就是索引的使用情况，常见的类型列出如下，效率从低到高 - All（全表扫描）； - index（全索引扫描）； - range（索引范围扫描）； - ref（非唯一索引扫描）； - eq_ref（唯一索引扫描）； - const（结果只有一条的主键或唯一索引扫描）。</p>
<p>All 和 index 开销都很大</p>
<p>range 表示采用了索引范围扫描，一般在 where 子句中使用 &lt; 、&gt;、in、between 等关键词，只检索给定范围的行，属于范围查找。<strong>从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</strong></p>
<p>ref 类型表示采用了非唯一索引，虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，<strong>要进行目标值附近的小范围扫描</strong></p>
<p>eq_ref 类型是使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref</p>
<p>const 类型表示使用了主键或者唯一索引与常量值进行比较，比如： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></p>
<p>注意：onst 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong>const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中</strong></p>
<h3 id="索引优化问题">索引优化问题</h3>
<p>理解索引的原理和mysql使用索引的方式，我们就能知道如何让索引更好的工作，使得mysql查询的 性能更好</p>
<h4 id="前缀索引">前缀索引</h4>
<p>前缀索引优化即使用某个字段中字符串的前几个字符建立索引，这样可以减小索引字段的大小，节约空间同时增加查询速度。一般应用在内容很长，但区分度主要聚集在开头的字符串，例如外国人名、电子邮件。</p>
<p>这种优化方式的缺点在于 order by 无法使用，也无法进行覆盖索引</p>
<h4 id="覆盖索引重要">覆盖索引（重要）</h4>
<p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以<strong>避免回表操作</strong></p>
<p>问题：假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？ 答案：我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表</p>
<p>使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作</p>
<h4 id="主键索引保持自增">主键索引保持自增</h4>
<p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中</p>
<p><strong>如果我们使用自增主键</strong>，可以将插入操作变为追加操作，不需要从中间插入B+树，避免导致现有数据的移动，甚至是<strong>页分裂</strong></p>
<p>问题：什么是页分裂？ 答案：如下图所示，插入新数据时不得不移动其它数据来腾出位置，甚至需要从一个页面复制数据到另外一个页面。页分裂会导致<strong>大量的内存碎片，使索引结构不再紧凑，从而影响查询效率</strong> <img src="Pasted%20image%2020240409213434.png" srcset="/img/loading.gif" lazyload></p>
<p>如果是顺序插入，就会如下图所示，不会引发分裂，只会重新申请一个页 <img src="Pasted%20image%2020240409213625.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="控制主键索引长度">控制主键索引长度</h4>
<p>主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong></p>
<h4 id="索引最好设置为-not-null">索引最好设置为 NOT NULL</h4>
<p>这样做的好处在于： （1）索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，进而影响查询效率。比如进行索引统计时，count 会省略值为NULL 的行 （2） NULL 会占用物理空间，带来存储空间问题，如果表中存在允许为 NULL 的字段，那么行格式中<strong>至少会用 1 字节空间存储 NULL 值列表</strong>（在之前innodb行格式中提到了）</p>
<h2 id="事务">事务</h2>
<p><strong>事务是一系列不可分割的数据库的操作。这些操作要么同时成功，要么同时失败，不允许出现中间状态的数据。</strong></p>
<p>事务是由 MySQL 的引擎来实现的， InnoDB 支持事务，MyISAM不支持。该部分的所有内容都是基于InnoDB引擎</p>
<h3 id="事务的特性">事务的特性</h3>
<p>实现事务需要遵守四个方面的特性： （1）<strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态 （2）<strong>一致性（Consistency）</strong>：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如转帐前A和B共100元，转账后两者的余额依然为100元。（一致性与原子性是密切相关的） （3）<strong>隔离性（Isolation）</strong>：并发运行时，一个事务的执行不能被其他事务干扰 （4）<strong>持久性（Durability）</strong>：事务一旦提交，它对数据库中数据的改变就应该是永久性的</p>
<p>这些事务在Innodb中有对应的机制来保证： （1）原子性是通过 undo log（回滚日志） 来保证 （2）隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证 （3）持久性是通过 redo log （重做日志）来保证 （4）一致性则是通过持久性+原子性+隔离性共同来保证</p>
<p>理解mysql事务，其实就是理解这三种机制，每一个机制都不简单，涉及到的内容很多，因此只有<strong>隔离性</strong>的保证会在当前二级标题下进行总结，剩余的部分会放到后面的二级标题中</p>
<h3 id="事务的隔离级别有哪些">事务的隔离级别有哪些？</h3>
<p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现并发事务：在同时处理多个事务的时候，就可能出现问题： （1）脏读（dirty read）：一个事务读到了另一个未提交事务修改过的数据 （2）不可重复读（non-repeatable read）：在一个事务内多次读取同一个数据，其他事务修改了数据，出现前后两次读到的数据内容不一样的情况 （3）幻读（phantom read）：在一个事务内多次读取范围内数据的时候，其他事务插入或删除了数据，出现前后两次查询到的记录数量不一样的情况</p>
<p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下： - <strong>读未提交（<em>read uncommitted</em>）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到 - <strong>读提交（<em>read committed</em>）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到，通过在事务的每次select时创建read view来实现 - <strong>可重复读（<em>repeatable read</em>）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，通过在事务开启时时创建read view实现（注意与<strong>读提交</strong>时机不同）。 - <strong>串行化（<em>serializable</em> ）</strong>；通过加读写锁避免并行访问，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</p>
<p><img src="Pasted%20image%2020240410100827.png" srcset="/img/loading.gif" lazyload></p>
<p>要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」</p>
<p>串行化非常影响数据库性能，因此 <strong>如何在可重复读模式下控制幻读的发生</strong> 就尤为重要了，mysql给出的答案是，根据不同的读场景分别处理，MySQL读取数据实际上有两种模式，分别是当前读和快照读： （1）<strong>快照读</strong>：普通的select语句(不包括 select ... lock in share mode; select ... for update)。也就是说，不加锁的select操作都是采用快照读的模式。<strong>用基于MVCC多版本并发控制方式解决幻读</strong> <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">读已提交：事务每次<span class="hljs-keyword">select</span>时创建快照读<br>可重复读：事务第一次<span class="hljs-keyword">select</span>时创建快照读，后续一直使用<br></code></pre></td></tr></table></figure> （2）<strong>当前读</strong>：数据修改的操作(update、insert、delete) 都是采用当前读的模式，<strong>用next-key lock（记录锁+间隙锁）方式解决幻读</strong></p>
<p>后文主要对这两种情况展开</p>
<h3 id="mvcc">MVCC</h3>
<h4 id="mvcc是什么">MVCC是什么？</h4>
<p>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制机制，提高了数据库并发读写的性能，同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cos">（<span class="hljs-number">1</span>）MVCC 多版本并发控制是只是一个模型概念，并非具体实现<br>（<span class="hljs-number">2</span>）MySQL实现MVCC概念中，快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现<br>（<span class="hljs-number">3</span>）MVCC模型在MySQL中的具体实现则是由三个隐式字段，undo日志 ，<span class="hljs-keyword">Read</span> <span class="hljs-keyword">View</span>等去实现的<br></code></pre></td></tr></table></figure>
<p>注意：MVCC主要用来实现普通select的可重复读隔离等级，同时解决这种情况下的幻读问题。</p>
<h4 id="mvcc是如何是实现的快照读是如何避免幻读的">MVCC是如何是实现的？（快照读是如何避免幻读的？）</h4>
<p>上面的问题其实可以更进一步，即</p>
<p>MVCC开始事务后（执行 begin 语句后），根据隔离级别会在不同的时机产生一个read view。后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途其他事务插入了新纪录，也是查询不出来的，避免了幻读问题</p>
<p>read view的结构如下：</p>
<p><img src="Pasted%20image%2020240410160614.png" srcset="/img/loading.gif" lazyload></p>
<p>在上文讲解innodb引擎的行结构时提到了每个行包含了额外信息和真实信息，其中，真实信息里除了列数据，还包括了三个隐式字段，有作用的主要是trx_id和roll_ptr： （1）trx_id：记录创建这条记录以及最后一次修改该记录的事务的ID，是一个指针 （2）roll_ptr：回滚指针，指向这条记录的上一个版本（存储于rollback segment回滚段）。每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，于是就可以通过它找到修改前的记录 <img src="Pasted%20image%2020240408221901.png" srcset="/img/loading.gif" lazyload> 根据read view的四个字段，可以将记录中的 trx_id 划分这三种情况： （1）如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong> （2）如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong> （3）如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中 - 如果记录的 trx_id <strong>在</strong> m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong> - 如果记录的 trx_id <strong>不在</strong> m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</p>
<p>**这样通过「版本链」就实现了 MVCC（多版本并发控制）</p>
<h4 id="可重复读是如何实现的">可重复读是如何实现的？</h4>
<p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong></p>
<p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：</p>
<p><img src="Pasted%20image%2020240410161912.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。</p></li>
<li><p>在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，<strong>活跃的事务 id 中最小的事务 id 是事务 A</strong>，下一个事务 id 应该是 53。</p></li>
</ul>
<p>接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作 （1）事务 B 读取账户余额记录，读到余额是 100 万 事务 B 第一次读取账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时<strong>发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的</strong>，也就是事务 B 可以获取到这条记录。</p>
<p>（2） 事务 A 将账户余额记录修改成 200 万，并没有提交事务 事务 A 通过 update 语句将这条记录修改了（还未提交事务），将余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong> <img src="Pasted%20image%2020240410162900.png" srcset="/img/loading.gif" lazyload></p>
<p>（3）事务 B 读取账户余额记录，读到余额还是 100 万 事务 B 第二次去读取该记录，发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间， 且trx_id 值是在 m_ids 范围内，，那么说明这条记录是被还未提交的事务修改的，这时事务 B 会沿着 undo log 链条找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是余额是 100 万的这条记录</p>
<p>（4）事务 A 提交事务</p>
<p>（5）事务 B 读取账户余额记录，读到余额依然还是 100 万； 由于隔离级别时<strong>可重复读</strong>，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是余额是 100 万的这条记录</p>
<p>我们可以发现，其实mvcc已经很好的控制了幻读的发生，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的。</p>
<h4 id="读提交是如何工作的">读提交是如何工作的？</h4>
<p>如果隔离模式是读已提交，那会发生什么？</p>
<p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p>
<p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务： （1）事务 B 读取数据（创建 Read View），账户余额为 100 万； （2）事务 A 修改数据（还没提交事务），将账户余额从 100 万修改成了 200 万； （3）事务 B 读取数据（创建 Read View），账户余额为 100 万； （4）事务 A 提交事务； （5）事务 B 读取数据（创建 Read View），账户余额为 200 万（同一个事物，多次读取前后不一致）；</p>
<h3 id="当前读是如何避免幻读的">当前读是如何避免幻读的？</h3>
<h4 id="当前读的业务场景">当前读的业务场景</h4>
<p>问题：有了快照读难道还不够吗？为什么还需要当前读？ 答案：因为快照读读取的不是最新数据，但很多业务场景必须读最新数据，例如涉及到金钱、转账等情况，此时就需要引入锁来解决问题了。</p>
<p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作，否则就会产生冲突。</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">问题：什么时候会使用<span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span> （这种语句是当前读）<br>答案：在高并发场景下还对数据的准确性有很高要求的时候使用。比如涉及到金钱、库存等。一般这些操作都是很长一串并且是开启事务的。如果库存刚开始读的时候是<span class="hljs-number">1</span>，而立马另一个进程进行了<span class="hljs-keyword">update</span>将库存更新为<span class="hljs-number">0</span>了，而事务还没有结束，会将错的数据一直执行下去，就会有问题。所以需要<span class="hljs-keyword">for</span> upate 进行数据加锁防止高并发时候数据出错<br><br>注意：这时使用的锁发分为表锁和行锁。如果查询时没用索引/主键的话就是表锁，否则就是是行锁。<br></code></pre></td></tr></table></figure>
<h4 id="间隙锁记录锁">间隙锁+记录锁</h4>
<p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。</p>
<p><img src="Pasted%20image%2020240410202002.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="Pasted%20image%2020240410202114.png" srcset="/img/loading.gif" lazyload></p>
<p>（1）事务 A 执行了这面这条锁定读语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合） （2）事务 B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-key lock，于是事物 B 会生成一个插入意向锁，同时进入等待状态，直到事务 A 提交了事务。这就避免了由于事务 B 插入新记录而导致事务 A 发生幻读的现象（其实也就是串行化了）</p>
<h3 id="幻读被解决了吗">幻读被解决了吗？</h3>
<p>虽然上面的内容都在说如何解决幻读问题，但其实都只是尽可能的让幻读少发生，**MySQL Innodb 中的 MVCC 并不能完全避免幻读现象，只是很大程度上避免了幻读现象的发生</p>
<p>情况（1）： <img src="Pasted%20image%2020240410203445.png" srcset="/img/loading.gif" lazyload></p>
<p>情况（2）： - T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</p>
<ul>
<li><p>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</p></li>
<li><p>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</p></li>
</ul>
<p>这些情况其实都是由于在执行update这样的「当前读语句」之前，也就是插入next-key lock之前发生了其他事务对查询区间的插入和删除操作。</p>
<p>所以要避免这类特殊场景下发生幻读的现象的方法在于： <strong>尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录</strong></p>
<h3 id="事务-总结">事务-总结</h3>
<p>这一部分按照顺序： （1）什么是事务？ACID四性 （2）并发事务带来了什么问题？脏读、不可重复读、幻读 （3）如何解决这些问题？不同的事务隔离等级 （4）这些事务隔离等级是如何实现的？默认「可重复读」，引出了MVCC （5）MVCC是什么？如何实现的？ （6）「当前读」如何实现？</p>
<p>这一部分由于出现了很多名词，比如隐式字段，undo日志（回滚日志），read view。可能会看的云里雾里，所以我整合出了一张图片。</p>
<p><img src="Pasted%20image%2020240410194737.png" srcset="/img/loading.gif" lazyload></p>
<p>MVCC实现主要是依赖 <strong>隐式字段</strong>，<strong>undo日志</strong> 和 <strong>Read View</strong> ，但这三者并不是并行的关系，隐式字段将unode日志和read view连接在了一起。隐式字段的roll_ptr指向了undo日志，trx_id和read view建立关联</p>
<p>当前读的只要实现是根据next-key lock，关于锁的应用会在后面再进行总结</p>
<h2 id="锁">锁</h2>
<p>锁往往是与并发问题同时出现，并发问题的根源我已经在之前的<a href>并发基础</a>文章中进行了详细的阐述，并在<a href>xv6 lock</a>中对操作系统不同类型的锁进行了递进式的讲解（自旋锁、睡眠锁、ticket锁、MCS锁）。</p>
<p>本章节只要的内容主要是介绍mysql为了保证并发安全提供的锁</p>
<h3 id="全局锁">全局锁</h3>
<h4 id="如何使用全局锁">如何使用全局锁？</h4>
<p>使用全局锁需要执行这条命令： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">加锁：flush tables <span class="hljs-keyword">with</span> read lock<br>解锁：unlock tables<br></code></pre></td></tr></table></figure></p>
<p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程无论是修改数据还是修改表结构，都会被阻塞： （1）对数据的增删改操作，比如 insert、delete、update等语句； （2）对表结构的更改操作，比如 alter table、drop table 等语句。 <strong>当会话断开了，全局锁会被自动释放</strong>（否则会导致死锁）</p>
<h4 id="全局锁的应用场景">全局锁的应用场景？</h4>
<p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">问题：加全局锁又会带来什么缺点呢？<br>答案：如果数据库里有很多数据，全库备份就会花费很多的时间，这期间，业务只能读数据，而不能更新数据，会造成业务停滞！<br></code></pre></td></tr></table></figure>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">问题：如何避免全局锁造成的业务停滞？<br>答案：如果数据引擎支持支持[可重复读]，那么在备份数据库之前先开启事务，会先创建 <span class="hljs-keyword">Read</span> <span class="hljs-keyword">View</span>，然后整个事务执行期间都在用这个<span class="hljs-keyword">Read</span> <span class="hljs-keyword">View</span>来完成，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作，即使其他事务更新了表的数据，也不会影响备份数据库时的 <span class="hljs-keyword">Read</span> <span class="hljs-keyword">View</span><br><br>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 –single-<span class="hljs-keyword">transaction</span> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎<br><br>对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法<br></code></pre></td></tr></table></figure>
<h3 id="表级锁">表级锁</h3>
<h4 id="表锁">表锁</h4>
<p>如果想对学生表（t_student）加表锁，可以使用下面的命令： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的共享锁，也就是读锁；<br>lock tables t_student read;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的独占锁，也就是写锁；<br>lock tables t_stuent write;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>解锁<br>unlock tables<br></code></pre></td></tr></table></figure> 当会话退出后，也会释放所有表锁</p>
<p>尽量避免在使用 InnoDB 引擎的表使用表锁，因为一种常见的提高锁性能的方案就是锁分段，将粗粒度的锁换为细粒度的锁，mysql默认引擎更换为<strong>InnoDB 的重要原因在于细粒度的行级锁</strong>，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">问题：表锁有什么缺点？<br>答案：粒度太大，并发效率低<br></code></pre></td></tr></table></figure>
<h4 id="元数据锁">元数据锁</h4>
<p>我们不需要显示的使用 元数据锁（MDL），因为当我们对数据库表进行操作时，会自动加锁 （1）对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>； （2）对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</p>
<p>MDL 的作用是保证用户对表执行 CRUD 操作时，防止其他线程对表结构做变更，只有在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">问题：元数据锁有什么缺点？<br>答案：如果某个事务占用锁的时间太长，对表结构的更新操作（写锁）会导致其他线程对表的读操作阻塞（因为申请 MDL 锁的操作会形成一个队列，队列写锁获取优先级高于读锁），这时数据库的线程很快就会爆满<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">问题：如何应对元数据锁的缺陷？<br>答案：在对表结构进行变更时，先看看数据库中是否有长事务已经对表加上了MDL读锁，可以考虑<span class="hljs-built_in">kill</span>掉这个长事务再进行表结构变更<br></code></pre></td></tr></table></figure>
<h4 id="意向锁">意向锁</h4>
<p><strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong></p>
<p>用法： （1）在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」； （2）在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</p>
<p>我们已经知道innodb会对记录加行锁来替代表锁，但是在进行一些表级别的修改时还是需要表锁的，此时： （1）如果没有意向锁，那么加独占表锁时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢 （2）有了意向锁，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加独占表锁时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录</p>
<h4 id="auto-inc-锁">AUTO-INC 锁</h4>
<p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的，之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的</p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉</p>
<p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的</p>
<p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞</p>
<h3 id="行级锁">行级锁</h3>
<p>InnoDB 引擎支持行级锁的， MyISAM引擎并不支持行级锁</p>
<p>普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为<strong>锁定读</strong></p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//对读取的记录加共享锁</span><br><span class="hljs-function"><span class="hljs-title">select</span></span> ... lock in share mode;<br><br><span class="hljs-comment">//对读取的记录加独占锁</span><br><span class="hljs-function"><span class="hljs-title">select</span></span> ... <span class="hljs-keyword">for</span> update;<br></code></pre></td></tr></table></figure>
<p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong></p>
<p>行级锁的类型主要有三类：记录锁（Record Lock）、间隙锁（Gap Lock）、记录锁 + 间隙锁（Next-Key Lock）</p>
<p>（1）记录锁是一种读写锁，锁住的是一条记录。在持有读锁时可以接收其他读锁，但不能加写锁。持有写锁时既不能加读锁也不能加写锁 （2）间隙锁锁住一个id范围。只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象（前面已经讲到了）。 假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生 （3）Next-Key Lock锁定一个范围，并且锁定记录本身。 假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。 （4）插入意向锁，这是一种特殊的间隙锁，锁住的是一个点。 一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态</p>
<p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p>
<h3 id="加锁规则与死锁">加锁规则与死锁</h3>
<h4 id="加锁规则">加锁规则</h4>
<p>MySQL中普通的select不需要加锁，只有增删改和特殊的select会加独占行锁。</p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/how_to_lock.html#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2">MySQL 是怎么加锁的？ | 小林coding (xiaolincoding.com)</a></p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">问题：为什么<span class="hljs-keyword">update</span>时没加索引会锁全表？<br>答案：在 <span class="hljs-keyword">update</span> 语句的 <span class="hljs-keyword">where</span> 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-<span class="hljs-keyword">key</span> 锁（记录锁 + 间隙锁），相当于把整个表锁住了，可能导致业务崩溃。<br><br>注意：在线上在执行 <span class="hljs-keyword">update</span>、<span class="hljs-keyword">delete</span>、<span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span> 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-<span class="hljs-keyword">key</span> 锁，相当于把整个表锁住了<br><br>连问：如何避免这种情况的发生？<br>答案：将 MySQL 里的 sql_safe_updates 参数设置为 <span class="hljs-number">1</span>。<br>此时<span class="hljs-keyword">update</span> 语句必须满足如下条件之一才能执行成功：<br>（<span class="hljs-number">1</span>）使用 <span class="hljs-keyword">where</span>，并且 <span class="hljs-keyword">where</span> 条件中必须有索引列；<br>（<span class="hljs-number">2</span>）使用 <span class="hljs-keyword">limit</span>；<br><span class="hljs-keyword">delete</span> 语句必须满足以下条件能执行成功：<br>（<span class="hljs-number">1</span>）同时使用 <span class="hljs-keyword">where</span> 和 <span class="hljs-keyword">limit</span>，此时 <span class="hljs-keyword">where</span> 条件中可以没有索引列；<br></code></pre></td></tr></table></figure>
<h4 id="死锁">死锁</h4>
<p>https://xiaolincoding.com/mysql/lock/show_lock.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81</p>
<p><img src="Pasted%20image%2020240411105024.png" srcset="/img/loading.gif" lazyload></p>
<p>Time1：事务A获取(20,30)的间隙锁（会在事务结束后释放） Time2：事务B获取(20,30)的间隙锁（会在事务结束后释放）（间隙锁是兼容的，所以不会阻塞） Time3：事务A插入行为被事务B的间隙锁阻塞，获取插入意向锁 Time4：事务B插入行为被事务A的间隙锁阻塞，获取插入意向锁</p>
<p>两个事务都在等待对方释放间隙锁，导致死锁</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran">问题：如何避免死锁？<br>答案：<br>（<span class="hljs-number">1</span>）设置事务等待锁的超时时间<br>（<span class="hljs-number">2</span>）开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务（默认开启）<br><br>追问：主动死锁检测是如何实现的？<br>答案：对事务等待图(<span class="hljs-keyword">wait</span>-for graph)进行深度优先搜索，该图存储了锁和事务等待关系。事务与事务之间的连线，代表事务在等待另一个事务释放资源，发现环则出现了死锁<br></code></pre></td></tr></table></figure>
<h2 id="日志">日志</h2>
<p>在xv6文件系统的学习中，我们知道文件系统中有提供崩溃一致性服务的日志层。现在我们来看看mysql中有哪些日志，分别有什么作用</p>
<h3 id="buffer-pool">Buffer Pool</h3>
<h4 id="什么是buffer-pool">什么是Buffer Pool ？</h4>
<p>在xv6中，为了提供给CPU直接访问磁盘的错觉，每次对磁盘的访问都会转化为对内存缓存的访问，buffer cache层有一个bcache数据结构，维护了磁盘块和缓存块的映射关系。</p>
<p>buffer pool可以理解为是mysql的buffer cahce，在进程的角度来看，每次访问都是访问磁盘，这样效率比较低，所以最好将使用过的数据缓存起来，下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了。</p>
<p>buffer pool由 innnodb 维护，默认大小为128MB</p>
<p><img src="Pasted%20image%2020240411152746.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li>
<li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），<strong>为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</strong></li>
</ul>
<p>每一个页都存在一个控制块（这也是文件系统的常规操作了），控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等 <img src="Pasted%20image%2020240411215332.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="buffer-pool缓存了什么">buffer pool缓存了什么？</h4>
<p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p>
<p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">注意：根据linux懒分配的原理，申请的连续内存空间只是连续的虚拟地址，并且暂时不会真的分配物理地址，而是等待虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址建立映射关系，所以MySQL 刚启动的时候，虚拟内存空间很大，而物理内存空间却很小<br></code></pre></td></tr></table></figure>
<p>在前面的内容中，我们知道一个表空间包含了数据段，索引段，回滚段。所以buffer pool，除了缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等</p>
<h4 id="buffer-pool的结构">Buffer Pool的结构？</h4>
<p>Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页可以分为： （1）空闲的 空闲空间的控制块以<strong>空闲链表</strong>的形式连接在一起，每个节点都包含了对空闲控制块的指针，然后每个控制块又包含了对应缓存页的指针 每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除 （2）干净的页（已经被使用，但是未修改） 使用LRU进行管理。当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部，当访问的页不在 Buffer Pool 里，除了要把从磁盘新读取的页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。<strong>注意脏数据页也在LRU当中，</strong> （3）脏的 脏空间的控制块以<strong>Flush 链表</strong>的形式连接在一起，结构和空闲链表一致，只不过节点中指向的控制块都是脏页的控制块。 有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘</p>
<p><img src="Pasted%20image%2020240411223355.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="lru的结构有什么问题如何解决">LRU的结构有什么问题？如何解决？</h4>
<p>简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题 （1）预读失效 MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO，但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。如果使用简单的 LRU 算法，就会把预读页放到 LRU 链表头部，而当 Buffer Pool空间不够的时候，还需要把末尾的页淘汰掉（明明不是最经常使用的页，却放在了LRU最前面，使得缓存命中率下降） （2）Buffer Pool 污染 当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong></p>
<p>（1）针对预读失效的问题，解决方案在于让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长，具体的做法在于改进LRU算法： 将LRU分为两个部分，前半部分为young区域，后半部分为old 区域，<strong>预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong></p>
<p>（2）针对Buffer pool污染问题，解决方案在于给进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间 如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>； 如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>； 也就说，只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</p>
<p>另外，MySQL 还针对 young 区域做了一个优化，young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">问题：如何提高buffer pool缓存命中率？（其他的缓存也是一样的道理）<br>答案：（<span class="hljs-number">1</span>）避免预读导致的缓存失效，将LRU分为young和<span class="hljs-keyword">old</span>，前者缓存热点数据，后者做预读<br>（<span class="hljs-number">2</span>）避免缓存污染，只有同时满足「被访问」与「在 <span class="hljs-keyword">old</span> 区域停留时间超过 <span class="hljs-number">1</span> 秒」两个条件，才会被插入到 young 区域头部，避免因为大范围搜索导致的LRU热点缓存失效<br></code></pre></td></tr></table></figure>
<h3 id="undo-log">undo log</h3>
<p>一个事务在还没有提交事前，如果 MySQL 发生了崩溃，怎么保证崩溃一致性呢？（要怎么回滚到事务之前的数据呢？），使用的就是回滚日志undo log，<strong>保证了事务的 ACID 特性中的原子性（Atomicity，要么都成功，要么都失败）</strong>。 每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如： （1） 在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了； （2）在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了； （3）在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</p>
<p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 会把记录中的内容都保存下来，然后写入 Buffer Pool 中的 Undo 页面。当执行回滚操作的时候，就可以读取 undo log 里的数据，然后进行 insert 操作</p>
<p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id（老朋友了，这两个值都是保存在row中隐式字段）： （1）通过 trx_id 可以知道该记录是被哪个事务修改的； （2）通过 roll_pointer 指针可以将这些 undo log 串成一个链表形成版本链</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel">问题：<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>有什么作用？<br>答案：<br>（<span class="hljs-number">1</span>）实现事务回滚，保障事务的原子性<br>（<span class="hljs-number">2</span>）参与实现 MVCC（多版本并发控制）<br></code></pre></td></tr></table></figure>
<h3 id="redo-log">redo log</h3>
<p>通过对undo log记录的讲解，我们知道该日志是在内存更新的，每次对事物的记录会写入到buffer pool中的undo页。</p>
<p>然而这些记录都是在内存中的，内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失，所以如果想要它们真的持久化，还需要刷盘到磁盘上</p>
<h4 id="什么是redo-log">什么是redo log？</h4>
<p>redo log 是物理日志，记录了某个数据页做了什么修改，比如“ 对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新 ”，每当执行一个事务就会产生这样的一条或者多条物理日志。</p>
<p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要急着将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p>
<h4 id="为什么需要redo-log">为什么需要redo log？</h4>
<p>redo log用来实现<strong>WAL （Write-Ahead Logging）技术</strong>：MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</p>
<p>这样做的好处在于： （1）写入 redo log 的方式使用了追加操作，所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写，顺序写比随机写高效的多，因此 redo log 写入磁盘的开销更小 （2）<strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失</p>
<p>整个更新的流程如下：</p>
<p><img src="Pasted%20image%2020240411154002.png" srcset="/img/loading.gif" lazyload></p>
<p>其实如果熟悉文件系统的话，会明白这就是文件系统日志层提供的功能，xv6中的log_write()函数会将对磁盘的写入先记录在日志中，然后将日志刷入磁盘，之后再把数据刷入磁盘。</p>
<h4 id="redo-log写入磁盘的时机">redo log写入磁盘的时机</h4>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim">问题：<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> 要写到磁盘，数据也要写磁盘，为什么要多此一举？<br>答案：<br>（<span class="hljs-number">1</span>）将磁盘的随机写行为转换为<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span>的顺序写（追加写是一种顺序写），效率更高<br>（<span class="hljs-number">2</span>）实现事务的持久性，提供崩溃恢复的能力（已提交的事务不会崩溃，未提交的事务当作没发生，不会出现数据写磁盘写一办后崩溃导致错误的情况）<br><br>追问：产生的 <span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> 是直接写入磁盘的吗？<br>答案：不是，因为这样会产生大量IO，<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> 也有自己的缓存<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">buffer</span>，每当产生一条 <span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> 时，会先写入到 <span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">buffer</span><br><br>追问：那<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span>会在什么时候写入磁盘呢？<br>答案：<br>（<span class="hljs-number">1</span>）MySQL 正常关闭时；<br>（<span class="hljs-number">2</span>）当 <span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">buffer</span> 中记录的写入量大于 <span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">buffer</span> 内存空间的一半时，会触发落盘<br>（<span class="hljs-number">3</span>）InnoDB 的后台线程每隔 <span class="hljs-number">1</span> 秒，将 <span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">buffer</span> 持久化到磁盘<br>（<span class="hljs-number">4</span>）每次事务提交时根据innodb_flush_log_at_trx_commit 参数决定刷盘策略<br></code></pre></td></tr></table></figure>
<p>innodb_flush_log_at_trx_commit有0、1、2三种取值，分别代表了不同的策略： （0）表示每次事务提交时 ，<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。直接在内存操作，开销最小 （1）表示每次事务提交时，<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，涉及到系统调用和磁盘IO，开销最大 （2）表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件</strong>。注意：写入到文件并不等于写入到磁盘（这里又是文件系统的知识），只涉及到系统调用，没有涉及到磁盘IO，开销适中</p>
<p><img src="Pasted%20image%2020240411162914.png" srcset="/img/loading.gif" lazyload></p>
<p>所以参数0和2都没有直接写入磁盘，因此需要等待其他刷盘条件触发，例如InnoDB 的后台线程每隔 1 秒： - 针对参数 0 ：会把缓存在 redo log buffer 中的 redo log ，通过调用 <code>write()</code> 写到操作系统的 Page Cache，然后调用 <code>fsync()</code> 持久化到磁盘。<strong>所以参数为 0 的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失</strong>;</p>
<ul>
<li>针对参数 2 ：调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log 持久化到磁盘。<strong>所以参数为 2 的策略，较取值为 0 情况下更安全，因为 MySQL 进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失</strong>。</li>
</ul>
<p>我们可以发现：数据安全性和写入性能是不可得兼的，<strong>要不追求数据安全性，牺牲性能；要不追求性能，牺牲数据安全性</strong>。</p>
<h4 id="redo-log-文件写满了怎么办">redo log 文件写满了怎么办？</h4>
<p>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ：<code>ib_logfile0</code> 和 <code>ib_logfile1</code> 。</p>
<p>重做日志文件组是以<strong>循环写</strong>的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形</p>
<p>所以 InnoDB 存储引擎会先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时，会切换回 ib_logfile0 文件</p>
<p><img src="Pasted%20image%2020240411221019.png" srcset="/img/loading.gif" lazyload></p>
<p>redo log 是为了防止 Buffer Pool 中的脏页丢失而设计的，随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了，可以擦除</p>
<p>redo log 是循环写的方式，相当于一个环形，InnoDB 用 write pos 表示 redo log 当前记录写到的位置，用 checkpoint 表示当前要擦除的位置</p>
<p><img src="Pasted%20image%2020240411180259.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>write pos 和 checkpoint 的移动都是顺时针方向；</li>
<li>write pos ～ checkpoint 之间的部分（图中的红色部分），用来记录新的更新操作；</li>
<li>check point ～ write pos 之间的部分（图中蓝色部分）：待落盘的脏数据页记录；</li>
</ul>
<p>如果 write pos 追上了 checkpoint，就意味着 redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞，此时会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针），然后 MySQL 恢复正常运行，继续执行新的更新操作</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">问题：为什么要注重<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>的大小设置？<br>答案：针对并发量大的系统，如果<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>太小，很容易导致<span class="hljs-keyword">log</span>写满，进而阻塞MySQL的更新操作，使得业务停滞，因此要非常注意<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>的大小<br></code></pre></td></tr></table></figure>
<h3 id="binlog">binlog</h3>
<p>前面介绍的 undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。</p>
<p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件</p>
<p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mel">问题：为什么有了 binlog， 还要有<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>？<br>答案：这个问题跟 MySQL 的时间线有关系，最开始 MySQL 里并没有 InnoDB 引擎，没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，使用 <span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 来实现 crash-safe 能力<br><br>追问：binlog和<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>有什么区别？<br>答案：<br>（<span class="hljs-number">1</span>）适用对象不同。binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用。<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 是 Innodb 存储引擎实现的日志<br>（<span class="hljs-number">2</span>）写入方式不同。binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志。<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 是循环写，日志空间大小是固定，全部写满就从头开始<br>（<span class="hljs-number">3</span>）用途不同。binlog 用于备份恢复、主从复制，<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 用于掉电等故障恢复<br><br>追问：如果不小心整个数据库的数据被删除了，能使用 <span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 文件恢复数据吗？<br>答案：不可以使用 <span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 文件恢复，只能使用 binlog 文件恢复，因为<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>的任务是让数据安全的刷入磁盘不因为崩溃丢失，但是不能恢复主动删除的数据。binlog因为记录了所有的更新操作，所以可以复原。<br></code></pre></td></tr></table></figure>
<h4 id="binlog什么时候刷盘">binlog什么时候刷盘？</h4>
<p>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，<strong>执行器</strong>把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache</p>
<p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率，具体和redo log的innodb_flush_log_at_trx_commit是类似的。 ​（1）当sync_binlog=0的时候，表示每次提交事务都只write，不fsync ​（2）当sync_binlog=1的时候，表示每次提交事务都执行fsync （3）当sync_binlog=N的时候，表示每次提交事务都write，但积累N个事务后才fsync。</p>
<h4 id="如何实现主从复制">如何实现主从复制？</h4>
<p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上</p>
<p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成</p>
<p>MySQL 集群的主从复制过程梳理成 3 个阶段： （1）<strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据 MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应 （2）<strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中 从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。 （3）<strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据 从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua">问题：从库是不是越多越好？<br>答案：不是，从库数量增加，从库连接上来的 I/O 线程也比较多，主库也要创建同样多的 <span class="hljs-built_in">log</span> <span class="hljs-built_in">dump</span> 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽，导致较长的主从延迟<br><br>追问：一般主从复制的模型是什么样的？<br>答案：一个主库一般跟 <span class="hljs-number">2</span>～<span class="hljs-number">3</span> 个从库（<span class="hljs-number">1</span> 套数据库，<span class="hljs-number">1</span> 主 <span class="hljs-number">2</span> 从 <span class="hljs-number">1</span> 备主）<br><br>追问：如何解决主从延迟问题？<br>答案：<br>（<span class="hljs-number">1</span>）架构层面采用分库架构，让不同的业务请求分散到不同的数据库服务上，分散单台机器的压力<br>（<span class="hljs-number">2</span>）配置方面修改sync_binlog参数的值，从<span class="hljs-number">1</span>变成<span class="hljs-number">100</span>~<span class="hljs-number">1000</span><br>（<span class="hljs-number">3</span>）采用并行复制策略，将SQL线程转化成多个线程来进行重放，加快对DML数据的处理速度，从而减缓主从延迟<br></code></pre></td></tr></table></figure>
<h3 id="一条update语句的执行流程">一条update语句的执行流程</h3>
<p>前面的步骤都和select语句一样，从连接器、解析器、预处理器、优化器到执行器。不同之处就在于执行器的执行。</p>
<p>具体更新一条记录 <code>UPDATE t_user SET name = 'cygnus' WHERE id = 1;</code> 的流程如下： （1）执行器调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录 如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新 如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器 （2）执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样 如果一样的话就不进行后续更新流程 如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作 （3）开启事务， InnoDB 层更新记录前，首先生成一条 undo log写入Buffer Pool 中的 Undo 页面维护版本链 （4）InnoDB 层开始更新记录，将记录写入内存（同时标记为脏页），然后创建一条 redo log，写入到redo log buffer（此时更新完成，剩下的写入磁盘操作会由后台线程选择合适的时机来完成，这就是WAL技术） （5）在一条更新语句执行完成后，然后生成该语句对应的 binlog，保存到binlog cache （6）事务完成，开始「两阶段提交」</p>
<h3 id="两阶段提交">两阶段提交</h3>
<h4 id="为什么需要两阶段提交">为什么需要两阶段提交？</h4>
<p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成主从库数据不一致。前者成功后者失败，则主库的数据更多，后者成功前者失败，则从库的数据更多。</p>
<p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong></p>
<h4 id="如何实现两阶段提交">如何实现两阶段提交？</h4>
<p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 开启一个内部 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong>，如下图： <img src="Pasted%20image%2020240411213234.png" srcset="/img/loading.gif" lazyload></p>
<p>（1）<strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用） （2）<strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit</p>
<p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID： （1）<strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。对应时刻 A 崩溃恢复的情况 （2）<strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</strong>。对应时刻 B 崩溃恢复的情况。</p>
<p>可以发现，<strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong></p>
<p>注意：两阶段提交看起来似乎是redo log和binlog按顺序刷盘，但实际上redo log还有1s间隔这种刷盘条件，因此<strong>事务没提交的时候，redo log 也是可能被持久化到磁盘的</strong>。但是仍然不会引发主从不一致的问题，因为如果发生崩溃，在重启时，会拿着已经写入磁盘的redo log的XID去 binlog 查看是否存在此 XID，如果没有会发生回滚</p>
<p><strong>所以， redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘</strong></p>
<h4 id="两阶段提交有什么问题">两阶段提交有什么问题？</h4>
<p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差： （1）<strong>磁盘 I/O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘 （2）<strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致</p>
<h4 id="磁盘io太高怎么办">磁盘IO太高怎么办？</h4>
<p>事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，如果出现 MySQL 磁盘 I/O 很高的现象，可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I/O 的频率。 （1）设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数 （2）将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机 （3）将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是将 redo log 写到 redo log 文件而不是直接写入磁盘</p>
<h2 id="总结">总结</h2>
<p>回答下面的问题可以很好的校验对知识的掌握程度 #### 基础部分 （1）<strong>为什么会有utf8mb4？和utf8有什么不同？</strong> （2）char和varchar有什么区别？ （3）<strong>说一下数据库的三大范式</strong> （4）删除表数据后表的大小却没有变动,这是为什么?</p>
<h4 id="架构部分">架构部分</h4>
<p>（1）<strong>执行一条select语句的过程中发生了什么？</strong></p>
<h4 id="存储引擎-1">存储引擎</h4>
<p>（1） <strong>MySQL 一行记录是怎么存储的？</strong> （2）<strong>为什么 MySQL 采用 B+ 树作为索引？</strong> （3）MyISAM 与 InnoDB 的区别是什么？ （5）使用 Innodb 的情况下，一条更新语句是怎么执行的? （6）为什么 VarChar 建议不要超过255？ （7）<strong>buffer pool 是做什么的？</strong> （8）如何避免缓存失效？</p>
<h4 id="索引-1">索引</h4>
<p>（1）什么是索引? （2）<strong>索引失效有哪些情况？</strong> （3）什么是回表? （4）什么是索引下推? （5）什么是覆盖索引? （6）什么是最左前缀原则? （7）普通索引和唯一索引该怎么选择?</p>
<h4 id="事务-1">事务</h4>
<p>（1）什么是事务?其特性是什么? （2）<strong>事务的隔离级别是什么？如何实现？</strong> （3）说一说 mvcc 吧，有什么作用? （4）为什么不要使用长事务? 更大的主从延迟；锁定太多的数据，造成阻塞和锁超时；回滚耗时长；undo log膨胀 （5）<strong>mysql如何实现可重复读？能解决幻读吗？什么情况下仍然会发生？如何尽可能避免？</strong></p>
<h4 id="锁-1">锁</h4>
<p>（1）<strong>mysql中有哪些锁？分别有什么应用场景？有什么缺点？</strong> （2）<strong>什么情况下会发生死锁？如何解决死锁？</strong> （3） <strong>select......for update会锁表还是锁行？</strong></p>
<h4 id="日志-1">日志</h4>
<p>（1）如果数据库的数据被误删了，如何恢复？ （2）什么是预读？什么时候会发生预读失效？ （3）buffer pool是一种什么样的结构？ （4）WAl 是什么?有什么好处? （5）<strong>binlog 是做什么的?</strong> （6）<strong>undo log 是做什么的?</strong> （7）relaylog 是做什么的? （8）<strong>redo log 是做什么的?</strong> （9）redo log 是怎么记录日志的? （10）redolog 和 binlog 的区别是什么? （11）Mysql 主从之间是怎么同步数据的？主从延迟要怎么解决？ （12）Innodb 事务为什么要两阶段提交? （13）<strong>如何进行主从复制？</strong></p>
<h4 id="综合">综合</h4>
<p>（1）使用 Innodb 的情况下，一条更新语句是怎么执行的? （2）一条 Sql 语句查询偶尔慢会是什么原因? - 数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘<br>
- 执行的时候遇到锁，如表锁、行锁 （3）一条 Sql 语句查询一值慢会是什么原因？ - 没有用索引或索引失效 （4）怎样使用explain的？对于执行计划你是怎样分析的？ 通过<strong>type</strong>判断索引的使用情况 （5）说说你的 Sql 调优思路 - 打开慢查询日志，这样可以定位到执行慢的SQL语句 - 利用explain查看执行计划，大多数情况下慢的原因在于索引，根据type判断索引使用情况 （6）为什么不要使用长事务？ - 并发情况下，连接池容易被撑爆 - 锁定太多的数据，造成大量的阻塞和锁超时 - 执行时间长，容易造成主从延迟 （7）如何避免长事务？ - 在一个事务里面， 避免一次处理太多数据 - 在一个事务里面， 避免耗时太多的操作，造成事务超时。一些非DB的操作，比如rpc调用，消息队列的操作尽量放到事务之外操作</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%90%8E%E7%AB%AF/" class="category-chain-item">后端</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-mysql/" class="print-no-link">#数据库, mysql</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MySQL学习总结</div>
      <div>http://example.com/2024/04/12/MySQL学习总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Cygnus</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年4月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/04/12/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%88%E9%94%81%E7%9A%84%E6%A0%B9%E6%BA%90%EF%BC%89/" title="并发基础（锁的根源）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">并发基础（锁的根源）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/16/docker/" title="docker">
                        <span class="hidden-mobile">docker</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
