

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Cygnus">
  <meta name="keywords" content="">
  
    <meta name="description" content="Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器。特点是占有内存少，并发能力强。有报告表明能支持高达 50,000 个并发连接数。主要优点在于： 1. 高性能：事件驱动、异步调用、Epoll 2. 轻量级：Nginx的二进制文件很小，可以快速启动并占用较少的内存。 3. 可靠性高：Nginx的代码被设计为高可靠性的，可以在长时间运行中保持稳定性。 4. 可扩展性好：N">
<meta property="og:type" content="article">
<meta property="og:title" content="Nginx学习总结">
<meta property="og:url" content="http://example.com/2024/04/19/Nginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Cygnus的博客">
<meta property="og:description" content="Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器。特点是占有内存少，并发能力强。有报告表明能支持高达 50,000 个并发连接数。主要优点在于： 1. 高性能：事件驱动、异步调用、Epoll 2. 轻量级：Nginx的二进制文件很小，可以快速启动并占用较少的内存。 3. 可靠性高：Nginx的代码被设计为高可靠性的，可以在长时间运行中保持稳定性。 4. 可扩展性好：N">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/04/19/Nginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240319205726.png">
<meta property="og:image" content="http://example.com/2024/04/19/Nginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240319184553.png">
<meta property="og:image" content="http://example.com/2024/04/19/Nginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240318165716.png">
<meta property="og:image" content="http://example.com/2024/04/19/Nginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240319215247.png">
<meta property="og:image" content="http://example.com/2024/04/19/Nginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240319221248.png">
<meta property="article:published_time" content="2024-04-19T09:31:11.000Z">
<meta property="article:modified_time" content="2024-04-19T09:35:02.686Z">
<meta property="article:author" content="Cygnus">
<meta property="article:tag" content="Nginx,中间件">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2024/04/19/Nginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Pasted%20image%2020240319205726.png">
  
  
  
  <title>Nginx学习总结 - Cygnus的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cygnus</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/%E4%BB%99%E5%89%91%E9%97%AE%E6%83%85%E5%A5%B3%E7%A5%9E.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Nginx学习总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-04-19 17:31" pubdate>
          2024年4月19日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          176 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Nginx学习总结</h1>
            
            
              <div class="markdown-body">
                
                <p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器。特点是占有内存少，并发能力强。有报告表明能支持高达 50,000 个并发连接数。主要优点在于： 1. 高性能：事件驱动、异步调用、Epoll 2. 轻量级：Nginx的二进制文件很小，可以快速启动并占用较少的内存。 3. 可靠性高：Nginx的代码被设计为高可靠性的，可以在长时间运行中保持稳定性。 4. 可扩展性好：Nginx可以通过添加第三方模块或编写自定义模块来扩展其功能。 5. 支持热部署：Nginx可以在不停止服务的情况下重新加载配置文件和动态模块。</p>
<p>Nginx的主要功能有三点： （1）反向代离 （2）负载均衡 （3）动静分离</p>
<h2 id="架构">架构</h2>
<p>下图是Nginx的进程架构图，可以看到它含有4类进程：1个Master管理进程、多个Worker工作进程、1个Cache Loader缓存载入进程和1个Cache Manager缓存淘汰进程：</p>
<p><img src="Pasted%20image%2020240319205726.png" srcset="/img/loading.gif" lazyload></p>
<p>Master是管理进程，它长期处于Sleep状态，并不参与请求的处理，因此几乎不消耗服务器的IT资源。另外，只有在开启HTTP缓存后，Cache Loader和Cache Manager进程才存在，其中，当Nginx启动时加载完磁盘上的缓存文件后，Cache Loader进程也会自动退出</p>
<p>该架构下程序的工作模式是这样的： （1）主进程执行 bind() + listen() 后，创建多个子进程 （2）每个子进程，都通过 accept() 或 epoll_wait() ，来处理相同的套接字</p>
<h2 id="为什么nginx性能好">为什么Nginx性能好？</h2>
<p>谈到Redis缓存，我们描述其性能时会这么说：支持C10K（1万并发连接），几万QPS。而我们描述Nginx的高性能时，则会宣示：支持C10M（1千万并发连接），百万级QPS</p>
<p>Redis与Nginx同样使用了事件驱动、异步调用、Epoll这些机制，为什么Nginx的并发连接会高出那么多呢？</p>
<p>https://cloud.tencent.com/developer/article/1761931</p>
<p>（1）将Worker进程控制在略大于CPU核心数量，占据更多的CPU时间</p>
<p>（2）设置worker进程的静态优先级，占据更长的CPU时间片 在Linux中，静态优先级共包含40级，从-20到+19不等，其中-20表示最高优先级。进程的默认优先级是0，所以你可以通过调级优先级，让Worker进程获得更多的CPU资源。在nginx.conf文件中，worker_priority配置就能设置静态优先级，比如： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">worker_priority <span class="hljs-number">-10</span>;<br></code></pre></td></tr></table></figure></p>
<p>（3）使用CPU亲和机制（见后文） 由于每个CPU核心都拥有一级、二级缓存，为了提高这两级缓存的命中率，可以将Worker进程与CPU核心绑定在一起。频繁命中CPU缓存，可以提升Nginx指令的执行速度**</p>
<p>Nginx的多进程架构已经能够支持C10M级别的高并发了，那么Nginx中的多线程又是怎么回事呢？</p>
<p>材料、散热这些基础科技没有获得重大突破前，CPU频率很难增长，类似Redis、NodeJS这样的单进程、单线程高并发服务，只能向分布式集群方向发展，才能继续提升性能。Nginx通过Master/Worker多进程架构，可以充分使用服务器上百个CPU核心，实现C10M。</p>
<p>总结： 为了榨干多核CPU的价值，Nginx无所不用：通过绑定CPU提升二级缓存的命中率，通过静态优先级扩大时间片，通过多种手段均衡Worker进程之间的负载，在独立线程池中隔离阻塞的IO操作，建立本地代理缓存等等。可见，高性能既来自于架构，更来自于细节。</p>
<h2 id="为什么-nginx-不使用多线程">为什么 Nginx 不使用多线程？</h2>
<p>（1）多进程已经够用了，效率很高，所以没必要 每进来一个request，会有一个worker进程去处理。但不是全程的处理，只处理到发生阻塞的地方，比如向上游（后端）服务器转发request，并等待请求返回。那么，这个处理的worker不会傻等（阻塞），他会在发送完请求后，注册一个事件：“如果upstream返回了，告诉我一声&quot;。于是他就休息去了。此时，如果再有request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。这样即使很少的进程也可以完成很大的并发任务</p>
<p>（2）会引入风险降低可用性 Nginx的模块化设计允许第三方代码（结合自己的业务设计模块，例如限流模块）嵌入到核心流程中执行，这虽然大大丰富了Nginx生态，却也引入了风险。作为高性能负载均衡，稳定性非常重要。由于多线程共享同一地址空间，一旦出现内存错误，所有线程都会被内核强行终止，这会降低系统的可用性。</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nim">指令： upstream <br>语法： upstream name <span class="hljs-meta">&#123;...&#125;</span> <br>环境： http含义：定义一组 <span class="hljs-type">HTTP</span>服务器，这些服务器可以监听不同的端口，以及 <span class="hljs-type">TCP</span>和 <span class="hljs-type">UNIX</span>套接字。在同一个 upstream中可以混合使用不同的端口、 <span class="hljs-type">TCP</span>和 <span class="hljs-type">UNIX</span>套接字。需要指定一系列的回调函数<br><br>注意：从本质上说，upstream 属于 handler，只是他不产生自己的内容，而是通过请求后端服务器得到内容<br></code></pre></td></tr></table></figure>
<h2 id="反向代离">反向代离</h2>
<p>正向代理：客户端的一切请求都传递到代理服务器，服务端收到的请求都来自代理服务器，具体是哪个客户端的请求，服务端不关心。<strong>正向代理相当于向服务端屏蔽了具体的客户端细节</strong></p>
<p><strong>反向代理相当于服务端向客户端屏蔽了具体的服务端细节</strong>，客户端在发起域名请求时，并不关心到底是访问的哪台服务器，这样Nginx就可以接收所有客户端的请求，然后决定派发到哪一个服务器。</p>
<p>nginx也可以用来做正向代理</p>
<h2 id="负载均衡">负载均衡</h2>
<p>客户端发出的请求<code>192.168.12.129</code>最终会转变为：<code>http://192.168.12.129:80/</code>，然后再向目标<code>IP</code>发起请求，流程如下： - 由于<code>Nginx</code>监听了<code>192.168.12.129</code>的<code>80</code>端口，所以最终该请求会找到<code>Nginx</code>进程； - <code>Nginx</code>首先会根据配置的<code>location</code>规则进行匹配，根据客户端的请求路径<code>/</code>，会定位到<code>location /&#123;&#125;</code>规则； - 然后根据该<code>location</code>中配置的<code>proxy_pass</code>会再找到名为<code>nginx_boot</code>的<code>upstream</code>； - 最后根据<code>upstream</code>中的配置信息，将请求转发到运行<code>WEB</code>服务的机器处理，由于配置了多个<code>WEB</code>服务，且配置了权重值，因此<code>Nginx</code>会依次根据权重比分发请求</p>
<p><strong>为了防止服务器上的其他进程占用过多的CPU，你还可以给Worker进程赋予更高的静态优先级</strong></p>
<p>具体的负载均衡内置策略包含：加权轮询 和 IP hash</p>
<h4 id="为什么要做负载均衡">为什么要做负载均衡？</h4>
<p>很容易理解，因为单机无法解决现在的访问量，所以引入了多机+nginx反向代理，但如果不能负载均衡，所有的请求都冲到一个服务器上，就回归了单机的情况，后端服务会崩溃</p>
<h2 id="动静分离">动静分离</h2>
<p>也就是将动态资源和静态资源分开处理</p>
<h4 id="为什么需要做动静分离呢它带来的好处是什么">为什么需要做动静分离呢？它带来的好处是什么？</h4>
<p>当我们进行web访问时，比如浏览器输入<code>www.taobao.com</code>访问淘宝首页，打开开发者调试工具可以很明显的看到，首页加载会出现<code>100+</code>的请求数，而正常初学项目开发时，静态资源一般会放入到<code>resources/static/</code>目录下。</p>
<p>如果这样的话，首页100+的所有请求都会来到部署WEB服务的机器处理，那则代表着一个客户端请求淘宝首页，就会对后端服务器造成100+的并发请求，一旦用户多起来，这对于后端服务器的压力是巨大的。</p>
<p>但如果仔细分析这100+个请求会发现，至少有<code>60+</code>是属于<code>*.js、*.css、*.html、*.jpg.....</code>这类静态资源的请求。这些资源有一个特性就是短时间不会改变（不会或者不要求实时改变）。那其实就没必要让这些请求到后端去处理，在nginx就可以处理了。</p>
<p><strong>做了动静分离之后，至少能够让后端服务减少一半以上的并发量。</strong></p>
<h2 id="nginx缓冲区">Nginx缓冲区</h2>
<p>接入<code>Nginx</code>的项目一般请求流程为：“客户端→<code>Nginx</code>→服务端”，在这个过程中存在两个连接：“客户端→<code>Nginx</code>、<code>Nginx</code>→服务端”，那么两个不同的连接速度不一致，就会影响用户的体验（比如浏览器的加载速度跟不上服务端的响应速度）</p>
<p>其实也就类似电脑的内存跟不上<code>CPU</code>速度，所以对于用户造成的体验感极差，因此在<code>CPU</code>设计时都会加入三级高速缓冲区，用于缓解<code>CPU</code>和内存速率不一致的矛盾。在<code>Nginx</code>也同样存在缓冲区的机制，主要目的就在于：<strong>「用来解决两个连接之间速度不匹配造成的问题」</strong> ，有了缓冲后，<code>Nginx</code>代理可暂存后端的响应，然后按需供给数据给客户端。先来看看一些关于缓冲区的配置项：</p>
<h4 id="缓存机制">缓存机制</h4>
<p>对于性能优化而言，缓存是一种能够大幅度提升性能的方案，因此几乎可以在各处都能看见缓存，如客户端缓存、代理缓存、服务器缓存等等，<code>Nginx</code>的缓存则属于代理缓存的一种。对于整个系统而言，加入缓存带来的优势额外明显：</p>
<ul>
<li>减少了再次向后端或文件服务器请求资源的带宽消耗。</li>
<li>降低了下游服务器的访问压力，提升系统整体吞吐。</li>
<li>缩短了响应时间，提升了加载速度，打开页面的速度更快。</li>
</ul>
<p>那么在<code>Nginx</code>中，又该如何配置代理缓存呢？通过配置项：<strong>「proxy_cache_path」</strong></p>
<h2 id="黑白名单">黑白名单</h2>
<p>有时候往往有些需求，可能某些接口只能开放给对应的合作商，或者购买/接入<code>API</code>的合作伙伴，那么此时就需要实现类似于<code>IP</code>白名单的功能。而有时候有些恶意攻击者或爬虫程序，被识别后需要禁止其再次访问网站，因此也需要实现<code>IP</code>黑名单。那么这些功能无需交由后端实现，可直接在<code>Nginx</code>中处理。<code>Nginx</code>做黑白名单机制，主要是通过<code>allow、deny</code>配置项来实现：</p>
<h2 id="nginx防盗链设计">Nginx防盗链设计</h2>
<p>盗链：<strong>「盗链即是指外部网站引入当前网站的资源对外展示」</strong></p>
<p>举个简单的例子理解：好比壁纸网站<code>X</code>站、<code>Y</code>站，<code>X</code>站是一点点去购买版权、签约作者的方式，从而积累了海量的壁纸素材，但<code>Y</code>站由于资金等各方面的原因，就直接通过<code>&lt;img src=&quot;X站/xxx.jpg&quot; /&gt;</code>这种方式照搬了<code>X</code>站的所有壁纸资源，继而提供给用户下载。</p>
<p>应该该如何屏蔽这类问题呢？答案是「防盗链」技术！<code>Nginx</code>的防盗链机制实现，跟一个头部字段：<code>Referer</code>有关，该字段主要描述了当前请求是从哪儿发出的，那么在<code>Nginx</code>中就可获取该值，然后判断是否为本站的资源引用请求，如果不是则不允许访问</p>
<h2 id="性能优化">性能优化</h2>
<h4 id="优化一打开长连接配置">优化一：打开长连接配置</h4>
<p>通常Nginx作为代理服务，负责分发客户端的请求，那么建议开启<code>HTTP</code>长连接，用户减少握手的次数，降低服务器损耗，具体如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">upstream xxx &#123; <br>	# 长连接数 <br>	keepalive <span class="hljs-number">32</span>; <br>	# 每个长连接提供的最大请求数 <br>	keepalived_requests <span class="hljs-number">100</span>; <br>	# 每个长连接没有新的请求时，保持的最长时间 <br>	keepalive_timeout <span class="hljs-number">60</span>s; &#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="优化二开启零拷贝技术">优化二：开启零拷贝技术</h4>
<p>零拷贝这个概念，在大多数性能较为不错的中间件中都有出现，例如<code>Kafka、Netty</code>等，而<code>Nginx</code>中也可以配置数据零拷贝技术</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sendfile on; # 开启零拷贝机制  <br></code></pre></td></tr></table></figure>
<p>零拷贝读取机制与传统资源读取机制的区别： - <strong>「传统方式：」</strong> 硬件--&gt;内核--&gt;用户空间--&gt;程序空间--&gt;程序内核空间--&gt;网络套接字</p>
<ul>
<li><strong>「零拷贝方式：」</strong> 硬件--&gt;内核--&gt;程序内核空间--&gt;网络套接字</li>
</ul>
<h4 id="优化三开启无延迟或多包共发机制">优化三：开启无延迟或多包共发机制</h4>
<p>在<code>Nginx</code>中有两个较为关键的性能参数，即<code>tcp_nodelay、tcp_nopush</code>，开启方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">tcp_nodelay on;   <span class="hljs-comment">//一般要建立在开启了长连接模式的情况下使用</span><br>tcp_nopush on;    <span class="hljs-comment">//必须要开启sendfile参数（零拷贝）才可使用的</span><br></code></pre></td></tr></table></figure>
<p><code>TCP/IP</code>协议中默认是采用了Nagle算法的，即在网络数据传输过程中，每个数据报文并不会立马发送出去，而是会等待一段时间，将后面的几个数据包一起组合成一个数据报文发送，但这个算法虽然提高了网络吞吐量，但是实时性却降低了，因此： （1）项目如果属于交互性很强的应用，那么可以手动开启<code>tcp_nodelay</code>配置，让应用程序向内核递交的每个数据包都会立即发送出去。但这样会产生大量的<code>TCP</code>报文头，增加很大的网络开销。常见的场景为<code>IM</code>、金融等类型的项目 （2）有些项目的业务对数据的实时性要求并不高，追求的则是更高的吞吐，那么则可以开启<code>tcp_nopush</code>配置项，这个配置就类似于“塞子”的意思，首先将连接塞住，使得数据先不发出去，等到拔去塞子后再发出去。设置该选项后，内核会尽量把小数据包拼接成一个大的数据包（一个<code>MTU</code>）再发送出去，当然若一定时间后（一般为<code>200ms</code>），内核仍然没有积累到一个<code>MTU</code>的量时，也必须发送现有的数据，否则会一直阻塞，常见常见为调度系统、报表系统等</p>
<h4 id="优化四调整worker工作进程">优化四：调整Worker工作进程</h4>
<p><code>Nginx</code>启动后默认只会开启一个<code>Worker</code>工作进程处理客户端请求，而我们可以根据机器的CPU核数开启对应数量的工作进程，以此来提升整体的并发量支持，如下 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"># 自动根据CPU核心数调整Worker进程数量  <br>worker_processes <span class="hljs-keyword">auto</span>;  <br></code></pre></td></tr></table></figure></p>
<p><strong>Worker进程的数量必须等于或者大于CPU核心的数量</strong>。由于Nginx采用了事件驱动的非阻塞架构，繁忙时Worker进程会一直处于Running状态，<strong>因此1个Worker进程就能够完全占用1个CPU核心的全部计算力</strong>，如果Worker进程数超过了CPU核心数，反而会造成一些Worker进程因为抢不到CPU而进入Sleep状态休眠</p>
<h4 id="优化五开启cpu亲和机制redis也有类似的优化方案">优化五：开启CPU亲和机制（redis也有类似的优化方案）</h4>
<p>因为进程/线程数往往都会远超出系统CPU的核心数，因此操作系统执行的原理本质上是采用时间片切换机制，也就是一个CPU核心会在多个进程之间不断频繁切换，造成很大的性能损耗。而CPU亲和机制则是指将每个<code>Nginx</code>的工作进程，绑定在固定的CPU核心上，从而减小CPU切换带来的时间开销和资源损耗，开启方式如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">worker_cpu_affinity <span class="hljs-keyword">auto</span>;  <br></code></pre></td></tr></table></figure>
<p>taskset是linux提供的一个命令，可以让某个程序运行在某个（或）某些CPU上</p>
<h4 id="优化六开启epoll模型及调整并发连接数">优化六：开启epoll模型及调整并发连接数</h4>
<p><code>Nginx、Redis</code>都是基于多路复用模型去实现的程序，但最初版的多路复用模型<code>select</code>最大只能监听<code>1024</code>个连接，而<code>epoll</code>则属于<code>select</code>接口的增强版，因此采用该模型能够大程度上提升单个<code>Worker</code>的性能</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">问题：为什么select只能监听1024的连接？<br>答案：select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认**最大值为 1024**，只能监听 0~1023 的文件描述符<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">events &#123;  <br>    # 使用epoll网络模型  <br>    use epoll;  <br>    # 调整每个Worker能够处理的连接数上限  <br>    worker_connections  <span class="hljs-number">10240</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure>
<h2 id="nginx与网关">Nginx与网关</h2>
<p>网关是系统的唯一对外的入口，介于客户端和服务器端之间的中间层，处理非业务功能，提供路由请求、鉴权、监控、缓存、限流等功能。无论你查看任何一个微服务项目架构，你都会发现在客户端和服务器端之间有一个网关，移动端的任何请求都必须经过网关才能到达服务端，见下图： <img src="Pasted%20image%2020240319184553.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">过滤器Filter和网关的区别<br><span class="hljs-bullet">- </span>过滤器用于拦截单个服务<br><span class="hljs-bullet">- </span>网关用于拦截整个微服务<br><span class="hljs-bullet">- </span>可以理解成网关是小区门口的保安，拦截的是所有到访者；过滤器则是每户人家的门，拦截的是单个人，而且要想到达过滤器必须先经过网关。<br></code></pre></td></tr></table></figure>
<h4 id="nginx和gateway区别">Nginx和Gateway区别</h4>
<ul>
<li>相同点：都是可以实现对api接口的拦截，负载均衡、反向代理、请求过滤等。</li>
<li>不同点：Nginx是用C语言写的，而Gateway是用Java写的，能够更好对微服务实现拓展功能，而Nginx想要实现拓展功能需要结合Lua语言等。此外Nginx实现负载均衡原理是属于服务器端负载均衡器，而Gateway则是采用本地负载均衡的形式。</li>
</ul>
<h4 id="使用场景">使用场景</h4>
<p>首先Nginx会抵御第一波的并发流量，是用户最前端的访问，可以把它当做第一层网关。可以看到上面的图片中项目都是通过Nginx来实现静态资源映射的，这时候输入的url是Nginx中配置的url。经过Nginx之后，Nginx通过反向代理再将请求转发到不同的网关系统，这是第二层网关，网关系统是根据不同的微服务来整合的，比如移动端网关，自媒体端网关，管理员端网关等。</p>
<p><strong>在项目中同时使用到这两者的情况时候，可以这么理解，用户请求进来是先过Nginx网关，这里的Nginx就相当于一个流量网关，是属于用户访问的一个入口。 然后在进入到getway网关中，这里的getway网关属于一个业务网关，通过对应的属性配置将请求传递到每一个业务微服务中去。</strong></p>
<p>换句话说： <strong>Nginx做四层LB（传输层负载均衡）</strong> <strong>SpringGateway做七层LB（应用层负载均衡）</strong></p>
<p><strong>Nginx不再承担着服务的路由分发和负载均衡，转而使用SpringCloudGateway做更专业的事，是解耦的一种表现，两种网关的出现是架构在进化中对服务进一步细分的体现。</strong></p>
<h4 id="为什么有nginx还需要springcloudgateway">为什么有Nginx还需要SpringCloudGateway?</h4>
<p>SpringCloudGateway是一个从逻辑上更贴近服务侧，一般作为API网关，与项目更是一个整体。可以根据业务更可塑地进行网关逻辑的编写和调度。同时在控制层上多加上统一的一层，有效地实现了统一鉴权，将鉴权这件事成功地从原来的代码逻辑中解耦出来。<strong>核心：解耦</strong></p>
<h4 id="为什么有springcloudgateway还需要nginx呢">为什么有SpringCloudGateway还需要Nginx呢？</h4>
<p>（1）SpringCloudGateway是一个从逻辑上更贴近服务侧，一般作为API网关，而Nginx则是流量网关，二者负责的功能不同 （2）除了网关这个能力外，Nginx在很多情况下还充当静态资源服务器 服务器本地放着静态资源，实现动静分离，当大量的访问到达，nginx可以回应一部分不常变化的请求，例如css文件。避免大量的访问冲击后端业务。</p>
<h2 id="upstream-使用方式">upstream 使用方式</h2>
<p>upstream 模块不产生自己的内容，而是通过请求后端服务器得到内容。Nginx 内部封装了请求并取得响应内容的整个过程，所以upstream 模块只需要开发若干回调函数，完成构造请求和解析响应等具体的工作。</p>
<p>HTTP 模块启动upstream 机制的过程： 1. 调用函数 ngx_http_upstream_create 为请求创建upstream； 2. 设置上游服务器的地址；可通过配置文件 nginx.conf 配置好上游服务器地址；也可以通过ngx_http_request_t 中的成员resolved 设置上游服务器地址； 3. 设置 upstream 的回调方法； 4. 调用函数 ngx_http_upstream_init 启动upstream；</p>
<h4 id="如何处理http请求">如何处理http请求？</h4>
<p>在 Nginx 的初始化启动过程中，worker 工作进程会调用事件模块的ngx_event_process_init 方法为每个监听套接字ngx_listening_t 分配一个 ngx_connection_t 连接，并设置该连接上读事件的回调方法handler 为ngx_event_accept，同时将读事件挂载到epoll 事件机制中等待监听套接字连接上的可读事件发生，到此，Nginx 就可以接收并处理来自客户端的请求</p>
<h2 id="事件驱动模型源码">事件驱动模型源码</h2>
<p>事件驱动处理又被称为IO多路复用，最常见的包括以下三种：select模型，poll模型和epoll模型。Nginx服务器还支持rtsig模型、kqueue模型、dev/poll模型和eventport模型等</p>
<h3 id="select库poll库">select库/poll库</h3>
<p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</p>
<p>所以，对于 select 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认<strong>最大值为 1024</strong>，只能监听 0~1023 的文件描述符</p>
<p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p>
<p>但是 poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长</p>
<h3 id="epoll库">epoll库</h3>
<p>epoll库是Nginx服务器支持的高性能事件驱动库之一，它是公认的非常优秀的事件驱动模型，和poll库及select库有很大的不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//用法</span><br><span class="hljs-type">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>bind(s, ...);<br>listen(s, ...)<br><br><span class="hljs-type">int</span> epfd = epoll_create(...);<br>epoll_ctl(epfd, ...); <span class="hljs-comment">//将所有需要监听的socket添加到epfd中</span><br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">int</span> n = epoll_wait(...);<br>    <span class="hljs-keyword">for</span>(接收到数据的socket)&#123;<br>        <span class="hljs-comment">//处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>epoll 通过两个方面，很好解决了 select/poll 的问题 第一点，epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 <code>O(logn)</code>。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p>
<p>第二点， epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p>
<p><img src="Pasted%20image%2020240318165716.png" srcset="/img/loading.gif" lazyload></p>
<p>epoll 的方式即使监听的 Socket 数量越多的时候，<strong>效率不会线性下降</strong>，能够同时监听的 Socket 的数目上限为系统定义的进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p>
<h3 id="源码解析">源码解析</h3>
<p>两个数据结构和四个函数 （1）epitem <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> &#123;</span><br>	RB_ENTRY(epitem) rbn;<br>	<span class="hljs-comment">/*  RB_ENTRY(epitem) rbn等价于</span><br><span class="hljs-comment">	struct &#123;											</span><br><span class="hljs-comment">		struct type *rbe_left;		//指向左子树</span><br><span class="hljs-comment">		struct type *rbe_right;		//指向右子树</span><br><span class="hljs-comment">		struct type *rbe_parent;	//指向父节点</span><br><span class="hljs-comment">		int rbe_color;			    //该节点的颜色</span><br><span class="hljs-comment">	&#125; rbn</span><br><span class="hljs-comment">	*/</span><br> <br>	LIST_ENTRY(epitem) rdlink;<br>	<span class="hljs-comment">/* LIST_ENTRY(epitem) rdlink等价于</span><br><span class="hljs-comment">	struct &#123;									</span><br><span class="hljs-comment">		struct type *le_next;	//指向下个元素</span><br><span class="hljs-comment">		struct type **le_prev;	//前一个元素的地址</span><br><span class="hljs-comment">	&#125;*/</span><br> <br>	<span class="hljs-type">int</span> rdy; <span class="hljs-comment">//判断该节点是否同时存在与红黑树和双向链表中</span><br>	<br>	<span class="hljs-type">int</span> sockfd; <span class="hljs-comment">//socket句柄</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>;</span>  <span class="hljs-comment">//存放用户填充的事件</span><br>&#125;;<br></code></pre></td></tr></table></figure></p>
<p>epitem是中包含了两个主要的成员变量，分别是rbn和rdlink，前者是红黑树的节点，而后者是双链表的节点，也就是说一个epitem对象即可作为红黑树中的一个节点又可作为双链表中的一个节点。并且每个epitem中存放着一个event，对event的查询也就转换成了对epitem的查询。</p>
<p>也就是说在epoll中，epitem作为操作的最小单元出现，在红黑树中它就是红黑树节点，在链表中就是链表的节点</p>
<p>（2）eventpoll <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> &#123;</span><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	struct ep_rb_tree &#123;</span><br><span class="hljs-comment">		struct epitem *rbh_root; 			</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">	*/</span><br>	ep_rb_tree rbr;      <span class="hljs-comment">//rbr指向红黑树的根节点</span><br>	<br>	<span class="hljs-type">int</span> rbcnt; <span class="hljs-comment">//红黑树中节点的数量（也就是添加了多少个TCP连接事件）</span><br>	<br>	LIST_HEAD( ,epitem) rdlist;    <span class="hljs-comment">//rdlist指向双向链表的头节点；</span><br>	<span class="hljs-comment">/*	这个LIST_HEAD等价于 </span><br><span class="hljs-comment">		struct &#123;</span><br><span class="hljs-comment">			struct epitem *lh_first;</span><br><span class="hljs-comment">		&#125;rdlist;</span><br><span class="hljs-comment">	*/</span><br>	<br>	<span class="hljs-type">int</span> rdnum; <span class="hljs-comment">//双向链表中节点的数量（也就是有多少个TCP连接来事件了）</span><br> <br>	<span class="hljs-comment">// ...略...</span><br>	<br>&#125;;<br></code></pre></td></tr></table></figure></p>
<p>eventpoll是epoll的核心结构体。其中包含了两个主要的成员变量，分别是rbr和rdlist，前者指向红黑树的根节点，后者指向双链表的头结点。</p>
<p>（3）epoll_create() <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建epoll对象，包含一颗空红黑树和一个空双向链表</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>	<span class="hljs-comment">//与很多内核版本一样，size参数没有作用，只要保证大于0即可</span><br>	<span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	<br>	nty_tcp_manager *tcp = nty_get_tcp_manager(); <span class="hljs-comment">//获取tcp对象</span><br>	<span class="hljs-keyword">if</span> (!tcp) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">nty_socket</span> *<span class="hljs-title">epsocket</span> =</span> nty_socket_allocate(NTY_TCP_SOCK_EPOLL);<br>	<span class="hljs-keyword">if</span> (epsocket == <span class="hljs-literal">NULL</span>) &#123;<br>		nty_trace_epoll(<span class="hljs-string">&quot;malloc failed\n&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br> <br>	<span class="hljs-comment">// 1° 开辟了一块内存用于填充eventpoll对象</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span> =</span> (<span class="hljs-keyword">struct</span> eventpoll*)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> eventpoll));<br>	<span class="hljs-keyword">if</span> (!ep) &#123;<br>		nty_free_socket(epsocket-&gt;id, <span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br> <br>	ep-&gt;rbcnt = <span class="hljs-number">0</span>;<br> <br>	<span class="hljs-comment">// 2° 让红黑树根指向空</span><br>	RB_INIT(&amp;ep-&gt;rbr);       <span class="hljs-comment">//等价于ep-&gt;rbr.rbh_root = NULL;</span><br> <br>	<span class="hljs-comment">// 3° 让双向链表的头指向空</span><br>	LIST_INIT(&amp;ep-&gt;rdlist);  <span class="hljs-comment">//等价于ep-&gt;rdlist.lh_first = NULL;</span><br> <br>	<span class="hljs-comment">// 4° 并发环境下进行互斥</span><br>	<span class="hljs-comment">// ...该部分代码与主线逻辑无关，可自行查看...</span><br> <br>	<span class="hljs-comment">//5° 保存epoll对象</span><br>	tcp-&gt;ep = (<span class="hljs-type">void</span>*)ep;<br>	epsocket-&gt;ep = (<span class="hljs-type">void</span>*)ep;<br> <br>	<span class="hljs-keyword">return</span> epsocket-&gt;id;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>对以上代码的逻辑进行梳理，可以总结为以下6步： 1. 创建eventpoll对象 2. 让eventpoll中的rbr指向空 3. 让eventpoll中的rdlist指向空 4. 在并发环境下进行互斥 5. 保存eventpoll对象 6. 返回eventpoll对象的句柄(id)</p>
<p>（4）epoll_ctl() <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//往红黑树中加每个tcp连接以及相关的事件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epid, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> sockid, <span class="hljs-keyword">struct</span> epoll_event *event)</span> &#123;<br> <br>	nty_tcp_manager *tcp = nty_get_tcp_manager();<br>	<span class="hljs-keyword">if</span> (!tcp) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br> <br>	nty_trace_epoll(<span class="hljs-string">&quot; epoll_ctl --&gt; 1111111:%d, sockid:%d\n&quot;</span>, epid, sockid);<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">nty_socket</span> *<span class="hljs-title">epsocket</span> =</span> tcp-&gt;fdtable-&gt;sockfds[epid];<br> <br>	<span class="hljs-keyword">if</span> (epsocket-&gt;socktype == NTY_TCP_SOCK_UNUSED) &#123;<br>		errno = -EBADF;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br> <br>	<span class="hljs-keyword">if</span> (epsocket-&gt;socktype != NTY_TCP_SOCK_EPOLL) &#123;<br>		errno = -EINVAL;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br> <br>	nty_trace_epoll(<span class="hljs-string">&quot; epoll_ctl --&gt; eventpoll\n&quot;</span>);<br><br>	<span class="hljs-comment">//取出之前创建的ep</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span> =</span> (<span class="hljs-keyword">struct</span> eventpoll*)epsocket-&gt;ep;<br>	<span class="hljs-keyword">if</span> (!ep || (!event &amp;&amp; op != EPOLL_CTL_DEL)) &#123;<br>		errno = -EINVAL;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br> <br>	<span class="hljs-keyword">if</span> (op == EPOLL_CTL_ADD) &#123;<br>		<span class="hljs-comment">//添加sockfd上关联的事件</span><br>		pthread_mutex_lock(&amp;ep-&gt;mtx);<br> <br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> <span class="hljs-title">tmp</span>;</span><br>		tmp.sockfd = sockid;<br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> RB_FIND(_epoll_rb_socket, &amp;ep-&gt;rbr, &amp;tmp); <span class="hljs-comment">//先在红黑树上找，根据key来找，也就是这个sockid，找的速度会非常快</span><br>		<span class="hljs-keyword">if</span> (epi) &#123;<br>			<span class="hljs-comment">//原来有这个节点，不能再次插入</span><br>			nty_trace_epoll(<span class="hljs-string">&quot;rbtree is exist\n&quot;</span>);<br>			pthread_mutex_unlock(&amp;ep-&gt;mtx);<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>		&#125;<br> <br>		<span class="hljs-comment">//只有红黑树上没有该节点【没有用过EPOLL_CTL_ADD的tcp连接才能走到这里】；</span><br> <br>		<span class="hljs-comment">//(1)生成了一个epitem对象，这个结构对象，其实就是红黑的一个节点；</span><br>		epi = (<span class="hljs-keyword">struct</span> epitem*)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epitem));<br>		<span class="hljs-keyword">if</span> (!epi) &#123;<br>			pthread_mutex_unlock(&amp;ep-&gt;mtx);<br>			errno = -ENOMEM;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>		&#125;<br>		<br>		<span class="hljs-comment">//(2)把socket(TCP连接)保存到节点中；</span><br>		epi-&gt;sockfd = sockid;  <span class="hljs-comment">//作为红黑树节点的key，保存在红黑树中</span><br> <br>		<span class="hljs-comment">//(3)我们要增加的事件也保存到节点中；</span><br>		<span class="hljs-built_in">memcpy</span>(&amp;epi-&gt;event, event, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event));<br> <br>		<span class="hljs-comment">//(4)把这个节点插入到红黑树中去</span><br>		epi = RB_INSERT(_epoll_rb_socket, &amp;ep-&gt;rbr, epi); <span class="hljs-comment">//实际上这个时候epi的rbn成员就会发挥作用，如果这个红黑树中有多个节点，那么RB_INSERT就会epi-&gt;rbi相应的值：可以参考图来理解</span><br>		assert(epi == <span class="hljs-literal">NULL</span>);<br>		ep-&gt;rbcnt ++;<br>		<br>		pthread_mutex_unlock(&amp;ep-&gt;mtx);<br> <br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == EPOLL_CTL_DEL) &#123;<br>		pthread_mutex_lock(&amp;ep-&gt;mtx);<br> <br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> <span class="hljs-title">tmp</span>;</span><br>		tmp.sockfd = sockid;<br><br>		<span class="hljs-comment">//先在红黑树上找到要删除的sockid，根据key来找</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> RB_FIND(_epoll_rb_socket, &amp;ep-&gt;rbr, &amp;tmp);<br>		<span class="hljs-keyword">if</span> (!epi) &#123;<br>			nty_trace_epoll(<span class="hljs-string">&quot;rbtree no exist\n&quot;</span>);<br>			pthread_mutex_unlock(&amp;ep-&gt;mtx);<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>		&#125;<br>		<br>		<span class="hljs-comment">//只有在红黑树上找到该节点【用过EPOLL_CTL_ADD的tcp连接才能走到这里】；</span><br> <br>		<span class="hljs-comment">//从红黑树上把这个节点移除</span><br>		epi = RB_REMOVE(_epoll_rb_socket, &amp;ep-&gt;rbr, epi);<br>		<span class="hljs-keyword">if</span> (!epi) &#123;<br>			nty_trace_epoll(<span class="hljs-string">&quot;rbtree is no exist\n&quot;</span>);<br>			pthread_mutex_unlock(&amp;ep-&gt;mtx);<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>		&#125;<br> <br>		ep-&gt;rbcnt --;<br>		<span class="hljs-built_in">free</span>(epi);<br>		<br>		pthread_mutex_unlock(&amp;ep-&gt;mtx);<br> <br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == EPOLL_CTL_MOD) &#123;<br>		<span class="hljs-keyword">struct</span> epitem tmp;<br>		tmp.sockfd = sockid;<br>		<br>		<span class="hljs-comment">//同理查找</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> RB_FIND(_epoll_rb_socket, &amp;ep-&gt;rbr, &amp;tmp); <br>		<span class="hljs-keyword">if</span> (epi) &#123;<br>			<span class="hljs-comment">//红黑树上有该节点，则修改对应的事件</span><br>			epi-&gt;event.events = event-&gt;events;<br>			epi-&gt;event.events |= EPOLLERR | EPOLLHUP;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			errno = -ENOENT;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>		&#125;<br> <br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		nty_trace_epoll(<span class="hljs-string">&quot;op is no exist\n&quot;</span>);<br>		assert(<span class="hljs-number">0</span>);<br>	&#125;<br> <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 该函数的逻辑其实很简单，无非就是将用户传入的参数封装为一个epitem对象，然后根据传入的op是 - EPOLL_CTL_ADD，将epitem对象插入红黑树中</p>
<ul>
<li><p>EPOLL_CTL_MOD，更新红黑树中的epitem对象</p></li>
<li><p>EPOLL_CTL_DEL，移除红黑树中的epitem对象</p></li>
</ul>
<ol start="5" type="1">
<li>epoll_wait()</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//到双向链表中去取相关的事件通知</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epid, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span> &#123;<br> <br>	nty_tcp_manager *tcp = nty_get_tcp_manager();<br>	<span class="hljs-keyword">if</span> (!tcp) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br> <br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">nty_socket</span> *<span class="hljs-title">epsocket</span> =</span> tcp-&gt;fdtable-&gt;sockfds[epid];<br> <br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span> =</span> (<span class="hljs-keyword">struct</span> eventpoll*)epsocket-&gt;ep;<br>	<br>    <span class="hljs-comment">// ...此处主要是一些负责验证性工作的代码...</span><br> <br>	<span class="hljs-comment">//(1)当eventpoll对象的双向链表为空时，程序会在这个while中等待一定时间，</span><br>	<span class="hljs-comment">//直到有事件被触发，操作系统将epitem插入到双向链表上使得rdnum&gt;0时，程序才会跳出while循环</span><br>	<span class="hljs-keyword">while</span> (ep-&gt;rdnum == <span class="hljs-number">0</span> &amp;&amp; timeout != <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">// ...此处主要是一些与等待时间相关的代码...</span><br>	&#125;<br> <br> <br>	pthread_spin_lock(&amp;ep-&gt;lock);<br> <br>	<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br> <br>	<span class="hljs-comment">//(1)取得事件的数量</span><br>	<span class="hljs-comment">//ep-&gt;rdnum：代表双向链表里边的节点数量（也就是有多少个TCP连接来事件了）</span><br>	<span class="hljs-comment">//maxevents：此次调用最多可以收集到maxevents个已经就绪【已经准备好】的读写事件</span><br>	<span class="hljs-type">int</span> num = (ep-&gt;rdnum &gt; maxevents ? maxevents : ep-&gt;rdnum); <span class="hljs-comment">//哪个数量少，就取得少的数字作为要取的事件数量</span><br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	<br>	<span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span> &amp;&amp; !LIST_EMPTY(&amp;ep-&gt;rdlist)) &#123; <span class="hljs-comment">//EPOLLET</span><br> <br>		<span class="hljs-comment">//(2)每次都从双向链表头取得 一个一个的节点</span><br>		<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> LIST_FIRST(&amp;ep-&gt;rdlist);<br> <br>		<span class="hljs-comment">//(3)把这个节点从双向链表中删除【但这并不影响这个节点依旧在红黑树中】</span><br>		LIST_REMOVE(epi, rdlink); <br> <br>		<span class="hljs-comment">//(4)这是个标记，标记这个节点【这个节点本身是已经在红黑树中】已经不在双向链表中；</span><br>		epi-&gt;rdy = <span class="hljs-number">0</span>;  <span class="hljs-comment">//当这个节点被操作系统 加入到 双向链表中时，这个标记会设置为1。</span><br> <br>		<span class="hljs-comment">//(5)把事件标记信息拷贝出来；拷贝到提供的events参数中</span><br>		<span class="hljs-built_in">memcpy</span>(&amp;events[i++], &amp;epi-&gt;event, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event));<br>		<br>		num --;<br>		cnt ++;       <span class="hljs-comment">//拷贝 出来的 双向链表 中节点数目累加</span><br>		ep-&gt;rdnum --; <span class="hljs-comment">//双向链表里边的节点数量减1</span><br>	&#125;<br>	<br>	pthread_spin_unlock(&amp;ep-&gt;lock);<br> <br>	<span class="hljs-comment">//(5)返回 实际 发生事件的 tcp连接的数目；</span><br>	<span class="hljs-keyword">return</span> cnt; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>先看一下eventpoll对象的双链表中是否有节点。如果有节点的话则取出节点中的事件填充到用户传入的指针所指向的内存中。如果没有节点的话，则在while循环中等待一定时间，直到有事件被触发后操作系统会将epitem插入到双向链表上使得rdnum&gt;0时(这个过程是由操作系统调用epoll_event_callback函数完成的)，程序才会跳出while循环，去双向链表中取数据。</p>
<p>（6）epoll_event_callback() 通过跟踪epoll_event_callback在内核中被调用的位置。可知，当服务器在以下5种情况会调用epoll_event_callback： 1. 客户端connect()连入，服务器处于SYN_RCVD状态时 2. 三路握手完成，服务器处于ESTABLISHED状态时 3. 客户端close()断开连接，服务器处于FIN_WAIT_1和FIN_WAIT_2状态时 4. 客户端send/write()数据，服务器可读时 5. 服务器可以发送数据时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//当发生客户端三路握手连入、可读、可写、客户端断开等情况时，操作系统会调用这个函数，用以往双向链表中增加一个节点【该节点同时 也在红黑树中】</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_event_callback</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-type">int</span> sockid, <span class="hljs-type">uint32_t</span> event)</span> &#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> <span class="hljs-title">tmp</span>;</span><br>	tmp.sockfd = sockid;<br> <br>	<span class="hljs-comment">//(1)根据给定的key【这个TCP连接的socket】从红黑树中找到这个节点</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> RB_FIND(_epoll_rb_socket, &amp;ep-&gt;rbr, &amp;tmp);<br>	<span class="hljs-keyword">if</span> (!epi) &#123;<br>		nty_trace_epoll(<span class="hljs-string">&quot;rbtree not exist\n&quot;</span>);<br>		assert(<span class="hljs-number">0</span>);<br>	&#125;<br> <br>	<span class="hljs-comment">//(2)从红黑树中找到这个节点后，判断这个节点是否已经被连入到双向链表里【判断的是rdy标志】</span><br>	<span class="hljs-keyword">if</span> (epi-&gt;rdy) &#123;<br>		<span class="hljs-comment">//这个节点已经在双向链表里，那无非是把新发生的事件标志增加到现有的事件标志中</span><br>		epi-&gt;event.events |= event;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125; <br> <br>	<span class="hljs-comment">//走到这里，表示 双向链表中并没有这个节点，那要做的就是把这个节点连入到双向链表中</span><br> <br>	nty_trace_epoll(<span class="hljs-string">&quot;epoll_event_callback --&gt; %d\n&quot;</span>, epi-&gt;sockfd);<br>	<br>	pthread_spin_lock(&amp;ep-&gt;lock);<br> <br>	<span class="hljs-comment">//(3)标记这个节点已经被放入双向链表中，我们刚才研究epoll_wait()的时候，从双向链表中把这个节点取走的时候，这个标志被设置回了0</span><br>	epi-&gt;rdy = <span class="hljs-number">1</span>;  <br> <br>	<span class="hljs-comment">//(4)把这个节点链入到双向链表的表头位置</span><br>	LIST_INSERT_HEAD(&amp;ep-&gt;rdlist, epi, rdlink);<br> <br>	<span class="hljs-comment">//(5)双向链表中的节点数量加1，刚才研究epoll_wait()的时候，从双向链表中把这个节点取走的时候，这个数量减了1</span><br>	ep-&gt;rdnum ++;<br> <br>	pthread_spin_unlock(&amp;ep-&gt;lock);<br>	pthread_mutex_lock(&amp;ep-&gt;cdmtx);<br>	pthread_cond_signal(&amp;ep-&gt;cond);<br>	pthread_mutex_unlock(&amp;ep-&gt;cdmtx);<br> <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>将eventpoll所指向的红黑树的节点插入到双向链表中</p>
<p>总的来说，epoll底层实现中有两个关键的数据结构，一个是eventpoll另一个是epitem，其中eventpoll中有两个成员变量分别是rbr和rdlist,前者指向一颗红黑树的根，后者指向双向链表的头。而epitem则是红黑树节点和双向链表节点的综合体，也就是说epitem即可作为树的节点，又可以作为链表的节点，并且epitem中包含着用户注册的事件 （1）当用户调用epoll_create()时，会创建eventpoll对象（包含一个红黑树和一个双链表）； （2）而用户调用epoll_ctl(ADD)时，会在红黑树上增加节点（epitem对象）； （3）接下来，操作系统会默默地在通过epoll_event_callback()来管理eventpoll对象。当有事件被触发时，操作系统则会调用epoll_event_callback函数，将含有该事件的epitem添加到双向链表中。 （4）当用户需要管理连接时，只需通过epoll_wait()从eventpoll对象中的双链表下&quot;摘取&quot;epitem并取出其包含的事件即可。</p>
<p>之后对应读写操作的进程就可以苏醒，处理这个事件，调用recvfrom将准备好的数据从内核态拷贝到用户态，然后正常使用这些数据。</p>
<h3 id="触发模式">触发模式</h3>
<p>epoll 支持两种事件触发模式，分别是边缘触发（edge-triggered，ET）和水平触发（level-triggered，LT）**。</p>
<ul>
<li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；（）</li>
<li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</li>
</ul>
<p>举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式</p>
<p>二者的核心区别： <strong>保证1</strong>：在LT模式下，“就绪链表”上取出的epi上报完事件后会重新加回“就绪链表”；<strong>保证2</strong>：如果“就绪链表”不为空，且此时有进程阻塞在同一个epoll句柄的睡眠队列上，则唤醒它。</p>
<p>ET模式不满足上述的“保证1”，所以不会将已经上报事件的epi重新链接回“就绪链表”，也就是说，只要一个“<strong>就绪队列</strong>”上的epi上的事件被上报了，它就会被删除出“<strong>就绪队列</strong>”。（所以</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//LT</span><br>set_socket_nonblocking(sd);  <br>epfd = epoll_create(<span class="hljs-number">64</span>);  <br>event.data.fd = sd;  <br>epoll_ctl(epfd, EPOLL_CTL_ADD, sd, &amp;event);  <br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;  <br>    epoll_wait(epfd, events, <span class="hljs-number">64</span>, xx);  <br>    ... <span class="hljs-comment">// 危险区域！如果有共享同一个epfd的进程/线程调用epoll_wait，它们也将会被唤醒！  </span><br><span class="hljs-comment">// 这个accept将会有多个进程/线程调用，如果并发请求数很少，那么将仅有几个进程会成功：  </span><br><span class="hljs-comment">// 1. 假设accept队列中有n个请求，则仅有n个进程能成功，其它将全部返回EAGAIN (Resource temporarily unavailable)  </span><br><span class="hljs-comment">// 2. 如果n很大(即增加请求负载)，虽然返回EAGAIN的比率会降低，但这些进程也并不一定取到了epoll_wait返回当下的那个预期的请求。  </span><br>    csd = accept(sd, &amp;in_addr, &amp;in_len);   <br>    ...  <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//ET</span><br>set_socket_nonblocking(sd);  <br>epfd = epoll_create(<span class="hljs-number">64</span>);  <br>event.data.fd = sd;  <br><span class="hljs-comment">// 添加ET标记  </span><br>event.events |= EPOLLET;  <br>epoll_ctl(epfd, EPOLL_CTL_ADD, sd, &amp;event);  <br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;  <br>    epoll_wait(epfd, events, <span class="hljs-number">64</span>, xx);  <br>    <span class="hljs-keyword">while</span> ((csd = accept(sd, &amp;in_addr, &amp;in_len)) &gt; <span class="hljs-number">0</span>) &#123;  <br>        do_something(...);  <br>    &#125;   <br>    ...  <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="惊群现象">惊群现象</h3>
<p>对于nginx的惊群问题，首先需要理解的是，在nginx启动过程中，master进程会监听配置文件中指定的各个端口，然后master进程就会调用fork()方法创建各个子进程，根据进程的工作原理，子进程是会继承父进程的全部内存数据以及监听的端口的，也就是说worker进程在启动之后也是会监听各个端口的。</p>
<p>关于惊群，指的就是当客户端有新建连接的请求到来时，就会触发各个worker进程的连接建立事件，但是只有一个worker进程能够正常处理该事件，而其他的worker进程会发现事件已经失效，从而重新循环进入等待状态。</p>
<p>这种由于一个事件而“惊”起了所有worker进程的现象就是惊群问题。很明显，如果所有的worker进程都被触发了，那么这将消耗大量的资源，本文则主要讲解nginx是如何处理惊群问题的。</p>
<p><strong>解决方案：</strong> 每个worker进程被创建的时候，都会调用ngx_worker_process_init()方法初始化当前worker进程，这个过程中有一个非常重要的步骤，即每个worker进程都会调用epoll_create()方法为自己创建一个独有的epoll句柄。</p>
<p>对于每一个需要监听的端口，都有一个文件描述符与之对应，而worker进程只有将该文件描述符通过epoll_ctl()方法添加到当前进程的epoll句柄中，并且监听accept事件，此时才会被客户端的连接建立事件触发，从而处理该事件。</p>
<p>从这里也可以看出，worker进程如果没有将所需要监听的端口对应的文件描述符添加到该进程的epoll句柄中，那么其是无法被触发对应的事件的。基于这个原理，nginx就使用了一个共享锁来控制当前进程是否有权限将需要监听的端口添加到当前进程的epoll句柄中，也就是说，只有获取锁的进程才会监听目标端口。通过这种方式，就保证了每次事件发生时，只有一个worker进程会被触发。如下图所示为worker进程工作循环的一个示意图：</p>
<p><img src="Pasted%20image%2020240319215247.png" srcset="/img/loading.gif" lazyload></p>
<p>这里关于图中的流程，需要说明的一点是，每个worker进程在进入循环之后就会尝试获取<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%85%B1%E4%BA%AB%E9%94%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2347799383%7D">共享锁</a>，如果没有获取到，就会将所监听的端口的文件描述符从当前进程的epoll句柄中移除（即使并不存在也会移除），这么做的主要目的是防止丢失客户端连接事件</p>
<p>举个例子：如果按照理论，在当前进程释放锁的时候就将监听的端口的文件描述符从epoll句柄中移除，那么在下一个worker进程获取锁之前，这段时间各个端口对应的文件描述符是没有任何<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=epoll&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2347799383%7D">epoll</a>句柄进行监听的，此时就会造成事件的丢失。如果反过来，按照图中的在获取锁失败的时候才移除监听的文件描述符，由于获取锁失败，则说明当前一定有一个进程已经监听了这些文件描述符，因而此时移除是安全的</p>
<p>是这样会造成的一个问题是，按照上图，当前进程在一个循环执行完毕的时候，会释放锁，然后处理其他的事件，注意这个过程中其是没有释放所监听的文件描述符的。此时，如果另一个进程获取到了锁，并且监听了文件描述符，那么这个时候就有两个进程监听了文件描述符，因而此时如果客户端发生连接建立事件，那么就会触发两个worker进程，但这个问题是可以容忍的。</p>
<p>这样处理其实还有一个问题，那就是在抢夺锁的过程中，可能会出现饥饿现象。因此nginx还采用了ngx_accept_disabled参数来控制worker进程是否参与抢夺锁，如果进程繁忙，就不抢夺锁，避免其他进程饥饿以及自己的负载过高。</p>
<p>注意： 为什么<strong>reuseport</strong>没有惊群？ 惊群发生的原因在于同时唤醒了多个进程处理一个事件，导致了不必要的CPU空转。为什么会唤醒多个进程，因为发生事件的文件描述符在多个进程之间是共享的。而reuseport呢，侦听同一个IP地址端口对的多个socket本身在socket层就是相互隔离的，在它们之间的事件分发是TCP/IP协议栈完成的，所以不会再有惊群发生。</p>
<p>https://mp.weixin.qq.com/s/xxjCrFH1361iG-srfNL9_Q</p>
<h2 id="实际场景tcp-epoll的工作流程">实际场景：tcp + epoll的工作流程</h2>
<p><img src="Pasted%20image%2020240319221248.png" srcset="/img/loading.gif" lazyload></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%90%8E%E7%AB%AF/" class="category-chain-item">后端</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Nginx-%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="print-no-link">#Nginx,中间件</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Nginx学习总结</div>
      <div>http://example.com/2024/04/19/Nginx学习总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Cygnus</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年4月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/04/19/docker%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="docker学习总结">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">docker学习总结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/04/15/Lab9-Symlink/" title="Lab9 Symlink">
                        <span class="hidden-mobile">Lab9 Symlink</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
