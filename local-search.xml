<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Lab2 system calls</title>
    <link href="/2023/09/04/Lab2-system-calls/"/>
    <url>/2023/09/04/Lab2-system-calls/</url>
    
    <content type="html"><![CDATA[<p>[课程地址]([<a href="https://pdos.csail.mit.edu/6.S081/2021/labs/syscall.html">Lab: System calls (mit.edu)</a>])_</p><p>本次实验是需要完成一些系统调用功能，在开始前需要先理解进程相关的概念和系统调用的原理</p><h2 id="系统调用的原理"><a href="#系统调用的原理" class="headerlink" title="系统调用的原理"></a>系统调用的原理</h2><p>回顾第二章书本上的知识，我们知道程序一般运行在用户态，只有遇到以下三种情况才会陷入中断进入内核态：</p><ol><li><strong>系统调用</strong>：当用户程序执行<strong>ecall</strong>指令要求内核为其做某事时。</li><li><strong>异常</strong>：一条指令(用户或内核)做了一些非法的事情，如除以零或使用无效的虚拟地址。</li><li><strong>中断</strong>：当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时。</li></ol><p>所以研究系统调用，其实也就是研究中断（trap）过程是如何发生的。宏观上可分为四个步骤，本文会针对这四个步骤，结合xv6系统进行详细的讲解：</p><ol><li>中断请求</li><li>保护现场</li><li>中断处理</li><li>中断返回</li></ol><p>以上过程自然离不开与寄存器打交道，例如<strong>satp寄存器用于控制分页系统</strong>，以下是与trap相关的寄存器概述，这些寄存器可以分为两类：<br><strong>1. 发生中断时，硬件自动写入的寄存器</strong><br>    -  <code>sepc</code>：当trap发生时，RISC-V会将程序计数器保存在这里(因为<code>PC</code>会被<code>stvec</code>覆盖)。<code>sret</code>(从trap中返回)指令将<code>sepc</code>复制到<code>pc</code>中。内核可以写<code>sepc</code>来控制<code>sret</code>的返回到哪里。<br>    -  <code>scause</code>：RISC -V在这里放了一个数字，描述了trap的原因。<br>    -  <code>stval</code>：<code>scause</code> 不足以存下中断所有的必须信息。例如缺页异常，就会将 <code>stval</code> 设置成需要访问但是不在内存中的地址，以便于操作系统将这个地址所在的页面加载进来。</p><p><strong>2. 指导硬件处理中断的寄存器</strong><br>    - <code>stvec</code>：保存内核中断处理流程的入口地址，内核在这里写下trap处理程序的地址；RISC-V跳转到这里来处理trap。<br>    - <code>sstatus</code>：具有许多状态位，控制全局中断等。<code>sstatus</code>中的<strong>SIE</strong>位控制设备中断是否被启用，如果内核清除<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核设置<strong>SIE</strong>。<strong>SPP</strong>位表示trap是来自用户模式还是supervisor模式，并控制<code>sret</code>返回到什么模式。<br>    - <code>sie</code>：即 Supervisor Interrupt Enable，用来控制具体类型中断，例如其中的 STIE 控制时钟中断<br>    - <code>sip</code>：即 Supervisor Interrupt Pending，和 <code>sie</code> 相对应，记录每种中断是否被触发。仅当 <code>sie</code> 和 <code>sip</code> 的对应位都为 1 时，意味着开中断且已发生中断，这时中断最终触发。<br>    - <code>sscratch</code>：内核在这里放置了一个值，在trap处理程序开始时可以方便地使用。在用户态保存内核栈的地址，在内核态值为 0。为什么需要内核栈？因此中断处理流程也需要利用内存空间，很可能需要使用栈，而程序当前的用户栈是不安全的（说不定指针不断运行到其他进程的空间，破坏了隔离性）。因此，我们还需要一个预设的安全的栈空间，存放在这里。</p><p>有了上述与中断相关的寄存器，自然也就有与中断相关的指令：<br><strong>1. 进入和退出中断</strong><br>    - <code>ecall</code>：触发中断，进入更高一层的中断处理流程之中。用户态进行系统调用进入内核态中断处理流程，内核态进行 SBI 调用进入机器态中断处理流程，使用的都是这条指令。<br>    - <code>sret</code>：从内核态返回用户态，同时将 <code>sepc</code> 的值赋值给 <code>pc</code>。（如果需要返回到 <code>sepc</code> 后一条指令，就需要在 <code>sret</code> 之前修改 <code>sepc</code> 的值）<br>    - <code>ebreak</code>：触发一个断电<br>    - <code>mret</code>：从机器态返回内核态，同时将 <code>pc</code> 的值设置为 <code>mepc</code>。</p><p><strong>2. 操作CSR</strong><br>    只有一系列特殊的指令（CSR Instruction）可以读写 CSR<br>    - <code>csrrw dst, csr, src</code>（CSR Read Write）同时读写的原子操作，将指定 CSR 的值写入 <code>dst</code>，同时将 <code>src</code> 的值写入 CSR。<br>    - <code>csrr dst, csr</code>（CSR Read）：仅读取一个 CSR 寄存器。<br>    - <code>csrw csr, src</code>（CSR Write）  ：仅写入一个 CSR 寄存器。</p><p>微观上，RISC-V硬件对每一个trap操作（除定时器中断外），都会执行如下步骤：</p><ol><li>如果该trap是设备中断，且sstatus SIE位为0，则不执行以下任何操作</li><li>通过清除 SIE 来禁用中断</li><li>复制 pc 到 sepc</li><li>将当前模式(用户态或特权态)保存在 sstatus 的 SPP 位</li><li>在 scause 设置该次trap的原因</li><li>将模式转换为特权态</li><li>将 stvec 复制到 pc</li><li>从新的pc开始执行</li></ol><h4 id="中断请求"><a href="#中断请求" class="headerlink" title="中断请求"></a>中断请求</h4><p>当使用到<code>write，read，open</code>等系统调用时，会使用<code>ecall</code>指令发起中断请求</p><ul><li><code>ecall</code>是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用</li></ul><p>在xv6中，<code>user/cat.c</code>文件是<code>cat shell</code>指令的源码，其中涉及到了<code>read</code>函数，它声明在<code>user/user.h</code>文件中，但是<code>read</code>函数的实现在<code>kernel/sysfile.c</code>文件中。显然<code>cat</code>并不是直接调用<code>sysfile.c</code>文件中的函数来达成目标的，毕竟一个在用户态，一个在内核态。</p><p>既然<code>read</code>在用户态的角度看不见具体的逻辑实现，那它为什么能正常运行呢？只声明不实现的函数是无法正常使用的呀？</p><p>仔细观察user文件架，我们可以发现虽然没有<code>read</code>函数的c语言实现，但其实存在汇编实现。用户在c代码中使用<code>read</code>函数时，其实是在运行<code>usys.S</code>文件（由<code>usys.pl</code>文件得来，make指令才能看见）中<code>read</code>函数。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">c</span>语言如何调用汇编函数？步骤：<br><span class="hljs-number">1</span>、先在汇编程序中声明函数属性为GLOBAL<br><span class="hljs-number">2</span>、在<span class="hljs-keyword">c</span>文件开头声明该函数<br><span class="hljs-number">3</span>、按照C语言正常调用函数的方式调用该函数<br></code></pre></td></tr></table></figure><p>当然，这个汇编函数虽然名称也叫<code>read</code>，但并不是在执行读取文件的逻辑，而是在建立用户态与内核态的桥梁。<code>usys.pl</code>脚本的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">#!/usr/bin/perl -w  <br>  <br># Generate usys.S, the stubs <span class="hljs-keyword">for</span> syscalls.  <br>  <br>print <span class="hljs-string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;  <br>  <br>print <span class="hljs-string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;  <br>  <br>sub entry &#123;  <br>    my $name = shift;  <br>    print <span class="hljs-string">&quot;.global $name\n&quot;</span>;  <br>    print <span class="hljs-string">&quot;$&#123;name&#125;:\n&quot;</span>;  <br>    print <span class="hljs-string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;  <br>    print <span class="hljs-string">&quot; ecall\n&quot;</span>;  <br>    print <span class="hljs-string">&quot; ret\n&quot;</span>;  <br>&#125;  <br>     <br>entry(<span class="hljs-string">&quot;fork&quot;</span>);  <br>entry(<span class="hljs-string">&quot;exit&quot;</span>);  <br>entry(<span class="hljs-string">&quot;wait&quot;</span>);  <br>entry(<span class="hljs-string">&quot;pipe&quot;</span>);  <br>entry(<span class="hljs-string">&quot;read&quot;</span>);  <br>entry(<span class="hljs-string">&quot;write&quot;</span>);  <br>entry(<span class="hljs-string">&quot;close&quot;</span>);  <br>entry(<span class="hljs-string">&quot;kill&quot;</span>);  <br>entry(<span class="hljs-string">&quot;exec&quot;</span>);  <br>entry(<span class="hljs-string">&quot;open&quot;</span>);  <br>entry(<span class="hljs-string">&quot;mknod&quot;</span>);  <br>entry(<span class="hljs-string">&quot;unlink&quot;</span>);  <br>entry(<span class="hljs-string">&quot;fstat&quot;</span>);  <br>entry(<span class="hljs-string">&quot;link&quot;</span>);  <br>entry(<span class="hljs-string">&quot;mkdir&quot;</span>);  <br>entry(<span class="hljs-string">&quot;chdir&quot;</span>);  <br>entry(<span class="hljs-string">&quot;dup&quot;</span>);  <br>entry(<span class="hljs-string">&quot;getpid&quot;</span>);  <br>entry(<span class="hljs-string">&quot;sbrk&quot;</span>);  <br>entry(<span class="hljs-string">&quot;sleep&quot;</span>);  <br>entry(<span class="hljs-string">&quot;uptime&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>usys.pl</code>是一个Perl语言文件。即使对Perl语言并没有深入了解，但根据语法规则可以大概了解它的作用：这个脚本文件将根据输入的字符名，通过<code>entry()</code>格式化生成文本文件。</p><p><code>usys.pl</code>的输入是系统调用的名称，输出内容则保存为<code>kernel/usys.S</code>。这样每个系统调用都在<code>usys.S</code>文件中都有一个实现，通过<code>global</code>声明后，用户在使用同名的函数时，会执行这里的<code>entry()</code>中的逻辑：</p><ol><li>将系统调用的ID存入a7寄存器<ul><li>虽然输入的是名称（字符串），但是<code>kernel/syscall.h</code>文件下将字符串映射为了编号</li></ul></li><li>执行ecall命令<ul><li><code>ecall</code>是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用</li></ul></li></ol><p>这样就通过<code>ecall</code>指令（中断请求）将需要的系统调用从用户态传递给了内核态。在ecall调用过程中会发生（和前文中讲到的微观操作一致，但这里只写主要内容）：</p><ol><li>关中断</li><li>代码从<code>user mode</code>改到supervisor mode</li><li>程序计数器<code>PC</code>的值保存进 <code>SEPC</code> 寄存器</li><li>CPU执行<code>STVEC</code>寄存器指向的指令（<code>PC</code>重置为 <code>STVEC</code> 寄存器的值）</li></ol><p>问题：那么<code>STVEC</code>寄存器的值到底是多少？<br>答案：<code>STVEC</code>是一个特权寄存器，只能在supervisor mode下执行，每次从内核空间返回到用户空间之前，内核会设置<code>STVEC</code>寄存器指向内核希望中断代码运行的位置（由<code>trap.c</code>中的代码设置）。</p><p>Xv6在内核页表和每个用户页表中的<strong>同一个虚拟地址</strong>上映射了 <code>trampoline page</code> 。<code>STVEC</code> 寄存器保存的地址是 <code>trampoline page</code> 的起始位置，主要执行一些保护用户态寄存器的操作。<code>trampoline page</code> 的首地址是 <code>uservec</code> 函数。所以其实<code>STVEC</code>指向了<code>kernel/trampoline.S</code>文件中的<code>uservec</code>函数。</p><p><strong>综上，其实操作系统伪装了一个系统调用的实现，当使用<code>read</code>等函数时并没有真正的读写逻辑，而是利用ecall发起中断，并通过寄存器将函数的ID告知内核，方便在内核找到函数真正的实现。</strong></p><h4 id="保护现场"><a href="#保护现场" class="headerlink" title="保护现场"></a>保护现场</h4><p>上文讲到CPU将执行<code>uservec</code>函数（<code>kernel/trampoline.S</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c">.globl uservec  <br>uservec:      <br>   #  <br>        <span class="hljs-meta"># trap.c sets stvec to point here, so  </span><br>        <span class="hljs-meta"># traps from user space start here,  </span><br>        <span class="hljs-meta"># in supervisor mode, but with a  </span><br>        <span class="hljs-meta"># user page table.  </span><br>        #  <br>        <span class="hljs-meta"># sscratch points to where the process<span class="hljs-string">&#x27;s p-&gt;trapframe is  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # mapped into user space, at TRAPFRAME.  </span></span><br><span class="hljs-string"><span class="hljs-meta">        #  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # swap a0 and sscratch  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # so that a0 is TRAPFRAME  </span></span><br><span class="hljs-string"><span class="hljs-meta">        csrrw a0, sscratch, a0 </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # save the user registers in TRAPFRAME  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd ra, 40(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd sp, 48(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd gp, 56(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd tp, 64(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t0, 72(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t1, 80(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t2, 88(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s0, 96(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s1, 104(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a1, 120(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a2, 128(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a3, 136(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a4, 144(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a5, 152(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a6, 160(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a7, 168(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s2, 176(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s3, 184(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s4, 192(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s5, 200(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s6, 208(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s7, 216(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s8, 224(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s9, 232(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s10, 240(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s11, 248(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t3, 256(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t4, 264(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t5, 272(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t6, 280(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">   # save the user a0 in p-&gt;trapframe-&gt;a0  </span></span><br><span class="hljs-string"><span class="hljs-meta">        csrr t0, sscratch  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t0, 112(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld sp, 8(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld tp, 32(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld t0, 16(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld t1, 0(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        csrw satp, t1  //切换到内核页表</span></span><br><span class="hljs-string"><span class="hljs-meta">        sfence.vma zero, zero  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # a0 is no longer valid, since the kernel page  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # table does not specially map p-&gt;tf.  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # jump to usertrap(), which does not return  </span></span><br><span class="hljs-string"><span class="hljs-meta">        jr t0</span></span><br></code></pre></td></tr></table></figure><p>在进程的结构中有一个结构体变量名为<code>trapframe</code>，它的作用是：</p><ol><li>发生中断时，保存进程在用户态使用的各种寄存器的值，以便于到时候恢复进程运行状态。</li><li>保存完成后，加载进程在内核态运行需要使用的寄存器的值</li></ol><p>在上面的代码中：</p><ol><li>先使用<code>csrrw</code>指令，将a0寄存器设置为<code>sscratch</code>寄存器的值，此时a0指向进程的<code>trapframe</code>结构。按照特定的顺序，保存寄存器的值。从偏移量40开始是因为，0到40（5 * 8）之间保存了5个内核态相关的值<code>（kernel_satp，kernel_sp，kernel_trap，epc，kernel_hartid）</code>，具体可参考<code>proc.h</code>文件中<code>trapframe</code>的结构。</li><li>恢复内核栈指针，将5个内核态相关的值加载进寄存器中，然后强制跳转执行<code>usertrap</code>函数（地址存储在<code>p-&gt;trapframe-&gt;kernel_trap</code>）。</li></ol><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><p>在保存好上下文之后就要开始执行中断处理的逻辑了，这里使用的栈已经从用户栈变成了内核栈<br><code>usertrap</code>函数的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  </span><br><span class="hljs-comment">// handle an interrupt, exception, or system call from user space.  </span><br><span class="hljs-comment">// called from trampoline.S  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;  <br>  <br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)   <span class="hljs-comment">//判断中断是否合法</span><br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);  <br>  <br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),  </span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.  </span><br>  w_stvec((uint64)kernelvec);  <br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>    <br>  <span class="hljs-comment">// save user program counter.  </span><br>  p-&gt;trapframe-&gt;epc = r_sepc();  <span class="hljs-comment">//保存sepc寄存器的值，前文提到了ecall指令执行后会将当前的PC保存到sepc中，因此 p-&gt;trapframe-&gt;epc其实指向ecall的最后一条指令</span><br>    <br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;   <span class="hljs-comment">//scause记录了发生中断的原因，8是系统调用的代号</span><br>    <span class="hljs-comment">// system call  </span><br>  <br>    <span class="hljs-keyword">if</span>(p-&gt;killed)  <br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);  <br>  <br>    <span class="hljs-comment">// sepc points to the ecall instruction,  </span><br>    <span class="hljs-comment">// but we want to return to the next instruction.    </span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;   <span class="hljs-comment">//此时epc指向ecall，我们恢复上下文后执行下一条指令，因此+4</span><br>  <br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,  </span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.    </span><br>    intr_on();   <span class="hljs-comment">//开中断，允许内核在执行系统调用时嵌套中断</span><br>  <br>    syscall(); <br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;  <br>    <span class="hljs-comment">// ok  </span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());  <br>    p-&gt;killed = <span class="hljs-number">1</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-keyword">if</span>(p-&gt;killed)  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);  <br>  <br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.  </span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)  <br>    yield();  <br>  <br>  usertrapret();  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>usertrap</code>负责中断处理，主要通过调用三个函数完成<code>syscall,yield,usertrapret</code></p><p><code>yield</code>是在发生时钟中断时的处理逻辑，进程修改自己的状态并自愿放弃CPU使用权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Give up the CPU for one scheduling round.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  acquire(&amp;p-&gt;lock);  <br>  p-&gt;state = RUNNABLE;  <br>  sched();  <br>  release(&amp;p-&gt;lock);  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>syscall()</code>是在发生系统调用时的处理逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> num;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  num = p-&gt;trapframe-&gt;a7;  <br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;  <br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <span class="hljs-comment">//执行系统调用</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,  <br>            p-&gt;pid, p-&gt;name, num);  <br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>前文讲到在使用函数<code>read</code>时，并没有真正的实现代码，而是一步一步走到了这里，现在终于可以开始执行具体的<code>read</code>逻辑了。在<code>syscall</code>函数中，a7寄存器中保存了<code>read</code>的编号，系统调用表提供了一个从编号到对应函数指针的实现，通过函数指针就能找到对应需要执行的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//syscalls是一个函数指针数组</span><br><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;  <br>[SYS_fork]    sys_fork,   <span class="hljs-comment">//sys_fork是一个宏定义，其实是数字1</span><br>[SYS_exit]    sys_exit,   <span class="hljs-comment">//同理</span><br>[SYS_wait]    sys_wait,  <br>[SYS_pipe]    sys_pipe,  <br>[SYS_read]    sys_read,  <br>[SYS_kill]    sys_kill,  <br>[SYS_exec]    sys_exec,  <br>[SYS_fstat]   sys_fstat,  <br>[SYS_chdir]   sys_chdir,  <br>[SYS_dup]     sys_dup,  <br>[SYS_getpid]  sys_getpid,  <br>[SYS_sbrk]    sys_sbrk,  <br>[SYS_sleep]   sys_sleep,  <br>[SYS_uptime]  sys_uptime,  <br>[SYS_open]    sys_open,  <br>[SYS_write]   sys_write,  <br>[SYS_mknod]   sys_mknod,  <br>[SYS_unlink]  sys_unlink,  <br>[SYS_link]    sys_link,  <br>[SYS_mkdir]   sys_mkdir,  <br>[SYS_close]   sys_close,  <br>&#125;;<br></code></pre></td></tr></table></figure><p><code>sys_read</code>代码如下，此时才执行真正的<code>read</code>逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_read</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span>  <br>  <span class="hljs-type">int</span> n;  <br>  uint64 p;  <br>  <br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;n) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;p) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  <span class="hljs-keyword">return</span> fileread(f, p, n);  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code>完成了系统调用过程并将返回值保存在a0寄存器，系统调用逻辑执行完毕，因此需要开始中断返回。</p><h4 id="中断返回"><a href="#中断返回" class="headerlink" title="中断返回"></a>中断返回</h4><p><code>usertrapret</code>函数被<code>usertrap</code>调用，用来从内核态返回用户态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  </span><br><span class="hljs-comment">// return to user space  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();   <br>  <br>  <span class="hljs-comment">// we&#x27;re about to switch the destination of traps from  </span><br>  <span class="hljs-comment">// kerneltrap() to usertrap(), so turn off interrupts until  </span><br>  <span class="hljs-comment">// we&#x27;re back in user space, where usertrap() is correct.  </span><br>  intr_off();  <span class="hljs-comment">//关中断，不能在执行中断恢复过程时嵌套中断</span><br>  <br>  <span class="hljs-comment">// send syscalls, interrupts, and exceptions to trampoline.S  </span><br>  <span class="hljs-comment">// 因为在执行ecall指令后，CPU几哦执行STVEC寄存器指向的指令（PC重置为 STVEC寄存器的值）</span><br>  <span class="hljs-comment">// 所以设置STVEC寄存器的值为我们想要中断发生时执行的代码的地址（前文提到的uservec函数）</span><br>  w_stvec(TRAMPOLINE + (uservec - trampoline));  <br>  <br>  <span class="hljs-comment">// set up trapframe values that uservec will need when  </span><br>  <span class="hljs-comment">// the process next re-enters the kernel.  </span><br>  <span class="hljs-comment">// 和发生中断时保存上下文类似，内核使用完毕，即将进入用户态，要将目前的值保存起来，</span><br>  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="hljs-comment">// kernel page table  </span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack  </span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;  <br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid()  </span><br>  <br>  <span class="hljs-comment">// set up the registers that trampoline.S&#x27;s sret will use  // to get to user space.     // set S Previous Privilege mode to User.  </span><br>  <span class="hljs-comment">// 设置CPU特权等级，从supervisor mode 到user mode（也就是将操作系统从内核态修改为用户态）</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_sstatus();  <br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// clear SPP to 0 for user mode  </span><br>  x |= SSTATUS_SPIE; <span class="hljs-comment">// enable interrupts in user mode  </span><br>  w_sstatus(x);  <br>  <br>  <span class="hljs-comment">// set S Exception Program Counter to the saved user pc.  </span><br>  w_sepc(p-&gt;trapframe-&gt;epc);   <span class="hljs-comment">//修改sepc寄存器的值，在sret指令后，sepc的值会写入pc，此时sepc指向ecall的下一条指令</span><br>  <br>  <span class="hljs-comment">// tell trampoline.S the user page table to switch to.  </span><br>  uint64 satp = MAKE_SATP(p-&gt;pagetable);  <br>  <br>  <span class="hljs-comment">// jump to trampoline.S at the top of memory, which   </span><br>  <span class="hljs-comment">// switches to the user page table, restores user registers,  </span><br>  <span class="hljs-comment">// and switches to user mode with sret.  </span><br>  uint64 fn = TRAMPOLINE + (userret - trampoline);  <br>  <br>  <span class="hljs-comment">//调用userret函数（trampoline.S），userret(TRAPFRAME, pagetable)</span><br>  ((<span class="hljs-type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp); <br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>userret</code>函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c">.globl userret  <br>userret:  <br>        <span class="hljs-meta"># userret(TRAPFRAME, pagetable)  </span><br>        <span class="hljs-meta"># switch from kernel to user.  </span><br>        <span class="hljs-meta"># usertrapret() calls here.  </span><br>        # a0: TRAPFRAME, in user page table.   函数传参时使用a0，a1寄存器<br>        # a1: user page table, <span class="hljs-keyword">for</span> satp.  <br>  <br>        <span class="hljs-meta"># switch to the user page table.  </span><br>        csrw satp, a1  <br>        sfence.vma zero, zero  <br>  <br>        <span class="hljs-meta"># put the saved user a0 in sscratch, so we  </span><br>        <span class="hljs-meta"># can swap it with our a0 (TRAPFRAME) in the last step.  </span><br>        ld t0, <span class="hljs-number">112</span>(a0)  <br>        csrw sscratch, t0  <br>  <br>        <span class="hljs-meta"># restore all but a0 from TRAPFRAME  </span><br>        ld ra, <span class="hljs-number">40</span>(a0)  <br>        ld sp, <span class="hljs-number">48</span>(a0)  <br>        ld gp, <span class="hljs-number">56</span>(a0)  <br>        ld tp, <span class="hljs-number">64</span>(a0)  <br>        ld t0, <span class="hljs-number">72</span>(a0)  <br>        ld t1, <span class="hljs-number">80</span>(a0)  <br>        ld t2, <span class="hljs-number">88</span>(a0)  <br>        ld s0, <span class="hljs-number">96</span>(a0)  <br>        ld s1, <span class="hljs-number">104</span>(a0)  <br>        ld a1, <span class="hljs-number">120</span>(a0)  <br>        ld a2, <span class="hljs-number">128</span>(a0)  <br>        ld a3, <span class="hljs-number">136</span>(a0)  <br>        ld a4, <span class="hljs-number">144</span>(a0)  <br>        ld a5, <span class="hljs-number">152</span>(a0)  <br>        ld a6, <span class="hljs-number">160</span>(a0)  <br>        ld a7, <span class="hljs-number">168</span>(a0)  <br>        ld s2, <span class="hljs-number">176</span>(a0)  <br>        ld s3, <span class="hljs-number">184</span>(a0)  <br>        ld s4, <span class="hljs-number">192</span>(a0)  <br>        ld s5, <span class="hljs-number">200</span>(a0)  <br>        ld s6, <span class="hljs-number">208</span>(a0)  <br>        ld s7, <span class="hljs-number">216</span>(a0)  <br>        ld s8, <span class="hljs-number">224</span>(a0)  <br>        ld s9, <span class="hljs-number">232</span>(a0)  <br>        ld s10, <span class="hljs-number">240</span>(a0)  <br>        ld s11, <span class="hljs-number">248</span>(a0)  <br>        ld t3, <span class="hljs-number">256</span>(a0)  <br>        ld t4, <span class="hljs-number">264</span>(a0)  <br>        ld t5, <span class="hljs-number">272</span>(a0)  <br>        ld t6, <span class="hljs-number">280</span>(a0)  <br>  <br>   <span class="hljs-meta"># restore user a0, and save TRAPFRAME in sscratch  </span><br>        csrrw a0, sscratch, a0  <br>          <br>        <span class="hljs-meta"># return to user mode and user pc.  </span><br>        <span class="hljs-meta"># usertrapret() set up sstatus and sepc.  </span><br>        sret<br></code></pre></td></tr></table></figure><p><code>userret</code>代码的主要功能和<code>uservec</code>正好相反，后者是将用户运行时的寄存器信息保存起来，切换到内核页表；前者是将这些保存起来的寄存器值恢复回去，切换到用户页表</p><p>随着<code>sret</code>指令的调用，整个中断过程完成，sepc寄存器中的值填回pc，用户程序恢复正常执行</p><h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>参照教程，在实验2前应该：</p><ul><li>仔细阅读<code>Chapter 2、 Chapter 4 的 Sections 4.3 and 4.4</code></li><li>仔细阅读<code>user/user.h</code>,<code>user/usys.pl</code>，学习xv6中工具函数和系统调用原型</li><li>仔细阅读<code>kernel/syscall.h</code>,<code>kernel/syscall.c</code>,系统调用实现</li><li>仔细阅读<code>kernel/proc.h</code>,<code>kernel/proc.c</code>，进程代码实现</li></ul><p>如果是从前文一步一步看到这里，那么这些代码相当于已经看过了，下面直接看练习要求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">实验要求：<br><br>实现一个系统调用追踪的功能：trace mask command命令，<br>- mask 表示系统调用号的掩码<br>- command 表示命令<br>- 能够实现如下效果<br><br><span class="hljs-comment">//因由于read的系统调用号是5，因此（1 &lt;&lt; 5,10000) 如果输入的数字从右往左第六位为1，则需要追踪read，即十进制数字32表示仅需要追踪read系统调用</span><br>$ trace <span class="hljs-number">32</span> grep hello README<br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">1023</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">966</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">70</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">0</span><br><br><span class="hljs-comment">//2147483647的二进制是1111111111111111111111111111111，因为所有位都为1，说明所有系统调用都需要追踪</span><br>$ trace <span class="hljs-number">2147483647</span> grep hello README<br><span class="hljs-number">4</span>: syscall trace -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">4</span>: syscall exec -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">4</span>: syscall open -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">1023</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">966</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">70</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">4</span>: syscall close -&gt; <span class="hljs-number">0</span><br><br><span class="hljs-comment">//没有trace指令，不追踪，不能影响其他程序的正常运行</span><br>$ grep hello README<br>$<br><br><span class="hljs-comment">//fork的系统调用号是1，因此(1 &lt;&lt; 2，2)如果输入的数字从右往左第二位为1，则仅需要追踪fork，</span><br>$ trace <span class="hljs-number">2</span> usertests forkforkfork<br>usertests starting<br>test forkforkfork: <span class="hljs-number">407</span>: syscall fork -&gt; <span class="hljs-number">408</span><br><span class="hljs-number">408</span>: syscall fork -&gt; <span class="hljs-number">409</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">410</span><br><span class="hljs-number">410</span>: syscall fork -&gt; <span class="hljs-number">411</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">412</span><br><span class="hljs-number">410</span>: syscall fork -&gt; <span class="hljs-number">413</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">414</span><br><span class="hljs-number">411</span>: syscall fork -&gt; <span class="hljs-number">415</span><br><br></code></pre></td></tr></table></figure><p>理解了需求，再结合前文提到的系统调用过程，可以想想我们为了完成任务可以做些什么？<br>首先，一个完整的系统调用从一个用户态的<code>shell</code>函数开始，trace.c文件已经提供给了我们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br>  <br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>  <br>&#123;  <br>    <span class="hljs-type">int</span> i;  <br>    <span class="hljs-comment">//存储待跟踪程序的名称和参数  </span><br>    <span class="hljs-type">char</span> *nargv[MAXARG];  <br>  <br>    <span class="hljs-comment">//保证trace的参数不少于三个，并且跟踪的系统调用号在0-99之间  </span><br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">3</span> || (argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-string">&#x27;9&#x27;</span>))&#123;  <br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: %s mask command\n&quot;</span>, argv[<span class="hljs-number">0</span>]);  <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br>    <span class="hljs-comment">//调用trace系统调用，传入待跟踪系统调用号  </span><br>    <span class="hljs-keyword">if</span> (trace(atoi(argv[<span class="hljs-number">1</span>])) &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="hljs-number">0</span>]);  <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br>    <span class="hljs-comment">//保存待跟踪程序的名称和参数  </span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;  <br>        nargv[i<span class="hljs-number">-2</span>] = argv[i];  <br>    &#125;  <br>    <span class="hljs-comment">//运行待跟踪的程序  </span><br>    exec(nargv[<span class="hljs-number">0</span>], nargv);  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><p>由于trace的语法规定了，第二个参数必须是待追踪系统调用的数字，因此具体的执行逻辑就是通过<code>argv[2]</code>取出这个数字，然后传递到内核态，然后执行一系列的操作。</p><p>当我们需要完成一个系统调用，有了用户态的代码，自然需要增加对该系统调用的用户态声明，即在<code>user/user.h</code>文件中新增trace的系统调用声明<code>int trace(int);</code></p><p>有了声明就需要有实现，但这个实现不是真正的函数实现，而是凭借<code>ecall</code>指令进入内核态，这个部分是<code>usys.pl</code>负责完成，因此需要在代码中增添<code>entry(trace)</code></p><p><code>entry(trace)</code>，将trace的系统调用名称放入a7寄存器，下一步就是通过系统调用名称在系统调用表中找到对应的系统调用编号。因此需要在<code>kernel/syscall.h</code>中新增<code>#define SYS_trace  22</code>，并且在<code>kernel/syscall.c</code>中增添<code>sys_trace</code>的函数声明<code>extern uint64 sys_trace(void);</code>，在系统调用表中新增<code>SYS_trace</code>（即22号调用）到函数实现的映射关系，<code>[SYS_trace]   sys_trace,</code></p><p>最后，这是个和进程相关的系统调用，因此在<code>kernel/sysproc.c</code>中新增<code>sys_trace</code>函数的实现。</p><p>完成了前面的步骤，看着下面空荡荡的函数代码，我们应该怎么去完成一个trace任务呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们可能会追踪任何一个系统调用，但我们不可能修改所有系统调用的代码，因此可以想到从他们共有的内容下手，<strong>由于所有的系统调用都是通过<code>syscall.c中的syscall</code>函数来执行的，并且所有系统调用的运行参数和结果均保存在<code>proc</code>结构体中的<code>trapframe</code>结构体中，例如a7保存当前进程系统调用的编号，a0表示系统调用执行的结果。因此只需要<code>proc结构体 + syscall函数</code>，我们就可以达成任务目标。</strong></p><p>可以考虑先在proc结构体中添加一个标记，作为判断执行trace的判断标准，然后在syscall添加一段逻辑：如果当前proc对应的标记为真，则打印输出当前系统调用的结果。</p><p>总结以上过程：</p><ol><li>在proc结构体中添加标记：<code>int trace_mask;  </code></li><li>修改<code>syscall</code>函数：<code>num</code>是系统调用号，如果<code>（1 &lt;&lt; num）与mask（用户输入的值）的&amp;运算结果为1</code>，则说明需要执行<code>trace</code>操作，例如如果<code>mask</code>的第二位和第六位都为1，则<code>num</code>为<code>read</code>和<code>fork</code>时就需要执行<code>trace</code>操作。<br> 注意：由于在内核态只能拿到系统调用编号，但是用户希望在看到的是系统调用的名称，因此还需要一个表格，建立从系统调用编号到系统调用名称的映射，也就是下面代码中的<code>syscalls_name</code> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//lab2 trace 添加识别名  </span><br>   <span class="hljs-type">char</span>* syscalls_name[<span class="hljs-number">23</span>] = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;fork&quot;</span>, <span class="hljs-string">&quot;exit&quot;</span>, <span class="hljs-string">&quot;wait&quot;</span>, <span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>, <span class="hljs-string">&quot;kill&quot;</span>,                <span class="hljs-string">&quot;exec&quot;</span>,  <span class="hljs-string">&quot;fstat&quot;</span>, <span class="hljs-string">&quot;chdir&quot;</span>, <span class="hljs-string">&quot;dup&quot;</span>, <span class="hljs-string">&quot;getpid&quot;</span>, <span class="hljs-string">&quot;sbrk&quot;</span>, <span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-string">&quot;uptime&quot;</span>,                   <span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;write&quot;</span>, <span class="hljs-string">&quot;mknod&quot;</span>, <span class="hljs-string">&quot;unlink&quot;</span>, <span class="hljs-string">&quot;link&quot;</span>, <span class="hljs-string">&quot;mkdir&quot;</span>, <span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-string">&quot;trace&quot;</span>&#125;;<br>   <br>   <span class="hljs-type">void</span>  <br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> num;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  num = p-&gt;trapframe-&gt;a7;  <br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;  <br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <br>    <span class="hljs-comment">//---------------------添加的部分--------------------------------------</span><br>    <span class="hljs-keyword">if</span>(p-&gt;trace_mask &amp; (<span class="hljs-number">1</span> &lt;&lt; num))&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid,syscalls_name[num],p-&gt;trapframe-&gt;a0);  <br>    &#125;  <br>    <span class="hljs-comment">//--------------------------------------------------------------------</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,  <br>            p-&gt;pid, p-&gt;name, num);  <br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>由此可见，trace操作的核心代码并不在<code>sys_trace</code>函数中，而是在<code>syscall</code>函数，那么<code>sys_trace</code>函数是干什么用的？</p><p>答案：取参数。用户态的trace.c代码中写明，使用trace时会传递一个参数，表示需要监视的系统调用号，而函数传参则是通过寄存器，第一个参数保存在a0寄存器，取参数需要使用<code>syscall.c中的argraw，argaddr，argint</code>三个函数，具体的实现可以看代码，<code>argraw(n)</code>是获取了发生中断时，$a_n$寄存器对应的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> uint64  <br><span class="hljs-title function_">argraw</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <span class="hljs-keyword">switch</span> (n) &#123;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a0;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a1;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a2;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a3;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a4;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a5;  <br>  &#125;  <br>  panic(<span class="hljs-string">&quot;argraw&quot;</span>);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;<br> <br><span class="hljs-comment">// Fetch the nth 32-bit system call argument.  </span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">argint</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> *ip)</span>  <br>&#123;  <br>  *ip = argraw(n);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>sys_trace</code>代码如下，将取回的参数放入proc结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> mask;  <br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;mask) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  myproc()-&gt;trace_mask = mask;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>另外，实验要求fork新诞生的子进程执行系统调用时也要打印出来，因此需要修改fork代码，子进程的<code>trace_mask</code>值应与父进程保持一致：<code>np-&gt;trace_mask = p-&gt;trace_mask;</code></p><p>这样整个实验就完成了</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab1 Xv6 and Unix utilities</title>
    <link href="/2023/08/14/Lab1-Xv6-and-Unix-utilities/"/>
    <url>/2023/08/14/Lab1-Xv6-and-Unix-utilities/</url>
    
    <content type="html"><![CDATA[<p>[课程地址](<a href="https://pdos.csail.mit.edu/6.828/2021/labs/util.html">Lab: Xv6 and Unix utilities (mit.edu)</a>)_</p><h2 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1. 配置环境"></a>1. 配置环境</h2><ul><li><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu<br></code></pre></td></tr></table></figure><p>出现网速不够的情况自行换源</p></li><li><p>git获取课程配套代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021<br></code></pre></td></tr></table></figure><p>在根目录下运行<code>make qemu</code>，看见如下输出即启动成功</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m <span class="hljs-number">128</span>M -smp <span class="hljs-number">3</span> -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.<span class="hljs-number">0</span><br><br><span class="hljs-attribute">xv6</span> kernel is booting<br><br><span class="hljs-attribute">hart</span> <span class="hljs-number">1</span> starting<br><span class="hljs-attribute">hart</span> <span class="hljs-number">2</span> starting<br><span class="hljs-attribute">init</span>: starting sh<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-sleep指令"><a href="#2-sleep指令" class="headerlink" title="2. sleep指令"></a>2. sleep指令</h2><p><strong>实验要求</strong>：为 xv6 系统实现 UNIX 的 sleep 程序。你的 sleep 程序应该使当前进程暂停相应的时钟周期数，时钟周期数由用户指定。例如执行 sleep 100 ，则当前进程暂停，等待 100 个时钟周期后才继续执行。</p><p>安装好xv6系统内核后，观察项目代码（我这里已经编译过，所以实际可能有所不同），可以发现用户态的代码聚集在user文件夹下，内核态的代码聚集在kernel文件夹下</p><p>课程需要我们仿照user目录下的命令（例如ls），写一个sleep命令，在开始这个任务前，我们有一些前置工作需要完成</p><ol><li>阅读<a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6 book</a>中的Chapter 1</li><li>阅读user&#x2F;目录下的所有程序，理解如何编写一个命令行程序</li></ol><p><a href>这个链接</a>包含了我对整本书的阅读理解</p><p>通过观察user文件夹下的其他代码，可以发现如果想要实现自己的函数，需要将代码放在user文件夹下，然后将文件名称写入makefile的UPROGS</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">UPROGS=\  <br>   $U/_cat\  <br>   $U/_echo\  <br>   $U/_forktest\  <br>   $U/_grep\  <br>   $U/_init\  <br>   $U/_kill\  <br>   $U/_ln\  <br>   $U/_ls\  <br>   $U/_mkdir\  <br>   $U/_rm\  <br>   $U/_sh\  <br>   $U/_stressfs\  <br>   $U/_usertests\  <br>   $U/_grind\  <br>   $U/_wc\  <br>   $U/_zombie\<br>   $U/_sleep\  <span class="hljs-comment">//新的代码要按格式加在这里</span><br></code></pre></td></tr></table></figure><p>所有实验都只能使用XV6所提供的函数，记录在user.h文件下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// system calls  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((<span class="hljs-keyword">noreturn</span>))</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">void</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">exec</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>**)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">mknod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">short</span>, <span class="hljs-type">short</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> stat*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">getpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">sbrk</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;   <span class="hljs-comment">//本次实验需要使用的系统调用</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">uptime</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <br>  <br><span class="hljs-comment">// ulib.c  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-keyword">struct</span> stat*)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">void</span> *<span class="hljs-title function_">memmove</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">strchr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">char</span> c)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*, ...)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, ...)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">gets</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">int</span> max)</span>;  <br>uint <span class="hljs-title function_">strlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">void</span>* <span class="hljs-title function_">memset</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">int</span>, uint)</span>;  <br><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(uint)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">memcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *, uint)</span>;  <br><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *, uint)</span>;<br></code></pre></td></tr></table></figure><p>模仿其他文件例如rm.c，我们可以发现，需要使用int等数据类型，因此需要引入kernel&#x2F;types.h头文件，还需要包含系统调用声明的头文件user.h，stat.h中包含了与文件相关的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//rm.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>   <br><span class="hljs-comment">//程序入口，argc表示参数个数，argv分别表示每个具体参数,argv[0]是命令本身</span><br>&#123;  <br>  <span class="hljs-type">int</span> i;  <br>  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;   <span class="hljs-comment">//error处理</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: rm files...\n&quot;</span>);  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);   <br>  &#125; <br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;   <span class="hljs-comment">//循环获取参数然后执行操作</span><br>    <span class="hljs-keyword">if</span>(unlink(argv[i]) &lt; <span class="hljs-number">0</span>)&#123;  <br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;rm: %s failed to delete\n&quot;</span>, argv[i]);  <br>      <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>  &#125;  <br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//正常退出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察rm.c以及其他要求观察的代码，我们可以发现实现一个可以在shell中运行程序需要按照如下模板：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从kernel和user中获取需要的头文件，sleep不需要文件操作，所以不需要stat.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br><br><span class="hljs-comment">//程序入口，argc表示参数个数，argv分别表示每个具体参数,argv[0]是命令本身</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>   <br>&#123;  <br><span class="hljs-comment">//参数处理模块</span><br><span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;  <br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: xxx files...\n&quot;</span>);  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);   <br>&#125; <br><br><span class="hljs-comment">//获取参数，执行程序的模块</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;   <br><br>    &#125;  <br><br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//正常退出</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>按照要求完成sleep代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: sleep &lt;ticks&gt;\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> ticks = atoi(argv[<span class="hljs-number">1</span>]); <br>    sleep(ticks);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在目录下使用执行测试：.&#x2F;grade-lab-util sleep<br>结果如下：<br><img src="20230718234029.png" alt="实验结果"></p><h2 id="3-pingpong"><a href="#3-pingpong" class="headerlink" title="3. pingpong"></a>3. pingpong</h2><p><strong>实验要求</strong>：使用 UNIX 系统调用编写一个程序 pingpong ，在一对管道上实现两个进程之间的通信。父进程应该通过第一个管道给子进程发送一个信息 “ping”，子进程接收父进程的信息后打印 <pid>: received ping ，其中是其进程 ID 。然后子进程通过另一个管道发送一个信息 “pong” 给父进程，父进程接收子进程的信息然后打印 <pid>: received pong ，然后退出。</pid></pid></p><p><strong>实验提示</strong>：</p><ul><li>使用 pipe 创建管道。</li><li>使用 fork 创建一个子进程。</li><li>使用 read 从管道读取信息，使用 write 将信息写入管道。</li><li>使用 getpid 获取当前 进程 ID 。</li><li>将程序添加到 Makefile 中的 UPROGS 。</li><li>xv6 上的用户程序具有有限的库函数可供它们使用。你可以在 user&#x2F;user.h 中查看，除系统调用外其他函数代码位于 user&#x2F;ulib.c 、user&#x2F;printf.c 、和 user&#x2F;umalloc.c 中。</li></ul><p><strong>实验代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br>    pipe(p);<br>    pipe(p1);  <span class="hljs-comment">//开启两个管道，p用于父进程向子进程传输，p1则相反</span><br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;  <br>        close(p[<span class="hljs-number">1</span>]);       <span class="hljs-comment">//子进程关闭p的写入端，管道不能有多余的端口</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];  <br>        read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-number">10</span>);  <span class="hljs-comment">//利用p从父进程读取信息</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf);  <span class="hljs-comment">//打印读取到的信息</span><br>        close(p[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//关闭p的读取端，完成一次传输</span><br>        close(p1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//子进程关闭p1的读取端，准备向父进程传输信息</span><br>        write(p1[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">//写入信息</span><br>        close(p1[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//写入完成，关闭p1的写入端</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        close(p[<span class="hljs-number">0</span>]);     <span class="hljs-comment">//父进程关闭p的读取端，管道不能有多余的端口</span><br>        write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;pong&quot;</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment">//向子进程传输信息</span><br>        close(p[<span class="hljs-number">1</span>]);   <span class="hljs-comment">//写入完成，关闭p的写入端口</span><br>        close(p1[<span class="hljs-number">1</span>]);    <span class="hljs-comment">//关闭p1管道的写入端，准备从子进程读取信息</span><br>        <span class="hljs-type">char</span> buf1[<span class="hljs-number">10</span>];  <br>        read(p1[<span class="hljs-number">0</span>], buf1, <span class="hljs-number">10</span>); <span class="hljs-comment">//利用p1从子进程读取信息 </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf1); <br>        close(p1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//读取完成，关闭读取端</span><br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//正常结束，退出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>整个实验其实是考察对管道的理解程度，让我们熟练应用管道</p><h2 id="3-primes"><a href="#3-primes" class="headerlink" title="3. primes"></a>3. primes</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book Chapter1</title>
    <link href="/2023/07/14/xv6-book-Chapter1/"/>
    <url>/2023/07/14/xv6-book-Chapter1/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter1-操作系统接口"><a href="#Chapter1-操作系统接口" class="headerlink" title="Chapter1 操作系统接口"></a>Chapter1 操作系统接口</h1><p>操作系统是硬件的抽象表示，需要通过接口对用户程序提供服务。unix的接口设计十分成功，而xV6是一个模仿unix设计的操作系统，理解xv6是理解现代操作系统的良好开端。</p><p>但是哪怕是简单的xv6系统，我们也需要一个框架形的学习方式，Chapter 1主要从用户使用操作系统的角度出发，先介绍操作系统提供的接口，即系统调用。</p><p>用户的程序运行在用户态，内核执行的程序运行在内核态，如果用户需要发起需要操作系统参与的活动时（例如读写磁盘，删除文件），不能直接执行操作，而是要利用操作系统的提供的接口，这个接口被成为系统调用（系统调用是一串预先实现好的函数）。如下图所示</p><p><img src="20230711210052.png"></p><p>为什么要这样做呢？</p><ol><li><strong>它为用户空间提供了一种统一的硬件的抽象接口</strong>，用户程序不必关心底层的具体实现。例如对于读写操作，用户不关心存储介质是固态硬盘还是机械硬盘，只需要往文件中读写即可，至于信息到底保存在哪里，如何与硬件对接，由操作系统负责完成</li><li><strong>系统调用保证了系统的稳定和安全</strong>。作为硬件设备和应用程序之间的中间人，内核可以基于权限和其他一些规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确地使用硬件设备，例如窃取其他进程的资源。</li><li><strong>假设没用内核，应用程序可以随意访问硬件，几乎就没法实现多任务和虚拟内存</strong></li></ol><p>下图列出了xv6操作系统的所有系统调用，本章的其余部分概述了xv6的服务——进程、内存、文件描述符、管道和文件系统——并通过代码片段对它们进行了说明，并讨论了shell (Unix的命令行用户界面)如何使用它们。<br>注意：进入unix系统看到的<strong>shell窗口是一个用户程序</strong>而不是内核的一部分，xv6的shell代码可以在user&#x2F;sh.c找到。<br><img src="20230711215725.png" alt="系统调用列表"></p><h2 id="进程与内存"><a href="#进程与内存" class="headerlink" title="进程与内存"></a>进程与内存</h2><p>xv6进程由用户空间内存(指令、数据和堆栈)和内核私有的每个进程状态组成。</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">进程 </span>=<span class="hljs-string"> 占用的内存空间 + 进程状态</span><br></code></pre></td></tr></table></figure><p>每个进程可以使用fork()系统调用创建一个新的子进程。其内存内容与父进程完全相同，父进程执行的fork会返回子进程的pid（进程的唯一标识符），子进程的fork返回0。以下面的代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = fork();    <span class="hljs-comment">//创建子进程</span><br><span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;         <span class="hljs-comment">//如果是父进程则执行下面的语句</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: child=%d\n&quot;</span>, pid);<br>pid = wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>);  <span class="hljs-comment">//wait系统调用返回当前进程退出子进程的PID，并将子进程的退出状态复制到传递给wait的地址,如果调用者的子进程都没有退出，则等待其中一个退出,如果调用者没有子进程，wait立即返回-1, 如果父进程不关心子进程的退出状态，它可以传递一个0地址来等待</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d is done\n&quot;</span>, pid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//如果是子进程则执行下面的语句</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child: exiting\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//exit系统调用导致调用进程停止执行，并释放资源</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>&#125;<br><br>这个代码的输出结果，前两行可能交换顺序:<br>parent: child=<span class="hljs-number">1234</span><br>child: exiting<br>parent: child <span class="hljs-number">1234</span> is done<br></code></pre></td></tr></table></figure><p>exec系统调用从存储在文件系统中加载新的内存映像替换调用进程的内存(可以理解为把一个程序替换为另一个程序)，一般搭配fork使用</p><p>shell就是一个特殊的程序，当你在shell界面输入命令时，shell会fork一个子进程，然后使用exec将子进程的内存空间替换为你输入的命令的内存空间（也就是把子进程变成你想要执行的进程），如果内存空间不够，可以使用sbrk这一系统调用扩宽。</p><p>如下方代码所示，主循环使用getcmd从用户那里读取一行输入。然后调用fork，创建shell进程的副本。父进程调用wait，而子进程运行该命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Read and run input commands.  </span><br><span class="hljs-keyword">while</span>(getcmd(buf, <span class="hljs-keyword">sizeof</span>(buf)) &gt;= <span class="hljs-number">0</span>)&#123;  <br><span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;  <br><span class="hljs-comment">// Chdir must be called by the parent, not the child.  </span><br>buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// chop \n  </span><br><span class="hljs-keyword">if</span>(chdir(buf+<span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>)  <br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="hljs-number">3</span>);  <br><span class="hljs-keyword">continue</span>;  <br>&#125;  <br><span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)  <br>runcmd(parsecmd(buf));   <span class="hljs-comment">//子进程执行指令</span><br>wait(<span class="hljs-number">0</span>);  <span class="hljs-comment">//父进程等待</span><br>&#125;    <br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <br><br><br>fork1(<span class="hljs-type">void</span>)  &#123;  <br><span class="hljs-type">int</span> pid;  <br>pid = fork();  <br><span class="hljs-keyword">if</span>(pid == <span class="hljs-number">-1</span>)  <br>panic(<span class="hljs-string">&quot;fork&quot;</span>);  <br><span class="hljs-keyword">return</span> pid;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="I-O和文件描述符"><a href="#I-O和文件描述符" class="headerlink" title="I&#x2F;O和文件描述符"></a>I&#x2F;O和文件描述符</h2><p>文件描述符（File Descriptor，简称FD）是一个小整数，linux使用它来作为文件的唯一标识（文件是一个抽象概念，表示文件描述符引用的对象，不仅仅是文件夹里的文件，也可以是管道和设备），内核为每个进程维护了一个文件描述符表，这个表以为索引，再进一步指向文件的详细信息。<br><img src="20230713134913.png" alt="IO描述符"></p><p>在Unix系统中，每个进程都有STDIN、STDOUT和STDERR这3种标准I&#x2F;O（分别对应文件描述符0、1、2），它们是程序最通用的输入输出方式。几乎所有语言都有相应的标准I&#x2F;O函数，比如，C语言可以通过scanf从终端输入字符，通过printf向终端输出字符<br>在这一部分内容中，主要涉及到两个系统调用，open，read和write可以[看这里](<a href="https://zhuanlan.zhihu.com/p/435406445">Linux系统中I&#x2F;O操作的数据读写流程介绍 - 知乎 (zhihu.com)</a>)</p><h4 id="I-O重定向详解"><a href="#I-O重定向详解" class="headerlink" title="I&#x2F;O重定向详解"></a>I&#x2F;O重定向详解</h4><p>unix通过将fork和exec分离，实现了IO重定向（让已创建的FD指向其他文件）。<br>具体来说，fork复制父进程的文件描述符表及其内存，这样子进程打开的文件与父进程完全相同。系统调用exec替换调用进程的内存，但保留文件表，就使得shell命令输入的IO操作可以灵活的运用。只看概念很晦涩，不妨碍看看下面案例：</p><p>dup和dup2是IO重定向的涉及的核心系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">内核在进程中创建一个新的文件描述符(目前可用文件描述符的最小值）newfd，并且使newfd指向oldfd所指向的文件表项</span><br><span class="hljs-comment">**/</span><br><br><span class="hljs-comment">//eg：</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello world!\n&quot;</span>;<br><span class="hljs-type">int</span> newfd = <span class="hljs-number">-1</span>;<br>newfd = dup(<span class="hljs-number">1</span>);    <span class="hljs-comment">//将newfd重定向到标准输出，0、1、2是默认存在的FD，3是目前可用的最小描述符，因此newfd=3</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;newfd = &quot;</span>&lt;&lt;newfd&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//输出newfd=3</span><br>write(newfd,str,<span class="hljs-built_in">strlen</span>(str));    <span class="hljs-comment">//向newfd中写入字符串，由于newfd重定向到1，因此newfd和标准输出有相同的指向，会在屏幕上输出hello world!</span><br>    close(newfd); <br>    <span class="hljs-comment">//close系统调用释放一个文件描述符，使其可以被将来的open、pipe或dup系统调用重用。新分配的文       件描述符总是当前进程中编号最低的未使用描述符</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">让传入的参数newfd与参数oldfd指向同一文件表项，如果newfd已经被open过，那么就会先将newfd关闭，然后让newfd指向oldfd所指向的文件表项，如果newfd本身就等于oldfd，那么就直接返回newfd。因此，传入的newfd既可以是open过的，也可以是一个任意非负整数，</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">总之，dup2函数的作用就是让newfd重定向到oldfd所指的文件表项上</span><br><span class="hljs-comment">如果出错就返回-1，否则返回的就是newfd</span><br><span class="hljs-comment">**/</span><br><br><span class="hljs-comment">//eg:</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello world!\n&quot;</span>;<br> <br>dup2(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);    <span class="hljs-comment">//将“5”重定向到标准输出</span><br>write(<span class="hljs-number">5</span>,str,<span class="hljs-built_in">strlen</span>(str));   <span class="hljs-comment">//向文件描述符5写入数据,此时相当于输出到文件描述符1对应的文件表项上，也就是输出到屏幕</span><br>close(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面可以讲几个具体的样例：<br><strong>1.  重定向标准输入</strong><br>标准输入（文件描述符0）所对应的设备是键盘，当read指定FD&#x3D;1时，实际上是read键盘输入的数据，那如果不想让键盘作为标准输入呢？比如说让程序从某个文件中读取输入数据，这就需要重定向标准输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">string</span> rdstr;<br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//打开想要读取数据的文件，open返回新的FD，这个fd指向test.txt这一文件表项</span><br><span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR)) == <span class="hljs-number">-1</span>) <br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;open failed !&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//重定向标准输入到外部文件test.txt中（即0重定向到fd，指向fd对应的文件表项）</span><br>dup2(fd,<span class="hljs-number">0</span>); <br><br><span class="hljs-keyword">while</span>(getline(<span class="hljs-built_in">cin</span>,rdstr))     <span class="hljs-comment">//用getline从标准输入中获取数据，也就是从此时的fd读取</span><br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;rdstr&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//通过标准输出将读入的数据打印出来</span><br>&#125;<br> <br>    close(fd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>2.  重定向标准输出</strong><br>标准输出（文件描述符1）的设备是显示器，通过标准输出进行write时，数据会直接输出到显示器上。那么如果想让cout、printf直接将数据输出到文件，而不是显示屏上呢？那么就需要重定向标准输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//创建test.txt并清空文本（O_TRUNC是清空之前内容的标志），并生成文件描述符fd</span><br><span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC)) == <span class="hljs-number">-1</span>)  <br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;open failed !&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>dup2(fd,<span class="hljs-number">1</span>);   <span class="hljs-comment">//重定向标准输出到外部文件test.txt</span><br><span class="hljs-comment">//向标准输出输出数据，此时的标准输出指向了fd指向的文本表项，也就是test.txt</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;重定向标准输出测试！&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;   <br>    close(fd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展：</p><p><strong>3.  重定向错误输出</strong><br>标准错误输出实际上与标准输出类似，都是将数据输出到显示器上，只不过标准错误输出是输出错误信息，C语言中常用的错误输出就是perror了，如下面打开一个不存在的文件，就会直接在显示器上输出报错信息，因此重定向的方式与重定向标准输出一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>open(<span class="hljs-string">&quot;123.txt&quot;</span>,O_RDWR); <br>perror(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.  重定向恢复</strong><br>在进行重定向后，如果想要恢复到重定向之前的状态，可以在重定向之前用dup函数保留该文件描述符对应的文件表项，然后在需要恢复重定向的时候使用dup2重定向到原来的文件表项，以重定向后恢复标准输出为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC)) == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;open failed !&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-type">int</span> oldfd = dup(<span class="hljs-number">1</span>);     <span class="hljs-comment">//保存标准输出对应的文件表项</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">注意：并不是保存了文件表项本身，而是生成并保存了一个指向标准输出对应文件表项的文件描述符（oldfd）</span><br><span class="hljs-comment">**/</span><br>dup2(fd,<span class="hljs-number">1</span>);    <span class="hljs-comment">//重定向标准输出到外部文件test.txt中</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;重定向标准输出测试！&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//重定向测试</span><br>dup2(oldfd,<span class="hljs-number">1</span>);   <span class="hljs-comment">//将重定向后的文件描述符1再次重定向到一开始保存的标准输出对应的文件表项中</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;重定向标准输出恢复测试！&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;   <span class="hljs-comment">//重定向恢复测试</span><br>close(fd);<br>close(oldfd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//在第一次重定向后，cout输出信息是输出到了外部文件中，当再次重定向进行恢复之后，此时的cout就将数据输出到显示器上了，回到了最原始的标准输出</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="管道（pipe）"><a href="#管道（pipe）" class="headerlink" title="管道（pipe）"></a>管道（pipe）</h2><p>管道是一个小的内核缓冲区，作为一对文件描述符公开给进程，一个用于读取，一个用于写入。将数据写入管道的一端，使该数据可用于从管道的另一端读取。<strong>管道为进程提供了一种通信方式</strong>。</p><p>下面的示例代码运行程序wc，标准输入连接到管道的读取端:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>]; <span class="hljs-comment">//用来存储管道的两个文本描述符</span><br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>]; <span class="hljs-comment">//argv表示命令行输入</span><br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;wc&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>pipe(p); <span class="hljs-comment">//此时生成了管道，pipe是生成管道的系统调用</span><br><span class="hljs-comment">//在执行fork操作前已经生成了管道，那么fork操作后，父进程和子进程并行执行，每个进程中都有一个管道，且管道的文本描述符是相同的</span><br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//如果是子进程，执行如下分支的程序</span><br>close(<span class="hljs-number">0</span>);  <span class="hljs-comment">//关闭标准输入，此时0成为了最小的文本描述符</span><br>dup(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//上文讲到了dup的作用，生成了个新的指向p[0]对应文本表项的文本描述符，由于0是最小的文本描述符，所有dup会生成0作为文本描述符，标准输入对应了p[0]原本（管道用于读取的那一端）对应的文本表项。可以形象的理解为标准输入和管道的读取端对接上了（用水的事物和水管的出水口接上了）。</span><br>close(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//p[0]和0指向的表项相同，不再需要</span><br>close(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">//读取端不需要写入，所以关闭</span><br>exec(<span class="hljs-string">&quot;/bin/wc&quot;</span>, argv); <span class="hljs-comment">//子进程执行读取操作，读取被写入到管道的数据</span><br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//如果是父进程，执行如下分支的程序</span><br>close(p[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//写入端不需要读取管道的数据</span><br>write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>, <span class="hljs-number">12</span>) <span class="hljs-comment">//p[1]是管道的进水口，程序向管道中写入数据（水龙头往管道中放水</span><br>close(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">//数据写完了，关闭管道（水龙头关闭了，水管也可以撤走了）</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述的例子中，如果管道的缓冲区中没有可用的数据，管道上的读操作要么等待数据被写入，要么等待指向写端的所有文件描述符被关闭，在后一种情况下，read将返回0。<br><strong>注意：由于父进程和子进程共有两对管道文本描述符，但整个数据传输过程中只会用到一对描述符，如果读取端不关闭多余的写入端口，那么wc将永远不会结束，即读取端永远等待自己没有使用的那个写入端写入数据</strong>。<br><img src="20230713171305.png" alt="管道"></p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>暂时没看懂</p>]]></content>
    
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
