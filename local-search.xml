<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>xv6-book Chapter3</title>
    <link href="/2023/11/06/xv6-book-Chapter3/"/>
    <url>/2023/11/06/xv6-book-Chapter3/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter3-页表"><a href="#Chapter3-页表" class="headerlink" title="Chapter3 页表"></a>Chapter3 页表</h1><p>之前的内容围绕进程展开，大概了解了操作系统是什么，第一个进程如何运行，操作系统提供的系统如何工作，学习了进程隔离的概念。但是既然每个进程都有自己单独的内存空间，那么这些空间到底是怎么被分配使用的？本章的所有内容都围绕物理内存和虚拟内存展开。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存是计算机的核心组件，由RAM组成，断电后数据会丢失。我们可以将内存看作是一个<code>[0,max]</code> 的<strong>字节</strong>数组（RISC-V加载与储存数据都是以字节为单位，取单字或双字），那么内存地址，也就是这个大数组的索引，知道内存地址就可以快速的访问某个具体的字节。</p><p>我们知道通过ld sd等汇编指令，程序可以很轻松的访问内存空间，那么一个进程是否可以读取或写入另一个进程对应内存空间的内容？答案当然是否定，为了避免这种危险的行为，操作系统提供了虚拟内存的概念：每个进程都拥有自己独立的虚拟内存空间，虚拟内存地址从0开始，给了一种进程在使用整个内存的错觉。</p><p>由于使用的地址空间是虚拟的，自然也就不存在危险行为，不同的进程被天然隔离开。</p><p>但是如果需要CPU完成指令，终究是需要依托内存硬件的。这就涉及到虚拟地址到物理地址的映射。这个映射过程可以将虚拟地址（VA）映射到实际的物理地址（PA）上，程序运行时不需要关心物理内存到底是多少，只需要专注自己的内容即可，CPU会更根据映射关系表，从虚拟地址找到对应的物理地址，实现前后解耦。</p><p>这个映射的过程是通过CPU提供的<strong>分页硬件</strong>MMU实现的。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">MMU:是集成到CPU内的一个组件，主要是负责读取虚拟内存的映射表<span class="hljs-comment">(查看页表)</span>，并通过映射表将虚拟地址转换为物理地址。  <br>RISC-V指令可以操作虚拟地址<span class="hljs-comment">(VA,virtual address)</span>。<br></code></pre></td></tr></table></figure><p>注意：从CPU的角度来说，一旦MMU打开了，它执行的每条指令中的地址都是虚拟内存地址。<br><img src="20230920190826.png"></p><p>a0寄存器中的0x1000是一个虚拟地址（VA），通过MMU映射为物理地址（PA）0xFFF0，然后再利用这个物理地址再内存中找到对应的位置。</p><p>satp(Supervisor Address Translation and Protection Registers)是存放映射表物理地址的寄存器。由于映射表保存在内存中，satp记录了这张表的开始位置，所以MMU可以通过satp迅速找到内存中保存的映射表。例如在上图中VA &#x3D; 0x1000，其中satp &#x3D; 0x10的物理地址中保存的是这个VA的映射表。</p><p>每个程序都会有自己独立的映射表，并且这个映射表定义了应用的地址空间。当进程上下文切换时，同时也需要切换satp寄存器的内容，从而获得新的表单。这样的话就可以将相同的虚拟地址翻译为不同的物理地址了（读写satp寄存器在CPU管理者模式，也就是操作系统内核态才可以使用）。</p><p>这个映射表被称为页表（page table），页表带来了以下好处：</p><ol><li>增强了进程间的隔离性</li><li>实现了物理内存的复用</li></ol><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>建立了将虚拟地址和物理地址解耦的方案，那么如何分配与管理内存空间就成为了一件需要考虑的事情，一般来说有两种方法：</p><ol><li>分段；将空间分割成<strong>不同长度</strong>的分片，这样使用灵活但是<strong>空间碎片化</strong>的问题会变得更加严重<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">外部碎片：物理内存中的空闲空间被分割成不同大小的小块，后续分配请求可能失败，因为没有一块足够大的连续空闲空间，尽管总的空闲空间超出了请求的大小。  <br>内部碎片：分配程序给出的内存块超出请求的大小，在块中超出请求的空间可能因此而未被使用，造成了发生在已分配单元内部的浪费。<br></code></pre></td></tr></table></figure></li><li>分页；将空间切成<strong>固定长度</strong>的分片，彻底解决了外部碎片的问题。每个固定长度的单元我们称之为<strong>页Page</strong>，然后我们将物理内存看成是定长槽块的阵列，这些槽块大小与页相同，每个槽块叫做<strong>页帧Page Frame</strong>，每个页帧都可以装载一个<strong>虚拟内存页</strong>。同时，分页很灵活，能很好地支持稀疏虚拟地址空间。分页的逻辑如下图所示：</li></ol><p><img src="20230920202213.png" alt="分页"><br>CPU接受到一个地址（一般是uint64类型变量），由索引p + 偏移量d组成，根据p在页表中找到对应的物理页地址f。物理页地址 + 页内偏移量就可以索引到一个具体字节的物理地址。</p><p>总结：RISC-V指令（用户指令或内核指令）对<strong>虚拟地址</strong>进行操作，物理地址则是用于寻址实际物理内存RAM的（注意：RISC-V可以处理64位的虚拟地址，但物理地址只被设计成56位（够用了）），两者之间通过页表建立映射关系，页表保存在satp寄存器中，每个进程都有一个变量存储各自satp的值（注意：不是说每个进程都有自己的satp寄存器，而是每个进程有自己的页表，使用时，赋值给satp寄存器，供CPU使用）</p><p>xv6使用分页的方式管理内存，具体如下：<br><img src="20230920202919.png" alt="VA映射到PA"></p><p>xv6运行在Sv39 RISC-V处理器上，因此64位虚拟地址中，只有低39位在被使用，剩下的25位都暂时保留，供日后的设计者利用。蓝色部分EXT表示不被使用，剩下的39位被划分为27位索引和12位偏移量（2的12次方正好是4K，用来表示一个页内偏移量，所以一个页的大小是4KB）</p><p>前文说到，RISC-V的分页硬件，将每个虚拟地址映射到一个物理地址，页表会以某种形式的表项来保存这种映射关系，这种表项我们称之为<strong>页表条目PTE</strong>（Page Table Entry）。虚拟地址的高27位索引会指向了一个PTE。每个PTE由44位的<strong>物理页帧号PPN</strong>和10位的<strong>标志位Flags</strong>组成。总归54位，因此一个PTE可以用8个字节来存储（uint64）</p><p>PPN + Offset（偏移量） ，构成一个虚拟地址对应的物理地址，共56位。 </p><p>总结：在页表转换一个虚拟地址时，首先提取出有效的39位，用高27位来索引对应的PTE，从PTE中我们可以得到44位的PPN，并且根据Flags检查一些权限，最后将44位的PPN和原虚拟地址的低12位Offset加在一起，得到最后56位的有效物理地址，接着就可以访问物理内存。</p><p>上述提到的内容是经过<strong>简化的页表的方案</strong>，实际的RISC-V页表采用的是三级页表。那么一级页表，页就是上面提到的图有什么问题呢？先给出PTE的计算公式：</p><p><strong><em>PTE 地址 &#x3D; 页目录的地址 + 4 * 虚拟内存地址 &#x2F; 4KB</em></strong></p><p>一级页表情况下，页目录地址由satp寄存器，虚拟内存地址也就是27位的index，这意味着每个进程需要使用2的27次方个PTE，每个PTE占8字节，总共1GB，这显然太大了，我们最终需要的仅仅是一个4KB的页（xv6进程的内存空间默认分配为4KB）。那<strong>是否可以不把所有 PTE 都放到页表中，当进程需要访问某段虚拟内存时，再把对应的 PTE 加载到内存中？</strong></p><p>答案是不行：因为 MMU 进行过虚拟内存映射时。按照公式，PTE是根据虚拟内存连续放置的，假设我们允许某些 PTE 不在物理内存，其他的PTE位置由于是计算出来的而不是查找出来的，因此这些PTE该放在哪还是放在哪，相当于那些被允许不在物理内存里的PTE，虽然人不在，但是座位却占住了，所以这种做法毫无意义。如果不按照公式，虽然PTE可以随处放了，但是查询PTE时只能顺序查找，时间复杂度从O(1)变成O(n)，性能大幅度降低</p><p>但是在三级页表的情况下，情况不一样了。<br><img src="20230920212642.png" alt="三级页表"></p><p>整体的运行逻辑和一级页表没什么不同，把27位的索引平分成了9+9+9的三级索引，</p><ul><li>第一次页目录地址由satp提供，9位刚好可以表示512个PTE，因此L2表示偏移量，两者结合找到L1对应页目录所在位置</li><li>L1页目录结合L1偏移量找到L0页目录的位置</li><li>L0页目录结合L0偏移量，找到物理地址的PPN</li><li>物理地址PPN，结合offset得到最后物理地址</li></ul><p>问题：这个过程实际上涉及到的PTE数量似乎并不比一级页表少，为什么可以节省空间？</p><ol><li>根据局部性原理，进程访问内存时，大部分时候只访问某一段内存，比如（8～16KB）。</li><li>对于多级页表来说，因为需要按照公式计算定位，所以第一级页表，需要完整的加载所有 PTE 到内存中。按照上图，也就是 3 个 PTE，这一点也容易理解。</li><li>剩下第二级第三级页表的 PTE，可以等到程序真实访问时，再加载到内存中。</li></ol><p><strong>总而言之，多级页表情况下，只有一级页表的 PTE 条目需要完全加载到内存中（用来定位二级页表），而不同的二级页表之间，因为没有按照公式去快速定位的需求，所以二级页表可以选择是否加载到物理内存中。三级页表同理。</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**举个生动的例子**</span><br>学校有一百万个学生，每个学生都有自己的学号和手机号码，每个学生之间的学号都是连续的，也就是 1 ～ 100万。如果只有一级页表，也就是这张表里得有所有学生的信息（学号+家庭地址），校长想查找某个学生的手机号码时，先根据学号，利用公式快速算出它在表中的位置，然后找到这个位置，这个位置就记录了该学生的手机号码。<br><br><span class="hljs-strong">**但是这是一张巨大无比的表，打印出来的话，校长的公文包估计放不下去。**</span><br><br><span class="hljs-strong">**校委会就想出了多级页表的方法，将这一百万学生，按照连续的学号，分成一千个班，每个班一千个学生和一个班主任。比如 1 班学号是 1～1000，2 班是 1001～2000。**</span><br><br>校长的公文包里，每次只需要带上一张表，这张表记录了一千个班，每个班的班主任手机号。<br><br>当校长想找某个学生时，<br><br><span class="hljs-bullet">1.</span> 先根据学号，计算出他在哪个班。<br><br>2.在表中找到这个班，里面有这个班的班主任手机号。<br>（找到第二级页目录）<br><br>3.打电话给班主任，班主任再送来他们班的一张表，表中记录了这个班每个学生的手机号。<br>(等到程序真实访问时，再加载到内存中)<br><br>4.校长再根据学号，再这个班的班级表中找到这个学生和他的手机号。<br><br>上述这个过程是一个二级页表运行的过程<br></code></pre></td></tr></table></figure><h2 id="内存初始化"><a href="#内存初始化" class="headerlink" title="内存初始化"></a>内存初始化</h2><p>如果没有代码，即使理解了页表运行的原理，也依然不明白如何实现，很容易忘记。在之前的文章中，我讲到了在start.c代码中，CPU特权从机器级变为特权等级，然后跳转到main.c中。<code>userinit()</code>，即运行第一个进程是main.c的最后一件事情（启动进程调度死循环不算），那么第一件事是什么呢？正是内存相关的初始化操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// start() jumps here in supervisor mode on all CPUs.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    、、、、、、、、、、、、<span class="hljs-comment">//省略</span><br>    kinit();         <span class="hljs-comment">// 初始化物理页</span><br>    kvminit();       <span class="hljs-comment">// 创建内核页表</span><br>    kvminithart();   <span class="hljs-comment">// 打开分页机制</span><br>    procinit();      <span class="hljs-comment">//为每个进程分配一个内核栈</span><br>    、、、、、、、、、、、、<span class="hljs-comment">//省略</span><br>  scheduler();        <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="物理页初始化"><a href="#物理页初始化" class="headerlink" title="物理页初始化"></a>物理页初始化</h4><p> Qemu 启动的时候会跳转到<code>0x80000000</code>，然后执行相应的指令，xv6 也就运行起来了，此时的第一件事就是初始化物理内存。所有的内容都包含在kalloc.c文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">kinit</span><span class="hljs-params">()</span>  <br>&#123;  <br>  initlock(&amp;kmem.lock, <span class="hljs-string">&quot;kmem&quot;</span>);   <span class="hljs-comment">//初始化锁，也就是给锁赋初值</span><br>  freerange(end, (<span class="hljs-type">void</span>*)PHYSTOP);  <br>&#125;<br><br><span class="hljs-comment">// extract the three 9-bit page table indices from a virtual address.  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXMASK          0x1FF <span class="hljs-comment">// 9 bits  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span><br><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa_start, <span class="hljs-type">void</span> *pa_end)</span>  <br>&#123;  <br>  <span class="hljs-type">char</span> *p;  <br>  p = (<span class="hljs-type">char</span>*)PGROUNDUP((uint64)pa_start);     <span class="hljs-comment">//使内存按照4K对齐，也就是将末尾的12位置为0</span><br>  <span class="hljs-keyword">for</span>(; p + PGSIZE &lt;= (<span class="hljs-type">char</span>*)pa_end; p += PGSIZE)  <span class="hljs-comment">//将内存按照PGSIZE（4KB）分页</span><br>    kfree(p);    <span class="hljs-comment">//初始化（或者说释放）内存空间并加入空闲列表</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>问题</strong>：什么是空闲列表（可利用空间表）？<br><strong>答案</strong>：“空闲列表” 是动态内存管理的一种方法。通过把空闲内存划分成固定大小的数据块，而且利用指针字段把这些数据块链接起来，并使用一个指针指向首结点，这样就形成了一个单链表，即空闲列表（FreeList）</p><p><strong>好处</strong>：常常会有频繁申请、释放内存的需求，比如在发送网络报文时，每次都要分配内存以存储报文，等报文发送完成后又需要删除报文。为了避免频繁的new&#x2F;delete对系统带来的开销，需要实现一个通用的FreeList机制。使用者总是从FreeList中分配内存，如果存在没有使用的内存块就直接摘出来使用，如果没有的话再从系统中分配。使用完毕后并不去直接delete该内存块，而是交给FreeList保管。</p><p>当用户请求分配时，系统从FreeList中删除一个结点分配之；当用户释放其所占内存时，系统即回收并将它插入到FreeList中，因此，FreeList亦称为“存储池”</p><p>FreeList有三种结点结构：</p><ol><li><strong>结点大小相同</strong>：把内存分为大小相同的若干块，将各块链接起来，分配时从头上摘取，用完后插入到头上，这实际是链式栈。</li><li><strong>结点有若干规格</strong>：当用户所需内存量不同，但只允许在几种规格间选取。这种情况下，可利用空间表中可以维护几条链表，同一链表中的结点大小相同。如大小为2、4、8字节，可以构造3个链表。</li><li><strong>结点大小不等</strong>：内存块大小不固定，只有一个链表。通常操作系统的可利用空间表属于此类。即FreeList中只有一个大小为整个存储区的结点。随着分配和回收的进行，FreeList的结点大小和个数也随之而变化。—— 由于结点的大小不同，在分配时并不是FreeList中的任一结点都能满足，而需要按照申请的长度在FreeList中进行检索，找到其长度大于等于申请长度的结点，从中截取合适的长度。这就涉及到分配策略<ul><li>首次适配法：从链表头指针开始查找，找到第一个大于等于所需空间的结点即分配。（分配时查询，释放时插入表头）。优点是速度快，缺点是可能把较大块拆分成较小的块，导致后来对大块的申请难以满足，这种分配策略适合于系统事先不掌握运行期间可能出现的请求分配和释放的信息的情况。</li><li>最佳适配法：要求结点从小到大排列，找到第一个大于等于所需空间的结点即分配。（分配和回收时都需要查询）。优点是使无法满足大请求块的可能性降到最低，但可能导致严重的外部碎片问题 —— 这种分配策略适合请求分配内存大小范围较广的系统</li><li>最差适配法：要求结点从大到小排列，总从第一个结点开始分配。（分配时不需查询，回收时查询）。最佳适配法的。最差适配法的优点是使得空闲块长度趋于一致，适合于分配请求长度比较均匀的情况。</li></ul></li></ol><p>在xv6中，内存以4KB位标准大小，被切割成若干个块，不同的块之间按照单向链表的方式连接，每次进程申请内存时，就分配一个4KB的块给它。</p><p><img src="20230921144414.png%5D" alt="空闲链表freelist"></p><p>更深入的看kfree()代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[]; <span class="hljs-comment">// first address after kernel.  </span><br>                   <span class="hljs-comment">// defined by kernel.ld.</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> &#123;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">next</span>;</span>  <br>&#125;;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span>  <br>&#125; kmem;<br><br><span class="hljs-comment">// Free the page of physical memory pointed at by v,  </span><br><span class="hljs-comment">// which normally should have been returned by a  </span><br><span class="hljs-comment">// call to kalloc().  (The exception is when  </span><br><span class="hljs-comment">// initializing the allocator; see kinit above.)  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span>  <br>  <br>  <span class="hljs-comment">//确认是否对齐  </span><br>  <span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)  <br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);  <br>  <br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.  </span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);  <br>  <br>  r = (<span class="hljs-keyword">struct</span> run*)pa;  <br>  <br>  acquire(&amp;kmem.lock);  <br>  r-&gt;next = kmem.freelist;  <br>  kmem.freelist = r;  <br>  release(&amp;kmem.lock);  <br>&#125;  <br>  <br><br></code></pre></td></tr></table></figure><p>next是一个嵌套指针，自己占用了一段空间并指向一个内存块，kmem是链表的头节点，表示整个需要管理的物理内存块，访问时需要上锁。</p><p>kfree函数接收一个物理地址pa（physical address），pa指向了一个4KB大小的内存块，函数检查这个内存块是否4KB对齐，是否越界，然后填充上无效信息，将其插入到空闲列表中，表示这块空间以及被释放了，下次有进程再申请内存时可以将它分配出去。</p><p>有释放内存的函数，自然就有分配内存的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate one 4096-byte page of physical memory.  </span><br><span class="hljs-comment">// Returns a pointer that the kernel can use.  </span><br><span class="hljs-comment">// Returns 0 if the memory cannot be allocated.  </span><br><span class="hljs-type">void</span> *  <br><span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span>  <br>  <br>  acquire(&amp;kmem.lock);  <br>  r = kmem.freelist;  <br>  <span class="hljs-keyword">if</span>(r)  <br>    kmem.freelist = r-&gt;next;  <br>  release(&amp;kmem.lock);  <br>  <br>  <span class="hljs-keyword">if</span>(r)  <br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk  </span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)r;  <br>&#125;<br></code></pre></td></tr></table></figure><p>kalloc不需要接收任何参数，直接从空闲列表取出来一块内存空间（同样是4KB），填充上无用信息并返回内存地址。</p><p>综上所述，kinit()函数是xv6初始化内存空间的函数，它将内存以4KB位单位切割成块，并串联成空闲列表，每次需要使用时直接分配即可。这个过程需要锁机制来保证安全。</p><h4 id="创建内核页表"><a href="#创建内核页表" class="headerlink" title="创建内核页表"></a>创建内核页表</h4><p>内核使用各种设备也需要使用空间，而现代CPU允许时都必须经过MMU，因此内核页是需要页表的，但是这部分空间的映射并不是随机的，而是虚拟地址&#x3D;物理地址，因此不需要额外的PTE进行表示，直接建立对应关系就可以了。例如内核本身虚拟地址和物理地址都位于<code>KERNBASE=0x80000000</code>，如何建立映射关系？看函数kvmmake<br><img src="20230921152857.png" alt="内核的虚拟地址映射情况"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// qemu -machine virt is set up like this,  </span><br><span class="hljs-comment">// based on qemu&#x27;s hw/riscv/virt.c:  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">// 00001000 -- boot ROM, provided by qemu  </span><br><span class="hljs-comment">// 02000000 -- CLINT  </span><br><span class="hljs-comment">// 0C000000 -- PLIC  </span><br><span class="hljs-comment">// 10000000 -- uart0 </span><br><span class="hljs-comment">// 10001000 -- virtio disk </span><br><span class="hljs-comment">// 80000000 -- boot ROM jumps here in machine mode  </span><br><span class="hljs-comment">//             -kernel loads the kernel here  </span><br><span class="hljs-comment">// unused RAM after 80000000.  </span><br>  <br><span class="hljs-comment">// the kernel uses physical memory thus:  </span><br><span class="hljs-comment">// 80000000 -- entry.S, then kernel text and data  </span><br><span class="hljs-comment">// end -- start of kernel page allocation area  </span><br><span class="hljs-comment">// PHYSTOP -- end RAM used by the kernel</span><br></code></pre></td></tr></table></figure><p>kvmmake通过调用kvmmap，建立虚拟地址和硬件地址的关联，此调用发生在 xv6 启用 RISC-V 上的分页之前，因此地址直接引用物理内存。UART0，VITRIO0，PLIC的位置是通过宏定义设定好的常量，具体可参见memlayout.h文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Make a direct-map page table for the kernel.  </span><br><span class="hljs-type">pagetable_t</span>  <br><span class="hljs-title function_">kvmmake</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">pagetable_t</span> kpgtbl;  <br>  <br>  kpgtbl = (<span class="hljs-type">pagetable_t</span>) kalloc();  <br>  <span class="hljs-built_in">memset</span>(kpgtbl, <span class="hljs-number">0</span>, PGSIZE);  <br>  <br>  <span class="hljs-comment">// uart registers  </span><br>  <span class="hljs-comment">//因为没有打开分页功能，因此UART0此时实际表示的是物理地址</span><br>  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W); <br>  <br>  <span class="hljs-comment">// virtio mmio disk interface  </span><br>  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);  <br>  <br>  <span class="hljs-comment">// PLIC  </span><br>  kvmmap(kpgtbl, PLIC, PLIC, <span class="hljs-number">0x400000</span>, PTE_R | PTE_W);  <br>  <br>  <span class="hljs-comment">// map kernel text executable and read-only.  </span><br>  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);  <br>  <br>  <span class="hljs-comment">// map kernel data and the physical RAM we&#x27;ll make use of.  </span><br>  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);  <br>  <br>  <span class="hljs-comment">// map the trampoline for trap entry/exit to  </span><br>  <span class="hljs-comment">// the highest virtual address in the kernel.  </span><br>  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);  <br>  <span class="hljs-comment">//另外 `TRAMPOLINE` 页面是映射到物理地址 `trampoline` 上了</span><br>  <br>  <span class="hljs-comment">// map kernel stacks  </span><br>  proc_mapstacks(kpgtbl);  <br>    <br>  <span class="hljs-keyword">return</span> kpgtbl;  <br>&#125;<br></code></pre></td></tr></table></figure><p>具体来说，kvmmake 首先调用kalloc()函数分配一个物理内存页来保存根页表页 <strong>（kpgtbl是根目录页，也就是前文举例子时校长随身携带的那张表）</strong>。然后将 <code>UART0</code> 、<code>VIRTIO0</code>、<code>PLIC</code>、<code>KERNBASE</code> 和 <code>etext</code> 都做了直接映射（即虚拟地址和物理地址一样）；另外 <code>TRAMPOLINE</code> 页面是映射到物理地址 <code>trampoline</code> 上了，关于<code> etext 和 trampoline</code> 可以在链接脚本 <code>kernel/kernel.ld</code> 中查看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">OUTPUT_ARCH( <span class="hljs-string">&quot;riscv&quot;</span> )<br>ENTRY( _entry )<br><br>SECTIONS<br>&#123;<br>  . = <span class="hljs-number">0x80000000</span>;<br>  .text : &#123;<br>    *(.text .text.*)<br>    . = ALIGN(<span class="hljs-number">0x1000</span>);<br>    _trampoline = .;<br>    *(trampsec)<br>    . = ALIGN(<span class="hljs-number">0x1000</span>);<br>    ASSERT(. - _trampoline == <span class="hljs-number">0x1000</span>, <span class="hljs-string">&quot;error: trampoline larger than one page&quot;</span>);<br>    PROVIDE(etext = .);<br>  &#125;<br>  ...<span class="hljs-comment">// 后面内容省略</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>etext</code> 是 .text 段结束位置，<code>_trampoline</code> 也是写在 .text 段中；</p><p>继续深挖kvmmap如何是如何建立映射关系的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// add a mapping to the kernel page table.  </span><br><span class="hljs-comment">// only used when booting.  </span><br><span class="hljs-comment">// does not flush TLB or enable paging.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">kvmmap</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="hljs-type">int</span> perm)</span>  <br>&#123;  <br>  <span class="hljs-keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="hljs-number">0</span>)  <br>    panic(<span class="hljs-string">&quot;kvmmap&quot;</span>);  <br>&#125;  <br>  <br><span class="hljs-comment">// Create PTEs for virtual addresses starting at va that refer to  </span><br><span class="hljs-comment">// physical addresses starting at pa. va and size might not  </span><br><span class="hljs-comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t  </span><br><span class="hljs-comment">// allocate a needed page-table page.  </span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">mappages</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>  uint64 a, last;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  <span class="hljs-comment">// 需要映射的大小为0，panic</span><br>  <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;mappages: size&quot;</span>);<br>  <br>  a = PGROUNDDOWN(va);               <span class="hljs-comment">// 需要映射的虚拟地址的下边界</span><br>  last = PGROUNDDOWN(va + size - <span class="hljs-number">1</span>); <span class="hljs-comment">// 需要映射的虚拟地址的上边界</span><br>  <span class="hljs-comment">// 遍历每个4KB的页面</span><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">// 得到最后一级页表项</span><br>    <span class="hljs-keyword">if</span>((pte = walk(pagetable, a, <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// 如果页表项已经有效了，说明这个页表之前已经被映射过了，panic</span><br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_V)<br>      panic(<span class="hljs-string">&quot;mappages: remap&quot;</span>);<br>    <span class="hljs-comment">// 页表项存放对应的物理地址，并设置页表项的标志位</span><br>    *pte = PA2PTE(pa) | perm | PTE_V;<br>    <span class="hljs-comment">// 映射完成</span><br>    <span class="hljs-keyword">if</span>(a == last)<br>      <span class="hljs-keyword">break</span>;<br>    a += PGSIZE;<br>    pa += PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在讲MMU的原理时提到，想要定位一个PTE，需要<strong>页目录的地址+索引</strong>，pagetable参数就是页目录的地址。va和pa分别表示需要建立关联的虚拟地址和物理地址的起始位置，size用来计算结束的位置，perm则是在建立PTE关系时可以用来设定标志位。</p><p>mappages将范围虚拟地址到同等范围物理地址的映射装载到一个页表中。它以页面大小为间隔，为范围内的每个虚拟地址单独执行此操作。对于要映射的每个虚拟地址，mappages调用walk来查找该地址的PTE地址。然后，它初始化PTE以保存相关的物理页号、所需权限（PTE_W、PTE_X和&#x2F;或PTE_R）以及用于标记PTE有效的PTE_V</p><p>mappages还涉及到了一些宏定义的内容，他们的定义位于riscv.h例如PGROUNDDOWN。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSIZE 4096 <span class="hljs-comment">// bytes per page  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSHIFT 12  <span class="hljs-comment">// bits of offset within a page  </span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))  <span class="hljs-comment">//向上取整对齐</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1)) <span class="hljs-comment">//向下取整对齐</span></span><br></code></pre></td></tr></table></figure><p>在map中涉及到了walk函数，这是内存管理的核心函数，<strong>是上文提到的三级页表原理的具体实现。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return the address of the PTE in page table pagetable  </span><br><span class="hljs-comment">// that corresponds to virtual address va.  If alloc!=0,  </span><br><span class="hljs-comment">// create any required page-table pages.  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">// The risc-v Sv39 scheme has three levels of page-table  </span><br><span class="hljs-comment">// pages. A page-table page contains 512 64-bit PTEs.  </span><br><span class="hljs-comment">// A 64-bit virtual address is split into five fields:  </span><br><span class="hljs-comment">//   39..63 -- must be zero.  </span><br><span class="hljs-comment">//   30..38 -- 9 bits of level-2 index.  </span><br><span class="hljs-comment">//   21..29 -- 9 bits of level-1 index.  </span><br><span class="hljs-comment">//   12..20 -- 9 bits of level-0 index.  </span><br><span class="hljs-comment">//    0..11 -- 12 bits of byte offset within the page.  </span><br><br><br><span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">walk</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-type">int</span> alloc)</span><br>&#123;<br>  <span class="hljs-comment">// 访问的虚拟地址超过规定的最大值</span><br>  <span class="hljs-keyword">if</span>(va &gt;= MAXVA)<br>    panic(<span class="hljs-string">&quot;walk&quot;</span>);<br><br>  <span class="hljs-comment">// 模拟三级页表访问过程，从L2-&gt;L1</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> level = <span class="hljs-number">2</span>; level &gt; <span class="hljs-number">0</span>; level--) &#123;<br>    <span class="hljs-comment">// PX(level, va)得到页表中的虚拟页号</span><br>    <span class="hljs-comment">// 根据虚拟页号来得到对应的页表项</span><br>    <span class="hljs-type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];<br>    <span class="hljs-comment">// 如果页表项是有效的</span><br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_V) &#123;<br>      <span class="hljs-comment">// 将页表项转为物理地址，并更新此时的页表</span><br>      pagetable = (<span class="hljs-type">pagetable_t</span>)PTE2PA(*pte);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果页表项是无效的</span><br>      <span class="hljs-comment">// 看是否需要分配新的页表（alloc==1)</span><br>      <span class="hljs-comment">// 需要分配，并且物理内存足够则分配新的页表</span><br>      <span class="hljs-keyword">if</span>(!alloc || (pagetable = (<span class="hljs-type">pde_t</span>*)kalloc()) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 将页表对应的4KB物理内存清空</span><br>      <span class="hljs-built_in">memset</span>(pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>      <span class="hljs-comment">// 将分配的物理地址存放在上一级页表项中，并设置页表标志位V=1</span><br>      *pte = PA2PTE(pagetable) | PTE_V;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 返回最后一级对应的页表项</span><br>  <span class="hljs-keyword">return</span> &amp;pagetable[PX(<span class="hljs-number">0</span>, va)];<br>&#125;<br><br><br>以下是这个过程使用的宏定义，被定义在riscv.h：<br><span class="hljs-comment">// shift a physical address to the right place for a PTE.  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10) <span class="hljs-comment">//右侧12位是偏移量，这个过程相当于抹掉偏移量，取出了物理地址所在页的物理地址，并空出低位10位用于设置标志位  </span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12) <span class="hljs-comment">//PTE低10位是标志位，这个操作抹掉了标志位，然后腾出来12位变成物理地址所在页的地址，与偏移量拼接后即可得到物理地址  </span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF) <span class="hljs-comment">//0x3FF表示低10位，而低10位正好是标志位，这个操作用来取出pte中的标志位  </span></span><br><span class="hljs-comment">//对位运算的运行真的很巧妙  </span><br>  <br><span class="hljs-comment">// extract the three 9-bit page table indices from a virtual address.  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXMASK          0x1FF <span class="hljs-comment">// 9 bits  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level))) <span class="hljs-comment">//level表示索引的层级，xv6有三级索引，这个操作是得到当前需要的索引所在的位置，例如L2位于12 + 9 * 2 =30位  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK) <span class="hljs-comment">//获得索引，例如获得L2索引则需要虚拟地址右移12 + 9 * 2 = 30位，这样最低位的9位就是L2索引的地址</span></span><br><br></code></pre></td></tr></table></figure><p>函数是根据虚拟地址来找到最后一级对应的页表项，返回 0 表示没找到；alloc 参数规定了页表遍历的过程，如果遇见无效的页表是否需要分配一块新的物理内存当做页表，体现了按需分配的原则。</p><p>综上，经过上述一系列函数的操作，完成了最初那张图片所展示的内存空间映射关系。下一步就是打开分页功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Switch h/w page table register to the kernel&#x27;s page table,  </span><br><span class="hljs-comment">// and enable paging.  </span><br><br><br><span class="hljs-comment">//riscv.h文件下</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SATP_SV39 (8L &lt;&lt; 60) <span class="hljs-comment">// use riscv&#x27;s sv39 page table scheme.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) &gt;&gt; 12))</span><br><span class="hljs-comment">// flush the TLB.  </span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span>  <br><span class="hljs-title function_">sfence_vma</span><span class="hljs-params">()</span>  <span class="hljs-comment">//这是一条RISCV指令</span><br>&#123;  <br>  <span class="hljs-comment">// the zero, zero means flush all TLB entries.  </span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;sfence.vma zero, zero&quot;</span>)</span>;  <span class="hljs-comment">//刷新TLB</span><br>&#125;<br><br><br><span class="hljs-comment">//vm.c文件下</span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">kvminithart</span><span class="hljs-params">()</span>  <span class="hljs-comment">//被main.c调用</span><br>&#123;  <br>  w_satp(MAKE_SATP(kernel_pagetable));  <span class="hljs-comment">//kernel_pagetable是前文分配的根目录页</span><br>  sfence_vma();   <span class="hljs-comment">//刷新TLB，打开分页功能</span><br>&#125;<br></code></pre></td></tr></table></figure><p>问题：什么是TLB？<br>答案：Translation Lookaside Buffer。TLB又称快表，在三级页表中，对于PA寻址，需要读取三次内存，代价也十分高。但在实际中，每一个处理器都会缓存最近使用VA对应的PPN，这个缓存也被称作为TLB，通常保存PTE的缓存。因此当CPU第一次翻译VA，通过三次查找页表可以获得最终的PPN，TLB会保存虚拟地址到物理地址的映射关系。那么下一次访问同一个VA时，查看TLB就会直接通过映射得到PA。(应该保存的是<strong>VA的index</strong>与<strong>最终的PPN</strong>的映射)，这种方案因为程序的局部性原理而有效。</p><h2 id="从进程的创建过程看虚拟内存"><a href="#从进程的创建过程看虚拟内存" class="headerlink" title="从进程的创建过程看虚拟内存"></a>从进程的创建过程看虚拟内存</h2><p>前文讲述了xv6启动时的内存初始化操作，整个地址空间已经映射完毕，可用物理内存也已经切成块加入到Freelist中。下面我们以fork和exec为例，看一个新进程产生过程中地址分配是如何运作的。</p><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create a new process, copying the parent.  </span><br><span class="hljs-comment">// Sets up child kernel stack to return as if from fork() system call.  </span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> i, pid;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span>            <span class="hljs-comment">//计划创建的子进程</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <span class="hljs-comment">//第一步，获取当前正在允许的进程</span><br>  <br>  <span class="hljs-comment">// Allocate process.  </span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;   <span class="hljs-comment">//为子进程分配内存空间</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-comment">// Copy user memory from parent to child.  </span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//创建用户内存，下文详解该函数</span><br>    freeproc(np);  <br>    release(&amp;np-&gt;lock);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br><br><span class="hljs-comment">//下文将父进程的内容都copy给子进程，包括进程大小sz，保存上下文的trapframe结构体，文件，名称</span><br>  np-&gt;sz = p-&gt;sz;  <br>  <br>  <span class="hljs-comment">// copy saved user registers.  </span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);  <br>  <br>  <span class="hljs-comment">// Cause fork to return 0 in the child.  </span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;  <br><br><span class="hljs-comment">//文件相关，暂时不管</span><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.  </span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)  <br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])  <br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);  <br>  np-&gt;cwd = idup(p-&gt;cwd);  <br>  <br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));  <br>  <br>  <span class="hljs-comment">//lab2 trace  </span><br>  np-&gt;trace_mask = p-&gt;trace_mask;  <br>  <br>  pid = np-&gt;pid;  <br><br><br><span class="hljs-comment">//新进程创建完毕，修改新建的状态，将子进程指向父进程，修改进程状态（这个过程需要上锁）</span><br>  release(&amp;np-&gt;lock);  <br>  <br>  acquire(&amp;wait_lock);  <br>  np-&gt;parent = p;  <br>  release(&amp;wait_lock);  <br>  <br>  acquire(&amp;np-&gt;lock);  <br>  np-&gt;state = RUNNABLE;  <br>  release(&amp;np-&gt;lock);  <br>  <br>  <span class="hljs-keyword">return</span> pid;  <br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，涉及到内存相关的内容就是下面这段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">// Copy user memory from parent to child.  </span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;  <br>    freeproc(np);  <br>    release(&amp;np-&gt;lock);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;<br><br><span class="hljs-comment">// vm.c</span><br><span class="hljs-comment">// Given a parent process&#x27;s page table, copy  </span><br><span class="hljs-comment">// its memory into a child&#x27;s page table.  </span><br><span class="hljs-comment">// Copies both the page table and the  </span><br><span class="hljs-comment">// physical memory.  </span><br><span class="hljs-comment">// returns 0 on success, -1 on failure.  </span><br><span class="hljs-comment">// frees any allocated pages on failure.  </span><br><br><span class="hljs-comment">//每个进程都有一个根页目录，old和new是父进程和子进程指向根页目录的指针，sz是父进程占用内存大小</span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">uvmcopy</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> old, <span class="hljs-type">pagetable_t</span> new, uint64 sz)</span>   <br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;  <br>  uint64 pa, i;  <br>  uint flags;  <br>  <span class="hljs-type">char</span> *mem;  <br><br><span class="hljs-comment">//因为进程可能大于4kB，也就是由多个页组成，在虚拟内存机制下，页内部是连续的，但是不同页之间不一定连续，因此需要循环找到每一页进行拷贝</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;   <br>    <span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)    <span class="hljs-comment">//根据old页目录地址 + 虚拟地址找到PTE</span><br>      panic(<span class="hljs-string">&quot;uvmcopy: pte should exist&quot;</span>);  <br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)             <span class="hljs-comment">//PTE有效性检查</span><br>      panic(<span class="hljs-string">&quot;uvmcopy: page not present&quot;</span>);  <br>    pa = PTE2PA(*pte);               <span class="hljs-comment">//根据PTE找到物理页的首地址</span><br>    flags = PTE_FLAGS(*pte);         <span class="hljs-comment">//设置PTE标识位</span><br>    <span class="hljs-keyword">if</span>((mem = kalloc()) == <span class="hljs-number">0</span>)        <span class="hljs-comment">//分配一页物理内存</span><br>      <span class="hljs-keyword">goto</span> err;  <br>    memmove(mem, (<span class="hljs-type">char</span>*)pa, PGSIZE);   <span class="hljs-comment">//拷贝</span><br>    <span class="hljs-keyword">if</span>(mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//在虚拟地址和新分配的物理地址之间建立映射关系，这样新进程的页表就构建好了</span><br>      kfree(mem);  <br>      <span class="hljs-keyword">goto</span> err;  <br>    &#125;  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  <br> err:  <br>  uvmunmap(new, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">1</span>);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>整个函数的思路是</p><ol><li>因为进程可能大于4kB，也就是由多个页组成，在虚拟内存机制下，页内部是连续的，但是不同页之间不一定连续，因此需要循环找到每一页进行拷贝。i从0开始一直到SZ停止，意味着需要拷贝整个进程的内存空间。</li><li>old是父进程的页目录虚拟地址，new是新建的子进程页目录虚拟地址（暂未赋值），通过walk函数找到进程的物理地址</li><li>为子进程分配新的物理内存，并设置PTE标志位，再将父进程的物理内存复制到子进程的内存</li><li>建立子进程虚拟地址与子进程物理地址的映射关系、</li><li><code>uvmunmap</code>函数，如果在分配内存或者建立映射关系时出现错误，说明这次拷贝任务失败，需要将循环过程中之前已经分配的内容都释放（这一步在工程上非常重要，不然会出现看起来已经被分配，但无法使用的，也无法被回收的内存）</li></ol><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>  <br><span class="hljs-title function_">exec</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> **argv)</span>  <br>&#123;  <br>  <span class="hljs-type">char</span> *s, *last;  <br>  <span class="hljs-type">int</span> i, off;  <br>  uint64 argc, sz = <span class="hljs-number">0</span>, sp, ustack[MAXARG], stackbase;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> <span class="hljs-title">elf</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> <span class="hljs-title">ph</span>;</span>  <br>  <span class="hljs-type">pagetable_t</span> pagetable = <span class="hljs-number">0</span>, oldpagetable;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  begin_op();  <br>  <br>  <span class="hljs-keyword">if</span>((ip = namei(path)) == <span class="hljs-number">0</span>)&#123;  <br>    end_op();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>  ilock(ip);  <br>  <br>  <span class="hljs-comment">// Check ELF header  </span><br>  <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;elf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(elf)) != <span class="hljs-keyword">sizeof</span>(elf))  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <span class="hljs-keyword">if</span>(elf.magic != ELF_MAGIC)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <br>  <span class="hljs-keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <br>  <span class="hljs-comment">// Load program into memory.  </span><br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="hljs-keyword">sizeof</span>(ph))&#123;  <br>    <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;ph, off, <span class="hljs-keyword">sizeof</span>(ph)) != <span class="hljs-keyword">sizeof</span>(ph))  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    <span class="hljs-keyword">if</span>(ph.type != ELF_PROG_LOAD)  <br>      <span class="hljs-keyword">continue</span>;  <br>    <span class="hljs-keyword">if</span>(ph.memsz &lt; ph.filesz)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    <span class="hljs-keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    uint64 sz1;  <br>    <span class="hljs-keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    sz = sz1;  <br>    <span class="hljs-keyword">if</span>((ph.vaddr % PGSIZE) != <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    <span class="hljs-keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>  &#125;  <br>  iunlockput(ip);  <br>  end_op();  <br>  ip = <span class="hljs-number">0</span>;  <br>  <br>  p = myproc();  <br>  uint64 oldsz = p-&gt;sz;  <br>  <br>  <span class="hljs-comment">// Allocate two pages at the next page boundary.  </span><br>  <span class="hljs-comment">// Use the second as the user stack.  sz = PGROUNDUP(sz);  </span><br>  uint64 sz1;  <br>  <span class="hljs-keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="hljs-number">2</span>*PGSIZE)) == <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  sz = sz1;  <br>  uvmclear(pagetable, sz<span class="hljs-number">-2</span>*PGSIZE);  <br>  sp = sz;  <br>  stackbase = sp - PGSIZE;  <br>  <br>  <span class="hljs-comment">// Push argument strings, prepare rest of stack in ustack.  </span><br>  <span class="hljs-keyword">for</span>(argc = <span class="hljs-number">0</span>; argv[argc]; argc++) &#123;  <br>    <span class="hljs-keyword">if</span>(argc &gt;= MAXARG)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    sp -= <span class="hljs-built_in">strlen</span>(argv[argc]) + <span class="hljs-number">1</span>;  <br>    sp -= sp % <span class="hljs-number">16</span>; <span class="hljs-comment">// riscv sp must be 16-byte aligned  </span><br>    <span class="hljs-keyword">if</span>(sp &lt; stackbase)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    <span class="hljs-keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="hljs-built_in">strlen</span>(argv[argc]) + <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    ustack[argc] = sp;  <br>  &#125;  <br>  ustack[argc] = <span class="hljs-number">0</span>;  <br>  <br>  <span class="hljs-comment">// push the array of argv[] pointers.  </span><br>  sp -= (argc+<span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(uint64);  <br>  sp -= sp % <span class="hljs-number">16</span>;  <br>  <span class="hljs-keyword">if</span>(sp &lt; stackbase)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <span class="hljs-keyword">if</span>(copyout(pagetable, sp, (<span class="hljs-type">char</span> *)ustack, (argc+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(uint64)) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <br>  <span class="hljs-comment">// arguments to user main(argc, argv)  </span><br>  <span class="hljs-comment">// argc is returned via the system call return  // value, which goes in a0.  p-&gt;trapframe-&gt;a1 = sp;  </span><br>  <br>  <span class="hljs-comment">// Save program name for debugging.  </span><br>  <span class="hljs-keyword">for</span>(last=s=path; *s; s++)  <br>    <span class="hljs-keyword">if</span>(*s == <span class="hljs-string">&#x27;/&#x27;</span>)  <br>      last = s+<span class="hljs-number">1</span>;  <br>  safestrcpy(p-&gt;name, last, <span class="hljs-keyword">sizeof</span>(p-&gt;name));  <br>      <br>  <span class="hljs-comment">// Commit to the user image.  </span><br>  oldpagetable = p-&gt;pagetable;  <br>  p-&gt;pagetable = pagetable;  <br>  p-&gt;sz = sz;  <br>  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="hljs-comment">// initial program counter = main  </span><br>  p-&gt;trapframe-&gt;sp = sp; <span class="hljs-comment">// initial stack pointer  </span><br>  proc_freepagetable(oldpagetable, oldsz);  <br>  <br>  <span class="hljs-keyword">return</span> argc; <span class="hljs-comment">// this ends up in a0, the first argument to main(argc, argv)  </span><br>  <br> bad:  <br>  <span class="hljs-keyword">if</span>(pagetable)  <br>    proc_freepagetable(pagetable, sz);  <br>  <span class="hljs-keyword">if</span>(ip)&#123;  <br>    iunlockput(ip);  <br>    end_op();  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;  <br>  <br><span class="hljs-comment">// Load a program segment into pagetable at virtual address va.  </span><br><span class="hljs-comment">// va must be page-aligned  </span><br><span class="hljs-comment">// and the pages from va to va+sz must already be mapped.  </span><br><span class="hljs-comment">// Returns 0 on success, -1 on failure.  </span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  <br><span class="hljs-title function_">loadseg</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-keyword">struct</span> inode *ip, uint offset, uint sz)</span>  <br>&#123;  <br>  uint i, n;  <br>  uint64 pa;  <br>  <br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;  <br>    pa = walkaddr(pagetable, va + i);  <br>    <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)  <br>      panic(<span class="hljs-string">&quot;loadseg: address should exist&quot;</span>);  <br>    <span class="hljs-keyword">if</span>(sz - i &lt; PGSIZE)  <br>      n = sz - i;  <br>    <span class="hljs-keyword">else</span>  <br>      n = PGSIZE;  <br>    <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)pa, offset+i, n) != n)  <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>我们拆开了看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">begin_op();  <br><br><span class="hljs-comment">//path是可执行文件的位置</span><br><span class="hljs-keyword">if</span>((ip = namei(path)) == <span class="hljs-number">0</span>)&#123;   <span class="hljs-comment">//namei是文件系统的内容，没学，暂时搁置</span><br>  end_op();  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;  <br>ilock(ip);<br><br></code></pre></td></tr></table></figure><p>exec通过路径名打开文件，然后读取该文件的<strong>ELF Header</strong>（kernel&#x2F;elf.h）。</p><p>xv6的所有应用程序以通用的<strong>ELF格式</strong>来描述。一个ELF二进制文件大概这样组成（更准确的定义，建议查阅相关资料，这里进行简单的不严谨的说明）：一个ELF Header，后面紧跟一系列的Program Section Headers。每个Program Section Header都对应一段需要加载到内存中的程序，xv6的应用程序只有一个Program Section Header，而在其它操作系统上可能有好几个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// File header</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> &#123;</span><br>  uint magic;  <span class="hljs-comment">// must equal ELF_MAGIC</span><br>  uchar elf[<span class="hljs-number">12</span>];<br>  ushort type;<br>  ushort machine;<br>  uint version;<br>  uint64 entry;<br>  uint64 phoff;<br>  uint64 shoff;<br>  uint flags;<br>  ushort ehsize;<br>  ushort phentsize;<br>  ushort phnum;<br>  ushort shentsize;<br>  ushort shnum;<br>  ushort shstrndx;<br>&#125;;<br><br><span class="hljs-comment">// Program section header</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> &#123;</span><br>  uint32 type;<br>  uint32 flags;<br>  uint64 off;<br>  uint64 vaddr;<br>  uint64 paddr;<br>  uint64 filesz;<br>  uint64 memsz;<br>  uint64 align;<br>&#125;;<br><br><span class="hljs-comment">// Format of an ELF executable file</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_MAGIC 0x464C457FU  <span class="hljs-comment">// &quot;\x7FELF&quot; in little endian</span></span><br><br><span class="hljs-comment">// Values for Proghdr type</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_LOAD           1</span><br><br><span class="hljs-comment">// Flag bits for Proghdr flags</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_EXEC      1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_WRITE     2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_READ      4</span><br><br></code></pre></td></tr></table></figure><p>exec读取了文件系统上的文件之后，第一件事就是先检查该文件是否包含ELF二进制文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Check ELF header  </span><br><span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;elf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(elf)) != <span class="hljs-keyword">sizeof</span>(elf))  <span class="hljs-comment">//readi用来从inode获取数据</span><br>  <span class="hljs-keyword">goto</span> bad;  <br><span class="hljs-keyword">if</span>(elf.magic != ELF_MAGIC)  <br>  <span class="hljs-keyword">goto</span> bad;  <br></code></pre></td></tr></table></figure><p>完成检验后，exec为用户进程调用<code>proc_pagetable（proc.c）</code>，该函数通过<code>uvmcreate</code>创建一个空的用户页表，然后在该用户页表上添加了trampoline（位于虚拟地址最高位）和trapframe（trampoline下面）的映射，其它的虚拟地址空间都暂时为空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">  <br><span class="hljs-keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="hljs-number">0</span>)  <br>  <span class="hljs-keyword">goto</span> bad;<br><br><span class="hljs-comment">//proc.c</span><br><span class="hljs-comment">// Create a user page table for a given process,</span><br><span class="hljs-comment">// with no user memory, but with trampoline pages.</span><br><span class="hljs-type">pagetable_t</span><br><span class="hljs-title function_">proc_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>&#123;<br>  <span class="hljs-type">pagetable_t</span> pagetable;<br><br>  <span class="hljs-comment">// An empty page table.</span><br>  pagetable = uvmcreate();<br>  <span class="hljs-keyword">if</span>(pagetable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// map the trampoline code (for system call return)</span><br>  <span class="hljs-comment">// at the highest user virtual address.      </span><br>  <span class="hljs-comment">// only the supervisor uses it, on the way</span><br>  <span class="hljs-comment">// to/from user space, so not PTE_U.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,<br>              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,<br>              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> pagetable;<br>&#125;<br><br><span class="hljs-comment">// create an empty user page table.</span><br><span class="hljs-comment">// returns 0 if out of memory.</span><br><span class="hljs-type">pagetable_t</span><br><span class="hljs-title function_">uvmcreate</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">pagetable_t</span> pagetable;<br>  pagetable = (<span class="hljs-type">pagetable_t</span>) kalloc();<br>  <span class="hljs-keyword">if</span>(pagetable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>  <span class="hljs-keyword">return</span> pagetable;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>一个可执行二进制程序（在 linux 下为一个进程单元），在存储时（<strong>没有加载到内存运行</strong>），至少拥有三个部分，分别是代码段(text)、数据段(data)、和bss段（未初始化的全局变量，不占用可执行文件的空间）。当应用程序运行时（<strong>运行态</strong>），此时需要另外两个域：<strong>堆</strong>和<strong>栈</strong>。正在运行的程序：**代码段 + 数据段 + bss 段 + 堆 + 栈。</p><ul><li>代码段：程序执行的指令</li><li>数据段：已初始化的全局变量和静态局部变量</li><li>bss段：存放程序中未初始化和初始化为 0的全局变量的一块内存区域，在程序载入时由内核清零</li><li>堆：动态分配的内存，FIFO的数据结构</li><li>栈：局部变量，参数，返回值，LIFO的数据结构</li></ul><p><img src="20231016200329.png" alt="一个可执行程序的内存结构"></p><p>exec对于每个程序段，先是调用<code>uvmalloc</code>分配足够的物理帧，更新了用户页表。然后调用<code>loadseg</code>加载程序段到这些物理帧中。<code>loadseg</code>将虚拟地址传给<code>walkaddr</code>，<code>walkaddr</code>又通过<code>walk</code>查找相关PTE，将va转换为pa，最后<code>walkaddr</code>成功返回<code>uvmalloc</code>分配的物理帧的物理地址，<code>loadseg</code>再调用<code>readi</code>，真正地将程序段加载到物理内存中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// Load program into memory</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="hljs-keyword">sizeof</span>(ph))&#123;<br>  <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;ph, off, <span class="hljs-keyword">sizeof</span>(ph)) != <span class="hljs-keyword">sizeof</span>(ph))<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>(ph.type != ELF_PROG_LOAD)<br>    <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-keyword">if</span>(ph.memsz &lt; ph.filesz)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)<br>    <span class="hljs-keyword">goto</span> bad;<br>  uint64 sz1;<br>  <span class="hljs-comment">// 再通过uvmalloc为每个ELF段分配内存</span><br>  <span class="hljs-keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  sz = sz1;<br>  <span class="hljs-keyword">if</span>(ph.vaddr % PGSIZE != <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-comment">// 然后通过loadseg把段的内容载入物理内存中</span><br>  <span class="hljs-comment">// loadseg通过walkaddr找到写入ELF段的内存的物理地址；通过readi来将段的内容从文件中读出</span><br>  <span class="hljs-keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>&#125;<br><br><br><span class="hljs-comment">// Load a program segment into pagetable at virtual address va.</span><br><span class="hljs-comment">// va must be page-aligned</span><br><span class="hljs-comment">// and the pages from va to va+sz must already be mapped.</span><br><span class="hljs-comment">// Returns 0 on success, -1 on failure.</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">loadseg</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-keyword">struct</span> inode *ip, uint offset, uint sz)</span><br>&#123;<br>  uint i, n;<br>  uint64 pa;<br><br>  <span class="hljs-keyword">if</span>((va % PGSIZE) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;loadseg: va must be page aligned&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    pa = walkaddr(pagetable, va + i);<br>    <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;loadseg: address should exist&quot;</span>);<br>    <span class="hljs-keyword">if</span>(sz - i &lt; PGSIZE)<br>      n = sz - i;<br>    <span class="hljs-keyword">else</span><br>      n = PGSIZE;<br>    <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)pa, offset+i, n) != n)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// Look up a virtual address, return the physical address,</span><br><span class="hljs-comment">// or 0 if not mapped.</span><br><span class="hljs-comment">// Can only be used to look up user pages.</span><br>uint64<br><span class="hljs-title function_">walkaddr</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va)</span><br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  uint64 pa;<br><br>  <span class="hljs-keyword">if</span>(va &gt;= MAXVA)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  pte = walk(pagetable, va, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(pte == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_U) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  pa = PTE2PA(*pte);<br>  <span class="hljs-keyword">return</span> pa;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h2><p>前文提到，节省空间是计算机使用三级页表的原因之一。因为局部性原理，部分PTE被用到的概率不大，因此存储在外部存储硬件上，既然没有装进去所有的PTE，那自然可能会存PTE不在内存中的情况，这时就需要触发缺页中断，将PTE从外部存储加载到内存中</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab2 system calls</title>
    <link href="/2023/09/04/Lab2-system-calls/"/>
    <url>/2023/09/04/Lab2-system-calls/</url>
    
    <content type="html"><![CDATA[<p>[课程地址]([<a href="https://pdos.csail.mit.edu/6.S081/2021/labs/syscall.html">Lab: System calls (mit.edu)</a>])_</p><p>本次实验是需要完成一些系统调用功能，在开始前需要先理解进程相关的概念和系统调用的原理</p><h2 id="系统调用的原理"><a href="#系统调用的原理" class="headerlink" title="系统调用的原理"></a>系统调用的原理</h2><p>回顾第二章书本上的知识，我们知道程序一般运行在用户态，只有遇到以下三种情况才会陷入中断进入内核态：</p><ol><li><strong>系统调用</strong>：当用户程序执行<strong>ecall</strong>指令要求内核为其做某事时。</li><li><strong>异常</strong>：一条指令(用户或内核)做了一些非法的事情，如除以零或使用无效的虚拟地址。</li><li><strong>中断</strong>：当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时。</li></ol><p>所以研究系统调用，其实也就是研究中断（trap）过程是如何发生的。宏观上可分为四个步骤，本文会针对这四个步骤，结合xv6系统进行详细的讲解：</p><ol><li>中断请求</li><li>保护现场</li><li>中断处理</li><li>中断返回</li></ol><p>以上过程自然离不开与寄存器打交道，例如<strong>satp寄存器用于控制分页系统</strong>，以下是与trap相关的寄存器概述，这些寄存器可以分为两类：<br><strong>1. 发生中断时，硬件自动写入的寄存器</strong><br>    -  <code>sepc</code>：当trap发生时，RISC-V会将程序计数器保存在这里(因为<code>PC</code>会被<code>stvec</code>覆盖)。<code>sret</code>(从trap中返回)指令将<code>sepc</code>复制到<code>pc</code>中。内核可以写<code>sepc</code>来控制<code>sret</code>的返回到哪里。<br>    -  <code>scause</code>：RISC -V在这里放了一个数字，描述了trap的原因。<br>    -  <code>stval</code>：<code>scause</code> 不足以存下中断所有的必须信息。例如缺页异常，就会将 <code>stval</code> 设置成需要访问但是不在内存中的地址，以便于操作系统将这个地址所在的页面加载进来。</p><p><strong>2. 指导硬件处理中断的寄存器</strong><br>    - <code>stvec</code>：保存内核中断处理流程的入口地址，内核在这里写下trap处理程序的地址；RISC-V跳转到这里来处理trap。<br>    - <code>sstatus</code>：具有许多状态位，控制全局中断等。<code>sstatus</code>中的<strong>SIE</strong>位控制设备中断是否被启用，如果内核清除<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核设置<strong>SIE</strong>。<strong>SPP</strong>位表示trap是来自用户模式还是supervisor模式，并控制<code>sret</code>返回到什么模式。<br>    - <code>sie</code>：即 Supervisor Interrupt Enable，用来控制具体类型中断，例如其中的 STIE 控制时钟中断<br>    - <code>sip</code>：即 Supervisor Interrupt Pending，和 <code>sie</code> 相对应，记录每种中断是否被触发。仅当 <code>sie</code> 和 <code>sip</code> 的对应位都为 1 时，意味着开中断且已发生中断，这时中断最终触发。<br>    - <code>sscratch</code>：内核在这里放置了一个值，在trap处理程序开始时可以方便地使用。在用户态保存内核栈的地址，在内核态值为 0。为什么需要内核栈？因此中断处理流程也需要利用内存空间，很可能需要使用栈，而程序当前的用户栈是不安全的（说不定指针不断运行到其他进程的空间，破坏了隔离性）。因此，我们还需要一个预设的安全的栈空间，存放在这里。</p><p>有了上述与中断相关的寄存器，自然也就有与中断相关的指令：<br><strong>1. 进入和退出中断</strong><br>    - <code>ecall</code>：触发中断，进入更高一层的中断处理流程之中。用户态进行系统调用进入内核态中断处理流程，内核态进行 SBI 调用进入机器态中断处理流程，使用的都是这条指令。<br>    - <code>sret</code>：从内核态返回用户态，同时将 <code>sepc</code> 的值赋值给 <code>pc</code>。（如果需要返回到 <code>sepc</code> 后一条指令，就需要在 <code>sret</code> 之前修改 <code>sepc</code> 的值）<br>    - <code>ebreak</code>：触发一个断电<br>    - <code>mret</code>：从机器态返回内核态，同时将 <code>pc</code> 的值设置为 <code>mepc</code>。</p><p><strong>2. 操作CSR</strong><br>    只有一系列特殊的指令（CSR Instruction）可以读写 CSR<br>    - <code>csrrw dst, csr, src</code>（CSR Read Write）同时读写的原子操作，将指定 CSR 的值写入 <code>dst</code>，同时将 <code>src</code> 的值写入 CSR。<br>    - <code>csrr dst, csr</code>（CSR Read）：仅读取一个 CSR 寄存器。<br>    - <code>csrw csr, src</code>（CSR Write）  ：仅写入一个 CSR 寄存器。</p><p>微观上，RISC-V硬件对每一个trap操作（除定时器中断外），都会执行如下步骤：</p><ol><li>如果该trap是设备中断，且sstatus SIE位为0，则不执行以下任何操作</li><li>通过清除 SIE 来禁用中断</li><li>复制 pc 到 sepc</li><li>将当前模式(用户态或特权态)保存在 sstatus 的 SPP 位</li><li>在 scause 设置该次trap的原因</li><li>将模式转换为特权态</li><li>将 stvec 复制到 pc</li><li>从新的pc开始执行</li></ol><h4 id="中断请求"><a href="#中断请求" class="headerlink" title="中断请求"></a>中断请求</h4><p>当使用到<code>write，read，open</code>等系统调用时，会使用<code>ecall</code>指令发起中断请求</p><ul><li><code>ecall</code>是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用</li></ul><p>在xv6中，<code>user/cat.c</code>文件是<code>cat shell</code>指令的源码，其中涉及到了<code>read</code>函数，它声明在<code>user/user.h</code>文件中，但是<code>read</code>函数的实现在<code>kernel/sysfile.c</code>文件中。显然<code>cat</code>并不是直接调用<code>sysfile.c</code>文件中的函数来达成目标的，毕竟一个在用户态，一个在内核态。</p><p>既然<code>read</code>在用户态的角度看不见具体的逻辑实现，那它为什么能正常运行呢？只声明不实现的函数是无法正常使用的呀？</p><p>仔细观察user文件架，我们可以发现虽然没有<code>read</code>函数的c语言实现，但其实存在汇编实现。用户在c代码中使用<code>read</code>函数时，其实是在运行<code>usys.S</code>文件（由<code>usys.pl</code>文件得来，make指令才能看见）中<code>read</code>函数。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">c</span>语言如何调用汇编函数？步骤：<br><span class="hljs-number">1</span>、先在汇编程序中声明函数属性为GLOBAL<br><span class="hljs-number">2</span>、在<span class="hljs-keyword">c</span>文件开头声明该函数<br><span class="hljs-number">3</span>、按照C语言正常调用函数的方式调用该函数<br></code></pre></td></tr></table></figure><p>当然，这个汇编函数虽然名称也叫<code>read</code>，但并不是在执行读取文件的逻辑，而是在建立用户态与内核态的桥梁。<code>usys.pl</code>脚本的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">#!/usr/bin/perl -w  <br>  <br># Generate usys.S, the stubs <span class="hljs-keyword">for</span> syscalls.  <br>  <br>print <span class="hljs-string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;  <br>  <br>print <span class="hljs-string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;  <br>  <br>sub entry &#123;  <br>    my $name = shift;  <br>    print <span class="hljs-string">&quot;.global $name\n&quot;</span>;  <br>    print <span class="hljs-string">&quot;$&#123;name&#125;:\n&quot;</span>;  <br>    print <span class="hljs-string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;  <br>    print <span class="hljs-string">&quot; ecall\n&quot;</span>;  <br>    print <span class="hljs-string">&quot; ret\n&quot;</span>;  <br>&#125;  <br>     <br>entry(<span class="hljs-string">&quot;fork&quot;</span>);  <br>entry(<span class="hljs-string">&quot;exit&quot;</span>);  <br>entry(<span class="hljs-string">&quot;wait&quot;</span>);  <br>entry(<span class="hljs-string">&quot;pipe&quot;</span>);  <br>entry(<span class="hljs-string">&quot;read&quot;</span>);  <br>entry(<span class="hljs-string">&quot;write&quot;</span>);  <br>entry(<span class="hljs-string">&quot;close&quot;</span>);  <br>entry(<span class="hljs-string">&quot;kill&quot;</span>);  <br>entry(<span class="hljs-string">&quot;exec&quot;</span>);  <br>entry(<span class="hljs-string">&quot;open&quot;</span>);  <br>entry(<span class="hljs-string">&quot;mknod&quot;</span>);  <br>entry(<span class="hljs-string">&quot;unlink&quot;</span>);  <br>entry(<span class="hljs-string">&quot;fstat&quot;</span>);  <br>entry(<span class="hljs-string">&quot;link&quot;</span>);  <br>entry(<span class="hljs-string">&quot;mkdir&quot;</span>);  <br>entry(<span class="hljs-string">&quot;chdir&quot;</span>);  <br>entry(<span class="hljs-string">&quot;dup&quot;</span>);  <br>entry(<span class="hljs-string">&quot;getpid&quot;</span>);  <br>entry(<span class="hljs-string">&quot;sbrk&quot;</span>);  <br>entry(<span class="hljs-string">&quot;sleep&quot;</span>);  <br>entry(<span class="hljs-string">&quot;uptime&quot;</span>);<br></code></pre></td></tr></table></figure><p><code>usys.pl</code>是一个Perl语言文件。即使对Perl语言并没有深入了解，但根据语法规则可以大概了解它的作用：这个脚本文件将根据输入的字符名，通过<code>entry()</code>格式化生成文本文件。</p><p><code>usys.pl</code>的输入是系统调用的名称，输出内容则保存为<code>kernel/usys.S</code>。这样每个系统调用都在<code>usys.S</code>文件中都有一个实现，通过<code>global</code>声明后，用户在使用同名的函数时，会执行这里的<code>entry()</code>中的逻辑：</p><ol><li>将系统调用的ID存入a7寄存器<ul><li>虽然输入的是名称（字符串），但是<code>kernel/syscall.h</code>文件下将字符串映射为了编号</li></ul></li><li>执行ecall命令<ul><li><code>ecall</code>是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用</li></ul></li></ol><p>这样就通过<code>ecall</code>指令（中断请求）将需要的系统调用从用户态传递给了内核态。在ecall调用过程中会发生（和前文中讲到的微观操作一致，但这里只写主要内容）：</p><ol><li>关中断</li><li>代码从<code>user mode</code>改到supervisor mode</li><li>程序计数器<code>PC</code>的值保存进 <code>SEPC</code> 寄存器</li><li>CPU执行<code>STVEC</code>寄存器指向的指令（<code>PC</code>重置为 <code>STVEC</code> 寄存器的值）</li></ol><p>问题：那么<code>STVEC</code>寄存器的值到底是多少？<br>答案：<code>STVEC</code>是一个特权寄存器，只能在supervisor mode下执行，每次从内核空间返回到用户空间之前，内核会设置<code>STVEC</code>寄存器指向内核希望中断代码运行的位置（由<code>trap.c</code>中的代码设置）。</p><p>Xv6在内核页表和每个用户页表中的<strong>同一个虚拟地址</strong>上映射了 <code>trampoline page</code> 。<code>STVEC</code> 寄存器保存的地址是 <code>trampoline page</code> 的起始位置，主要执行一些保护用户态寄存器的操作。<code>trampoline page</code> 的首地址是 <code>uservec</code> 函数。所以其实<code>STVEC</code>指向了<code>kernel/trampoline.S</code>文件中的<code>uservec</code>函数。</p><p><strong>综上，其实操作系统伪装了一个系统调用的实现，当使用<code>read</code>等函数时并没有真正的读写逻辑，而是利用ecall发起中断，并通过寄存器将函数的ID告知内核，方便在内核找到函数真正的实现。</strong></p><h4 id="保护现场"><a href="#保护现场" class="headerlink" title="保护现场"></a>保护现场</h4><p>上文讲到CPU将执行<code>uservec</code>函数（<code>kernel/trampoline.S</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c">.globl uservec  <br>uservec:      <br>   #  <br>        <span class="hljs-meta"># trap.c sets stvec to point here, so  </span><br>        <span class="hljs-meta"># traps from user space start here,  </span><br>        <span class="hljs-meta"># in supervisor mode, but with a  </span><br>        <span class="hljs-meta"># user page table.  </span><br>        #  <br>        <span class="hljs-meta"># sscratch points to where the process<span class="hljs-string">&#x27;s p-&gt;trapframe is  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # mapped into user space, at TRAPFRAME.  </span></span><br><span class="hljs-string"><span class="hljs-meta">        #  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # swap a0 and sscratch  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # so that a0 is TRAPFRAME  </span></span><br><span class="hljs-string"><span class="hljs-meta">        csrrw a0, sscratch, a0 </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # save the user registers in TRAPFRAME  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd ra, 40(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd sp, 48(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd gp, 56(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd tp, 64(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t0, 72(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t1, 80(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t2, 88(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s0, 96(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s1, 104(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a1, 120(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a2, 128(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a3, 136(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a4, 144(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a5, 152(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a6, 160(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a7, 168(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s2, 176(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s3, 184(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s4, 192(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s5, 200(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s6, 208(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s7, 216(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s8, 224(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s9, 232(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s10, 240(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s11, 248(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t3, 256(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t4, 264(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t5, 272(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t6, 280(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">   # save the user a0 in p-&gt;trapframe-&gt;a0  </span></span><br><span class="hljs-string"><span class="hljs-meta">        csrr t0, sscratch  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t0, 112(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld sp, 8(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld tp, 32(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld t0, 16(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld t1, 0(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        csrw satp, t1  //切换到内核页表</span></span><br><span class="hljs-string"><span class="hljs-meta">        sfence.vma zero, zero  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # a0 is no longer valid, since the kernel page  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # table does not specially map p-&gt;tf.  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # jump to usertrap(), which does not return  </span></span><br><span class="hljs-string"><span class="hljs-meta">        jr t0</span></span><br></code></pre></td></tr></table></figure><p>在进程的结构中有一个结构体变量名为<code>trapframe</code>，它的作用是：</p><ol><li>发生中断时，保存进程在用户态使用的各种寄存器的值，以便于到时候恢复进程运行状态。</li><li>保存完成后，加载进程在内核态运行需要使用的寄存器的值</li></ol><p>在上面的代码中：</p><ol><li>先使用<code>csrrw</code>指令，将a0寄存器设置为<code>sscratch</code>寄存器的值，此时a0指向进程的<code>trapframe</code>结构。按照特定的顺序，保存寄存器的值。从偏移量40开始是因为，0到40（5 * 8）之间保存了5个内核态相关的值<code>（kernel_satp，kernel_sp，kernel_trap，epc，kernel_hartid）</code>，具体可参考<code>proc.h</code>文件中<code>trapframe</code>的结构。</li><li>恢复内核栈指针，将5个内核态相关的值加载进寄存器中，然后强制跳转执行<code>usertrap</code>函数（地址存储在<code>p-&gt;trapframe-&gt;kernel_trap</code>）。</li></ol><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><p>在保存好上下文之后就要开始执行中断处理的逻辑了，这里使用的栈已经从用户栈变成了内核栈<br><code>usertrap</code>函数的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  </span><br><span class="hljs-comment">// handle an interrupt, exception, or system call from user space.  </span><br><span class="hljs-comment">// called from trampoline.S  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;  <br>  <br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)   <span class="hljs-comment">//判断中断是否合法</span><br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);  <br>  <br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),  </span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.  </span><br>  w_stvec((uint64)kernelvec);  <br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>    <br>  <span class="hljs-comment">// save user program counter.  </span><br>  p-&gt;trapframe-&gt;epc = r_sepc();  <span class="hljs-comment">//保存sepc寄存器的值，前文提到了ecall指令执行后会将当前的PC保存到sepc中，因此 p-&gt;trapframe-&gt;epc其实指向ecall的最后一条指令</span><br>    <br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;   <span class="hljs-comment">//scause记录了发生中断的原因，8是系统调用的代号</span><br>    <span class="hljs-comment">// system call  </span><br>  <br>    <span class="hljs-keyword">if</span>(p-&gt;killed)  <br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);  <br>  <br>    <span class="hljs-comment">// sepc points to the ecall instruction,  </span><br>    <span class="hljs-comment">// but we want to return to the next instruction.    </span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;   <span class="hljs-comment">//此时epc指向ecall，我们恢复上下文后执行下一条指令，因此+4</span><br>  <br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,  </span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.    </span><br>    intr_on();   <span class="hljs-comment">//开中断，允许内核在执行系统调用时嵌套中断</span><br>  <br>    syscall(); <br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;  <br>    <span class="hljs-comment">// ok  </span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());  <br>    p-&gt;killed = <span class="hljs-number">1</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-keyword">if</span>(p-&gt;killed)  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);  <br>  <br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.  </span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)  <br>    yield();  <br>  <br>  usertrapret();  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>usertrap</code>负责中断处理，主要通过调用三个函数完成<code>syscall,yield,usertrapret</code></p><p><code>yield</code>是在发生时钟中断时的处理逻辑，进程修改自己的状态并自愿放弃CPU使用权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Give up the CPU for one scheduling round.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  acquire(&amp;p-&gt;lock);  <br>  p-&gt;state = RUNNABLE;  <br>  sched();  <br>  release(&amp;p-&gt;lock);  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>syscall()</code>是在发生系统调用时的处理逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> num;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  num = p-&gt;trapframe-&gt;a7;  <br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;  <br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <span class="hljs-comment">//执行系统调用</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,  <br>            p-&gt;pid, p-&gt;name, num);  <br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>前文讲到在使用函数<code>read</code>时，并没有真正的实现代码，而是一步一步走到了这里，现在终于可以开始执行具体的<code>read</code>逻辑了。在<code>syscall</code>函数中，a7寄存器中保存了<code>read</code>的编号，系统调用表提供了一个从编号到对应函数指针的实现，通过函数指针就能找到对应需要执行的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//syscalls是一个函数指针数组</span><br><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;  <br>[SYS_fork]    sys_fork,   <span class="hljs-comment">//sys_fork是一个宏定义，其实是数字1</span><br>[SYS_exit]    sys_exit,   <span class="hljs-comment">//同理</span><br>[SYS_wait]    sys_wait,  <br>[SYS_pipe]    sys_pipe,  <br>[SYS_read]    sys_read,  <br>[SYS_kill]    sys_kill,  <br>[SYS_exec]    sys_exec,  <br>[SYS_fstat]   sys_fstat,  <br>[SYS_chdir]   sys_chdir,  <br>[SYS_dup]     sys_dup,  <br>[SYS_getpid]  sys_getpid,  <br>[SYS_sbrk]    sys_sbrk,  <br>[SYS_sleep]   sys_sleep,  <br>[SYS_uptime]  sys_uptime,  <br>[SYS_open]    sys_open,  <br>[SYS_write]   sys_write,  <br>[SYS_mknod]   sys_mknod,  <br>[SYS_unlink]  sys_unlink,  <br>[SYS_link]    sys_link,  <br>[SYS_mkdir]   sys_mkdir,  <br>[SYS_close]   sys_close,  <br>&#125;;<br></code></pre></td></tr></table></figure><p><code>sys_read</code>代码如下，此时才执行真正的<code>read</code>逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_read</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span>  <br>  <span class="hljs-type">int</span> n;  <br>  uint64 p;  <br>  <br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;n) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;p) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  <span class="hljs-keyword">return</span> fileread(f, p, n);  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code>完成了系统调用过程并将返回值保存在a0寄存器，系统调用逻辑执行完毕，因此需要开始中断返回。</p><h4 id="中断返回"><a href="#中断返回" class="headerlink" title="中断返回"></a>中断返回</h4><p><code>usertrapret</code>函数被<code>usertrap</code>调用，用来从内核态返回用户态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  </span><br><span class="hljs-comment">// return to user space  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();   <br>  <br>  <span class="hljs-comment">// we&#x27;re about to switch the destination of traps from  </span><br>  <span class="hljs-comment">// kerneltrap() to usertrap(), so turn off interrupts until  </span><br>  <span class="hljs-comment">// we&#x27;re back in user space, where usertrap() is correct.  </span><br>  intr_off();  <span class="hljs-comment">//关中断，不能在执行中断恢复过程时嵌套中断</span><br>  <br>  <span class="hljs-comment">// send syscalls, interrupts, and exceptions to trampoline.S  </span><br>  <span class="hljs-comment">// 因为在执行ecall指令后，CPU几哦执行STVEC寄存器指向的指令（PC重置为 STVEC寄存器的值）</span><br>  <span class="hljs-comment">// 所以设置STVEC寄存器的值为我们想要中断发生时执行的代码的地址（前文提到的uservec函数）</span><br>  w_stvec(TRAMPOLINE + (uservec - trampoline));  <br>  <br>  <span class="hljs-comment">// set up trapframe values that uservec will need when  </span><br>  <span class="hljs-comment">// the process next re-enters the kernel.  </span><br>  <span class="hljs-comment">// 和发生中断时保存上下文类似，内核使用完毕，即将进入用户态，要将目前的值保存起来，</span><br>  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="hljs-comment">// kernel page table  </span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack  </span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;  <br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid()  </span><br>  <br>  <span class="hljs-comment">// set up the registers that trampoline.S&#x27;s sret will use  // to get to user space.     // set S Previous Privilege mode to User.  </span><br>  <span class="hljs-comment">// 设置CPU特权等级，从supervisor mode 到user mode（也就是将操作系统从内核态修改为用户态）</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_sstatus();  <br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// clear SPP to 0 for user mode  </span><br>  x |= SSTATUS_SPIE; <span class="hljs-comment">// enable interrupts in user mode  </span><br>  w_sstatus(x);  <br>  <br>  <span class="hljs-comment">// set S Exception Program Counter to the saved user pc.  </span><br>  w_sepc(p-&gt;trapframe-&gt;epc);   <span class="hljs-comment">//修改sepc寄存器的值，在sret指令后，sepc的值会写入pc，此时sepc指向ecall的下一条指令</span><br>  <br>  <span class="hljs-comment">// tell trampoline.S the user page table to switch to.  </span><br>  uint64 satp = MAKE_SATP(p-&gt;pagetable);  <br>  <br>  <span class="hljs-comment">// jump to trampoline.S at the top of memory, which   </span><br>  <span class="hljs-comment">// switches to the user page table, restores user registers,  </span><br>  <span class="hljs-comment">// and switches to user mode with sret.  </span><br>  uint64 fn = TRAMPOLINE + (userret - trampoline);  <br>  <br>  <span class="hljs-comment">//调用userret函数（trampoline.S），userret(TRAPFRAME, pagetable)</span><br>  ((<span class="hljs-type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp); <br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>userret</code>函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c">.globl userret  <br>userret:  <br>        <span class="hljs-meta"># userret(TRAPFRAME, pagetable)  </span><br>        <span class="hljs-meta"># switch from kernel to user.  </span><br>        <span class="hljs-meta"># usertrapret() calls here.  </span><br>        # a0: TRAPFRAME, in user page table.   函数传参时使用a0，a1寄存器<br>        # a1: user page table, <span class="hljs-keyword">for</span> satp.  <br>  <br>        <span class="hljs-meta"># switch to the user page table.  </span><br>        csrw satp, a1  <br>        sfence.vma zero, zero  <br>  <br>        <span class="hljs-meta"># put the saved user a0 in sscratch, so we  </span><br>        <span class="hljs-meta"># can swap it with our a0 (TRAPFRAME) in the last step.  </span><br>        ld t0, <span class="hljs-number">112</span>(a0)  <br>        csrw sscratch, t0  <br>  <br>        <span class="hljs-meta"># restore all but a0 from TRAPFRAME  </span><br>        ld ra, <span class="hljs-number">40</span>(a0)  <br>        ld sp, <span class="hljs-number">48</span>(a0)  <br>        ld gp, <span class="hljs-number">56</span>(a0)  <br>        ld tp, <span class="hljs-number">64</span>(a0)  <br>        ld t0, <span class="hljs-number">72</span>(a0)  <br>        ld t1, <span class="hljs-number">80</span>(a0)  <br>        ld t2, <span class="hljs-number">88</span>(a0)  <br>        ld s0, <span class="hljs-number">96</span>(a0)  <br>        ld s1, <span class="hljs-number">104</span>(a0)  <br>        ld a1, <span class="hljs-number">120</span>(a0)  <br>        ld a2, <span class="hljs-number">128</span>(a0)  <br>        ld a3, <span class="hljs-number">136</span>(a0)  <br>        ld a4, <span class="hljs-number">144</span>(a0)  <br>        ld a5, <span class="hljs-number">152</span>(a0)  <br>        ld a6, <span class="hljs-number">160</span>(a0)  <br>        ld a7, <span class="hljs-number">168</span>(a0)  <br>        ld s2, <span class="hljs-number">176</span>(a0)  <br>        ld s3, <span class="hljs-number">184</span>(a0)  <br>        ld s4, <span class="hljs-number">192</span>(a0)  <br>        ld s5, <span class="hljs-number">200</span>(a0)  <br>        ld s6, <span class="hljs-number">208</span>(a0)  <br>        ld s7, <span class="hljs-number">216</span>(a0)  <br>        ld s8, <span class="hljs-number">224</span>(a0)  <br>        ld s9, <span class="hljs-number">232</span>(a0)  <br>        ld s10, <span class="hljs-number">240</span>(a0)  <br>        ld s11, <span class="hljs-number">248</span>(a0)  <br>        ld t3, <span class="hljs-number">256</span>(a0)  <br>        ld t4, <span class="hljs-number">264</span>(a0)  <br>        ld t5, <span class="hljs-number">272</span>(a0)  <br>        ld t6, <span class="hljs-number">280</span>(a0)  <br>  <br>   <span class="hljs-meta"># restore user a0, and save TRAPFRAME in sscratch  </span><br>        csrrw a0, sscratch, a0  <br>          <br>        <span class="hljs-meta"># return to user mode and user pc.  </span><br>        <span class="hljs-meta"># usertrapret() set up sstatus and sepc.  </span><br>        sret<br></code></pre></td></tr></table></figure><p><code>userret</code>代码的主要功能和<code>uservec</code>正好相反，后者是将用户运行时的寄存器信息保存起来，切换到内核页表；前者是将这些保存起来的寄存器值恢复回去，切换到用户页表</p><p>随着<code>sret</code>指令的调用，整个中断过程完成，sepc寄存器中的值填回pc，用户程序恢复正常执行</p><h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>参照教程，在实验2前应该：</p><ul><li>仔细阅读<code>Chapter 2、 Chapter 4 的 Sections 4.3 and 4.4</code></li><li>仔细阅读<code>user/user.h</code>,<code>user/usys.pl</code>，学习xv6中工具函数和系统调用原型</li><li>仔细阅读<code>kernel/syscall.h</code>,<code>kernel/syscall.c</code>,系统调用实现</li><li>仔细阅读<code>kernel/proc.h</code>,<code>kernel/proc.c</code>，进程代码实现</li></ul><p>如果是从前文一步一步看到这里，那么这些代码相当于已经看过了，下面直接看练习要求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">实验要求：<br><br>实现一个系统调用追踪的功能：trace mask command命令，<br>- mask 表示系统调用号的掩码<br>- command 表示命令<br>- 能够实现如下效果<br><br><span class="hljs-comment">//因由于read的系统调用号是5，因此（1 &lt;&lt; 5,10000) 如果输入的数字从右往左第六位为1，则需要追踪read，即十进制数字32表示仅需要追踪read系统调用</span><br>$ trace <span class="hljs-number">32</span> grep hello README<br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">1023</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">966</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">70</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">0</span><br><br><span class="hljs-comment">//2147483647的二进制是1111111111111111111111111111111，因为所有位都为1，说明所有系统调用都需要追踪</span><br>$ trace <span class="hljs-number">2147483647</span> grep hello README<br><span class="hljs-number">4</span>: syscall trace -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">4</span>: syscall exec -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">4</span>: syscall open -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">1023</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">966</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">70</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">4</span>: syscall close -&gt; <span class="hljs-number">0</span><br><br><span class="hljs-comment">//没有trace指令，不追踪，不能影响其他程序的正常运行</span><br>$ grep hello README<br>$<br><br><span class="hljs-comment">//fork的系统调用号是1，因此(1 &lt;&lt; 2，2)如果输入的数字从右往左第二位为1，则仅需要追踪fork，</span><br>$ trace <span class="hljs-number">2</span> usertests forkforkfork<br>usertests starting<br>test forkforkfork: <span class="hljs-number">407</span>: syscall fork -&gt; <span class="hljs-number">408</span><br><span class="hljs-number">408</span>: syscall fork -&gt; <span class="hljs-number">409</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">410</span><br><span class="hljs-number">410</span>: syscall fork -&gt; <span class="hljs-number">411</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">412</span><br><span class="hljs-number">410</span>: syscall fork -&gt; <span class="hljs-number">413</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">414</span><br><span class="hljs-number">411</span>: syscall fork -&gt; <span class="hljs-number">415</span><br><br></code></pre></td></tr></table></figure><p>理解了需求，再结合前文提到的系统调用过程，可以想想我们为了完成任务可以做些什么？<br>首先，一个完整的系统调用从一个用户态的<code>shell</code>函数开始，trace.c文件已经提供给了我们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br>  <br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>  <br>&#123;  <br>    <span class="hljs-type">int</span> i;  <br>    <span class="hljs-comment">//存储待跟踪程序的名称和参数  </span><br>    <span class="hljs-type">char</span> *nargv[MAXARG];  <br>  <br>    <span class="hljs-comment">//保证trace的参数不少于三个，并且跟踪的系统调用号在0-99之间  </span><br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">3</span> || (argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-string">&#x27;9&#x27;</span>))&#123;  <br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: %s mask command\n&quot;</span>, argv[<span class="hljs-number">0</span>]);  <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br>    <span class="hljs-comment">//调用trace系统调用，传入待跟踪系统调用号  </span><br>    <span class="hljs-keyword">if</span> (trace(atoi(argv[<span class="hljs-number">1</span>])) &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="hljs-number">0</span>]);  <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br>    <span class="hljs-comment">//保存待跟踪程序的名称和参数  </span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;  <br>        nargv[i<span class="hljs-number">-2</span>] = argv[i];  <br>    &#125;  <br>    <span class="hljs-comment">//运行待跟踪的程序  </span><br>    exec(nargv[<span class="hljs-number">0</span>], nargv);  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><p>由于trace的语法规定了，第二个参数必须是待追踪系统调用的数字，因此具体的执行逻辑就是通过<code>argv[2]</code>取出这个数字，然后传递到内核态，然后执行一系列的操作。</p><p>当我们需要完成一个系统调用，有了用户态的代码，自然需要增加对该系统调用的用户态声明，即在<code>user/user.h</code>文件中新增trace的系统调用声明<code>int trace(int);</code></p><p>有了声明就需要有实现，但这个实现不是真正的函数实现，而是凭借<code>ecall</code>指令进入内核态，这个部分是<code>usys.pl</code>负责完成，因此需要在代码中增添<code>entry(trace)</code></p><p><code>entry(trace)</code>，将trace的系统调用名称放入a7寄存器，下一步就是通过系统调用名称在系统调用表中找到对应的系统调用编号。因此需要在<code>kernel/syscall.h</code>中新增<code>#define SYS_trace  22</code>，并且在<code>kernel/syscall.c</code>中增添<code>sys_trace</code>的函数声明<code>extern uint64 sys_trace(void);</code>，在系统调用表中新增<code>SYS_trace</code>（即22号调用）到函数实现的映射关系，<code>[SYS_trace]   sys_trace,</code></p><p>最后，这是个和进程相关的系统调用，因此在<code>kernel/sysproc.c</code>中新增<code>sys_trace</code>函数的实现。</p><p>完成了前面的步骤，看着下面空荡荡的函数代码，我们应该怎么去完成一个trace任务呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们可能会追踪任何一个系统调用，但我们不可能修改所有系统调用的代码，因此可以想到从他们共有的内容下手，<strong>由于所有的系统调用都是通过<code>syscall.c中的syscall</code>函数来执行的，并且所有系统调用的运行参数和结果均保存在<code>proc</code>结构体中的<code>trapframe</code>结构体中，例如a7保存当前进程系统调用的编号，a0表示系统调用执行的结果。因此只需要<code>proc结构体 + syscall函数</code>，我们就可以达成任务目标。</strong></p><p>可以考虑先在proc结构体中添加一个标记，作为判断执行trace的判断标准，然后在syscall添加一段逻辑：如果当前proc对应的标记为真，则打印输出当前系统调用的结果。</p><p>总结以上过程：</p><ol><li>在proc结构体中添加标记：<code>int trace_mask;  </code></li><li>修改<code>syscall</code>函数：<code>num</code>是系统调用号，如果<code>（1 &lt;&lt; num）与mask（用户输入的值）的&amp;运算结果为1</code>，则说明需要执行<code>trace</code>操作，例如如果<code>mask</code>的第二位和第六位都为1，则<code>num</code>为<code>read</code>和<code>fork</code>时就需要执行<code>trace</code>操作。<br> 注意：由于在内核态只能拿到系统调用编号，但是用户希望在看到的是系统调用的名称，因此还需要一个表格，建立从系统调用编号到系统调用名称的映射，也就是下面代码中的<code>syscalls_name</code> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//lab2 trace 添加识别名  </span><br>   <span class="hljs-type">char</span>* syscalls_name[<span class="hljs-number">23</span>] = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;fork&quot;</span>, <span class="hljs-string">&quot;exit&quot;</span>, <span class="hljs-string">&quot;wait&quot;</span>, <span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>, <span class="hljs-string">&quot;kill&quot;</span>,                <span class="hljs-string">&quot;exec&quot;</span>,  <span class="hljs-string">&quot;fstat&quot;</span>, <span class="hljs-string">&quot;chdir&quot;</span>, <span class="hljs-string">&quot;dup&quot;</span>, <span class="hljs-string">&quot;getpid&quot;</span>, <span class="hljs-string">&quot;sbrk&quot;</span>, <span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-string">&quot;uptime&quot;</span>,                   <span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;write&quot;</span>, <span class="hljs-string">&quot;mknod&quot;</span>, <span class="hljs-string">&quot;unlink&quot;</span>, <span class="hljs-string">&quot;link&quot;</span>, <span class="hljs-string">&quot;mkdir&quot;</span>, <span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-string">&quot;trace&quot;</span>&#125;;<br>   <br>   <span class="hljs-type">void</span>  <br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> num;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  num = p-&gt;trapframe-&gt;a7;  <br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;  <br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <br>    <span class="hljs-comment">//---------------------添加的部分--------------------------------------</span><br>    <span class="hljs-keyword">if</span>(p-&gt;trace_mask &amp; (<span class="hljs-number">1</span> &lt;&lt; num))&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid,syscalls_name[num],p-&gt;trapframe-&gt;a0);  <br>    &#125;  <br>    <span class="hljs-comment">//--------------------------------------------------------------------</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,  <br>            p-&gt;pid, p-&gt;name, num);  <br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>由此可见，trace操作的核心代码并不在<code>sys_trace</code>函数中，而是在<code>syscall</code>函数，那么<code>sys_trace</code>函数是干什么用的？</p><p>答案：取参数。用户态的trace.c代码中写明，使用trace时会传递一个参数，表示需要监视的系统调用号，而函数传参则是通过寄存器，第一个参数保存在a0寄存器，取参数需要使用<code>syscall.c中的argraw，argaddr，argint</code>三个函数，具体的实现可以看代码，<code>argraw(n)</code>是获取了发生中断时，$a_n$寄存器对应的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> uint64  <br><span class="hljs-title function_">argraw</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <span class="hljs-keyword">switch</span> (n) &#123;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a0;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a1;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a2;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a3;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a4;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a5;  <br>  &#125;  <br>  panic(<span class="hljs-string">&quot;argraw&quot;</span>);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;<br> <br><span class="hljs-comment">// Fetch the nth 32-bit system call argument.  </span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">argint</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> *ip)</span>  <br>&#123;  <br>  *ip = argraw(n);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>sys_trace</code>代码如下，将取回的参数放入proc结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> mask;  <br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;mask) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  myproc()-&gt;trace_mask = mask;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>另外，实验要求fork新诞生的子进程执行系统调用时也要打印出来，因此需要修改fork代码，子进程的<code>trace_mask</code>值应与父进程保持一致：<code>np-&gt;trace_mask = p-&gt;trace_mask;</code></p><p>这样整个实验就完成了</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab1 Xv6 and Unix utilities</title>
    <link href="/2023/08/14/Lab1-Xv6-and-Unix-utilities/"/>
    <url>/2023/08/14/Lab1-Xv6-and-Unix-utilities/</url>
    
    <content type="html"><![CDATA[<p>[课程地址](<a href="https://pdos.csail.mit.edu/6.828/2021/labs/util.html">Lab: Xv6 and Unix utilities (mit.edu)</a>)_</p><h2 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1. 配置环境"></a>1. 配置环境</h2><ul><li><p>安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu<br></code></pre></td></tr></table></figure><p>出现网速不够的情况自行换源</p></li><li><p>git获取课程配套代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021<br></code></pre></td></tr></table></figure><p>在根目录下运行<code>make qemu</code>，看见如下输出即启动成功</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m <span class="hljs-number">128</span>M -smp <span class="hljs-number">3</span> -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.<span class="hljs-number">0</span><br><br><span class="hljs-attribute">xv6</span> kernel is booting<br><br><span class="hljs-attribute">hart</span> <span class="hljs-number">1</span> starting<br><span class="hljs-attribute">hart</span> <span class="hljs-number">2</span> starting<br><span class="hljs-attribute">init</span>: starting sh<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-sleep指令"><a href="#2-sleep指令" class="headerlink" title="2. sleep指令"></a>2. sleep指令</h2><p><strong>实验要求</strong>：为 xv6 系统实现 UNIX 的 sleep 程序。你的 sleep 程序应该使当前进程暂停相应的时钟周期数，时钟周期数由用户指定。例如执行 sleep 100 ，则当前进程暂停，等待 100 个时钟周期后才继续执行。</p><p>安装好xv6系统内核后，观察项目代码（我这里已经编译过，所以实际可能有所不同），可以发现用户态的代码聚集在user文件夹下，内核态的代码聚集在kernel文件夹下</p><p>课程需要我们仿照user目录下的命令（例如ls），写一个sleep命令，在开始这个任务前，我们有一些前置工作需要完成</p><ol><li>阅读<a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6 book</a>中的Chapter 1</li><li>阅读user&#x2F;目录下的所有程序，理解如何编写一个命令行程序</li></ol><p><a href>这个链接</a>包含了我对整本书的阅读理解</p><p>通过观察user文件夹下的其他代码，可以发现如果想要实现自己的函数，需要将代码放在user文件夹下，然后将文件名称写入makefile的UPROGS</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">UPROGS=\  <br>   $U/_cat\  <br>   $U/_echo\  <br>   $U/_forktest\  <br>   $U/_grep\  <br>   $U/_init\  <br>   $U/_kill\  <br>   $U/_ln\  <br>   $U/_ls\  <br>   $U/_mkdir\  <br>   $U/_rm\  <br>   $U/_sh\  <br>   $U/_stressfs\  <br>   $U/_usertests\  <br>   $U/_grind\  <br>   $U/_wc\  <br>   $U/_zombie\<br>   $U/_sleep\  <span class="hljs-comment">//新的代码要按格式加在这里</span><br></code></pre></td></tr></table></figure><p>所有实验都只能使用XV6所提供的函数，记录在user.h文件下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// system calls  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((<span class="hljs-keyword">noreturn</span>))</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">void</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">exec</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>**)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">mknod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">short</span>, <span class="hljs-type">short</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> stat*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">getpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">sbrk</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;   <span class="hljs-comment">//本次实验需要使用的系统调用</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">uptime</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <br>  <br><span class="hljs-comment">// ulib.c  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-keyword">struct</span> stat*)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">void</span> *<span class="hljs-title function_">memmove</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">strchr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">char</span> c)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*, ...)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, ...)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">gets</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">int</span> max)</span>;  <br>uint <span class="hljs-title function_">strlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">void</span>* <span class="hljs-title function_">memset</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">int</span>, uint)</span>;  <br><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(uint)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">memcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *, uint)</span>;  <br><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *, uint)</span>;<br></code></pre></td></tr></table></figure><p>模仿其他文件例如rm.c，我们可以发现，需要使用int等数据类型，因此需要引入kernel&#x2F;types.h头文件，还需要包含系统调用声明的头文件user.h，stat.h中包含了与文件相关的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//rm.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>   <br><span class="hljs-comment">//程序入口，argc表示参数个数，argv分别表示每个具体参数,argv[0]是命令本身</span><br>&#123;  <br>  <span class="hljs-type">int</span> i;  <br>  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;   <span class="hljs-comment">//error处理</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: rm files...\n&quot;</span>);  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);   <br>  &#125; <br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;   <span class="hljs-comment">//循环获取参数然后执行操作</span><br>    <span class="hljs-keyword">if</span>(unlink(argv[i]) &lt; <span class="hljs-number">0</span>)&#123;  <br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;rm: %s failed to delete\n&quot;</span>, argv[i]);  <br>      <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>  &#125;  <br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//正常退出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察rm.c以及其他要求观察的代码，我们可以发现实现一个可以在shell中运行程序需要按照如下模板：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从kernel和user中获取需要的头文件，sleep不需要文件操作，所以不需要stat.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br><br><span class="hljs-comment">//程序入口，argc表示参数个数，argv分别表示每个具体参数,argv[0]是命令本身</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>   <br>&#123;  <br><span class="hljs-comment">//参数处理模块</span><br><span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;  <br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: xxx files...\n&quot;</span>);  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);   <br>&#125; <br><br><span class="hljs-comment">//获取参数，执行程序的模块</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;   <br><br>    &#125;  <br><br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//正常退出</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>按照要求完成sleep代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: sleep &lt;ticks&gt;\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> ticks = atoi(argv[<span class="hljs-number">1</span>]); <br>    sleep(ticks);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在目录下使用执行测试：.&#x2F;grade-lab-util sleep<br>结果如下：<br><img src="20230718234029.png" alt="实验结果"></p><h2 id="3-pingpong"><a href="#3-pingpong" class="headerlink" title="3. pingpong"></a>3. pingpong</h2><p><strong>实验要求</strong>：使用 UNIX 系统调用编写一个程序 pingpong ，在一对管道上实现两个进程之间的通信。父进程应该通过第一个管道给子进程发送一个信息 “ping”，子进程接收父进程的信息后打印 <pid>: received ping ，其中是其进程 ID 。然后子进程通过另一个管道发送一个信息 “pong” 给父进程，父进程接收子进程的信息然后打印 <pid>: received pong ，然后退出。</pid></pid></p><p><strong>实验提示</strong>：</p><ul><li>使用 pipe 创建管道。</li><li>使用 fork 创建一个子进程。</li><li>使用 read 从管道读取信息，使用 write 将信息写入管道。</li><li>使用 getpid 获取当前 进程 ID 。</li><li>将程序添加到 Makefile 中的 UPROGS 。</li><li>xv6 上的用户程序具有有限的库函数可供它们使用。你可以在 user&#x2F;user.h 中查看，除系统调用外其他函数代码位于 user&#x2F;ulib.c 、user&#x2F;printf.c 、和 user&#x2F;umalloc.c 中。</li></ul><p><strong>实验代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br>    pipe(p);<br>    pipe(p1);  <span class="hljs-comment">//开启两个管道，p用于父进程向子进程传输，p1则相反</span><br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;  <br>        close(p[<span class="hljs-number">1</span>]);       <span class="hljs-comment">//子进程关闭p的写入端，管道不能有多余的端口</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];  <br>        read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-number">10</span>);  <span class="hljs-comment">//利用p从父进程读取信息</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf);  <span class="hljs-comment">//打印读取到的信息</span><br>        close(p[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//关闭p的读取端，完成一次传输</span><br>        close(p1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//子进程关闭p1的读取端，准备向父进程传输信息</span><br>        write(p1[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">//写入信息</span><br>        close(p1[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//写入完成，关闭p1的写入端</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        close(p[<span class="hljs-number">0</span>]);     <span class="hljs-comment">//父进程关闭p的读取端，管道不能有多余的端口</span><br>        write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;pong&quot;</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment">//向子进程传输信息</span><br>        close(p[<span class="hljs-number">1</span>]);   <span class="hljs-comment">//写入完成，关闭p的写入端口</span><br>        close(p1[<span class="hljs-number">1</span>]);    <span class="hljs-comment">//关闭p1管道的写入端，准备从子进程读取信息</span><br>        <span class="hljs-type">char</span> buf1[<span class="hljs-number">10</span>];  <br>        read(p1[<span class="hljs-number">0</span>], buf1, <span class="hljs-number">10</span>); <span class="hljs-comment">//利用p1从子进程读取信息 </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf1); <br>        close(p1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//读取完成，关闭读取端</span><br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//正常结束，退出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>整个实验其实是考察对管道的理解程度，让我们熟练应用管道</p><h2 id="3-primes"><a href="#3-primes" class="headerlink" title="3. primes"></a>3. primes</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc make makefile概述</title>
    <link href="/2023/08/07/gcc-make-makefile%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/08/07/gcc-make-makefile%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>MIT6.S081的实验都是基于C语言完成的，每当完成一个新函数（例如Lab1的sleep函数），都需要将它加入到makefile文件中编辑，那么弄清楚makefile，gcc相关的一些编译知识就非常有必要了。</p><h2 id="GCC概述"><a href="#GCC概述" class="headerlink" title="GCC概述"></a>GCC概述</h2><p>gcc是一个编译器，将一个c语言代码编译为可执行文件的流程如下：<br><img src="20230714160858.png"></p><p><strong>1. 预处理（pre-processing）</strong><br><code>gcc -E hello.c -o hello.i</code>，将引入的头文件（#include）和定义的宏（#define）扩展到代码中，预处理之后的程序还是文本，可以用文本编辑器打开，上述命令中-E是让编译器在预处理之后就退出，不进行后续编译过程</p><p><strong>2. 编译（compilation）</strong><br><code>gcc -S hello.i -o hello.s</code>，将预处理过的文件编译成汇编程序，在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error）</p><p><strong>3. 汇编（assembly）</strong><br><code>gcc -c hello.s hello.o</code>，将汇编程序转换成目标文件，二进制格式机器码，每一个源文件都需要产生一个目标文件</p><p><strong>4. 链接（linker）</strong><br><code>gcc hello.o -o hello</code>，将一个或多个目标文件连接成最终的可执行文件</p><h2 id="GCC常用参数"><a href="#GCC常用参数" class="headerlink" title="GCC常用参数"></a>GCC常用参数</h2><ol><li>–version 查看版本</li><li>-v（verbose冗长的），输出编译的详细信息 </li><li>-std 指定标准</li><li>-o 指定输出文件的名称</li><li>-Wall 输出所有的警告信息</li><li>-c 只将源文件编译为 object 文件（*.o），而不进行链接，之后可以使用 <code>gcc -o myprog.exe file1.o file2.o</code> 将多个 object 文件连接成可执行文件</li><li>-shared 编译为共享库（*.dll，*.so）</li><li>-S 编译为汇编代码</li></ol><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p><strong>会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力</strong>。因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按<strong>类型、功能、模块</strong>分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作</p><p>因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile成为了一种在工程方面的编译方法。</p><p>但是不同的厂商make各不相同，本介绍只对GNU的make进行介绍。</p><h4 id="Makefile里有什么？"><a href="#Makefile里有什么？" class="headerlink" title="Makefile里有什么？"></a>Makefile里有什么？</h4><p>Makefile里主要包含了<strong>五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</strong></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book Chapter2</title>
    <link href="/2023/07/27/xv6-book-Chapter2/"/>
    <url>/2023/07/27/xv6-book-Chapter2/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter2-操作系统组织结构"><a href="#Chapter2-操作系统组织结构" class="headerlink" title="Chapter2 操作系统组织结构"></a>Chapter2 操作系统组织结构</h1><p>Chapter 1中主要提到了操作系统提供的常见接口（系统调用），并且利用这些接口实现了一些可以在shell窗口运行的程序，但是并没有进入到内核中去。</p><p>一个操作系统最核心的功能就是给用户提供使用硬件的环境，可以井井有条的运行多个程序。这个过程涉及到了几个问题：</p><ol><li>操作系统如何为进程分配资源？（资源分配）</li><li>操作系统如何确保所有进程都能执行？即使进程数量大于CPU数量（进程调度），</li><li>一个进程发生故障怎样才能不影响其他进程？（隔离）</li><li>进程之间如何拥有安全的交互渠道?（管道）<br>总的来说，上面的问题可以展现出人们对操作系统的三个核心需求：多路复用，隔离和交互</li></ol><p>Chapter 2的主要目标就是：</p><ol><li>理解如何组织操作系统（单片内核）以实现这三个核心需求</li><li>弄清楚xv6系统启动时运行的第一个进程（xv6系统的隔离单元）</li></ol><p>注意：Xv6运行在多核RISC-V微处理器上，它的许多底层功能（例如进程实现）是针对于RISC-V的。RISC-V是64位CPU，而xv6是用“LP64”C语言编写的，这意味着C编程语言中的long数据类型和指针大小是64位，而int是32位。本书假设读者已经在某些架构上做了一些机器级编程，并将介绍risc - v特定的思想</p><h2 id="操作系统抽象硬件资源的意义"><a href="#操作系统抽象硬件资源的意义" class="headerlink" title="操作系统抽象硬件资源的意义"></a>操作系统抽象硬件资源的意义</h2><p>为什么要有操作系统？能不能让应用程序直接和硬件发生交互？<br>答案是肯定的，在这种情况下，每个应用程序都有自己定制的库，可以根据硬件的特性，以最适合的方式组织应用程序的代码设计，例如嵌入式设备的操作系统</p><p>但是这样做的缺点是：如果有多个应用程序同时执行（通用PC需要同时执行很多程序），每个程序必须定期的放弃自己目前占用的CPU，使得其他程序可以运行。这个过程要求程序相互信任且不会发生错误，在普遍的计算机设备上显然是不现实的</p><p>因此在大多数情况下，将应用程序隔离，禁止直接访问敏感的硬件资源，并将资源抽象成一种服务，是更好的方案</p><p>举个例子，假如有甲乙丙丁四个人去办公室盖公章，操作系统就像一个公章管理者，提供一种叫做”盖公章”的服务，甲乙丙丁四人只需要请求这个服务，操作系统就会将公章交给他使用并进行监督，一旦使用时间到了就交给下一个人。如果没有操作系统，那么每个人都可以来争抢公章并使用，一旦甲抢到了公章并且长时间使用不归还，那么其他人就一直无法完成盖公章的任务</p><p>再从计算机的角度考虑，Unix应用程序仅通过文件系统的open、write、read和close四个系统调用与存储交互，具体的磁盘管理由操作系统来完成</p><p>再比如，Unix在进程之间切换CPU，即使A程序陷入死循环，不用担心其他程序无法运行。看起来A一直死循环占用CPU，但其实每过一定时间，A会被迫暂停运行，由其他程序占用CPU</p><p>总的来说，使用操作系统抽象硬件资源的好处和API编程时”封装”的好处类似（方便好用，隐藏内部复杂的实现细节，可移植性，可维护性等等）</p><h2 id="CPU对进程隔离的硬件级别支持"><a href="#CPU对进程隔离的硬件级别支持" class="headerlink" title="CPU对进程隔离的硬件级别支持"></a>CPU对进程隔离的硬件级别支持</h2><p>我们需要一个操作系统来为应用程序提供底层硬件的抽象服务，而系统调用接口就是操作系统具体提供服务的方式，这既为程序员提供了便利，又提供了强隔离的可能性。</p><p>为了达成这一点，操作系统必须使得应用程序不能访问其他进程的内存以及操作系统的数据结构和指令，即不同的进程之间需要相互隔离。<strong>CPU的特权等级机制为这一要求的实现提供了硬件级别的支持</strong>（通过设置一个模式位来实现）</p><p>例如，RISC-V有三种执行CPU指令的模式：User级中运行用户程序；Supervisor级中运行操作系统内核（和设备驱动）；Machine级中运行BootLoader和其它固件。 正常情况下，处理器一直在某个特权等级下运行，除非进入trap（诸如软硬件中断、异常等）才有可能发生特权等级的转换</p><p>对于现代操作系统（如Linux、Windows等）而已，用户程序都运行在用户态，当它们需要切换到内核态以获得更高权限时，需要向操作系统申请；而操作系统内核和设备驱动程序则默认就运行在内核态。每个用户线程也拥有两个栈，一个是用户态栈，一个是内核态栈，分别当处于用户态和内核态时使用。操作系统的用户态和内核态对应到处理器的硬件层面上，即为不同的特权等级。在RISC-V中，用户态一般对应User Mode，而内核态一般对应Supervisor Mode。</p><p>一般来说用户程序一直运行在用户态中，只有当发生中断才会转到内核态中<br>中断可以分为三类：</p><ol><li>系统调用（又称陷入），在程序中使用系统调用引起；</li><li>异常，当应用程序运行时出现异常时（比如最常见的缺页异常）也会切换到内核态进行处理；</li><li>外部中断，由CPU外部引起的中断（或者说与CPU执行指令无关的事件），如I&#x2F;O中断、时钟中断</li></ol><h2 id="单片内核与微内核"><a href="#单片内核与微内核" class="headerlink" title="单片内核与微内核"></a>单片内核与微内核</h2><p>我们已经知道了操作系统的一些重要指令只有在Supervisor模式下才能执行，那么究竟操作系统的哪些指令应该放在Supervisor模式运行？一种可能性是整个操作系统驻留在内核中，因此所有系统调用的实现都以Supervisor模式运行，这种组织方式被称为<strong>单片内核</strong>。整个操作系统以完全硬件特权运行。</p><p>这种组织使得操作系统的不同部分更容易协作，例如一个操作系统可能有一个缓冲缓存，它可以被文件系统和虚拟内存系统共享；缺点是操作系统不同部分之间的接口通常很复杂，而且内核中出现错误时会导致所有应用程序崩溃（例如windows蓝屏），计算机必须重新启动。</p><p>为了减少在内核中出错的风险，操作系统设计者可以尽量减少在管理模式下运行的操作系统代码的数量，并在用户模式下执行大部分操作系统。这种内核组织称为<strong>微内核</strong>，如下图所示。<br><img src="20230718182913.png" alt="微内核"></p><p>文件系统作为用户级进程运行。作为进程运行的操作系统服务称为服务器。为了允许应用程序与文件服务器交互，内核提供了一个进程间通信机制，将消息从一个用户模式进程发送到另一个用户模式进程。例如，如果像shell这样的应用程序想要读取或写入文件，它会向文件服务器发送消息并等待响应，内核中只保留最基本的功能（进程管理、内存管理和通信）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown">微内核和单片内核（宏内核）的区别：<br>微内核：将非基本的操作系统功能从内核移到用户态，内核中只保留最基本的功能（进程管理、内存管理和通信）<br>缺点：效率低，需要频繁地在用户态和内核态之间切换<br>优点：<br><span class="hljs-bullet">1.</span> 便于扩展操作系统，新服务可以在用户空间增加，几乎不需要修改内核。<br><span class="hljs-bullet">2.</span> 精简内核，代码量减少，更容易实现，更好debug。<br><span class="hljs-bullet">3.</span> 微内核相比于宏内核更加稳定，因为大部分功能外移，内核中可能出现的错误也相应地减少。<br><br>宏内核：将操作系统的所有功能最为一个紧密的整体都放在内核中。<br>缺点：不易扩展，内核出错概率更大，debug难<br>优点：执行效率高<br><br>微内核的操作系统有：Window,Minix,Mac等等。<br>宏内核的操作系统有：Unix，Linux等等。<br></code></pre></td></tr></table></figure><p>XV6的内核源文件（位于kernel文件目录下）如下图所示，按照模块化的概念，源代码被粗略的分成多个文件，每个文件都注释了各自的作用。defs.h文件下定义了模块间的接口。<br><img src="20230718183155.png" alt="xv6源文件结构"></p><p>虽然kernel实现的比较简单，代码量甚至比一般的微内核还少，但因为XV6在内核中实现了<strong>整个操作系统</strong>，内核接口就是操作系统接口，所以XV6属于宏内核</p><h2 id="操作系统的启动过程"><a href="#操作系统的启动过程" class="headerlink" title="操作系统的启动过程"></a>操作系统的启动过程</h2><p>虽然已经明白了理解了操作系统内核的概念，但是它看起来仍然是一个虚无缥缈的东西，只有先弄清楚操作系统宏观意义上是如何启动的，我们才能进一步深入操作系统内部去理解它提供的服务。</p><p>因此我们需要先弄清楚，一台计算机在刚刚通电，<strong>内存为空的情况下</strong>，CPU是如何一步一步将操作系统运行起来的？</p><p>当risc-v计算机通电后，</p><ol><li>首先把CPU所有寄存器初始化（初始值由CPU制造商设置），除了CS寄存器的值设为0xFFFF，其他寄存器的值都为0，这样，根据CS 和 IP的值就可以找到指令的物理地址0xFFFF:0x0000，也就是0xFFFF0。这个地址存放CPU的第一条指令。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">CS的全拼为Code segment，即代码段寄存器，对应于内存中的存放代码的内存区域，用来存放内存代码段区域的入口地址（段基址）<br>IP全称instruction Pointer，指针寄存器，用来记录偏移量<br>CPU在执行指令时，通过CS和IP来确定要执行的下一条指令的内存地址，计算方式一般为CS左移<span class="hljs-number">4</span>位然后加上IP寄存器<br><br>例如：<span class="hljs-number">0xFFFF0</span> = <span class="hljs-number">0xFFFF</span> &lt;&lt; <span class="hljs-number">4</span> + <span class="hljs-number">0x0000</span><br></code></pre></td></tr></table></figure></li><li>CPU开始从寄存器读取并运行指令，0xFFFF0存放的是一条无条件跳转指令JMP，跳转到BIOS的位置。（Bios是一段写在ROM中的程序，内容不会随着断电小时）</li><li>BIOS首先先进行POST（Power－On Self Test，<strong>加电后自检</strong>）。POST主要检测系统中一些关键设备例如内存和显卡等设备是否正常工作；如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</li><li>之后CPU开始寻找引导扇区，将引导扇区中的指令加载到物理内存 0x7C00处， 修改IP寄存器的值跳转到0x7C00执行指令，从而实现了将 CPU的使用权交给引导扇区中的 Boot 程序。</li><li>引导加载器装载XV6内核到内存0x8000000开始的存储空间中，然后在machine mode下，CPU从kernel&#x2F;entry.s处的_entry处开始执行指令</li></ol><h3 id="entry-S"><a href="#entry-S" class="headerlink" title="entry.S"></a>entry.S</h3><p>进入到entry.S</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">        <span class="hljs-meta"># qemu -kernel loads the kernel at 0x80000000  </span><br>        <span class="hljs-meta"># and causes each hart (i.e. CPU) to jump there.  </span><br>        <span class="hljs-meta"># kernel.ld causes the following code to  </span><br>        <span class="hljs-meta"># be placed at 0x80000000.  </span><br>.section .text<br>.global _entry  <br>_entry:  <br>        <span class="hljs-meta"># set up a stack for C.  </span><br>        # stack0 is declared in start.c,  <br>        <span class="hljs-meta"># with a 4096-byte stack per CPU.  </span><br>        <span class="hljs-meta"># sp = stack0 + (hartid * 4096)</span><br><br>#将stack0读取到SP寄存器<br>        la sp, stack0  <br>#把<span class="hljs-number">4096</span>这个立即数存放到a0寄存器中<br>        li a0, <span class="hljs-number">1024</span>*<span class="hljs-number">4</span>  <br>        #将CPU的id读取到寄存器a1<br>        csrr a1, mhartid<br>        <span class="hljs-meta">#addi mul add三条运算指令完成sp = stack0 + (hartid * 4096)计算     </span><br>        addi a1, a1, <span class="hljs-number">1</span><br>        mul a0, a0, a1  <br>        add sp, sp, a0  <br>        #指令跳转，jump to <span class="hljs-title function_">start</span><span class="hljs-params">()</span> in start.c  <br>        call start  <br>spin:  <br>        j spin<br></code></pre></td></tr></table></figure><p>entry.s其实干了这些事情：为每个CPU分配了栈空间。<br>stack0是一个声明的外部符号，把它作为CPU的上栈的起始地址，然后按照公式，<code>sp = stack0 + (hartid * 4096)</code>，算出每个CPU对应的栈起始地址（sp是堆栈指针寄存器，hartid是CPU id，csr是控制和状态寄存器，csrr是读取csr寄存器的内容，la是地址加载指令，li是立即数加载指令）。</p><p>注意：此时CPU仍然处于machine mode，还没有切换到Supervisor Mode</p><h3 id="start-c"><a href="#start-c" class="headerlink" title="start.c"></a>start.c</h3><p>代码比较长，因此会分成三个部分讲解</p><ul><li><strong>第一部分</strong><br>完成了栈初始化后，CPU接下来要干什么？看看start.c的第一部分代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;param.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memlayout.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span>  </span><br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">timerinit</span><span class="hljs-params">()</span>;  <br>  <br><span class="hljs-comment">// entry.S needs one stack per CPU.  </span><br>__attribute__ ((aligned (<span class="hljs-number">16</span>))) <span class="hljs-type">char</span> stack0[<span class="hljs-number">4096</span> * NCPU];  <br>  <br><span class="hljs-comment">// a scratch area per CPU for machine-mode timer interrupts.  </span><br>uint64 timer_scratch[NCPU][<span class="hljs-number">5</span>];  <br>  <br><span class="hljs-comment">// assembly code in kernelvec.S for machine-mode timer interrupt.  </span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timervec</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li></ul><p>__attribute__定义了entry.S中的栈，要求16bit对齐</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">什么是内存对齐？<br>计算机中内存空间是按照<span class="hljs-built_in">byte</span>划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是：在访问特定类型变量的时候通常在特定的内存地址访问，这就需要对这些数据在内存中存放的位置有限制，各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。<br>内存对齐是编译器的管辖范围。表现为：编译器为程序中的每个“数据单元”安排在适当的位置上。<br><br>如果放置数据不考虑对齐，<span class="hljs-number">32</span>位的<span class="hljs-meta">CPU</span>读取一个<span class="hljs-number">4</span>字节的interesting最多需要两次内存访问（左图），如果对齐则只需要一次（如右图）<br></code></pre></td></tr></table></figure><p><img src="20230727122632.png" alt="内存对齐"><br>timer_scratch是一组共享变量，用于每个CPU的machine mode定时器中断<br>timervec是timer中断处理函数，在接下来的timerinit中会用到</p><ul><li><strong>第二部分</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// entry.S jumps here in machine mode on stack0.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">start</span><span class="hljs-params">()</span>  <br>&#123;  <br>  <span class="hljs-comment">// set M Previous Privilege mode to Supervisor, for mret.  </span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_mstatus();  <br>  x &amp;= ~MSTATUS_MPP_MASK;  <br>  x |= MSTATUS_MPP_S;  <br>  w_mstatus(x);  <br>  <br>  <span class="hljs-comment">// set M Exception Program Counter to main, for mret.  </span><br>  <span class="hljs-comment">// requires gcc -mcmodel=medany  </span><br>  w_mepc((uint64)main);  <br>  <br>  <span class="hljs-comment">// disable paging for now.  </span><br>  w_satp(<span class="hljs-number">0</span>);  <br>  <br>  <span class="hljs-comment">// delegate all interrupts and exceptions to supervisor mode.  </span><br>  w_medeleg(<span class="hljs-number">0xffff</span>);  <br>  w_mideleg(<span class="hljs-number">0xffff</span>);  <br>  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);  <br>  <br>  <span class="hljs-comment">// configure Physical Memory Protection to give supervisor mode  </span><br>  <span class="hljs-comment">// access to all of physical memory.  w_pmpaddr0(0x3fffffffffffffull);  </span><br>  w_pmpcfg0(<span class="hljs-number">0xf</span>);  <br>  <br>  <span class="hljs-comment">// ask for clock interrupts.  </span><br>  timerinit();  <br>  <br>  <span class="hljs-comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().  </span><br>  <span class="hljs-type">int</span> id = r_mhartid();  <br>  w_tp(id);  <br>  <br>  <span class="hljs-comment">// switch to supervisor mode and jump to main().  </span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;mret&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>CPU在entry.S定义了栈，然后从entry.S代码发生跳转，目的地是start.c文件中的start函数，这一段代码出现了很多读写寄存器的函数，下面进行讲解。</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">注意：<span class="hljs-built_in">start</span>.c代码不像其他程序有main入口，因此<span class="hljs-built_in">start</span>不会像一个调用一样返回(没有returning)。由于它处于machine <span class="hljs-built_in">mode</span>下，因此其实是通过操作寄存器将这些事情设置的像一个正常执行的普通调用一样。<br></code></pre></td></tr></table></figure><p>无论何时，一个 RISC-V 硬件线程（hart）总是会运行在某一个特权级，而这个信息则是通过两个二进制位编码记录在了多个 <strong>CSR</strong> 寄存器（control and status registers）中，其中就包括状态寄存器（Status Register）</p><p>状态寄存器分为两种（mstatus&#x2F;sstatus）作用在于记录并控制当前 CPU 的运行状态，<code>mstatus</code> 对应 M 模式，<code>sstatus</code> 对应 S 模式，具体字段如下图所示，本代码通过操作mstatus寄存器的MPP和SPP字段来达到修改CPU特权等级的目的。<br><img src="20230727125258.png" alt="mstatus寄存器"></p><p>如下是代码中不容易理解的一些函数：</p><ol><li><strong>mstatus</strong>(Machine Status Registers)：保存了上一个特权模式，调用mret指令就立刻进入保存好的特权模式。因此设置好mstatus寄存器的值，再调用mret指令可以达到切换特权等级的目的。w_mstatus即write mstatus，写入mstatus寄存器，同理r_mstatus即read mstatus，表示读取mstatus寄存器的内容。</li><li><strong>mepc</strong>(Machine Exception Program Counter Registers)：设置mret的返回地址。本代码将它设置为内核main函数的地址，因此mret指令完成，CPU会查询mepc寄存器，开始执行main函数。</li><li><strong>satp</strong>(Supervisor Address Translation and Protection Registers)：页表寄存器，写入0就禁用了页表硬件。w_satp表示写入页表寄存器。</li><li><strong>asm</strong> <strong>volatile</strong>(“xxx”);  “<strong>asm</strong>” 表示后面的代码为内嵌汇编,  “<strong>volatile</strong>” 表示编译器不要优化代码,后面的指令保留原样。括号里面的xxx是汇编指令。<br>通过这些函数，我们大概能猜到整个代码的逻辑：通过设置mstatus的模式为Supervisor Mode，mret的返回地址设置为main，再调用mret成功设置特权等级，并且让CPU紧接着准备执行main代码，这样xv6就在Supervisor Mode中进入内核程序主函数了。</li></ol><p>具体过程如下：</p><ol><li>通过在寄存器<code>mstatus</code>中，设置之前的特权模式为Supervisor Mode(24-27行)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_mstatus();  <br>  x &amp;= ~MSTATUS_MPP_MASK;  <br>  x |= MSTATUS_MPP_S;  <br>  w_mstatus(x);  <br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSTATUS_MPP_MASK (3L &lt;&lt; 11) <span class="hljs-comment">// previous mode.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSTATUS_MPP_M (3L &lt;&lt; 11)   3L表示long 3，3是machine mode的编码</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSTATUS_MPP_S (1L &lt;&lt; 11)   1是super</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSTATUS_MPP_U (0L &lt;&lt; 11)</span><br>riscv.h文件中定义了这几个<br></code></pre></td></tr></table></figure></li><li>通过写入main地址到寄存器<code>mepc</code>，设置返回地址为main的地址(31行)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">w_mepc((uint64)main);  <br></code></pre></td></tr></table></figure></li><li>通过写入0到页表寄存器<code>satp</code>，在Supervisor Mode中将<strong>虚拟地址禁用</strong>(34行)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// disable paging for now.  </span><br>w_satp(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li>将所有的异常与中断托付给Supervisor Mode(37-39行)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// delegate all interrupts and exceptions to supervisor mode.  </span><br>w_medeleg(<span class="hljs-number">0xffff</span>);  <br>w_mideleg(<span class="hljs-number">0xffff</span>);  <br>w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);<br></code></pre></td></tr></table></figure>事实上，在RISC-V的标准定义中，所有陷阱默认都是由机器模式(M-mode)来处理的。然而，在支持操作系统的设备上往往都实现了监管者模式(S-Mode)，如果按照默认模式发生中断则应该首先陷入M-Mode下的中断处理程序，然后触发一个S-Mode下的中断再mret回S-Mode下处理，这个过程过于繁琐且需要程序员自己实现，所以：</li></ol><p>RISC-V标准为了应对这种情况提出了陷阱委派机制。也就是说在M-Mode下可以配置寄存器，从而使得S-Mode下的所有陷阱都被S-Mode下的陷阱处理函数自动接管。有两个寄存器，medeleg和mideleg，分别用来管理异常和中断的委派。</p><ol start="5"><li>使Supervisor Mode能够接触到所有物理内存(43-44行)\<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// configure Physical Memory Protection to give supervisor mode  </span><br><span class="hljs-comment">// access to all of physical memory.  </span><br>w_pmpaddr0(<span class="hljs-number">0x3fffffffffffff</span>ull);  <br>w_pmpcfg0(<span class="hljs-number">0xf</span>);<br></code></pre></td></tr></table></figure></li><li>请求时钟中断，clock初始化（具体实现在后文讲解）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ask for clock interrupts.  </span><br>timerinit();  <br></code></pre></td></tr></table></figure></li><li>获取CPU的ID并保存在tp寄存器中<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().  </span><br>  <span class="hljs-type">int</span> id = r_mhartid();  <br>  w_tp(id);  <br></code></pre></td></tr></table></figure></li></ol><ul><li><strong>第三部分</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arrange to receive timer interrupts.  </span><br><span class="hljs-comment">// they will arrive in machine mode at  </span><br><span class="hljs-comment">// at timervec in kernelvec.S,  </span><br><span class="hljs-comment">// which turns them into software interrupts for  </span><br><span class="hljs-comment">// devintr() in trap.c.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">timerinit</span><span class="hljs-params">()</span>  <br>&#123;  <br>  <span class="hljs-comment">// each CPU has a separate source of timer interrupts.  </span><br>  <span class="hljs-type">int</span> id = r_mhartid();  <br>  <br>  <span class="hljs-comment">// ask the CLINT for a timer interrupt.  </span><br>  <span class="hljs-type">int</span> interval = <span class="hljs-number">1000000</span>; <span class="hljs-comment">// cycles; about 1/10th second in qemu.  </span><br>  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;  <br>  <br>  <span class="hljs-comment">// prepare information in scratch[] for timervec.  </span><br>  <span class="hljs-comment">// scratch[0..2] : space for timervec to save registers.  // scratch[3] : address of CLINT MTIMECMP register.  // scratch[4] : desired interval (in cycles) between timer interrupts.  uint64 *scratch = &amp;timer_scratch[id][0];  </span><br>  scratch[<span class="hljs-number">3</span>] = CLINT_MTIMECMP(id);  <br>  scratch[<span class="hljs-number">4</span>] = interval;  <br>  w_mscratch((uint64)scratch);  <br>  <br>  <span class="hljs-comment">// set the machine-mode trap handler.  </span><br>  w_mtvec((uint64)timervec);  <br>  <br>  <span class="hljs-comment">// enable machine-mode interrupts.  </span><br>  w_mstatus(r_mstatus() | MSTATUS_MIE);  <br>  <br>  <span class="hljs-comment">// enable machine-mode timer interrupts.  </span><br>  w_mie(r_mie() | MIE_MTIE);  <br>&#125;<br></code></pre></td></tr></table></figure><p>第三部分是时钟中断的初始化，可以先放着不管，后续有实验内容帮助理解中断的过程。</p><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;param.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memlayout.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span>  </span><br>  <br><span class="hljs-keyword">volatile</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> started = <span class="hljs-number">0</span>;  <br>  <br><span class="hljs-comment">// start() jumps here in supervisor mode on all CPUs.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">main</span><span class="hljs-params">()</span>  <br>&#123;  <br>  <span class="hljs-keyword">if</span>(cpuid() == <span class="hljs-number">0</span>)&#123;  <br>    consoleinit();  <br>    printfinit();  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xv6 kernel is booting\n&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    kinit();         <span class="hljs-comment">// physical page allocator  </span><br>    kvminit();       <span class="hljs-comment">// create kernel page table  </span><br>    kvminithart();   <span class="hljs-comment">// turn on paging  </span><br>    procinit();      <span class="hljs-comment">// process table  </span><br>    trapinit();      <span class="hljs-comment">// trap vectors  </span><br>    trapinithart();  <span class="hljs-comment">// install kernel trap vector  </span><br>    plicinit();      <span class="hljs-comment">// set up interrupt controller  </span><br>    plicinithart();  <span class="hljs-comment">// ask PLIC for device interrupts  </span><br>    binit();         <span class="hljs-comment">// buffer cache  </span><br>    iinit();         <span class="hljs-comment">// inode table  </span><br>    fileinit();      <span class="hljs-comment">// file table  </span><br>    virtio_disk_init(); <span class="hljs-comment">// emulated hard disk  </span><br>    userinit();      <span class="hljs-comment">// first user process  </span><br>    __sync_synchronize();  <br>    started = <span class="hljs-number">1</span>;  <br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-keyword">while</span>(started == <span class="hljs-number">0</span>)  <br>      ;  <br>    __sync_synchronize();  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hart %d starting\n&quot;</span>, cpuid());  <br>    kvminithart();    <span class="hljs-comment">// turn on paging  </span><br>    trapinithart();   <span class="hljs-comment">// install kernel trap vector  </span><br>    plicinithart();   <span class="hljs-comment">// ask PLIC for device interrupts  </span><br>  &#125;  <br>  <br>  scheduler();          <br>&#125;<br></code></pre></td></tr></table></figure><p>在执行完 start 函数后，开始执行 main 函数。首先，判断当前的 CPU 的 ID 是否为主 CPU（cpuid() &#x3D;&#x3D; 0） 。</p><p>如果是主 CPU ，则执行一系列的初始化操作，包括：</p><ul><li><code>consoleinit(); </code>控制台初始化；</li><li><code>printfinit(); </code>打印模块初始化；</li><li><code>kinit(); </code>和 <code>kvminit(); </code>创建内核页表；</li><li><code>kvminithart(); </code>打开分页机制；</li><li><code>procinit(); </code>创建进程表；</li><li><code>trapinit(); </code>和 <code>trapinithart();</code> 和<code> plicinit();</code> 设置系统中断向量和系统中断初始化；</li><li><code>plicinithart(); </code>设备中断初始化；</li><li><code>binit(); </code>和<code>iinit();</code>磁盘缓冲和磁盘节点的初始化；</li><li><code>fileinit(); </code>文件系统的初始化；</li><li><code>virtio_disk_init(); </code>磁盘初始化；</li><li><code>userinit(); </code>创建第一个用户进程，第一个进程执行一个小程序 user&#x2F;initcode.S ，该程序通过调用 exec 系统调用重新进入内核；</li><li><code>sync_synchronize();</code> 是 gcc 提供的原子操作，保证内存访问的操作都是原子操作；</li><li><code>started = 1;</code> 是设置初始化完成的标志。</li></ul><p>如果不是主 CPU ，首先循环等待主 CPU 初始化完成，当主 CPU 初始化完成，则初始化完成标志 started 为 1 ，跳出循环。然后同样是：</p><ul><li><code>sync_synchronize();</code> gcc 提供的原子操作，保证内存访问的操作都是原子操作。</li><li><code>kvminithart();</code> 打开分页功能</li><li><code>trapinithart(); </code>和 <code>plicinithart(); </code>设置系统和设备的中断初始化。</li></ul><p>以上函数的声明都包含在kernel&#x2F;defs.h文件中。</p><h2 id="第一个用户进程"><a href="#第一个用户进程" class="headerlink" title="第一个用户进程"></a>第一个用户进程</h2><p>从main.c代码中我们可以发现在启动第一个进程之前，还有很多准备工作。我们暂时不去看他们，先学习第一个进程对应的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Set up first user process.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">userinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>    <span class="hljs-comment">//新建进程的结构体</span><br>  <br>  p = allocproc();   <span class="hljs-comment">//第一个进程分配空间等初始化步骤基本都在该函数中进行，具体看下文</span><br>  initproc = p;  <br>    <br>  <span class="hljs-comment">// allocate one user page and copy init&#x27;s instructions  </span><br>  <span class="hljs-comment">// and data into it.  </span><br>  uvminit(p-&gt;pagetable, initcode, <span class="hljs-keyword">sizeof</span>(initcode));   <br>  p-&gt;sz = PGSIZE;   <span class="hljs-comment">//sz变量表示进程的最大内存空间</span><br>  <br>  <span class="hljs-comment">// prepare for the very first &quot;return&quot; from kernel to user.  </span><br>  <span class="hljs-comment">// user program counter</span><br>  <span class="hljs-comment">//指令指针指向初始化代码的入口点，即地址0。</span><br>  p-&gt;trapframe-&gt;epc = <span class="hljs-number">0</span>;  <br>  <span class="hljs-comment">// user stack pointer </span><br>  <span class="hljs-comment">//栈指针被设置为虚拟空间最大值（初始化）</span><br>  p-&gt;trapframe-&gt;sp = PGSIZE;  <br>  <br>  safestrcpy(p-&gt;name, <span class="hljs-string">&quot;initcode&quot;</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;name));   <span class="hljs-comment">//设置进程的名称，方便调试</span><br>  p-&gt;cwd = namei(<span class="hljs-string">&quot;/&quot;</span>);   <span class="hljs-comment">//指定进程的工作目录</span><br>  <br>  p-&gt;state = RUNNABLE;   <span class="hljs-comment">//进程已经初始化完毕，修改状态，表示它可以被调度了</span><br>  <br>  release(&amp;p-&gt;lock);   <span class="hljs-comment">//完成对进程的操作，释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>这段代码内部完成了很多事情，把他拆开来看：</p><p><strong>1. allocproc函数</strong>（构建新进程）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//进程表，NPROC表示支持的最大进程数量，xv6设置为64</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> <span class="hljs-title">proc</span>[<span class="hljs-title">NPROC</span>];</span><br><br><span class="hljs-comment">// Look in the process table for an UNUSED proc.  </span><br><span class="hljs-comment">// If found, initialize state required to run in the kernel,  </span><br><span class="hljs-comment">// and return with p-&gt;lock held.  </span><br><span class="hljs-comment">// If there are no free procs, or a memory allocation fails, return 0.  </span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc* <br><span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>  <br><br><span class="hljs-comment">//proc是进程表，&amp;proc[NPROC]是获取数组首地址，循环通过递增指针的方式遍历进程表</span><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    acquire(&amp;p-&gt;lock);  <span class="hljs-comment">//每个表格中的进程要加锁才能进行操作，同时该函数会关闭中断避免死锁</span><br>    <span class="hljs-keyword">if</span>(p-&gt;state == UNUSED) &#123;   <span class="hljs-comment">//寻找第一个state为UNUSED（未使用的）进程</span><br>      <span class="hljs-keyword">goto</span> found;   <span class="hljs-comment">//找到空位，可以执行初始化进程的操作</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;   <br>      release(&amp;p-&gt;lock);   <span class="hljs-comment">//未找到空位，释放当前指针所指向进程的锁，然后继续循环寻找</span><br>    &#125;  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  <br>found:   <br>  p-&gt;pid = allocpid();   <span class="hljs-comment">//为进程分配pid（进程的编号，唯一标识）</span><br>  p-&gt;state = USED;   <span class="hljs-comment">//将state设置为USED（已使用），state用于描述进程的状态</span><br>  <br>  <span class="hljs-comment">// Allocate a trapframe page.  </span><br>  <span class="hljs-comment">//为进程分配trapframe（用于保存中断时的进程上下文），这个结构在中断章节会进一步讲解</span><br>  <span class="hljs-comment">//kalloc函数可以分配物理内存，失败则返回0，这里是</span><br>  <span class="hljs-keyword">if</span>((p-&gt;trapframe = (<span class="hljs-keyword">struct</span> trapframe *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p);   <span class="hljs-comment">//如果分配失败，则将设置的pid等信息全部还原</span><br>    release(&amp;p-&gt;lock);   <span class="hljs-comment">//释放锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-comment">// An empty user page table.</span><br>  p-&gt;pagetable = proc_pagetable(p);  <span class="hljs-comment">//为进程分配页表</span><br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable == <span class="hljs-number">0</span>)&#123;  <br>    freeproc(p);  <span class="hljs-comment">//如果分配失败，则将设置的pid等信息全部还原</span><br>    release(&amp;p-&gt;lock);   <span class="hljs-comment">//释放锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-comment">// Set up new context to start executing at forkret,  </span><br>  <span class="hljs-comment">// which returns to user space.  memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));  </span><br>  <span class="hljs-comment">//context是保存内核中进程上下文切换时寄存器值的结构体</span><br>  <span class="hljs-comment">//当调用ret指令时，指令寄存器pc会被重置为ra寄存器所保存的地址</span><br>  <span class="hljs-comment">//进程调度切换上下文后会有ret指令，所以此处ra其实指定了CPU加载该进程后运行的程序是什么</span><br>  p-&gt;context.ra = (uint64)forkret;   <br>  p-&gt;context.sp = p-&gt;kstack + PGSIZE;   <br>  <span class="hljs-comment">//sp 栈指针,kstack是内核栈的地址，PGSIZE是常量，表示每个页的大小（4096 字节）</span><br><br>  <span class="hljs-keyword">return</span> p;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个使用static修饰的函数，返回一个进程结构体指针的。static 常在两种情况下使用：</p><ol><li>变量：static变量不会在函数重新进入时再次赋初值；不会在函数结束时而释放（存储在全局区）</li><li>函数：static函数只能在本文件中调用，不能在其他文件中调用</li></ol><p>函数的逻辑如下图：</p><p><img src="20230816182438.png" alt="运行流程图"><br>在新建进程时有三个结构体非常重要，后续会进一步讲解，这里只需要知道它们是干什么的即可：</p><ol><li>保存进程运行情况的trapframe（栈帧）</li><li>上下文切换时记录状态的context</li><li>pagetable（页表）</li></ol><p><strong>2. 分配物理内存（虚拟地址映射）</strong></p><p>在申请完进程结构体后，进程中保存的栈指针其实是个虚拟地址，让进程有自己在使用整个内存空间的错觉，其实要真正使用，还需要为进程分配真实的物理地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Load the user initcode into address 0 of pagetable,  </span><br><span class="hljs-comment">// for the very first process.  </span><br><span class="hljs-comment">// sz must be less than a page.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">uvminit</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uchar *src, uint sz)</span>  <br>&#123;  <br>  <span class="hljs-type">char</span> *mem;  <br>  <br>  <span class="hljs-keyword">if</span>(sz &gt;= PGSIZE)  <br>    panic(<span class="hljs-string">&quot;inituvm: more than a page&quot;</span>);  <br>  mem = kalloc();   <span class="hljs-comment">//kalloc会分配一个4k大小的物理内存并返回指针</span><br>  <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);   <span class="hljs-comment">//将物理内存初始化为0</span><br>  <span class="hljs-comment">//mappages将进程结构体中的虚拟内存pagetable映射到物理内存mem</span><br>  mappages(pagetable, <span class="hljs-number">0</span>, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);  <br>  memmove(mem, src, sz);  <span class="hljs-comment">//src指向位置的，大小为sz的内容，复制到mem指向的空间中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码涉及到虚拟内存和页表相关的知识，后续会进一步讨论</p><hr><p>在介绍完第一个进程创建过程中非常重要的两个函数调用后，我们可以回头再看第一个进程初始化的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Set up first user process.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">userinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>    <span class="hljs-comment">//新建进程的结构体</span><br>  <br>  p = allocproc();   <span class="hljs-comment">//第一个进程分配空间等初始化步骤基本都在该函数中进行，具体看下文</span><br>  initproc = p;  <br>    <br>  <span class="hljs-comment">// allocate one user page and copy init&#x27;s instructions  </span><br>  <span class="hljs-comment">// and data into it.  </span><br>  uvminit(p-&gt;pagetable, initcode, <span class="hljs-keyword">sizeof</span>(initcode));   <br>  p-&gt;sz = PGSIZE;   <span class="hljs-comment">//sz变量表示进程的最大内存空间</span><br>  <br>  <span class="hljs-comment">// prepare for the very first &quot;return&quot; from kernel to user.  </span><br>  <span class="hljs-comment">// user program counter</span><br>  <span class="hljs-comment">//指令指针指向初始化代码的入口点，即地址0（虚拟地址）。</span><br>  p-&gt;trapframe-&gt;epc = <span class="hljs-number">0</span>;  <br>  <span class="hljs-comment">// user stack pointer </span><br>  <span class="hljs-comment">//栈指针被设置为虚拟空间最大值（初始化），进行压栈操作，sp会减小（xv6的栈是倒着的）</span><br>  p-&gt;trapframe-&gt;sp = PGSIZE;  <br>  <br>  safestrcpy(p-&gt;name, <span class="hljs-string">&quot;initcode&quot;</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;name));   <span class="hljs-comment">//设置进程的名称，方便调试</span><br>  p-&gt;cwd = namei(<span class="hljs-string">&quot;/&quot;</span>);   <span class="hljs-comment">//指定进程的工作目录</span><br>  <br>  p-&gt;state = RUNNABLE;   <span class="hljs-comment">//进程已经初始化完毕，修改状态，表示它可以被调度了</span><br>  <br>  release(&amp;p-&gt;lock);   <span class="hljs-comment">//完成对进程的操作，释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，完成了进程创建和虚拟地址映射两个操作后，剩下的就是对进程的细微调整</p><ol><li>初始化栈帧的epc指针和sp指针</li><li>为进程命名</li><li>指定工作目录</li><li>修改进程状态为就绪态，随时等待CPU”宠幸”</li><li>完成对进程结构体的更改，释放锁</li></ol><p>然而完成了对第一个进程结构体的创建，不代表第一个进程已经运行起来了。我们还需要理解进程这个结构体是怎么运行起来的（如何被CPU使用）</p><p><strong>2. scheduler（进程调度）</strong></p><p>在main.c函数中，我们可以发现完成userinit后会调用scheduler()函数，这个函数是一个死循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-CPU process scheduler.  </span><br><span class="hljs-comment">// Each CPU calls scheduler() after setting itself up.  </span><br><span class="hljs-comment">// Scheduler never returns.  It loops, doing:  </span><br><span class="hljs-comment">//  - choose a process to run.  </span><br><span class="hljs-comment">//  - swtch to start running that process.  </span><br><span class="hljs-comment">//  - eventually that process transfers control  </span><br><span class="hljs-comment">//    via swtch back to the scheduler.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">scheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();  <br>    <br>  c-&gt;proc = <span class="hljs-number">0</span>;  <br>  <span class="hljs-keyword">for</span>(;;)&#123;  <br>    <span class="hljs-comment">// Avoid deadlock by ensuring that devices can interrupt.  </span><br>    intr_on();  <br>  <br>    <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;  <br>      acquire(&amp;p-&gt;lock);  <br>      <span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE) &#123;  <br>        <span class="hljs-comment">// Switch to chosen process.  It is the process&#x27;s job  </span><br>        <span class="hljs-comment">// to release its lock and then reacquire it        // before jumping back to us.        p-&gt;state = RUNNING;  </span><br>        c-&gt;proc = p;  <br>        swtch(&amp;c-&gt;context, &amp;p-&gt;context); <br>  <br>        <span class="hljs-comment">// Process is done running for now.  </span><br>        <span class="hljs-comment">// It should have changed its p-&gt;state before coming back.        c-&gt;proc = 0;  </span><br>      &#125;  <br>      release(&amp;p-&gt;lock);  <br>    &#125;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>每个CPU都会执行这个代码，在初始化CPU结构体之后开始循环。具体的逻辑很容易理解：</p><ul><li>打开中断（在之前的操作中，中断是关闭的，在开始执行进程前要打开中断避免死锁）</li><li>遍历进程表，找到就绪态的进程</li><li>给进程上锁，运行进程</li><li>运行结束，释放锁</li><li>继续遍历</li></ul><p>可以发现核心代码就是循环体中的<code>swtch(&amp;c-&gt;context, &amp;p-&gt;context); </code><br>为什么把进程结构体的上下文和CPU结构体的上下文传入swtch就可以实现进程的切换了？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"># Context <span class="hljs-keyword">switch</span>  <br>#  <br><span class="hljs-meta">#   void swtch(struct context *old, struct context *new);  </span><br>#   <br># Save current registers in old. Load from new.      <br>  <br>  <br>.globl swtch  <br>swtch:  <br>        sd ra, <span class="hljs-number">0</span>(a0)   <span class="hljs-comment">//0(a0)的意思是a0寄存器的内容作为基址 + 0得到真正的地址</span><br>        sd sp, <span class="hljs-number">8</span>(a0)  <br>        sd s0, <span class="hljs-number">16</span>(a0)  <br>        sd s1, <span class="hljs-number">24</span>(a0)  <br>        sd s2, <span class="hljs-number">32</span>(a0)  <br>        sd s3, <span class="hljs-number">40</span>(a0)  <br>        sd s4, <span class="hljs-number">48</span>(a0)  <br>        sd s5, <span class="hljs-number">56</span>(a0)  <br>        sd s6, <span class="hljs-number">64</span>(a0)  <br>        sd s7, <span class="hljs-number">72</span>(a0)  <br>        sd s8, <span class="hljs-number">80</span>(a0)  <br>        sd s9, <span class="hljs-number">88</span>(a0)  <br>        sd s10, <span class="hljs-number">96</span>(a0)  <br>        sd s11, <span class="hljs-number">104</span>(a0)  <br>  <br>        ld ra, <span class="hljs-number">0</span>(a1)  <br>        ld sp, <span class="hljs-number">8</span>(a1)  <br>        ld s0, <span class="hljs-number">16</span>(a1)  <br>        ld s1, <span class="hljs-number">24</span>(a1)  <br>        ld s2, <span class="hljs-number">32</span>(a1)  <br>        ld s3, <span class="hljs-number">40</span>(a1)  <br>        ld s4, <span class="hljs-number">48</span>(a1)  <br>        ld s5, <span class="hljs-number">56</span>(a1)  <br>        ld s6, <span class="hljs-number">64</span>(a1)  <br>        ld s7, <span class="hljs-number">72</span>(a1)  <br>        ld s8, <span class="hljs-number">80</span>(a1)  <br>        ld s9, <span class="hljs-number">88</span>(a1)  <br>        ld s10, <span class="hljs-number">96</span>(a1)  <br>        ld s11, <span class="hljs-number">104</span>(a1)  <br>          <br>        ret<br></code></pre></td></tr></table></figure><p>swtch函数其实是用汇编代码实现的（swtch.S），它的作用就是切换CPU运行时使用的寄存器的值，也就是进程的context结构体中记录的内容。具体来说，上面的代码就是实现了先保存现在寄存器的值到<strong>a0寄存器</strong>指向的位置，再加载新的值到<strong>a1寄存器</strong>指向的位置：</p><ul><li>sd是指store doubleword，将寄存器的值存入存储器</li><li>ld则是load doubleword，将存储器的值加载进寄存器</li><li>ret指令，CPU会将PC重置为ra寄存器的值<br>a0寄存器对应了swtch函数的第一个参数，是当前进程的context对象的地址，保存它的意义在于当前进程因为各种原因被调度走了，下次还可以在上次CPU中断的位置继续完成任务。<br>a1寄存器对应了swtch函数的第二个参数，是即将要CPU执行的进程对应的context结构体地址</li></ul><p>注意：一般来说，ra寄存器存放目前进程代码执行到的位置，方便下一次CPU调度该进程时可以接着执行，但由于是第一个进程，ra寄存器实际指向了我们想要执行的第一个程序</p><p>还记得吗？在新建第一个进程的时候，<code>p-&gt;context.ra = (uint64)forkret; </code> 新进程的ra寄存器的值被设定为forkret函数的地址，所以第一个进程实际上会先完成forkret函数的工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// A fork child&#x27;s very first scheduling by scheduler()  </span><br><span class="hljs-comment">// will swtch to forkret.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">forkret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> first = <span class="hljs-number">1</span>;  <br>  <br>  <span class="hljs-comment">// Still holding p-&gt;lock from scheduler.  </span><br>  release(&amp;myproc()-&gt;lock);  <br>  <br>  <span class="hljs-keyword">if</span> (first) &#123;  <br>    <span class="hljs-comment">// File system initialization must be run in the context of a  </span><br>    <span class="hljs-comment">// regular process (e.g., because it calls sleep), and thus cannot    // be run from main().    first = 0;  </span><br>    fsinit(ROOTDEV);  <br>  &#125;  <br>  <br>  usertrapret();  <br>&#125;<br></code></pre></td></tr></table></figure><p>forkret函数会初始化文件系统，注意：文件系统的初始化代码因为涉及到sleep系统调用，因此必须通过一个常规的进程运行，而不是再上文的main.c中进行</p><p>完成初始化后，程序会执行usertrapret()函数，这是一个从内核态返回用户态的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  </span><br><span class="hljs-comment">// return to user space  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  <span class="hljs-comment">// we&#x27;re about to switch the destination of traps from  </span><br>  <span class="hljs-comment">// kerneltrap() to usertrap(), so turn off interrupts until  // we&#x27;re back in user space, where usertrap() is correct.  intr_off();  </span><br>  <br>  <span class="hljs-comment">// send syscalls, interrupts, and exceptions to trampoline.S  </span><br>  w_stvec(TRAMPOLINE + (uservec - trampoline));  <br>  <br>  <span class="hljs-comment">// set up trapframe values that uservec will need when  </span><br>  <span class="hljs-comment">// the process next re-enters the kernel.  p-&gt;trapframe-&gt;kernel_satp = r_satp();         // kernel page table  </span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack  </span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;  <br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid()  </span><br>  <br>  <span class="hljs-comment">// set up the registers that trampoline.S&#x27;s sret will use  // to get to user space.    // set S Previous Privilege mode to User.  </span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_sstatus();  <br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// clear SPP to 0 for user mode  </span><br>  x |= SSTATUS_SPIE; <span class="hljs-comment">// enable interrupts in user mode  </span><br>  w_sstatus(x);  <br>  <br>  <span class="hljs-comment">// set S Exception Program Counter to the saved user pc.  </span><br>  w_sepc(p-&gt;trapframe-&gt;epc);  <br>  <br>  <span class="hljs-comment">// tell trampoline.S the user page table to switch to.  </span><br>  uint64 satp = MAKE_SATP(p-&gt;pagetable);  <br>  <br>  <span class="hljs-comment">// jump to trampoline.S at the top of memory, which   </span><br>  <span class="hljs-comment">// switches to the user page table, restores user registers,  </span><br>  <span class="hljs-comment">// and switches to user mode with sret.  uint64 fn = TRAMPOLINE + (userret - trampoline);  </span><br>  ((<span class="hljs-type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);  <br>&#125;<br></code></pre></td></tr></table></figure><p>这部分代码涉及到了中断的内容，会在后续章节学习，只需要知道：</p><ol><li>在这段代码中先将内核层级设定为用户态</li><li>通过<code>w_sepc(p-&gt;trapframe-&gt;epc);  </code> 设置PC（程序计数器）的值为寄存器中预先存好的值</li><li>CPU因为从PC处执行指令，因此执行<code>p-&gt;trapframe-&gt;epc</code>指向的代码。</li></ol><p>在第一个进程中，epc指向虚拟地址0，该虚拟地址绑定的物理地址实际指向initcode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a user program that calls exec(&quot;/init&quot;)  </span><br><span class="hljs-comment">// od -t xC initcode  </span><br>uchar initcode[] = &#123;  <br>  <span class="hljs-number">0x17</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x02</span>,  <br>  <span class="hljs-number">0x97</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0x02</span>,  <br>  <span class="hljs-number">0x93</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,  <br>  <span class="hljs-number">0x93</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,  <br>  <span class="hljs-number">0xef</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0x9f</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0x2f</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x69</span>,  <br>  <span class="hljs-number">0x74</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,  <br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>  <br>&#125;;<br></code></pre></td></tr></table></figure><p>这其实是initcode二进制代码的十六进制显示，也就是说CPU要开始加载initcode代码</p><p>也就是下面的汇编代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"># Initial process that execs /init.  <br># This code runs in user space.  <br>  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;syscall.h&quot;</span>  </span><br>  <br><span class="hljs-meta"># exec(init, argv)  </span><br>.globl start  <br>start:  <br>        la a0, init    <span class="hljs-comment">//la将一个内存地址的值加载到rd寄存器中</span><br>        la a1, argv    <br>        li a7, SYS_exec <span class="hljs-comment">//li可以将任意的32位数据或者地址加载到指定的寄存器中</span><br>        ecall  <br>  <br><span class="hljs-meta"># for(;;) exit();  </span><br><span class="hljs-built_in">exit</span>:  <br>        li a7, SYS_exit  <br>        ecall  <br>        jal <span class="hljs-built_in">exit</span>  <br>  <br><span class="hljs-meta"># char init[] = <span class="hljs-string">&quot;/init\0&quot;</span>;  </span><br>init:  <br>  .<span class="hljs-built_in">string</span> <span class="hljs-string">&quot;/init\0&quot;</span>  <br>  <br><span class="hljs-meta"># char *argv[] = &#123; init, 0 &#125;;  </span><br>.p2align <span class="hljs-number">2</span>  <br>argv:  <br>  .<span class="hljs-type">long</span> init  <br>  .<span class="hljs-type">long</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这段汇编代码的主要作用是触发系统调用exec（这个系统调用的作用前文已经讲过），执行名为init的程序（由user&#x2F;init.c编译得到），如果exec失败，则循环运行一个不会返回的系统调用exit</p><p>init的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// init: The initial user-level program  </span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/spinlock.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/sleeplock.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/file.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span>  </span><br>  <br><span class="hljs-type">char</span> *argv[] = &#123; <span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-number">0</span> &#125;;  <br>  <br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> pid, wpid;  <br>  <br>  <span class="hljs-keyword">if</span>(open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="hljs-number">0</span>)&#123;  <br>    mknod(<span class="hljs-string">&quot;console&quot;</span>, CONSOLE, <span class="hljs-number">0</span>);  <br>    open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR);  <br>  &#125;  <br>  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stdout  </span><br>  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stderr  </span><br><br>  <span class="hljs-comment">//启动shell</span><br>  <span class="hljs-keyword">for</span>(;;)&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: starting sh\n&quot;</span>);   <br>    pid = fork();  <br>    <span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>)&#123;  <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: fork failed\n&quot;</span>);  <br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;  <br>      exec(<span class="hljs-string">&quot;sh&quot;</span>, argv);  <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: exec sh failed\n&quot;</span>);  <br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br><br><span class="hljs-comment">//shell启动成功，进入死循环，</span><br>    <span class="hljs-keyword">for</span>(;;)&#123;  <br>      <span class="hljs-comment">// this call to wait() returns if the shell exits,  </span><br>      <span class="hljs-comment">// or if a parentless process exits.      wpid = wait((int *) 0);  </span><br>      <span class="hljs-keyword">if</span>(wpid == pid)&#123;  <br>        <span class="hljs-comment">// the shell exited; restart it.  </span><br>        <span class="hljs-keyword">break</span>;  <br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wpid &lt; <span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: wait returned an error\n&quot;</span>);  <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>      &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// it was a parentless process; do nothing.  </span><br>      &#125;  <br>    &#125;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>init会在需要的情况下创建一个新的控制台设备文件，然后把它作为描述符0，1，2打开。接下来它将不断循环，开启控制台 shell，处理没有父进程的僵尸进程，直到 shell 退出，然后再反复。系统就这样运行起来了。</p><h2 id="现实情况"><a href="#现实情况" class="headerlink" title="现实情况"></a>现实情况</h2><p>大多操作系统都采用了进程这个概念，而大多的进程都和 xv6 的进程类似。但是真正的操作系统会利用一个显式的链表在常数时间内找到空闲的 <code>proc</code>，而不像本文 <code>allocproc</code> 中那样花费线性时间；xv6 使用的是朴素的线性搜索，找第一个空闲的 <code>proc</code>（详情见前文的scheduler.c代码）。</p><p>注意：xv6 的地址空间结构有一个缺点，即无法使用超过 2GB 的物理 RAM。当然我们可以解决这个问题，不过最好的解决方法还是使用64位的机器。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>完成了对书籍第二章内容的阅读和扩展阅读，写成了这一篇笔记，在开始第三章学习之前，要先进入到系统调用相关的练习中了。</p><p>感谢你能看到这里！幸苦了！！</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book Chapter1</title>
    <link href="/2023/07/14/xv6-book-Chapter1/"/>
    <url>/2023/07/14/xv6-book-Chapter1/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter1-操作系统接口"><a href="#Chapter1-操作系统接口" class="headerlink" title="Chapter1 操作系统接口"></a>Chapter1 操作系统接口</h1><p>操作系统是硬件的抽象表示，需要通过接口对用户程序提供服务。unix的接口设计十分成功，而xV6是一个模仿unix设计的操作系统，理解xv6是理解现代操作系统的良好开端。</p><p>但是哪怕是简单的xv6系统，我们也需要一个框架形的学习方式，Chapter 1主要从用户使用操作系统的角度出发，先介绍操作系统提供的接口，即系统调用。</p><p>用户的程序运行在用户态，内核执行的程序运行在内核态，如果用户需要发起需要操作系统参与的活动时（例如读写磁盘，删除文件），不能直接执行操作，而是要利用操作系统的提供的接口，这个接口被成为系统调用（系统调用是一串预先实现好的函数）。如下图所示</p><p><img src="20230711210052.png"></p><p>为什么要这样做呢？</p><ol><li><strong>它为用户空间提供了一种统一的硬件的抽象接口</strong>，用户程序不必关心底层的具体实现。例如对于读写操作，用户不关心存储介质是固态硬盘还是机械硬盘，只需要往文件中读写即可，至于信息到底保存在哪里，如何与硬件对接，由操作系统负责完成</li><li><strong>系统调用保证了系统的稳定和安全</strong>。作为硬件设备和应用程序之间的中间人，内核可以基于权限和其他一些规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确地使用硬件设备，例如窃取其他进程的资源。</li><li><strong>假设没用内核，应用程序可以随意访问硬件，几乎就没法实现多任务和虚拟内存</strong></li></ol><p>下图列出了xv6操作系统的所有系统调用，本章的其余部分概述了xv6的服务——进程、内存、文件描述符、管道和文件系统——并通过代码片段对它们进行了说明，并讨论了shell (Unix的命令行用户界面)如何使用它们。<br>注意：进入unix系统看到的<strong>shell窗口是一个用户程序</strong>而不是内核的一部分，xv6的shell代码可以在user&#x2F;sh.c找到。<br><img src="20230711215725.png" alt="系统调用列表"></p><h2 id="进程与内存"><a href="#进程与内存" class="headerlink" title="进程与内存"></a>进程与内存</h2><p>xv6进程由用户空间内存(指令、数据和堆栈)和内核私有的每个进程状态组成。</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">进程 </span>=<span class="hljs-string"> 占用的内存空间 + 进程状态</span><br></code></pre></td></tr></table></figure><p>每个进程可以使用fork()系统调用创建一个新的子进程。其内存内容与父进程完全相同，父进程执行的fork会返回子进程的pid（进程的唯一标识符），子进程的fork返回0。以下面的代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = fork();    <span class="hljs-comment">//创建子进程</span><br><span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;         <span class="hljs-comment">//如果是父进程则执行下面的语句</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: child=%d\n&quot;</span>, pid);<br>pid = wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>);  <span class="hljs-comment">//wait系统调用返回当前进程退出子进程的PID，并将子进程的退出状态复制到传递给wait的地址,如果调用者的子进程都没有退出，则等待其中一个退出,如果调用者没有子进程，wait立即返回-1, 如果父进程不关心子进程的退出状态，它可以传递一个0地址来等待</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d is done\n&quot;</span>, pid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//如果是子进程则执行下面的语句</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child: exiting\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//exit系统调用导致调用进程停止执行，并释放资源</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>&#125;<br><br>这个代码的输出结果，前两行可能交换顺序:<br>parent: child=<span class="hljs-number">1234</span><br>child: exiting<br>parent: child <span class="hljs-number">1234</span> is done<br></code></pre></td></tr></table></figure><p>exec系统调用从存储在文件系统中加载新的内存映像替换调用进程的内存(可以理解为把一个程序替换为另一个程序)，一般搭配fork使用</p><p>shell就是一个特殊的程序，当你在shell界面输入命令时，shell会fork一个子进程，然后使用exec将子进程的内存空间替换为你输入的命令的内存空间（也就是把子进程变成你想要执行的进程），如果内存空间不够，可以使用sbrk这一系统调用扩宽。</p><p>如下方代码所示，主循环使用getcmd从用户那里读取一行输入。然后调用fork，创建shell进程的副本。父进程调用wait，而子进程运行该命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Read and run input commands.  </span><br><span class="hljs-keyword">while</span>(getcmd(buf, <span class="hljs-keyword">sizeof</span>(buf)) &gt;= <span class="hljs-number">0</span>)&#123;  <br><span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;  <br><span class="hljs-comment">// Chdir must be called by the parent, not the child.  </span><br>buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// chop \n  </span><br><span class="hljs-keyword">if</span>(chdir(buf+<span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>)  <br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="hljs-number">3</span>);  <br><span class="hljs-keyword">continue</span>;  <br>&#125;  <br><span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)  <br>runcmd(parsecmd(buf));   <span class="hljs-comment">//子进程执行指令</span><br>wait(<span class="hljs-number">0</span>);  <span class="hljs-comment">//父进程等待</span><br>&#125;    <br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <br><br><br>fork1(<span class="hljs-type">void</span>)  &#123;  <br><span class="hljs-type">int</span> pid;  <br>pid = fork();  <br><span class="hljs-keyword">if</span>(pid == <span class="hljs-number">-1</span>)  <br>panic(<span class="hljs-string">&quot;fork&quot;</span>);  <br><span class="hljs-keyword">return</span> pid;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="I-O和文件描述符"><a href="#I-O和文件描述符" class="headerlink" title="I&#x2F;O和文件描述符"></a>I&#x2F;O和文件描述符</h2><p>文件描述符（File Descriptor，简称FD）是一个小整数，linux使用它来作为文件的唯一标识（文件是一个抽象概念，表示文件描述符引用的对象，不仅仅是文件夹里的文件，也可以是管道和设备），内核为每个进程维护了一个文件描述符表，这个表以为索引，再进一步指向文件的详细信息。<br><img src="20230713134913.png" alt="IO描述符"></p><p>在Unix系统中，每个进程都有STDIN、STDOUT和STDERR这3种标准I&#x2F;O（分别对应文件描述符0、1、2），它们是程序最通用的输入输出方式。几乎所有语言都有相应的标准I&#x2F;O函数，比如，C语言可以通过scanf从终端输入字符，通过printf向终端输出字符<br>在这一部分内容中，主要涉及到两个系统调用，open，read和write可以[看这里](<a href="https://zhuanlan.zhihu.com/p/435406445">Linux系统中I&#x2F;O操作的数据读写流程介绍 - 知乎 (zhihu.com)</a>)</p><h4 id="I-O重定向详解"><a href="#I-O重定向详解" class="headerlink" title="I&#x2F;O重定向详解"></a>I&#x2F;O重定向详解</h4><p>unix通过将fork和exec分离，实现了IO重定向（让已创建的FD指向其他文件）。<br>具体来说，fork复制父进程的文件描述符表及其内存，这样子进程打开的文件与父进程完全相同。系统调用exec替换调用进程的内存，但保留文件表，就使得shell命令输入的IO操作可以灵活的运用。只看概念很晦涩，不妨碍看看下面案例：</p><p>dup和dup2是IO重定向的涉及的核心系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">内核在进程中创建一个新的文件描述符(目前可用文件描述符的最小值）newfd，并且使newfd指向oldfd所指向的文件表项</span><br><span class="hljs-comment">**/</span><br><br><span class="hljs-comment">//eg：</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello world!\n&quot;</span>;<br><span class="hljs-type">int</span> newfd = <span class="hljs-number">-1</span>;<br>newfd = dup(<span class="hljs-number">1</span>);    <span class="hljs-comment">//将newfd重定向到标准输出，0、1、2是默认存在的FD，3是目前可用的最小描述符，因此newfd=3</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;newfd = &quot;</span>&lt;&lt;newfd&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//输出newfd=3</span><br>write(newfd,str,<span class="hljs-built_in">strlen</span>(str));    <span class="hljs-comment">//向newfd中写入字符串，由于newfd重定向到1，因此newfd和标准输出有相同的指向，会在屏幕上输出hello world!</span><br>    close(newfd); <br>    <span class="hljs-comment">//close系统调用释放一个文件描述符，使其可以被将来的open、pipe或dup系统调用重用。新分配的文       件描述符总是当前进程中编号最低的未使用描述符</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">让传入的参数newfd与参数oldfd指向同一文件表项，如果newfd已经被open过，那么就会先将newfd关闭，然后让newfd指向oldfd所指向的文件表项，如果newfd本身就等于oldfd，那么就直接返回newfd。因此，传入的newfd既可以是open过的，也可以是一个任意非负整数，</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">总之，dup2函数的作用就是让newfd重定向到oldfd所指的文件表项上</span><br><span class="hljs-comment">如果出错就返回-1，否则返回的就是newfd</span><br><span class="hljs-comment">**/</span><br><br><span class="hljs-comment">//eg:</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello world!\n&quot;</span>;<br> <br>dup2(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);    <span class="hljs-comment">//将“5”重定向到标准输出</span><br>write(<span class="hljs-number">5</span>,str,<span class="hljs-built_in">strlen</span>(str));   <span class="hljs-comment">//向文件描述符5写入数据,此时相当于输出到文件描述符1对应的文件表项上，也就是输出到屏幕</span><br>close(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面可以讲几个具体的样例：<br><strong>1.  重定向标准输入</strong><br>标准输入（文件描述符0）所对应的设备是键盘，当read指定FD&#x3D;1时，实际上是read键盘输入的数据，那如果不想让键盘作为标准输入呢？比如说让程序从某个文件中读取输入数据，这就需要重定向标准输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">string</span> rdstr;<br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//打开想要读取数据的文件，open返回新的FD，这个fd指向test.txt这一文件表项</span><br><span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR)) == <span class="hljs-number">-1</span>) <br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;open failed !&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//重定向标准输入到外部文件test.txt中（即0重定向到fd，指向fd对应的文件表项）</span><br>dup2(fd,<span class="hljs-number">0</span>); <br><br><span class="hljs-keyword">while</span>(getline(<span class="hljs-built_in">cin</span>,rdstr))     <span class="hljs-comment">//用getline从标准输入中获取数据，也就是从此时的fd读取</span><br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;rdstr&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//通过标准输出将读入的数据打印出来</span><br>&#125;<br> <br>    close(fd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>2.  重定向标准输出</strong><br>标准输出（文件描述符1）的设备是显示器，通过标准输出进行write时，数据会直接输出到显示器上。那么如果想让cout、printf直接将数据输出到文件，而不是显示屏上呢？那么就需要重定向标准输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//创建test.txt并清空文本（O_TRUNC是清空之前内容的标志），并生成文件描述符fd</span><br><span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC)) == <span class="hljs-number">-1</span>)  <br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;open failed !&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>dup2(fd,<span class="hljs-number">1</span>);   <span class="hljs-comment">//重定向标准输出到外部文件test.txt</span><br><span class="hljs-comment">//向标准输出输出数据，此时的标准输出指向了fd指向的文本表项，也就是test.txt</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;重定向标准输出测试！&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;   <br>    close(fd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展：</p><p><strong>3.  重定向错误输出</strong><br>标准错误输出实际上与标准输出类似，都是将数据输出到显示器上，只不过标准错误输出是输出错误信息，C语言中常用的错误输出就是perror了，如下面打开一个不存在的文件，就会直接在显示器上输出报错信息，因此重定向的方式与重定向标准输出一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>open(<span class="hljs-string">&quot;123.txt&quot;</span>,O_RDWR); <br>perror(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.  重定向恢复</strong><br>在进行重定向后，如果想要恢复到重定向之前的状态，可以在重定向之前用dup函数保留该文件描述符对应的文件表项，然后在需要恢复重定向的时候使用dup2重定向到原来的文件表项，以重定向后恢复标准输出为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC)) == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;open failed !&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-type">int</span> oldfd = dup(<span class="hljs-number">1</span>);     <span class="hljs-comment">//保存标准输出对应的文件表项</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">注意：并不是保存了文件表项本身，而是生成并保存了一个指向标准输出对应文件表项的文件描述符（oldfd）</span><br><span class="hljs-comment">**/</span><br>dup2(fd,<span class="hljs-number">1</span>);    <span class="hljs-comment">//重定向标准输出到外部文件test.txt中</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;重定向标准输出测试！&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//重定向测试</span><br>dup2(oldfd,<span class="hljs-number">1</span>);   <span class="hljs-comment">//将重定向后的文件描述符1再次重定向到一开始保存的标准输出对应的文件表项中</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;重定向标准输出恢复测试！&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;   <span class="hljs-comment">//重定向恢复测试</span><br>close(fd);<br>close(oldfd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//在第一次重定向后，cout输出信息是输出到了外部文件中，当再次重定向进行恢复之后，此时的cout就将数据输出到显示器上了，回到了最原始的标准输出</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="管道（pipe）"><a href="#管道（pipe）" class="headerlink" title="管道（pipe）"></a>管道（pipe）</h2><p>管道是一个小的内核缓冲区，作为一对文件描述符公开给进程，一个用于读取，一个用于写入。将数据写入管道的一端，使该数据可用于从管道的另一端读取。<strong>管道为进程提供了一种通信方式</strong>。</p><p>下面的示例代码运行程序wc，标准输入连接到管道的读取端:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>]; <span class="hljs-comment">//用来存储管道的两个文本描述符</span><br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>]; <span class="hljs-comment">//argv表示命令行输入</span><br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;wc&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>pipe(p); <span class="hljs-comment">//此时生成了管道，pipe是生成管道的系统调用</span><br><span class="hljs-comment">//在执行fork操作前已经生成了管道，那么fork操作后，父进程和子进程并行执行，每个进程中都有一个管道，且管道的文本描述符是相同的</span><br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//如果是子进程，执行如下分支的程序</span><br>close(<span class="hljs-number">0</span>);  <span class="hljs-comment">//关闭标准输入，此时0成为了最小的文本描述符</span><br>dup(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//上文讲到了dup的作用，生成了个新的指向p[0]对应文本表项的文本描述符，由于0是最小的文本描述符，所有dup会生成0作为文本描述符，标准输入对应了p[0]原本（管道用于读取的那一端）对应的文本表项。可以形象的理解为标准输入和管道的读取端对接上了（用水的事物和水管的出水口接上了）。</span><br>close(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//p[0]和0指向的表项相同，不再需要</span><br>close(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">//读取端不需要写入，所以关闭</span><br>exec(<span class="hljs-string">&quot;/bin/wc&quot;</span>, argv); <span class="hljs-comment">//子进程执行读取操作，读取被写入到管道的数据</span><br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//如果是父进程，执行如下分支的程序</span><br>close(p[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//写入端不需要读取管道的数据</span><br>write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>, <span class="hljs-number">12</span>) <span class="hljs-comment">//p[1]是管道的进水口，程序向管道中写入数据（水龙头往管道中放水</span><br>close(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">//数据写完了，关闭管道（水龙头关闭了，水管也可以撤走了）</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述的例子中，如果管道的缓冲区中没有可用的数据，管道上的读操作要么等待数据被写入，要么等待指向写端的所有文件描述符被关闭，在后一种情况下，read将返回0。<br><strong>注意：由于父进程和子进程共有两对管道文本描述符，但整个数据传输过程中只会用到一对描述符，如果读取端不关闭多余的写入端口，那么wc将永远不会结束，即读取端永远等待自己没有使用的那个写入端写入数据</strong>。<br><img src="20230713171305.png" alt="管道"></p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>暂时没看懂</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
