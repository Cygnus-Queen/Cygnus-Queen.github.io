<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>以交易为生（总结）</title>
    <link href="/2024/01/31/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <url>/2024/01/31/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>想要战胜市场，以下三点缺一不可： （1）良好的心态（一切按照指标移动，不要相信感觉） （2）符合逻辑的交易系统（成体系，成记录） （3）有效的风险管理计划（资金管理）</p><p>整个内容就是围绕这三点展开，大多数会忽视第一和第三点，只在乎第二点，其实资金管理和心态管理（保持情绪）恰恰要重要的多，不能让情绪影响到交易系统，每一个买入或卖出订单的制定都应该是繁琐的，包括了客观指标，交易评分，交易日志，交易记录，而且结束后还要复盘。</p><p>如果完成交易用的时间很短，那想必是没考虑清楚，或者对待表格等客观事物应付了事，那亏损就不远了。</p><h2 id="个体心理成为一个清醒的人">1、个体心理（成为一个清醒的人）</h2><p>胜不骄败不馁，只专注复盘和技巧的学习，是专业交易者必须的素质，自毁倾向要不得（亏的就剩这么点了，就这样了，破罐子破摔之类的），你的失败都是基于自己，市场是不会错的</p><p><strong>==市场不知道你的存在，你的存在也无法影响市场。它不会故意关照你的财富，也不会特意伤害你的资金。你要做的，只是控制自己的行为。==</strong></p><p><strong>专业的交易者冷静地运用自己的智慧交易。只有业余者才会极易兴奋或沮丧。情绪化在交易时是谁也无法承担的累赘。</strong></p><p><strong>你的买卖决定，只有在理智的情况下做出才有效，而后文的众多指标就是为了帮助你确定自己的理智。</strong></p><p>应该避免的交易心理： （1）不要一波连胜之后认为自己是天才，开始偏离交易系统（往往是通过一两次偏移带来好处之后，认为不必要再遵守交易系统，这是损失本金的开始） （2）不要否认自己的失败，像酗酒者不承认酗酒毁了自己的生活一样，认为自己都能控制，其实已经走到了悬崖边缘。连续亏损之后不承认，还加仓，等待反转，其实就是站到了悬崖边上）</p><p><strong>作为一个交易者的第一步，就是要大声承认：我就是个失败者，我对亏损无能为力。</strong></p><p>作为一个交易者，我们经常要承担交易风险，但我们不应在可预知的风险之外，再多承担任何损失。打个比方，商店店主每次进货的时候都承担着风险。如果没有卖掉，他就会有损失。聪明的商人只会承担那些不会让他生意破产的风险——即使连续犯错。进两箱货可能是在合理的风险范围内，但是进一车的货物就真的是在赌博了。</p><p>想要成为专业交易者，是一个长线任务： （1）坚定自己在市场中长期作战的意念——从现在开始至少交易20年。 （2）像海绵一般地学习，关注专家的观点，但对任何事情都要保持有益的怀疑态度。遇到有疑问的地方要刨根究底，而不是简单地接受专家的观点，或只理解他们字面上的意思。（没有弄清楚内在逻辑的观点不如不要） （3）不贪婪，不急于交易——要把你的时间用于学习，市场一直在这里，未来无尽的岁月中会有更多更好的机会。 （4）<strong>培养分析市场的方法，换句话说，就是“如果A发生，那么B很可能会发生”</strong>。市场有很多维度，要使用多种解析方法来确认自己的交易决策。要学会用历史数据测试交易决策，随后在市场上真枪实弹地进行交易。市场瞬息万变，你需要的是根据牛市、熊市、震荡市等不同的特征采用不同的工具进行交易，同时还要有所区分（详情见技术分析章节）。 （5）<strong>建立一套资金管理计划</strong>。你的第一目标是必须长期生存下去，第二目标是资本的稳定增长，第三目标才是赚取高额利润。其实第一部分就已经很难了，不要觉得目标很容易实现 （6）要认识到交易者在任何交易系统中都是最为薄弱的一环，克制情绪交易 （7）胜利者在思考、感受与行动上的方式与失败者是完全不同的。你必须深探自己的内心，驱赶那些幻觉，改变你原来的思考、感受与行动的方式</p><p>为了成功，你需要动力、知识和自律。钱很重要，但这些品质的重要性要远远大于钱。如果你足够努力地鞭策自己，按照本书所说来努力学习努力交易，你会得到很多知识，然后我们会在最后一章回到纪律的话题上，为本书的一切画上圆满的句号。</p><p><strong>谨记，你的目标是交易获利，而不是频繁交易。可以自由的选择交易行为，是个人投资者最大的优势（比如这次熊市，公募仓位限制，不能卖出，他们只能选股，不能择时）</strong></p><h2 id="群体心理">2、群体心理</h2><p><strong>股票的实时成交价是所有交易者的共识</strong></p><p>每个成功的交易者必须学会独立地思考问题，他需要强大到能独自分析市场并进行买卖决策，而不是依靠各种专家</p><p>群众有着足够的力量来创造某种市场趋势，群众或许不够理智，但却比任何单个个体要强大很多。==<strong>千万不要逆趋势交易（这次的股市就给逆势交易想要抄底的人一记重锤）</strong>==。一旦上涨趋势得以确立，你能做的只有买进或者在一边观望。<strong>千万不要仅仅是因为感觉价格过高而去卖空——再次强调，不要和趋势作对</strong>。<strong>没有哪个规定说你一定要和人群一同奔跑，但你至少不应该逆着人群行进</strong>。</p><p>尊重群众的力量，但是不要畏惧它。<strong>群体虽然拥有强大的力量，但从源头上来看他们的行为是最为简单</strong>，并且反复重现的。想要从其他交易者的口袋中获取利润？做一个独立思考的交易者吧，你可以的。</p><p>唯有坚持长期以独立的个体角度进行思考和操作，你才能成为一个成功的交易者。在交易的过程中，你必须时刻留意自己，关注自己精神状态的变化。写出自己入场与出场的条件，包括资金管理规则。<strong>只要手上还有仓位头寸，就坚决不能修改计划</strong>。</p><p>个人行为是复杂多变而难以预测的，而群体行为是简单而原始的。技术分析者研究了市场群体模式。当他们识别到先前市场变化的形态时，他们开始交易。</p><p>成功的交易建立在三大支柱之上。你需要<strong>分析多空力量的平衡</strong>。你需要实践资金管理。你需要严格服从你的交易计划，避免在市场中过于兴奋或者沮丧。</p><p>股价的波动是多空双方博弈的过程，<strong>==技术分析的本质就是分析多空力量的平衡==</strong></p><h2 id="图表分析法">3、图表分析法</h2><p>市场根本不认同斜线（趋势线），但市场能够记住价位，这就是为什么<strong>水平支撑位和阻力位有意义</strong>，而<strong>斜线趋势却是主观的甚至是自欺欺人的。</strong></p><p>只需要使用几个客观的令人信赖的图表模式即可 （1）基于水平的支撑位和阻力位 （2）每日开盘价和收盘价的关系 （3）蜡烛图高点和低点的关系 （4）袋鼠尾</p><p>每日开盘价往往反映了业余者对价值的看法</p><p>在牛市中，市场通常在周一或周二时出现当周最低价——因为业余者会兑现前一周赚到的利润，然后市场会在周四或周五创出新高</p><p>每天或每周的收盘价则往往反映了专业交易者的行为。他们全天都在盯着市场交易，对市场变化做出反应，并倾向于主宰最后1小时的交易</p><p><strong>共识：</strong> 1. 每根柱状线的最高点代表了最强多方的力量，每根柱状线的最低点代表了最强空方的力量 2. 每一根柱状线的收盘价都是当天多方和空方博弈的最终结果 3. 柱线图中最高点和最低点的距离反映了多方和空方冲突的激烈程度 4. 滑点（见导论）在市场冷清的时候往往较小。在市场冷清的时候进场比较好。遇到很长的柱状线是兑现利润的好时机</p><p>根据混沌理论，市场在大多数情况下都是混乱的，但是秩序也偶尔会在市场潮汐中存在。市场分析的本质就在于能够辨认出这些固定的模式，并且有勇气和信心利用它们进行交易。</p><h3 id="支撑位和阻力位">支撑位和阻力位</h3><p><strong>支撑位和阻力位的形成源自亏钱的记忆和悔恨，下次到同一个地方一定要止损，这也就是经常说的套闹盘，抛压大</strong></p><p><strong>小的支撑位或者阻力位会导致趋势的暂停，而主要的支撑位和阻力位则会造成趋势的反转。大量的交易者们在支撑位买入，在阻力位卖出，使得支撑位和阻力位的有效性变成了一种自我实现的预言。支撑位和阻力位的强度取决于大量交易者感受的强度</strong></p><h4 id="支撑位和阻力位的强度">支撑位和阻力位的强度</h4><p><strong>这些区域的力量取决于三个因素：区域的长度、高度，以及在区域内的成交量（深度）</strong>。 1. 长度： （1）持续两周的反复震荡区只会产生一个微小的阻力位或者支撑位； （2）持续两个月的阻力位或者支撑位会让人们习惯这个价位，并且产生一个中等强度的支撑位或者阻力位； （3）持续两年的反复震荡区则会让人接受该价位是股票的真实价值（日本，国内3000点保卫战） 2. 高度： （1）如果一个密集成交区的高度仅有现在市场总价值的1%，那就只能提供一个弱小的支撑位和阻力位 （2）如果有3%那么高，就会形成一个中等强度的支撑位或者阻力位； （3）如果是7%或者更高，那么这个密集成交区能碾碎一个大的趋势 3. 深度 大成交量表示了交易者参与程度活跃——这是高的感情投入的信号</p><p><strong>如果用股票在密集交易区的天数乘以成交的平均价格和平均成交量，你就可以测算出支撑力量或阻力的总金额。</strong></p><h4 id="交易规则">交易规则</h4><ol type="1"><li>无论何时，当大盘走势逼近支撑位或者阻力位时，设定好你的保护性止损位。 趋势在阻力位和支撑位的表现显示了其健康程度。如果走势足够强，能突破阻力区或支撑区，你的保护性止损单将不会被触发。如果走势在阻力区或支撑区开始反转，说明趋势较弱。在这种情况下你的保护性止损单就会保住你的一大笔利润。</li><li><strong>阻力位和支撑位对于长期图表比对短期图表分析更重要。</strong> 如果周线图的趋势很强势，那么日线图触及阻力位也并不用太担心。当周趋势线逼近阻力位或者支撑位时，你就应该考虑退出了。</li><li>支撑位和阻力位意味着交易的机会（假突破） 技术分析中最重要的模式之一是“假突破”，如果价格微降至支撑位一下，然后又重回支撑区域，这意味着空方已经失去他们的机会。当出现向下假突破后，线柱的收盘价收回在密集成交区之内时，标志着这是买入的机会。你应该在近期假突破点底部附近设置一个保护性止损单。</li></ol><p>专业人士会抓住假突破，然后设置一个距离买入点很近的止损单，因为既然突破的压力位，如果是假突破，那下面的空间就不大了，不会触发止损单；如果判断错误是真突破，亏损也可以接受。</p><p><strong>在日线图上买入向上突破的最佳时机，是当你发现周线图出现新的上升趋势时。</strong></p><p><strong>真正的突破一般伴随有巨额的成交量，而假突破则成交量很少</strong></p><h3 id="趋势和震荡">趋势和震荡</h3><p>上升趋势：每一次上涨的高位都会突破之前的高位，而每一次下跌都会高于之前下跌的低位 下跌趋势：每一次下跌都会击穿上一次的低位，而每一次反弹又无法高于上一次反弹的最高点 震荡区间：每一次上涨都会抵达之前的高点，而每一轮下跌也回到以前的低位 以上是完美的情况，实际总伴随各种假突破</p><p>趋势和震荡有不同的交易法则 （1）在形成趋势后要使用宽松的止损单，避免因为噪音损失利润 （2）震荡环境要收紧止损单，持续关注行情，一旦发生反转的微弱迹象，立即抛售手中的仓位 （3）趋势和震荡中另一个交易技巧的区别在于如何看待强势和弱势。 在趋势之中你得跟着强势的一方走——在上升趋势中看多，在下降趋势中看空。当你处在交易范围中，你就得做反向操作——买入弱势的一方，卖出强势的一方。</p><p>大众在大部分时间内都在乱转，这也就是为什么市场的大部分时间都处在震荡而不是趋势中。大众必须被煽动起来才能创造出一种趋势。但是大众不会兴奋太久，他们很快就会回到漫无目的的状态。<strong>所以，当你不确定这是趋势还是震荡时，</strong>专业者倾向于相信市场处于震荡区间。**</p><h4 id="判断趋势和震荡的方法">判断趋势和震荡的方法</h4><p>没有一个完美的方法，多个指标相互印证，可以提高正确的概率 （1）分析高点和低点的模式。当价格回升总是能达到更高的高位，而下跌总能停止在更高的低位，那就是一个上升的趋势。而更低的高位和更低的低位则意味着一个下降的趋势。而不规则的高点和低点则意味着震荡区域 （2）看均线。一条20-30日的均线斜率的方向展现了趋势，<strong>如果移动平均曲线没有在月内达到一个新高或者新低，那么市场就可能处于震荡区间内</strong> （3）看摆动指标。MACD柱创下新高，预示着一个强力的趋势，表明市场上最近一次顶部要被试探或者被超过 （4）看市场指标。比如趋向系统（此处不展开，后面有）</p><h4 id="立即交易还是等待回调">立即交易还是等待回调？</h4><p>当你认出一个上升趋势时，你有两个选择，要决定是立刻买进还是先等待一个回调。 （1）立即买进要承担更大的风险，因为往往此时止损单的位置比较远， （2）等到回调时入场，要面临众多想入场的人的竞争，“倒车接人”给的机会空间相当窄</p><p><strong>如果你不确定，你可以分以下几个步骤买入（在满足2%法则的基础上）：在突破迹象出现的时候（疑似突破）买入三分之一，突破的时候（确认趋势）再买入三分之一，回调时再买入三分之一</strong></p><h3 id="袋鼠尾反转的标志之一">袋鼠尾（反转的标志之一）</h3><p>当你还以为正在运行中的趋势将会继续存在时——“砰！”——三条蜡烛线形成了一个袋鼠尾，标志着市场猝不及防地发生了反转。</p><p>袋鼠尾标志着牛市或熊市最后的一击。</p><p>例子： <strong>某股票可能从日线图看已经波动了好几天了，结果周一突然一根大阳线，结果周二股票的==开点是周一线柱的底部位置==，并且没有上涨，那就应该考虑在周二收盘前做空股票</strong></p><p><strong>如果市场已经在震荡区间内持续了一周并在周三的时候收出了一根长阴线，那你就要在周四做好准备：如果交易价格在周三线柱的==顶部附近==小幅震荡，那就在周四收盘前大胆买入</strong></p><p>向上的袋鼠尾意味着应该在当前的价位上兑现盈利，而向下的袋鼠尾则是一个加仓的好机会（别忘了设置<strong>止损单</strong>，位置在袋鼠尾的中部就可以了）</p><h2 id="技术分析基于计算机">4、技术分析（基于计算机）</h2><p>第三章的部分主要是传统图表分析，公式比较简单。这部分内容可能支持更复杂的指标</p><p>研究一只股票需要12年的交易历史（两波牛市和熊市）</p><p>新手应该避免日内交易，因为依赖瞬时决策的能力（我按照文章的要求制作表格之类的要很久，日内交易是不可能做到的）；也应该避免长线交易（因为止损点往往范围大，而且速度太慢，难以快速提高自己）；还应该避免跨国交易（所以我现在打算采用定投海外股市，实操国内股市的方式）</p><p>趋势交易是新手的起点，比如说，持有某个仓位几天。挑选那些趋势很好、成交量又不错的热门股票。</p><p>其实在第三章提到各种指标的时候，就可以意识到，多种指标完全可能出现冲突的情况。因此需要挑选出几个指标组合使用。（后文会有交易打分，综合判断是否值得买入）<strong>有的指标在趋势中有效，有的波动市场有效，有的擅长抓住反转，有的擅长确定趋势的延续</strong></p><p>指标可以分为三类： （1）趋势跟随指标（同步或者滞后指标）；在大盘上涨或者下跌时最有效，震荡区间效果急剧下降 MACD线，趋向系统，能量潮 （2）震荡指标（先行或者同步指标）；有助于识别反转点 MACD柱，强力指数，随机指标，变化率，动能指标，相对力量指标，威廉百分比，埃尔德射线指标 （3）复合型指标；提供多空双方强度信息 新高新低指标、看跌/认购期权比、好友指数、交易者指数</p><p>通过多种指标结合起来，就是三重滤网交易系统（后文会讲）的精髓</p><p>记住：有时候指标信号是非常明确的，有时候又很模糊。只有当你非常确定指标发出的信号时，才能选择进场。如果你看到一个熟悉的指标，但不理解其中的意思，那么最好翻到下一页去看另一只股票（机会多的是）。个人交易者最大的好处就是没有人逼着你交易——我们能够等待最好和最清晰的信号。</p><h3 id="趋势指标">趋势指标</h3><p>移动平均和MACD线是确定趋势是什么的指标，ADX趋向系统是确定趋势程度有多大的指标。</p><h4 id="移动平均">移动平均</h4><p>（1）当EMA上涨时，作为多头进行市场交易。当价格下降到移动平均值附近时买入。一旦你成为多头，一定要在最近的低点下面设置保护性止损单。一旦价格接近高点时，就把保护性止损单移至盈亏平衡点。 （2）当EMA下跌时，作为空头进行市场交易，当价格回升接近移动平均值时卖出，然后在最近的高点之上设置保护性止损单。当价格下跌时，将保护性止损单下移到盈亏平衡价位 （3）当EMA走平，只是小幅波动时，那意味着一种漫无目的、没有趋势的市场。这种情况下不要使用趋势跟随方法 （4）EMA也能用来作为<strong>支撑位</strong>和<strong>阻力位</strong> （5）长短EMA之间构成了价值区间，时间比例2：1。记住这点能帮助你成为一个理智的交易者。一旦你懂得了如何定义价值，你就能低买高卖了</p><p>画简单移动平均的正确方法是画在滞后价格的时间长度一半距离的位置</p><h4 id="macd线">MACD线</h4><p>MACD线和信号线的交点表明了市场中空方和多方实力变换的平衡点。较快的MACD线反映的是短期内大众的心理变化，而较慢的信号线则反映了大众心理在较长期的变化</p><p>手工做出MACD指标的步骤如下： （1）计算12日收盘价的EMA； （2）计算26日收盘价的EMA； （3）用12日收盘价的EMA减去26日收盘价的EMA，将其差值画成一条实线，这就是较快的MACD线（DIFF）； （4）计算这条实线的9日EMA，将其结果画成一条虚线，这就是较慢的信号线（DEA）。</p><p>当较快的MACD线上升超过信号线时，表示多方主导了市场，这时候最好做多方；当较快的线落到较慢的信号线下面时，表示空方主导了市场，做空方比较有利。 （1）当较快的MACD线穿越到较慢的信号线上方时，为买入信号。这时候要买多，然后在近期的<strong>次低点</strong>位置设置一个保护性止损单 （2）当较快的MACD线穿越到较慢的信号线下方时，为卖出信号。这时候要卖空，然后在近期的次高位位置设置一个保护性止损单。</p><p><strong>大多数人的MACD设置为（12，26，9），这组设置并不好</strong>，可以改成（6，30，9）</p><p><strong>MACD的使用原则：</strong> 1. <strong>一个中心：以0轴为中心（快慢线运行在0轴之上为多头市场，0轴之下为空头市场）</strong> 2. <strong>两个基本点：顶背离和底背离</strong> 当股价创出新低时，而相关MACD的两线数值却未能同时创出新低，这就形成了底背离现象，是买入信号。在底背离出现时，激进的投资者可以分批建仓。而为了安全起见，稳健的投资者应耐心等待股价止跌回升后再买入。 3. <strong>四项基本原则：买点、卖点、风险点、止损点</strong> （1）一级买点：底背离之后的第二次金叉 <img src="Pasted%20image%2020240131152602.png"> （2）次级买点：快慢线上穿0轴后在0轴获得二次支撑金叉 <img src="Pasted%20image%2020240131152840.png"> （3）一级卖点和次级卖点把金叉换成死叉即可 （4）风险点：在macd的快慢线上穿0轴时候的时刻判断不了是否能够上穿0轴进入多头市场，还是在0轴受阻再次下跌，风险点不是非卖不可的点，而是一个需要随时准备卖出的点，需要保持警惕的点。<strong>这时可以结合成交量分析</strong> （5）止损点就是macd指标跌破0轴进入空头市场的点（MACD柱也可以参考）</p><h4 id="趋向系统一般选择adx">趋向系统（一般选择ADX）</h4><p>指明趋势，并显示什么时候趋势的运动值得去追逐。它能帮助交易者在大趋势的主体部分获利。</p><p>正平滑趋向线和负平滑趋向线的关系能够确定趋，正平滑趋向线在上，说明趋势向上。负平滑趋向线在上面时，就说明趋势是向下的。通过两个趋向线可以计算出ADX （1）<strong>正负趋向线交叉时是个买入卖出信号</strong> （2）ADX增大是好的买入或卖出机会，表示市场的主导力量正在变强，趋势可能持续。在ADX值上升时，最好只用趋势跟随指标。 （3）当ADX下降时，表示市场的趋势正在减弱。这时可能产生很多假突破。当ADX下降时，最好不要用趋势跟随指标。 （4）当ADX落到两条趋向线之下时，则出现了趋向系统的最佳信号。它在此区域待得越久，那么下一次趋势的基础就越强。当ADX从两条趋向线下方开始回升时，意味着市场从平静中觉醒了。到底是熊市还是牛市取决于在上面的是哪条趋向线 （5）当ADX回升超过两条趋向线时，表示市场过热了。当ADX从高于两条趋向线的地方掉头向下，表示主要的趋势受到了阻碍，这正是趋势交易兑现利润的好时机。 <img src="Pasted%20image%2020240130202649.png"></p><p>注意：<strong>ADX是软指标。EMA改变方向是硬指标</strong>。比如A点到B点，ADX也上穿了绿线，但是EMA并没有改变趋向，软指标和硬指标冲突，相信硬指标。当绿箭头的位置，硬指标 + 软指标 共同指向了合适的买入位置</p><h4 id="平均真实波幅atr">平均真实波幅（ATR）</h4><p>平均真实波幅(ATR)是真实波幅TR在某一时间段内的平均值，常用的为13日均值。</p><p>克里·洛沃恩喜欢在移动平均线附近画三组线（在高于和低于EMA1倍、2倍和3倍ATR的位置），构成ATR通道线。<strong>它们能用于设定入场点、保护性止损位和盈利目标</strong></p><p><strong>ATR通道的方法不仅在价格方面有用。我们也可以将它和其他指标结合起来，来判断趋势有可能在哪些极端价位出现反转。我在周线图的强力指数上会结合使用ATR通道。</strong></p><h3 id="震荡指标">震荡指标</h3><p>趋势跟随指标能帮助我们辨认趋势——比如MACD线或者趋向系统，而<strong>震荡指标则能帮助我们抓住反转点</strong>。无论何时市场大众被恐惧或贪婪的情绪攫住时，人们都会蜂拥而上，但是过一阵子这种强烈的情绪又会逐渐消散。</p><p><strong>震荡指标就是测量这种冲击的速度的，并能显示出何时它的能量开始减弱。</strong></p><h4 id="超买超卖">超买超卖</h4><p>超买意味着市场点位太高，随时可能回调。当震荡指标到达前期的高位水平时，就形成了超买。超卖意味着市场点位太低，随时可能反弹。当震荡指标到达前期的低位水平时，就形成了超卖。一定要记住： （1）当一波强力的上升趋势开始后，震荡指标可以持续几个星期的超买状态，这样给出的卖出信号是过早的 （2）在急剧的下跌趋势中，也可能保持几周的超卖状态，这样给出的买入信号是过早的 （3）知道什么时候使用趋势跟随指标，什么时候使用震荡指标是成熟分析师的标志</p><p><strong>可以通过水平参考线来标记超买和超卖的震荡指标，划线的位置是让震荡指标只有5%的时间超出这些线之外。每3个月重新调整线的位置</strong></p><h4 id="macd柱">MACD柱</h4><p>背离现象</p><p><strong>要注意指标两个顶部之间的对0值线的突破，是真正背离所必需的因素。MACD柱状线在达到第二个顶点之前，必须低于0点。</strong></p><h4 id="相对强弱指标rsi">相对强弱指标RSI</h4><p>相对强弱指标(RSI)是由威尔斯·威尔德发明的一个震荡指标。它通过监测任意一种交易产品的收盘价变动来测量其强度。它是一个先行或者同步指标——从不滞后。</p><p>RSI的波动区间是0～100。当它到达顶点开始下降时，就确定了市场价格的顶部。当它下跌然后开始掉头向上时，就确定了一个底部。RSI底部和顶部的模式不会随着时间跨度增大而有所改变。交易信号在短期内的RSI上看得更清楚，比如7～9天的RSI（见图27-1）。 <img src="Pasted%20image%2020240130204048.png"> （1）当其上升到下参考线之上时，预示要上涨（图中以绿色垂直箭头标示） （2）当其下跌到上参考线之下时，预示要下跌（图中以红色垂直箭头标示）</p><p><strong>图中以倾斜实线箭头和虚线红色箭头标出的是相对强弱指标出现熊市背离给出的非常强的卖出信号</strong></p><p>图中右边缘处的尖锐跳空，不顾相对强弱指标发出的买入信号，将价格推向更低位。<strong>要避免受到伤害，我们必须使用保护性止损位，因为震荡区间里最后一笔交易，很容易在新趋势开始时造成亏损</strong>（你以外还会震荡上去，其实震荡阶段结束了，新的趋势已经形成）</p><p><strong>参考上面的案例，在趋势形成的边缘使用震荡指标是危险的，因此震荡指标要搭配好止损位</strong></p><p>水平参考线一定要能够穿过RSI的最高点和最低点。这些线通常是在30%和70%的地方。一些交易者在牛市中将其设置在40%和80%的水平上，或者在熊市中将其设置在20%和60%的地方。使用5%法则：每一条线都要保证RSI在过去的4～6个月中，位于参考线之上的时间少于5%。每3个月就调整一次参考线。</p><p>RSI能传达的重要信号有两种 1. 形成超买超卖的位置（RSI超过参考线） 2. 发生背离现象， （1）当价格上涨创出新高，但是RSI的顶部却低于其前一次上涨的顶部的时候。一旦RSI从第二次顶部下跌就马上可以卖空，同时在最近的新高价上方设置保护性止损单 （2）当价格创出新低，而RSI指数的底部比其前一次下跌的底部要高。一旦RSI从第二次底部开始上扬，马上可以买进并且在近期底部的价格最低点的下方设置保护性止损单 3. RSI通常比市场价格早几天突破阻力位或者支撑位，表现出了趋势可能要改变的迹象。RSI趋势线通常会比价格趋势线早1～2天被反转 （1）当RSI的下降趋势反转时，在最近的价格高位上挂一个买单来抓住这一次向上的突破； （2）当RSI的上升趋势反转时，在最近的价格低位上挂一个卖单来抓住这一次向下的突破。</p><p>注意：一个典型的新手会犯的错误就是“采购各种指标”，主观觉得股票可能上涨，但发现趋势没改变，于是通过找几个震荡指标，发现超卖，然后急切的买入，于是赔钱了。其实，<strong>震荡指标比较敏感，是要有几个指标之间佐证，几个时间周期佐证，并且在严格的交易系统下才可以使用的。</strong></p><h2 id="成交量和时间">5、成交量和时间</h2><p>尽管价格行情十分重要，但市场所包含的远远不只有价格一个维度，成交量给我们提供了另一种极具价值的参考维度</p><p>作为经验法则，在任何一个市场上 <strong>“高成交量”意味着高于其过去两周成交量平均值25%以上的成交量 “低成交量”意味着低于其过去两周成交量平均值25%以上的成交量</strong> （1）高成交量可以确认趋势。如果价格和成交量同时达到新的顶峰水平，价格将很可能保持高位或超过前期顶部后再创新高 （2）如果在趋势持续的过程中成交量缩水，那该趋势将发生反转。市场达到新顶峰时，其对应的成交量却不及达到上一个顶峰时的成交量，你就应该兑现多头头寸上的盈利或者抓住做空的机会。<strong>但这一技巧并不一定在市场处于下降趋势中时管用</strong>，<strong>因为下降趋势可能以一个很低的成交量来持续下去</strong>。华尔街流传着这样一句话：“将价格拉上去需要大家来买入，但价格会自行下降。” （3）观察趋势中反弹的成交量情况。当上升趋势出现回落时，由于慌张的获利了结盘，成交量会增加。当这种回落持续但成交量缩水时，表明多头不再逃跑或者抛压被消耗。当成交量耗尽时，下跌带来的抛售效应已经接近其尽头，上升趋势将重新开始。 ### 集散指标(A/D) 集散指标比OBV指标得到更好的调整，因为它只用当天交易量的一定比例归入到多头或空头势力中去，按照双方当日获胜的程度作为其比例</p><p>A/D = （（收盘价 - 开盘价）/ （最高价 - 最低价） ） * 成交量</p><p>A/D高低的形态十分重要，而它的绝对值水平主要受计算基准日影响（不必太关注数值） （1）如果价格上涨创新高但A/D值却没有随之创新高，则出现了卖出信号。这种熊市背离表明市场上专业投资者在上涨过程中卖出。 （2）牛市背离发生价格创新低但A/D值却没有创新低时，表明了市场上专业投资者在下跌过程不断买入并逐步建仓，反弹即将到来（见图29-2）。 <img src="Pasted%20image%2020240131162538.png"></p><p>当你根据A/D值与价格之间的背离为依据，进行做多或做空的时候，记住就算是市场上专业的投资者也会犯错。你需要设置止损单并用巴斯克维尔的猎犬法则（见第23节）来保护自己。 （A/D是个软指标）</p><h3 id="强力指数">强力指数</h3><p>强力指数指标=今日成交量×（今日收盘价-昨日收盘价） 然后使用2日和13日均值平滑</p><p>当强力指数指标上涨到新高时，表明多头的力量很强大，上升趋势将得到持续；当强力指数指标下降到新低时，表明空头的力量很强大，下降趋势将继续维持</p><p>因为2日EMA是一个敏感的指标，我们可以用其来对其他指标给出的信号进行微调。当趋势跟随指标确认了上升趋势时，同时2日EMA值下降到0以下，此时便是一个绝佳的买点——在长期上涨趋势中的回调期进行买入（见图30-1）。当趋势跟随指标确认了下降趋势，2日EMA的上升给出绝佳的卖出区域。 （1）市场处于上升趋势时，在2日强力指数EMA变负时买入。 （2）市场处于下降趋势时，在2日强力指数EMA变正时卖出。</p><p><strong>此外，2日EMA可以帮助我们决定什么时候建仓，你可以在上升趋势中每次强力指数指标变负时加仓，你也可以在下降趋势中每次强力指数指标变正时减仓。</strong></p><p>2日EMA也能帮助我们决定何时清仓。它通过确认短期反弹或回调来实现该作用。在2日EMA值为负的时候买入的短线交易者可以在该值变正的时候卖出</p><p>强力指数指标甚至还可以让我们瞥见未来的一角。当2日EMA值在当月内降低到最低点，说明了空头力量十分强大，并且价格将降得更低；当2日EMA在当月内升高到最高点，这说明了多头力量十分强大，并且价格将升到更高水平。</p><p><img src="Pasted%20image%2020240131163343.png"></p><h3 id="技术指标结合基本面">技术指标结合基本面</h3><p>按照时间长短，可以把交易划分： （1）长期交易或长期投资。即持有仓位的时间以月为单位，有时甚至以年为单位。优点：可以获得可观的长期投资收益，同时避免每天盯盘对精力的消耗。缺点：体现在跌势中持有时间过长亏损可能会很严重，让人无法忍受。 （2）波段交易。即持有仓位的时间以日为单位，有时候以周为单位。优点：有较多的交易机会，能做到严格的风险控制。缺点：可能会错过趋势中的主升浪。 （3）日内交易。即持有仓位的时间以分钟为单位，也有以小时为单位的。优点：有很多的短线交易机会，不存在隔夜风险。缺点：需要对市场的快速反应能力，并且频繁地交易会带来较大的交易成本。</p><p>长期投资以基本面为基础，但可能遇到较大的回撤是长期投资普遍会遇到的问题（亲身经历）。很少有人能有动力持有，以苹果为例 <img src="Pasted%20image%2020240131163803.png"> （1）2003年——AAPL股价跌到10美元以下，公司能否生存下去都成了问题，你会买公司的股票吗？ （2）2006年——AAPL股价飙升到86美元，然后缩水至51美元。如果此时你持有1000股，你会继续持有下去吗？在当其股价反弹回80美元并看上去要再次下跌时，你会不会卖出呢？ （3）2008年——AAPL股价飙升到202美元，然后又降到115美元，如果你持有1000股，看到了自己（4）2009年——AAPL股价回升到了192美元，后来又降至78美元，比先前的低点还要低，你的账面资产将经受超过50%的损失，你是继续持有还是选择将其变现？</p><p>现在回想起来苹果公司股票的上涨趋势可谓气势非凡，但是扪心自问，你有能力始终持有苹果公司的股票吗？要注意苹果公司期间经历了多次下跌，<strong>有些甚至跌去了50%以上</strong>。要知道，这种程度的下跌往往是标示着上升趋势已经结束了的。</p><p><strong>应对长期投资带来的挑战的一种明智的方法就是在技术分析交易工具的帮助下坚持并执行你对基本面的判断。</strong></p><p>当你决定买入时，可以参考技术指标来确保你买入的价格相对市价买入要便宜一些。如果你的投资很成功，资产价格飞涨，可以使用技术分析工具来确认被过度估值的价格区域。在该区域内兑现你的盈利并且准备好在不可避免的下跌回调过程中再次买入。<strong>这种投资计划需要高强度的专注以及坚持不懈的精神</strong>（坚信基本面 + 坚持做波段）</p><h4 id="波段交易">波段交易</h4><p>我强烈推荐初级和中级投资者进行波段交易。你交易的越多，从中学到的也就越多，可以帮助你积累风险管理和做好交易日志记录的经验。波段交易教起你来比需要几年才能完成学习课程的长期投资更快。</p><p>（13日EMA，26日EMA + 通道 + MACD线和柱 + 动力系统 + 2日强力指数）</p><h2 id="市场指标">6、市场指标</h2><p>没啥好讲的</p><h2 id="交易系统">7、交易系统</h2><p>交易系统是寻找、进入和退出交易的一整套规则（就像手术医生做手术要麻醉，消毒，开刀等一套流程）</p><p>注意：交易系统需要经过手动测试。 准备好每日的价格和成交量数据，时间跨度至少为两年，接着开始测试自己的交易系统。一次推进一天，趋势和震荡区间会慢慢挑战你的系统，你还需要在这个过程锻炼自己的决策技巧，就像经历了股市这几年一样</p><p><strong>如果逐条逐次的测试显示的结果是积极的，你便可以开始用较小头寸的真实资金进行交易了。</strong></p><p>初学者可以从模拟交易开始，但是大多数人是自己的账户被市场打爆后才转向模拟交易的。如果一个人在模拟中没有损失，在实操时损失大，说明： （1）人们在模拟交易中会少一些情绪化，好的决策也容易在没有真实风险的情况下做出 （2）在模拟交易中，你的指令总是能完全成交，真实交易环境下则未必能轻易成交 （3）最重要的一点是，一笔好的交易，当你还在考虑的时候它往往看起来很朦胧。而看起来轻轻松松的交易机会，则往往会伴随各种未知风险。紧张的初学者很容易跳入轻松的交易机会之中，最后以损失告终。</p><p>心理因素对交易影响巨大，进行模拟交易的唯一的好处，就是测试你的纪律性和你的系统。</p><p><strong>如果你能在每天日终坚持下载行情数据，自己做功课，提前准备好下一交易日你要做的交易指令，次日观察开盘情况并记录下你的入场情况，然后每天根据市场情况调整盈利目标和止损点——如果能连续几个月坚持做这组动作，并且一天不缺地记录你的操作日志——这样你就掌握交易真实资金的纪律了。</strong>（以冲动和娱乐为主的人是做不到的，这是要吃苦的）</p><h3 id="三重滤网交易系统">三重滤网交易系统</h3><p>三重滤网交易系统称之为中期时间周期。长其一号的是长期时间周期。短其一号的是短期时间周期</p><h4 id="第一重滤网市场潮流">第一重滤网——市场潮流</h4><p><strong>总结：使用趋势跟随指标识别周趋势并随着趋势的方向交易</strong></p><p>三重滤网从分析<strong>长期图表</strong>开始，三重滤网要求我们在看日线图之前，先要去分析周线图。MACD的斜率由最近两根MACD线柱之间的关系确定，此时会给出一个信号。</p><p>当MACD的斜率转而向上时（箭头A、C和E），它只允许我们在买入或者观望的方向上交易。当斜率转而向下时，它只允许我们在卖出或者观望的方向上交易。</p><p>注意在A点或者E点的买入信号要比在C点的买入信号质量高——因为C点的买入信号产生在中心线之上。 <img src="Pasted%20image%2020240130210830.png"></p><p>交易者有三种选择：买、卖或者观望。三重滤网交易系统的第一重会帮你排除其中一个选项。（记住要在更高一级时间周期里做判断）</p><h4 id="第二重滤网市场波浪">第二重滤网——市场波浪</h4><p>当周趋势是上升的，日趋势的回调正是很好的买入机会。当周趋势是下降的，日趋势的上升正是很好的卖出机会。</p><p>第二重滤网应用的是前面章节讨论过的震荡指标。将其应用到日线图之中以识别日趋势和周趋势之间的偏离。</p><p>将震荡指标应用于日线图之中。在周线的上升趋势中，利用日线的回调来寻找买入机会；在周线的下降趋势中，利用日线的反弹来寻找卖空机会。我喜欢在第二重滤网使用强力指数(force index)，这个指标在第30节已经介绍过。其他一些震荡指标，比如相对强弱指标(RSI)、埃尔德射线(Elder-ray)和随机指标(stochastic)等表现得也很不错。</p><p><img src="Pasted%20image%2020240130211133.png"> 2日强力指数指标EMA可以用作三重滤网交易系统第二重的众多震荡指标之一。当它下降到其中心线之下的时候，强力指数标记出买入的机会。当它上升到其中心线之上的时候，它会标记出卖出的机会。当周趋势是上升的（这里用绿色的水平线标出），在日线震荡指标中仅采用买入信号，以建立多头头寸。当周趋势是下降的（这里用红色的水平线标出），在日线震荡指标中仅采用卖出的信号，以建立空头头寸。</p><p>其他的震荡指标，比如随机指标和相对强弱指标（详见第26节、第27节），当它们进入各自买卖区域的时候会发出交易信号，采取类似的处理即可</p><h4 id="第三重滤网买入技术">第三重滤网——买入技术</h4><p>平均穿透值的计算： 使用日线图中的13周期EMA作为标准，当日内价格低于13日EMA时，记录一下日内价格和EMA的距离。然后选定4-6周的时间范围，逐日计算是否有穿透以及穿透的距离，再计算出平均穿透距离</p><p>用今日的EMA值减去昨日的EMA值，将其结果加回今日的EMA值：这是对明日EMA值的一个估算。用估算的明日EMA值减去你计算的平均穿透值，作为明日设置买入订单的触发价位。</p><p>你将利用回调以折扣价完成买入交易——避免了在突破时买入须支付的溢价。</p><p><strong>但是这种方法最大的问题是牛市时可能不会有这么大的回撤，在纳斯达克指数的测试中，仅仅交易了四次。为此，可以缩短时间范围，或者换别的买入方法</strong></p><p><img src="Pasted%20image%2020240130211658.png"></p><p><strong>突破法（另一种买入方法）：</strong> 当日线趋势与周线趋势相反时，经过短暂调整日线趋势会继续与周线趋势保持同步。此处以上升趋势为例，假设周线趋势向上，日线震荡指标向下，我们可以观察每日价格是否突破前一日最高价，如果突破前一日最高价，可以买入，同时把前一日的价格低点作为止损位。如果当日没有超过前一日最高价，则按照上面的操作继续，直到买入或者周线趋势变为下降</p><p><img src="Pasted%20image%2020240130211421.png"></p><h3 id="动力系统">动力系统</h3><p>注意：动力系统是应用在三重滤网交易系统中第一重的方法</p><p>动力系统能够加强任何一种寻找交易机会的方法，无论是技术分析还是基本面分析。</p><p>要度量任意交易品种的惯性，一个好的指标是短期EMA的斜率。上升的EMA意味着具有牛市惯性，而下降的EMA则说明具有熊市惯性。任意趋势的能量可以用MACD柱状线的斜率来表示。如果它的最近一根线柱比其前一根线柱的高度要高（像字母m-M的高度变化），或者是比其前一根线柱的深度要浅（像字母y-v的深度变化），则MACD柱状线的斜率是上升的，所以它的能量是向上推动的。</p><p>如果最近一根线柱比其前一根线柱要低（像字母M-m的高度变化或字母v-y的深度变化），则MACD柱状线的斜率是下降的，所以它的能量是向下推动的。当我们使用MACD柱状线来定义能量时，它是否高于或者低于零是无关紧要的：真正重要的是最近两条MACD线柱之间的高低关系。</p><p>运用动力系统的原理，在大多数交易软件进行编程，实现价格图表或蜡烛图的颜色显示，这并非难事。当两个指标都是上升的时，线显示的是绿色；代表牛市，如果都是下降的，线显示的是红色，代表熊市；当两个指标相互方向相反时，线显示的是蓝色，代表市场是中性的</p><p><img src="Pasted%20image%2020240130212558.png"></p><p><strong>垂直的绿色箭头标志的柱线后面紧跟着红色的柱线。红色禁止你买入。最好的买入时机是当红色消失的时候。你能看到这些绿色箭头指示出一个接一个的中期底部，包括在图表右边界的买入信号。拥有一个客观的方法能让你在市场下降停止的时候有买入的信心。</strong></p><p><strong>动力系统也会对兑现利润的好时机给出建议。倾斜的红色箭头指向蓝色柱线，蓝色柱线出现在一系列远离价值区域的绿色柱线之后。它们显示牛市上行受阻的位置——兑现盈利的好时机，并等待下一个买入机会</strong></p><p><img src="Pasted%20image%2020240130212739.png"></p><p>短期动量交易者： 如果你是个短期动量交易者，一旦动力系统显示的颜色不再支持你的交易方向，则马上了结你的交易，即使在两个时间周期中只有其中一个改变了颜色。通常，日线MACD的反转要快于周线MACD。当它在上升趋势中下降，表明上升的动量正在减弱。当买入的信号消失时，马上兑现收益，而不是等待出现卖出的信号。在下降的趋势中将这个做法反转一下。一旦动力系统不再显示红色，即使两个时间周期中只有其中一个改变了颜色，也马上清空你的空头头寸。最有效的下降部分已经结束，动力系统已经完成了它的使命。</p><p>动力交易系统鼓励你小心谨慎地入场，但快速地退出。这是专业的交易方法。</p><p>如果两个时间周期中的任意一个变成了蓝色，波段交易者或许仍会持有交易头寸。波段交易者要避免，时间周期中任意一个的颜色与交易的方向变得相反。如果你是多头，时间周期中的一个变成红色，则是时候卖出并空仓观望了；如果你是空头，当动力系统开始变绿，它就发出了让你平掉空头头寸的信号。</p><h3 id="通道交易系统">通道交易系统</h3><p>之前我们已经讨论过使用两条移动均线为一组，来进行交易（见第22节）。使用这组移动均线，并将<strong>长期移动均线作为通道线的核心</strong> 上通道线=EMA+通道系数×EMA 下通道线=EMA-通道系数×EMA</p><h4 id="自动包络">自动包络</h4><p>作者使用了自动包络，当为任意市场设置通道线的时候，开始通道系数可以设置为3%或者5%，然后不断调整通道系数值，直到通道线把最近100根线柱的所有价格数据中大约95%的包含在内，在日线图上大约是5个月时间长度。</p><p>实际操作时，同花顺上的参数设置是固定的，不是自动修改通道线的，所以这个方法需要自己写代码</p><h4 id="atr通道线">ATR通道线</h4><p>三组通道线分别设置在离移动平均线的1倍、2倍和3倍ATR的位置。正常的波动往往在1倍ATR的通道内，只有极端的波动会冲出3倍ATR通道，这往往也预示着反转即将临近</p><p><img src="Pasted%20image%2020240131154258.png"> 区域A——警告。价格跑出+3倍ATR——上升趋势到达了极限。 区域B——卖出。价格不能保持在+2倍ATR上方——多头兑现利润。 区域C——警示。价格下降到+2倍ATR位置停止——为底部的标志。 区域D——警示确认。价格稳定在+2倍ATR上方——底部已经筑成。 区域E——买入。向下假突破试探了+3倍ATR的位置，但不能维持这个低价（看后续、交易量，收盘价和次日开盘价等来判断） 区域F——警告。价格跑出+3倍ATR——看+2倍ATR是否能支撑住。 区域G——警告。价格跑出+3倍ATR——看+2倍ATR是否能支撑住。 区域H——又一个警告。价格跑出+3倍ATR——看+2倍ATR是否能支撑住。 区域I——卖出。价格不能维持在+2倍ATR上方——多头兑现利润。</p><h4 id="通道-macd的实战案例">通道 + MACD的实战案例</h4><p><img src="Pasted%20image%2020240131154822.png"></p><p>区域A——当价格到达下通道线，MACD线的新低表明这个低点将会被再次确认或者突破。 区域B——通道线拒绝了突破，反弹有可能即将开始。 区域C——价格到达上通道线并且被弹回——有可能发生反转 区域D——买入。<strong>价格已经到达下通道线</strong>，<strong>但MACD显示在A与D之间有牛市背离</strong>，中间由C点隔开。 区域E——<strong>价格到达了上通道线，MACD创了新高</strong>，表明这个高点很有可能被再次确认或者突破。 区域F——完全回归价值区间；MACD向下突破到0值线之下，创造了一个熊市背离的迹象，但仍可买入等待回到前期高点。 区域G——卖出并反向做空。价格已经到达了上通道线，然而MACD在高点E和G之间已经表现出熊市背离，中间由F点区隔开</p><h2 id="标准背离通道布林通道">标准背离通道（布林通道）</h2><p>这个通道线的特别之处在于它的宽度和市场的波动有关。它们的交易规则和常规的通道不一样。 （1）计算21日EMA； （2）用收盘价减去21日EMA，得到与均值之间的偏差； （3）将这些差值的平方加总，获得总方差； （4）用总方差除以EMA的长度，得到平均方差； （5）将平均方差开平方根，得到标准差。</p><p>上下两个通道分别是EMA + 两倍标准差（或者自己设置更大的宽度）</p><p><strong>当市场的波动性增大的时候，布林通道的宽度会增加； 当市场波动性减小的时候，布林通道会变窄。 窄的布林通道表明市场处于休眠的、安静的状态。 大的行情常常从平坦的底部位置上爆发。布林通道帮助我们发现市场从安静到活跃的转变。</strong></p><h2 id="交易工具">8、交易工具</h2><p>股票、期权、期货、汇率、等</p><h2 id="风险管理">9、风险管理</h2><p>即使是最周全的交易计划也有可能会出差错，因为市场有随机性。即使是最好的分析和最清晰的交易结构也不能完全避免事故的发生。你唯一能控制的只有风险。可以通过管理交易规模、设立止损线来控制风险。这样你才能将不可避免的损失保持到最小，不让损失拖累你的账户，在长期中才能获得成功。 ### 2%法则</p><p>这个法则是用来防止“鲨鱼”一击</p><p><strong>2%原则会防止你的账户在单次交易中出现本金亏损2%以上的风险。</strong></p><p>举个例子，如果你账户中有5万美元，那么2%原则要求你每次交易承担的最大风险控制在1000美元以内。这不是交易规模，而是账户中本金风险的大小，基于入场点和止损点之间距离大小来计算。</p><p>假定你决定按40美元的价格买入股票，止损线设在38美元。这意味着你每股要承担2美元的风险。你总的可承受风险为1000美元，除以每股2美元，得到你可以交易不超过500股。当然，你愿意交易更少的股票更好，并不需要每次都以最大额度买股票。如果你对那只股票非常有信心，想尽可能多地买入，最多可买的数量为500股。</p><h4 id="如何计算合适的交易规模">如何计算合适的交易规模</h4><p>下一笔交易你准备买入或卖空多少数量的股票呢？新手经常会随意地选择一个数量，比如说1000股或200股，如果他们上一笔交易挣钱了，他们可能会多买一些，如果他们上一笔赔钱了，这一笔就会少买一些。</p><p>事实上，交易规模应该是根据公式计算出来的</p><p>A.你计划要进行的交易的最大风险额度（永远不能超过账户规模的2%）。 B.你预计的进场位和止损位之间的价差——你每股所承担的风险。 C.将A除以B，得到所能交易的最大股数。你并不一定要交易这么多，但是不应该超过这个数字。</p><h3 id="法则">6%法则</h3><p>2%法则只能防止鲨鱼，不能防止一次一次下跌的食人鱼。</p><p>6%原则给每一个账户都设定了一个当月最大回撤比例。如果你达到了限制，这个月接下来的时间就要停止交易。6%原则强制你在受到食人鱼攻击前，从水里走出来。</p><p><strong>当你这个月总损失和持仓头寸的风险额度之和达到账户总金额的6%时，在本月剩下的时间内，6%原则将不允许你进行新的交易。</strong></p><h4 id="可用风险的概念">可用风险的概念</h4><p>在你下单交易前，问一下自己：<strong>如果你所有的交易都向不利于你的方向发展怎么办？</strong> 如果你用2%原则来设定止损位和交易规模，那么6%原则能给你的账户设定最大风险额度。 （1）把你这个月所有的亏损加总 （2）把你现在所有的持仓头寸的风险额度加起来。 假如你以50美元的价格买了200股股票，止损价是48.50美元，每股承担的风险是1.50美元。这样，你该笔交易的风险额度是300美元 （3）两项相加得到总的风险额度，这个额度应该少于月初账户资产的6%</p><p><strong>6%原则将一个常见的问题——“我有足够的钱进行这次交易吗？”——转变成了一个更有意义的问题——“我对这次交易有足够的风险承受能力吗？</strong></p><p>当你已经接近6%原则的限制，但发现了一个非常有吸引力的交易机会，此时你有两种选择：你可以兑现一个盈利的持仓头寸来释放可用风险额度；也可以收紧一些持仓头寸的止损线，减小持仓的风险。只要保证你想要的交易可以进行，而原持仓头寸的止损线又不至于过紧就行</p><h2 id="实践细节">10、实践细节</h2><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">总结：一次交易 </span>=<span class="hljs-string"> 基本面分析选股 + 技术分析确定入点 + 止损位和盈利位选择 + 风险额度计算 + 对交易进行阿氏评分（确认是否买入） + 执行操作 + 制作交易表格和日志 + 持续关注 + 交易结束后复盘</span><br></code></pre></td></tr></table></figure><p>基本面选股不在这本书的范围内</p><p>之前的内容通过三重交易系统确认了买入点</p><h3 id="如何计算盈利目标">如何计算盈利目标？</h3><p>新手没有清晰的盈利目标，当股票价格上涨时他们非常高兴，而当它们下跌时他们又感到特别沮丧。他们的情绪会引导他们在最坏的时机做出反应：在最高点买入，并继续持有；在最低点卖出。</p><ol type="1"><li>波段交易：在价值区间兑现利润</li><li>日内交易：上通道线是盈利目标</li><li>长线交易：阻力位为长线交易设定的盈利目标</li></ol><p><strong>可以设置多个目标分批止盈</strong></p><h3 id="如何设置止损目标">如何设置止损目标？</h3><p>没有设止损价位的交易就是赌博，不要让止损之后立刻上涨这种事情成为不止损的理由，纪律就是纪律。</p><h4 id="安全区域止损趋势交易时">安全区域止损（趋势交易时）</h4><p>先度量市场噪声，再把止损位设在市场噪声区域外数倍的位置。</p><p>例如使用22日EMA来定义为趋势线。如果趋势是向上的，标记出所有回溯期（10～20天）内向下穿透EMA线柱的深度值，将其加总后除以向下穿透的线柱数量，得到回溯期的平均向下穿透值。它反映了当前上升趋势中平均的噪声水平</p><p>你应该把止损位设在远离市场平均噪声水平的位置，把平均向下穿透值乘以一个系数，通常是2以上的数字。如果止损位设得太近容易弄巧成拙。</p><p>注意：<strong>止损位设在并不明显的位置比较好</strong>——要么更接近市场目前水平（波段交易），要么离明显位置更远一点（长期交易）。更近的止损位可以减少亏损规模的风险但是会增加被洗盘出局的风险。更低的止损位可以躲过一些假突破，但是一旦真触及止损，亏损规模会更大</p><h4 id="次低点止损">次低点止损</h4><p>把止损位设在近期的次低点，而不是设在最低点附近。这里面的逻辑很简单——如果股价跌到了次低点附近，那么很有可能还会继续下跌并触及最低点，而这正是止损单扎堆的位置。使用尼克止损法后，同样市场下跌情况下，承受的损失和滑点要少很多</p><h4 id="atr止损">ATR止损</h4><p>当你在最近的一根线柱中入场时，把你的止损位设在离当前这根线柱的极值至少一倍ATR的位置，如果是在两倍ATR的位置设置止损位就更安全了。</p><p>你可以把它当作一种移动止损的方法，随着线柱的转变而移动它。原理还是一样的——把止损位设在市场噪声区域之外</p><p>使用移动止损的一个优点是它们逐渐减小了所暴露的风险额度。前面我们讨论过“可用风险”的概念。使用移动止损时，如果交易价格朝对你有利的方向变化时，它可以逐渐释放可用风险额度，从而允许你开始做新的交易。</p><p>但是坏处在于，其他的止损方式，随着价格上涨，止损点一开始是不变的，上涨越多离止损位越小，受到噪声波动的概率越小。而ATR是始终改变的，受到噪声波动的概率是一致的</p><h4 id="不要让盈利变成亏损">不要让盈利变成亏损</h4><p>当交易的发展已经兑现了你的预期，这笔交易的盈利潜力逐渐变小。而你的风险（盈利和止损线之间的距离）会不断增加。交易就是在管理风险，当盈利与风险的比例渐渐恶化时，你便需要减小承担的风险。通过提升止损线，保护一定比例的利润，可以使盈利与风险比例控制在更平衡的位置。</p><p>提前设定好当盈利达到多少时，将止损点变为盈亏平衡点</p><h4 id="只顺着你交易的方向移动止损线">只顺着你交易的方向移动止损线</h4><p>当接近止损线时，市场出现了一个上涨信号，此时注意千万不能给下跌更大的空间。“给下跌更大的空间”只是一种美好的、单纯的想象。这个选项不应该出现在一名严谨的交易者的工具箱中。</p><h3 id="如何评价交易">如何评价交易？</h3><p>买入评级=（最高价-买入价）/（最高价-最低价），大于50%就是不错的成绩 卖出评级=（卖出价-最低价）/（最高价-最低价），大于50%就是不错的成绩</p><p>交易评级=（卖出点-买入点）/（通道线高点-通道线低点）。任何一笔交易的获利是通道线高度的30%或是更多，就是一笔A级交易</p><p>好的通道线包含过去100天日线里90%～95%的价格（参考第22节）。你可以使用任何通道线——EMA的平行线、自动包络线、肯特纳通道或者ATR通道——只要你前后标准始终一致就行。</p><h2 id="保持良好的习惯">11、保持良好的习惯</h2><p>每天看新闻，关注宏观经济指标的日期，关注财报的日期</p><h3 id="阿氏交易评分">阿氏交易评分</h3><p>任何交易计划都要依据所采用的策略量身定做。交易计划必须能提示你检查财报期、分红派息日期，以及期货交割日期，使你避免被可预见的新闻所侵袭。它必须清楚地记录你计划好的买入价、目标价、止损价以及交易规模。</p><p>把交易计划写下来能让其变得真实。一旦你进入了一笔交易，并且你的股票开始出现波动，你可能会感到紧张，而忘了去执行特定的操作。在进入交易之前，先写下计划能帮你在风暴中建立一个理智和稳定的堡垒，它能帮助你不会忽略任何必要的事情。</p><p><img src="Pasted%20image%2020240131173615.png"></p><p>（1）强力系统的周线图（前面章节有描述）——周线图是红色得0分，周线图是绿色得1分，周线图是蓝色得2分。强力系统为红色时，是禁止交易的；绿色时还可以进行交易，但是可能有些太晚；蓝色（紧跟在红色之后）表示恐慌正在褪去，是买入的好时机。 （2）强力系统的日线图——与上一条同样的问题、同样的评分，标记在日线图上。 （3）日线价格——在日线图上，如果最新价格在其价值区间之上得0分；在价值区间范围内得1分；低于其价值得2分。价格在价值区间之上时，买入已经有些迟了；在价值区间内还可以；在价值区间之下则是一笔好买卖。 （4）假突破——没有的话得0分；已经发生得1分；很有可能将要发生得2分。 （5）完备性——没有周期符合得0分；有一个符合得1分；两个周期看起来都很完备得2分。</p><p><strong>总分7分及以上才能买入</strong></p><h3 id="写交易表格">写交易表格</h3><p><img src="Pasted%20image%2020240131174123.png"></p><h4 id="第一部分交易鉴定">第一部分：交易鉴定</h4><p>分别写下股票代码（名称）、下一个财报的披露日期、除息日、制作表格的日期</p><h4 id="第二部分交易的阿氏评分">第二部分：交易的阿氏评分</h4><p>前文提到了 #### 第三部分：市场、买入点、目标价、止损点和风险控制 最左边的五个空格要求我回答有关市场基本状况的问题。尖峰反弹信号是否有效，追踪股票均线的指标是看多还是看空，这只股票的空头净额是多少，需要多少天来补上，所有这些内容都已在本书前面描述过。最后一个空格是简短的总结。</p><p>用箭头所连接的三个空格是我决策制定过程的核心部分。它们所要的是每笔交易最重要的三个数字：买入价、目标价、止损价。</p><p>资金风险——这笔交易中，你愿意冒亏损多少钱的风险？这个数额永远不应该超过你账户资产的2%。我通常把它控制在远远低于这个门槛的位置。</p><p>持仓规模——根据持仓限额和入场点与止损点的差额，可以算出你能买多少数量。这已经在第50节“风险控制的铁三角”中详细论述过。</p><h4 id="第四部分买入之后">第四部分：买入之后</h4><p>A级盈利目标是在买入价上加日通道线高度的30%。软止损是记在脑海中的指令，而硬止损或灾难性止损是实在的指令。它不应该比第三部分中所写的止损价低。记下你将把止损位移到盈亏平衡位置的价格水平。当你执行这些必要步骤时，检查右手边的方框：设置止损价，创建一个日志，下达止盈订单。</p><h4 id="第四部分备注">第四部分：备注</h4><p>自己再补上一些买这个股票的原因，避免很快忘掉这个交易，无法复盘。 当时你在K线图最右边区域艰难地决定买入卖出，如今这些K线已经到了图表的中间位置了，这个时候你可以重新审视你当时的决定，并学会如何改进它们</p><p><strong>回顾你的资产曲线是非常必要的，因为只有上升的曲线才能证明你是一位成功的交易者。如果你的资产曲线是下行的，说明或者你的系统可能有错误，或者你的风险管理十分薄弱，或者你缺乏交易纪律性——无论是什么，你都必须查找清楚并予以解决</strong>。</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">总结：一次交易 </span>=<span class="hljs-string"> 基本面分析选股 + 技术分析确定入点 + 止损位和盈利位选择 + 风险额度计算 + 对交易进行阿氏评分（确认是否买入） + 执行操作 + 制作交易表格和日志 + 持续关注 + 交易结束后复盘</span><br></code></pre></td></tr></table></figure><p>写在最后，我的指标是什么呢？ EMA（13，26） + 布林带 + 动力系统 + MACD + 强力系统 + ADX + RSI</p>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以交易为生（下）</title>
    <link href="/2024/01/29/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2024/01/29/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本部分包含风险管理、实践细节、如何养成记录习惯</p><h2 id="风险管理">风险管理</h2><p>好的交易系统在一段时间内实现的盈利比亏损要多，但即使是设计最细致的交易系统也不能保证每次交易都成功。没有交易系统可以确保从不遭受亏损，甚至要避免出现一系列连续亏损都很难。</p><p>没有管理亏损的能力是交易中最严重的缺陷之一。当不断恶化的损失将前期很多次成功交易的利润吞没时，新手会像车头灯前被吓住的鹿一样，僵在那儿。一般人的本性都是很快就止盈，但却会一直拿着亏损的交易，希望能回本甚至盈利。</p><p>当这些业余的交易者放弃了希望，在巨亏后平掉头寸的时候，他们的账户往往已经严重亏损甚至无可挽回了。要想成为成功的交易者，你需要学习风险管理规则，并严格执行它们。</p><h3 id="情绪与概率">情绪与概率</h3><p>金钱能激发强烈的情绪。赚钱或者赔钱产生的情绪会影响我们的交易</p><p>我在事业之初，曾听一位专业的交易者说：“成功的交易应该是有些无聊的。”他每天都花费很长的时间做功课，筛选市场数据，计算风险，坚持记录。这些耗时的任务并不有趣——但他的成功正是建立在这些枯燥乏味的工作之上的。新手和赌徒们觉得很好玩，但结果是以损失为代价。</p><p>另一种错误是反复盘算持仓头寸中的盈亏。<strong>新手幻想着持仓浮盈可以买到什么</strong>，或者比较持仓浮亏和自己的工资，就吓傻了。反复想钱的问题，干扰了我们及时去做决定。<strong>专业的交易者总是集中精力管理交易，他们只有在平掉头寸之后才会去关注账户中的资金。</strong></p><p>专业的交易者不会在持仓过程中计算得失。他们只是在账期末——比如说月末，才会去统计盈亏情况。如果你要问我的持仓情况怎样，我会回答稍微盈利、较大盈利或稍微亏损（较大亏损是不可能的，因为我会及时止损）。</p><p>如果你一定要我说出具体数字，我可能会说我赚或赔了几个点，但从不会转换成具体多少金额。持仓时去计算得失是很不好的习惯，我花了好几年的时间才让自己克服掉这个不良习惯。我可以关注收益或亏损的百分点，但是我不会把它们转化成钱来考虑。</p><p>另一个关键点是：专业人士不会因为单次交易的成败而生气。在市场中有太多的随机成分。交易中我们可能每个步骤都是对的——但是仍然可能会以失败告终，就像外科医生可能把每件事情都做对了，但仍然可能救不好一个病人。</p><p><strong>在市场中，梦想是我们承担不起的奢侈品。</strong></p><p>夏皮罗博士曾做过一项测试，说明人们对待商业机会的行为模式。首先，要求一组人从两种情形中选择一项：一是75%的机会获得1000美元，25%的可能什么都没有；二是直接获得700美元。五分之四的人选择了选项二，即使是向他们解释了长期来说选项一的预期收入是750美元。大部分人都做了情绪化的决定，只得到了较小的收入。</p><p>另一个测试的两个选项：一是人们必须选择确定的亏损700美元；二是75%的可能损失1000美元，25%的可能什么都不损失。四分之三的人选择了选项二，比起确定损失700美元，他们情愿多损失50美元。为了避免风险，他们最大化了损失。</p><p><strong>情绪化交易者渴望确定的回报，放弃了利润最大但包含不确定性的机会。他们选择赌博来推迟损失兑现。==迅速兑现盈利，推迟兑现损失，这是人类的天性==</strong></p><p>（其实这个论证是有问题的，因为量化交易的理论里面有一个很重要的概念叫效用模型，因为生活成本问题，不同人的效用模型是不同的， 比如有1000w会更着重于争取100w的收益，而有1000块则会更注重不造成100的亏损）</p><p>最好的交易系统简单而稳定。它们的构成要素很少。系统越复杂，其部件出错的风险越大。</p><p>交易者喜欢用历史数据回测来优化系统，但问题是你的经纪商不会让你回到历史去交易。市场在变化，一个指标能很好地跟踪过去一个月趋势不一定会很好地预测未来一个月的走势。所以不要优化你的系统，而是解除对系统的优化。稳定的系统能经受住市场的变化，在真实交易中可以战胜过于优化的系统</p><p>最后，一旦你开发出了一个好的系统，不要再改来改去。如果你喜欢修修补补，那就再去开发一个系统。罗伯特·普莱切特(Robert Prechter)曾提出：“大多数交易者有一个很好的交易系统，但为了改造成一个完美的系统反而毁了它。</p><p><strong>一旦你有了一套能稳定运行的系统后，接下来要制定资金管理规则，帮助你从敏锐的交易系统中获得正的期望收益。资金管理规则能帮助开发出一个好的系统，但并不能拯救一个没用的交易系统。</strong></p><h3 id="风险控制的两个原则">风险控制的两个原则</h3><p>有两种方式可以快速毁掉一个账户：从不使用止损和持有相对账户来说过高比例的仓位。</p><p>没有设置止损的交易会使你暴露在无限的损失之中。在接下来的章节中，我们会讨论风险控制的原则和规则，但只有你真正使用止损策略时它们才会起作用。</p><p>另一种致命的错误是过度交易——相对于你的账户来说持有过高的仓位。这就像在一艘小船上装上了一个大帆——一阵强风会将船掀翻，而不会使它跑得更快</p><p>人们之所以持有过高比例的仓位，是由于无知或贪婪，或者是二者兼有。有一条简单的数学理论会帮助你确定每次交易的最大规模，接下来会进行介绍</p><h4 id="法则">2%法则</h4><p>单次交易出现灾难性的亏损对账户来说，就像倒霉的游泳者被鲨鱼袭击了。可怜的新手在一次交易中就亏了四分之一资金，就像是被鲨鱼咬去了一条胳膊或腿，鲜血在海里弥漫。在后面的交易中，他必须要有33%的收益才能回本，而他能够做到的机会微乎其微。</p><p><strong>==2%原则会防止你的账户在单次交易中出现本金亏损2%以上的风险。==</strong></p><p>举个例子，如果你账户中有5万美元，那么2%原则要求你每次交易承担的最大风险控制在1000美元以内。这不是交易规模，而是账户中本金风险的大小，基于入场点和止损点之间距离大小来计算</p><p>假定你决定按40美元的价格买入股票，止损线设在38美元。这意味着你每股要承担2美元的风险。你总的可承受风险为1000美元，除以每股2美元，得到你可以交易不超过500股。当然，你愿意交易更少的股票更好，并不需要每次都以最大额度买股票。<strong>如果你对那只股票非常有信心，想尽可能多地买入，最多可买的数量为500股</strong></p><p>仅仅是市场分析能力强并不能使你成为赢家。善于寻找交易机会的能力也不能保证成功。市场中不乏好的分析师，但他们很多都最终以失败出局。只有当你保护自己不会遭到市场鲨鱼式的攻击时，你才能从你的研究中获利。</p><p>我曾见过交易者连续20次、30次，甚至50次盈利，但最终结果仍然是亏损出局。当连续赢钱的时候，你觉得自己已经完全了解了这个游戏。这时，<strong>往往一次灾难性的损失会把历史的盈利一扫而空，甚至连本金都折进去。你需要能抵抗“鲨鱼的一击”的资金管理方法。</strong></p><p><strong>技术分析能帮你决定止损点位置，这会将每股损失限定在一定范围内。资金管理规则能从整体上保护你的账户。最重要的一个原则就是在每次交易中都要将你账户承担的风险控制在2%以内。</strong></p><p><strong>这条原则中的本金范围仅仅指你交易账户中的钱，并不包括你的储蓄、家中的财产、退休金账户或圣诞节储蓄。</strong></p><p>交易资产是你投入到交易中的资产，这是你真正的风险资产——属于你交易事业的资产。如果你有各自独立的股票、期货、期权账户，那就对每个账户分开运用2%原则吧。</p><p>有人问我当对某笔交易很有信心时，2%原则这个数字是否可以增加，<strong>我的回答是这就像你蹦极时，因为喜欢桥上的风景，而额外加长了蹦极绳长度一样。</strong></p><p>往往专业人士经常说，2%太高了，他们一般只愿意冒更小的风险。如果有100万美元，你肯定不愿意一笔交易在一天内就亏掉2%。一位对冲基金经理在与我咨询时说，他未来六个月的目标是增加交易规模。在单次交易中，他从不会承担超过0.5%的风险——现在他正在努力使自己将风险水平提高到1%。好的交易者会倾向于把风险远控制在2%的限制以下。无论何时，业余人士和专业人士出现对立时，你肯定知道应该选择哪一边。尽力把风险控制在2%以下吧——<strong>这绝对已经是最大的风险水平了。</strong></p><p>下一笔交易你准备买入或卖空多少数量的股票呢？新手经常会随意地选择一个数量，比如说1000股或200股，如果他们上一笔交易挣钱了，他们可能会多买一些，如果他们上一笔赔钱了，这一笔就会少买一些</p><p>事实上，交易规模应该是根据公式计算出来的，而不是随意决定的。可以使用2%原则对你可以交易的最大数量做出理性的判断。我把这个过程叫作“风险控制的铁三角”（见图50-1）</p><p><img src="Pasted%20image%2020240129143541.png"></p><p><strong>如果你的账户比较小，可能你每次交易都要使用所允许的最大量。随着你的账户增大，你可能会想让每笔交易规模差异化，比如对一般的交易是最大限额的三分之一，对比较有信心的交易使用三分之二，其他更有信心的可能就全额使用了。无论你怎么做，风险控制的铁三角总会为你设定最大允许的交易规模。</strong></p><p>在期货市场中只有运用更敏感的风险控制才能取胜。你也可以使用2%原则。 （1）计算你的账户规模2%的值——这是每次交易所能承担的最大风险水平。如果你的期货账户中有5万美元，那么最大的风险额度是1000美元。 （2）找到你感兴趣的交易品种的图表，确定好入场点位、盈利目标点位和止损点位。记住：没有这三个价位的交易不是真正的交易，而是赌博。计算你设定的入场点位和止损点位的差值。 （3）将A值除以B值，如果结果小于1，不要交易——那意味着一份合约的风险你都承担不起。</p><h4 id="法则-1">6%法则</h4><p>食人鱼是热带河流中的一种鱼，不到人类的一只手掌大，但却有一副可怕的牙齿。它们十分危险的原因是，其会以群体的方式进行攻击。不论是狗、驴还是人，只要跌入热带河流里，整群食人鱼会围上来攻击，将猎物咬光。如果是一头牛走进河里，受到了食人鱼的攻击，几分钟之后河里就只剩它的骨头了。通过2%原则可以远离鲨鱼攻击的交易者，仍然需要保护，免受市场食人鱼式的攻击。6%原则能将你从一连串致命的攻击中拯救出来。</p><p>当发现自己遇到困难时，我们中的大多数人会加大赌注。亏钱的交易者经常加大头寸，试着拯救他们的交易。亏钱时更好的选择是退后一步，停下来去思考。6%原则给每一个账户都设定了一个当月最大回撤比例。如果你达到了限制，这个月接下来的时间就要停止交易。6%原则强制你在受到食人鱼攻击前，从水里走出来。</p><p><strong>当你这个月总损失和持仓头寸的风险额度之和达到账户总金额的6%时，在本月剩下的时间内，6%原则将不允许你进行新的交易</strong></p><p>在与市场的周旋中我们都有过连续盈利的时期，当我们的每笔交易都点石成金时，应该积极地交易。</p><p><strong>同样，有一些时候我们的交易变得非常糟糕。交易系统与市场步调完全相反，接连亏损。在这个时候，要重新审视这段时期，不要给自己太大的压力，退后一步、冷静一下尤为重要。</strong></p><p>专业人士在赔钱的时候可能会去休息一下，但会继续盯着市场，等待与市场的节奏重新匹配上。而业余人士更可能加大交易规模，直到账户出现严重亏损。6%原则会使你暂停下来，这时你的账户大体上还是完整的。</p><p>==<strong>6%法则带来了可用风险的概念，以下部分非常重要！</strong>== （1）把你这个月所有的亏损加总。 （2）把你现在所有的持仓头寸的风险额度加起来。一笔持仓交易的风险额度是你入场点位和止损点位之间的价差，乘以持仓数量。假如你以50美元的价格买了200股股票，止损价是48.50美元，每股承担的风险是1.50美元。这样，你该笔交易的风险额度是300美元。如果市场向有利于你的方向发展了，你把止损价位上调到盈亏平衡的价位，你的该笔交易的风险额度就会变成零。 （3）将以上两项相加（这个月的总损失加上持仓头寸的风险额度）。如果两者之和已经超过你月初账户资产的6%时，这个月剩下的时间你都不能再增加交易头寸了，除非市场顺着你持仓的方向发展了，允许你提高了止损线。</p><p>在你下单交易前，问一下自己：如果你所有的交易都向不利于你的方向发展怎么办？如果你用2%原则来设定止损位和交易规模，那么6%原则能给你的账户设定最大风险额度。</p><p>6%原则将一个常见的问题——“我有足够的钱进行这次交易吗？”——转变成了一个更有意义的问题——“我对这次交易有足够的风险承受能力吗？”</p><p>在任何一个月份风险水平都不要超过账户资产的6%，这条限制将你总的风险保持在可控范围之内，保证能在市场中长期存活下去。你每月的总的可用风险是你账户本金的6%，每次交易前你都要问自己的第一个问题是：“考虑自己这个月所有持仓头寸和已了结的交易，我还有足够的可用风险进行这笔交易吗？”</p><p><strong>如果你根据6%原则已经不能再进行新的交易，还是要继续跟踪自己感兴趣的股票。如果你看到了一个确实想交易的机会，但没有足够的可用风险额度了，可以考虑平掉部分持仓头寸，释放出一些风险额度给它。</strong></p><p>当你已经接近6%原则的限制，但发现了一个非常有吸引力的交易机会，此时你有两种选择：你可以兑现一个盈利的持仓头寸来释放可用风险额度；也可以收紧一些持仓头寸的止损线，减小持仓的风险。只要保证你想要的交易可以进行，而原持仓头寸的止损线又不至于过紧就行（见第54节）。</p><p><strong>下面是一个非常好的参考例子</strong>，假设交易者对任何一笔交易都将风险控制在账户规模的2%水平： （1）在月底时，交易者账户中有5万美元资金，无持仓头寸。他在月初确定好了最大的风险控制指标——每笔交易采取2%原则，也就是1000美元；总账户采取6%原则，也就是3000美元风险额度。 （2）几天后他发现了一只非常有吸引力的股票A，设定好止损线后买入了该股票，风险为账户本金的2%，也就是1000美元 （3）几天后他又发现了股票B，并做了一笔相似的买入交易，增加了另外的1000美元风险 （4）在这个星期快结束时，他又发现了股票C并买入，又增加了另外的1000美元风险 （5）第二个星期，他发现一只股票D比之前的三只股票都更有吸引力，他可以买入吗？——不可以，他不应该买入，因为他整体账户的风险暴露已经达到6%了。他有三个持仓的交易，每一个的风险都是2%，意味着如果市场变坏他可能损失6%。6%原则不允许他再增加任何风险。 （6）几天后，股票A上涨了，交易者将其止损线提高到了盈亏平衡的位置。在几天前还不能买入的D股票，现在依然有吸引力。他现在可以买入了吗？——可以，他可以买它，因为现在他账户承担的风险仅为4%。在股票B上承担的风险为2%，在股票C上承担的风险也为2%，但是股票A已没有承担任何风险，因为它的止损点在盈亏平衡点之上。交易者买入股票D，占用了另外的1000美元，也就是2%的风险额度。 （7）在这星期的之后几天，交易者发现了股票E，前景非常看好。他可以买入E吗？——不可以，根据6%原则，他的账户已经暴露在了B、C和D等三个合计6%的风险中（A已经没有风险了），因此他不能买入股票E。 （8）几天后，股票B被止损了，此时股票E仍然很诱人。他可以买它吗？不可以，因为他已经在股票B上亏损了2%，股票C和D又承担了4%的风险暴露，此时买入新头寸会使他每月的风险暴露超过6% <strong>这个案例中，三个个持仓头寸并不是非常分散，如果你想进行更多次交易，那就让每笔交易承担的风险小于2%。例如，如果每笔交易的风险仅为账户资产的1%，你持有6笔头寸才达到6%的限制。当交易的账户很大时，我依然使用6%原则，但是对2%原则，我会收紧到1%以下。</strong></p><p>6%原则允许你在一个好的趋势中，增加交易规模。但是在连续亏损的趋势中，会让你提早结束交易。当市场向着有利于你的方向变化时，你可以把止损线调整到盈亏平衡的水平，这样会有更多的可用风险用于增加新的交易。另一方面，如果头寸的趋势向着不利的方向变化，并且触及止损线时，你应该立即止损，保证账户主要资产的安全，以便下个月能有个全新的开始</p><p>2%原则和6%原则为资产增值提供了准绳——持仓头寸盈利后可以新增交易。如果你买了一只股票并且涨了很多，足以把止损线提高到成本线以上时，那么你可以加仓这只股票，只要新开头寸的风险额度不超过账户资产的2%，总的账户风险也不超过6%即可。对每次加仓当作一笔单独交易进行管理</p><p>很多交易者都会有情绪波动，在市场高位时表现得兴致高昂，而在市场低位时则感到沮丧。这些情绪波动是不利于你交易的，只会起相反作用。把精力放在风险控制上是更好的选择。2%原则和6%原则可以把你的努力转换成更安全的交易。</p><p>参考文中，连续十三天亏损的案例，让它把交易数额从500股降到100股，直到开始连续盈利为止，再慢慢提高额度，这说明： 更高的风险妨碍了我们的交易能力。你需要训练自己通过计划好的步骤慢慢地接受风险。基于你交易的频繁程度，这些步骤可以以周或月为单位，但原则都是一样的——你要在两个时间单位内盈利，然后进入下一个阶段，承担更大的风险。如果你在某个时间单位内赔钱了，则后退一步，减小你承担的风险。这对巨大亏损后，想重新回到交易中的人来说尤其有帮助。你要不带恐惧地逐渐以自己的方式回到交易中。</p><p>一个很有意思的事实是：当成功的机构交易员出来自己单干时，他们中的大多数人都会赔钱。即使他们使用的可能是相同的设备、相同的交易系统，仍然保持着社会关系，但最终他们仍会失败。几个月后，很多单干的人又会重回猎头公司那儿找一份交易员的工作。为什么他们能给公司赚钱，却不能给自己赚钱呢？</p><h2 id="实践细节">实践细节</h2><p>当股票创出新高后，你会买吗？在双重顶时会卖吗？在回调中会买吗？你会寻找趋势反转吗？以上这些的方法各不相同，每种方法都可能赚钱，也可能赔钱。你应该选择那些吸引你、让你很舒服、适合你能力和气质的交易方法。没有一种交易方法是适合所有人的，就像没有一种运动是适合所有人的一样。</p><p>要想成功地交易，先要选定一种交易模式。在进行行情数据扫描之前，你应该十分清楚你想要找到什么。开发你的系统，并通过一些小交易先测试一下，确定你可以遵守交易纪律。你必须确定在你看到设计好的交易信号出现时，会按计划交易。</p><p>不同的交易风格需要不同的入场技术、不同的设定止损线和确定盈利目标的方法，以及不同的扫描行情数据的方法。但是，有几条关键的原则是适用于所有交易系统的。</p><h3 id="怎样设置盈利目标足够是关键词">怎样设置盈利目标：足够是关键词</h3><p>为交易设定盈利目标跟找工作时要想清楚自己所需要的工资和福利待遇是一样的。你实际得到的可能比预想的或多或少，<strong>但是你要有一个预期值</strong></p><p><strong>在每次交易时，记下你的入场价格、盈利目标和止损线</strong>，以便比较你的风险和收益。<strong>盈利的潜力应该至少是风险的两倍</strong>。很少值得去为了赚一美元而承担一美元的风险——那样的话还不如直接去轮盘赌桌上赌颜色。在每次交易中符合实际的盈利目标和坚定的止损线能帮你做出是否参与交易的决定。</p><p>当计算交易者的盈利潜力时，我们陷入了一个悖论之中——你的预期持有时间越长，盈利潜力越大。在一个月内，股票上涨幅度肯定能比一周多。但另一方面，你持有的时间越长，不确定性越大。<strong>对短期价格变化来说，技术分析很可靠，但是长期内可能会出现很多重大失误。</strong></p><p>在以前关于选择交易时间长度的章节中，我们检验了三种主要的选项。<strong>长线交易或者说投资，持有期是以月来衡量的，有时甚至是年。波段交易可能就几天，有时可能是几周。日内交易是以分钟来计算的，甚至很少用到小时。</strong></p><p>移动平均线和通道线可以帮助我们设定波段交易的盈利目标，它们对日内交易也是很有用的，只是要更注意使用震荡指标。一旦出现与你交易方向背离的信号，马上退出。长线交易的盈利目标通常参考前期的支撑位和阻力位</p><p>上面提到的三个目标位——移动均线、通道线和支撑/阻力位，是很合适的。它们并不是高不可攀的目标，而是很现实的。记住，“足够”是很有力的词——在生活和交易中都是如此。这使一切都在你的掌控之中，通过一个又一个交易达到“足够”后，从长时间来看，你会取得相当不错的成果。</p><p>下面举个例子来说明</p><h4 id="波段交易">波段交易</h4><p><img src="Pasted%20image%2020240129152710.png"> 表中的最后三天被标记上了a、b和c。在a日，威瑞信股票向上突破压力位，也就是图中的水平虚线，但是MACD柱甚至没能上到0值之上。第二天，也就是b日，股票开盘价在橙色线以下。但是MACD柱甚至没能上到0值之上。第二天，也就是b日，股票开盘价在橙色线以下，说明前一天是一次向上假突破（有些人称之为“逆冲”），只要MACD柱向下，形成一个熊市背离，我所要的模式就形成了，立即做空。</p><p>威瑞信整天都在下跌并且收在最低的位置。第二天，也就是c日，<strong>它试图筑一次底，因为它的价格已经在价值区间内了</strong>。我觉得已经足够了，所以平掉了仓位。我有3000股，每股扣除佣金钱赚了82美分的利润，也就是合计2460美元。如果持有更长时间，我本可以赚得更多的，但是在波段交易中，快速地赚0.25美元要好过慢慢地赚1美元。<strong>在价值区间内兑现利润减小了不确定性，也减少了你暴露于风险中的时间</strong>。</p><p><img src="Pasted%20image%2020240129153653.png"> <strong>在阻力位为长线交易设定盈利目标：</strong> 艾戈公司(IGOI)在上面所示周线图的右侧的最新交易价格为3美元偏上水平，逐渐向上的EMA确认了一轮新的上升趋势。它之前的高点是60美元以上（注意有一个“袋鼠尾”），中间最近的两次反弹都以失败告终了，最近的一次是在15美元附近，之前的一次在22美元附近（都以紫色虚线标注）。如果这里开启了新一轮的上涨趋势，应该将第一盈利目标设在15美元，第二个设在22美元</p><h3 id="怎样设定止损线不要异想天开"><strong>怎样设定止损线：不要异想天开</strong></h3><p>对长期的生存和成功来说，止损是非常必要的，但是我们大多数人都非常不情愿去使用它们，<strong>市场的反复促使我们强化不止损的坏习惯</strong>。<strong>我们都有过这样不愉快的经历：你买入了一只股票，接着它的价格跌到了止损线，结果你亏损割肉出局了——但是你又眼睁睁地看着它反转上行了，跟你最初所预想的一样。如果你不设止损线，而是一直持有这只股票，本可以赚钱而不是亏钱的。像这样双重打击几次后，你就会对止损非常厌恶了</strong></p><p>经过几次这样的事情后，你的交易逐渐开始不使用止损策略了</p><p>在一小段时间内这也确实表现得很好，没有了那样的双重打击。有些交易虽然不成功，但在没有止损线的情况下，你也退出了——<strong>此时你有足够的纪律性。但这个幸福的旅程会在一笔大的交易开始走坏时结束。你一直等着，期待它可以稍微反弹一些，让你有个更好的退出价位，但它却一直下跌。随着时间的流逝，它对你的账户造成了越来越严重的伤害——你正在被一只鲨鱼吞掉</strong>。很快你的生存会受到威胁，你的信心也濒临崩溃。</p><p><strong>（1）在“市场噪声”之外设定止损</strong>（EMA + 平均穿透 * 系数） <strong>安全区域止损</strong>在我的《走进我的交易室》一书中已有详细的描述。先度量市场噪声，再把止损位设在市场噪声区域外数倍的位置。简言之，使用22日EMA来定义为趋势线。如果趋势是向上的，标记出所有回溯期（10～20天）内向下穿透EMA线柱的深度值，将其加总后除以向下穿透的线柱数量，得到回溯期的平均向下穿透值。</p><p>它反映了当前上升趋势中平均的噪声水平。你应该把止损位设在远离市场平均噪声水平的位置。这就是为什么你需要把平均向下穿透值乘以一个系数，<strong>通常是2以上的数字</strong>。如果止损位设得太近容易弄巧成拙。</p><p>当EMA趋势是下降的时候，我们使用前期线柱的最高价向上穿透来计算安全区域。我们数一下选定期间内线柱的向上穿透情况，计算它们的平均值，得到平均向上穿透值。选一个系数乘以它，比如<strong>可以从3开始选</strong>，将得到的值加到每次高点上。<strong>在高点卖空比在低点买入需要更宽的止损空间</strong>。</p><p>正如本书中其他所有的系统和指标，<strong>安全区域不是可以取代独立思考的自动工具。你必须选好回溯期，也就是计算安全区域的时间周期</strong>。<strong>你也需要调整好乘以平均穿透值的系数，这样你的止损线才能在正常的噪声水平之外。</strong></p><p><strong>（2）不要把止损线设在明显的位置</strong>（不要选最低点，可以选次低点）</p><p>从密集的价格区间向下探出显眼的新低点，最容易吸引交易者在新低点下方设置止损位。问题是太多人在这里设止损线，造成这个区域里止损的人过多。市场有一个神秘的习惯，会很快地跌穿这些明显低点，引发止损后再反转，发动新的上升趋势。为了避免这种情况，我有几点建议。</p><p>把止损位设在并不明显的位置比较好——<strong>要么更接近市场目前水平，要么离明显位置更远一点。更近的止损位可以减少亏损规模的风险但是会增加被洗盘出局的风险。更低的止损位可以躲过一些假突破，但是一旦真触及止损，亏损规模会更大。</strong></p><p>是做选择的时候了。对短期波段交易来说，<strong>把止损设在更近的位置比较好，然而对长线交易来说，最好设定更远的止损线。记住“风险控制的铁三角”——更远的止损可以交易的规模会较小</strong>。</p><p>我喜欢一种叫尼克止损的方法，他发明的这种止损方法是<strong>把止损位设在近期的次低点</strong>，<strong>而不是设在最低点附近</strong>。这里面的逻辑很简单——如果股价跌到了次低点附近，那么很有可能还会继续下跌并触及最低点，而这正是止损单扎堆的位置。使用尼克止损法后，同样市场下跌情况下，承受的损失和滑点要少很多。</p><p>当作为空方的时候这个原则也是一样的——不把止损线设在最高点之上，而是设在次高点</p><p><img src="Pasted%20image%2020240129154518.png"></p><p>在可口可乐(KO)公司的图中，我们发现了一个伴随着牛市背离的向下假突破，动力系统从红色变成了蓝色——允许买入。如果我们做多买入，我们应该在哪里设定止损线呢？ 线柱A——最低点是37.10美元； 线柱B——最低点是37.05美元； 线柱C——最低点是36.89美元（一个向下假突破，比线柱A的最低点还低21美分）； 线柱D——最低点是37.14美元</p><p>大众通常会把止损线设在36.89美元下面，但是尼克止损会设在37.04美元——<strong>比近期的次低点少1美分，是线柱B的最低点</strong></p><p>在直觉外科公司(ISRG)的图表中，我们可以看到一个伴随着熊市背离的向上假突破，动力系统由绿变蓝——允许卖出。如果我们做空卖出，我们应该在哪里设置止损线呢？ 线柱A——前期高点447.50美元； 线柱B——最高点是444.99美元； 线柱C——最高点是447.75美元（向上假突破，比前期高点还高25美分）； 线柱D——最高点是442.03美元</p><p>你可能想要多尝试几种设立止损的方法，像在本书前面提到的抛物线止损法、安全区域止损法和波动止损法。你可以激进，也可以保守，但是要记住最重要的原则：第一是要有止损；第二是不要把止损位设在太明显的位置，也就是图上谁都能看出来的位置。设止损位时要比显眼的位置更近或更远一点——<strong>要与集中的群体保持距离，因为你并不想做一个平庸的交易者。</strong></p><p><strong>同样的道理，不要把止损位设在整数价格上</strong></p><p><strong>（3）平均真实波幅（ATR）止损</strong> 当你在最近的一根线柱中入场时，把你的止损位设在离当前这根线柱的极值至少一倍ATR的位置，如果是在两倍ATR的位置设置止损位就更安全了。你可以把它当作一种移动止损的方法，随着线柱的转变而移动它。原理还是一样的——把止损位设在市场噪声区域之外</p><p>使用移动止损的一个优点是它们逐渐减小了所暴露的风险额度。前面我们讨论过“可用风险”（见第51节）的概念。使用移动止损时，如果交易价格朝对你有利的方向变化时，它可以逐渐释放可用风险额度，从而允许你开始做新的交易</p><p>（4）出现“尖峰反弹信号”后在2倍ATR处移动止损 <img src="Pasted%20image%2020240129155735.png"> 尖峰反弹信号（在第34节中已讲述）出现在当20日新高-新低指数跌到了负500以下的时候，这意味着下跌的趋势难以进一步持续，然后指数重新反弹到这个水平之上，表明牛市在重新回来。尖峰反弹信号由垂直的绿色箭头标示。在这里，标普线是绿色的，但是当尖峰信号消失时，它会变成紫色。红线跟踪的是标普500指数线柱最高价下方2倍ATR的价位。</p><p>尖峰反弹信号发出对整个市场的买入信号，这张图表用2倍ATR收盘价止损（日内波动超过止损线不触发止损，必须收盘价在止损线之下才触发止损）来跟踪每个买入信号。注意富有成效的信号A、B和C。在写这篇文章时E点的买入信号仍然是有效的。D点的信号会导致损失——说明信号并不总是能获利。即使你不用安全区域止损或ATR止损，也务必把止损位设在离最新价格稍远一点的位置。你肯定不想像那些胆小的交易者一样把止损位设在离现在价格很近的位置，结果一些无意义的扰动就触发了止损。</p><p><strong>（5）高点放置追高的买入方法</strong> 如果你发现了一只股票正处于强劲的趋势之中，但你又不想追高，你就<strong>降一个时间周期维度。比如说，周趋势是上升的，那就下降到日线图表，你可能会发现每隔几周，日线会有一次回调到价值区间的机会。测量一下最近几次穿透到长期EMA下方深度的平均值，得到平均穿透值（见图39-3）。提前一天在低于EMA均线一个平均穿透值的距离下一个买单，未成交之前每天都需要对它进行跟踪调整</strong>。你可以利用市场噪声为进入趋势跟踪交易，找到一个好的入场价格</p><p><strong>（6）不要让盈利变为亏损</strong>（达到一定比例的盈利目标后，就可以将止损线设在盈亏平衡点，然后随着利润增大，逐渐提高止损线，保护利润）</p><p>不要让有丰厚账面浮盈的未平仓头寸变为亏损！在交易之前，就要计划在什么水平开始保护你的利润。比如有一笔交易的盈利目标是1000美元，那么在有300美元盈利的时候就需要开始保护利润。一旦你的未平仓头寸浮盈达到300美元，你可以将止损线调整到盈亏平衡的位置。我们称这种移动为“为交易翻边”</p><p>一旦你将止损线调整到盈亏平衡点，你需要专注于如何保护住部分持续增长着的浮盈。提前计划好要保护多大比例的利润。</p><p>比如，你的决定可能是一旦止损线超过盈亏平衡点了，考虑保证三分之一的浮盈。那就意味着，如果你目前的交易有600美元的账面盈利，那么至少要得到200美元。（这个比例根据信心可以改变）</p><p><strong>当交易的发展已经兑现了你的预期，这笔交易的盈利潜力逐渐变小。而你的风险（盈利和止损线之间的距离）会不断增加。交易就是在管理风险，当盈利与风险的比例渐渐恶化时，你便需要减小承担的风险。通过提升止损线，保护一定比例的利润，可以使盈利与风险比例控制在更平衡的位置。</strong></p><p><strong>（7）只顺着你交易的方向移动止损线</strong>（非常经典的案例） 当你买了一只股票，作为有纪律的交易者，会在买入价下面设定止损线。股票开始上涨，产生好看的账面浮盈。但接着，上涨停止了，开始下跌一点，然后再下跌一点，这时浮盈变成了浮亏，市场价格离你的止损线只差分毫了。这时你再分析图表，认为从图形上看，这只股票出现了很好的底部形态——牛市背离，可能会带来一波强劲的上涨趋势。接下来你该怎么做？</p><ol type="1"><li>==<strong>首先，要认识到你的错误是没有及时提高你的止损线。在最初上涨的时机中你就应该将止损线提高到盈亏平衡线之上</strong>。==没能做到这一点，导致你目前的选择余地很小，要么马上卖出承担损失，等到以后再重新买入；要么一直持有。但麻烦在于，你可能会倾向于去做第三种选择——调低止损线，“给下跌更大的空间”<strong>==（但千万别这么做！）==</strong></li><li><strong>“给下跌更大的空间”只是一种美好的、单纯的想象。这个选项不应该出现在一名严谨的交易者的工具箱中。</strong></li><li>当一笔交易表现糟糕时，符合逻辑的做法是接受出现的损失，但保持关注这只股票，做好准备，当底部出现的时候重新买进。专业交易者一般在股票步入正轨之前会尝试几次快速的试探性交易，这样佣金成本也会低一些</li></ol><p>（8）灾难性止损：专业交易者的救生衣 我在搬到湖边别墅居住后，买了一个皮划艇，接着立即买了一件救生衣。因为按照法律，我需要在皮划艇中放一件救生衣，即使是一件质量十分糟糕的也可以。但我还是花了很高的价钱买了一件质量上乘、<strong>穿着舒适的救生衣。</strong></p><p><strong>其实，我计划的只是在湖面上平静地划皮划艇，而不是去什么水流激烈的地方，因此也并不认为有一天会用到那件救生衣。那我是在浪费钱吗？如果有一辆摩托艇撞上我的皮划艇，一件高质量的救生衣可能就是生与死的区别。</strong></p><p><strong>这和止损线的作用是一样的</strong>。</p><p><strong>它们很麻烦，并且会有成本，但总会有一天，这些止损线将拯救你的账户于危机之中。记住，在股票市场中出现意外的概率可比在湖中大多了</strong></p><p>“硬止损”是一种给你的经纪商下达的指令，而“软止损”是你心中的止损线，当到需要的时候你才会去执行真实操作。<strong>新手或业余交易者一定要使用硬止损线</strong>；</p><p>对于任何一笔A级交易来说，无论做多还是做空，你都需要在图表中画出你最不希望看到的价格极值。然后在这个位置设定你的硬止损线（哪怕是专业投资者），在取消之前，这个止损线会一直有效，这就是你的“灾难性止损线”。接下来你便可以开始灵活地使用软止损了。就像有了一件可靠的救生衣，你便可以使劲地划动手中的桨了。</p><p>（9）止损线和隔夜跳空：仅对专业交易者 如果你持有的股票在休市期间出现了一个重大利空，你怎么办？在第二天早上开盘之前查看集合竞价情况，你意识到股价将大幅低开，远低于你的止损线，意味着滑点会很大。</p><p>这情况不常见，但它确实会发生。</p><p>如果你是一名新手或者业余交易者，那并没有什么可选择的，只能咬紧牙关承受损失。但对于冷静的、有纪律的专业交易者来说，还有一种方法，那就是用做日内交易的方式退出。首先，撤走止损线，开盘之后当作开盘第一秒买入了一样，后面进行日内交易的操作。</p><p>开盘跳空缺口常常伴随着反弹，这给那些机敏的交易者提供了减少损失的机会。但这样的情况并不是一定会发生，所以大多数的交易者不要轻易尝试这种技术。因为这么做可能导致亏损更多，而不是减少亏损。</p><p><strong>记住在收盘前要及时退出——已经走坏了的股票，可能当天会反弹，但明天将会有更多的卖家进场卖出，驱使股价进一步下跌。不要让一次反弹引发你对反转的希望。</strong></p><h3 id="这是a级交易嘛对自己的交易行为做出评价">这是A级交易嘛？（对自己的交易行为做出评价）</h3><p>一旦你结束了一笔交易，市场将对你的入场、退出和最重要的整体交易三方面做出评级。</p><p>如果你是一位使用周线图和日线图做波段交易的交易者，那就用日线图来计算你每笔交易的级别。你的买入评级取决于入场点、购买当日的最高点和最低点的情况。</p><p>买入评级=（最高价-买入价）/（最高价-最低价） 卖出评级=（卖出价-最低价）/（最高价-最低价） 交易评级=（卖出点-买入点）/（通道线高点-通道线低点）</p><p><strong>每笔交易我都会计算买入评级，而且我认为大于50%就是不错的成绩了，意味着我是在当日线柱的较低部分买入的</strong> <strong>每次交易我都计算卖出成绩，如果在50%以上，它就是一笔好的交易，意味着我卖到了当日日线的上半部分</strong></p><p><strong>下面看一个交易案例：</strong></p><p><img src="Pasted%20image%2020240129184743.png"></p><p>我在此处的策略是“回调到价值区域时买入”。ADSK最近出现比平均水平更深的跌幅——注意由红色箭头标注的向下假突破，接着由绿色箭头标注出的二次探底。</p><p>A日——2014年2月10日，星期一：高点是52.49美元，低点是51.75美元，上通道线是53.87美元，下通道线是47.61美元（我们需要通道高度来计算退出的交易评级）。买入价为51.77美元。 买入评级=(52.49-51.77)/(52.49-51.75)≈97%。</p><p>B日和C日——星期二和星期三：继续上涨，开始向上移动止损线</p><p>D日——星期四：高点54.49美元，低点53.39美元。卖出点为53.78美元。 卖出评级=(53.78-53.39)/(54.49-53.39)=35%。 交易评级=（卖出点-买入点）/通道高度=(53.78-51.77)/(53.87-47.61)=32%。</p><p>在这次交易中我的买入评级异常高，卖出评级比平均水平低，但是总的交易评级很好。因为忙于写作此书，我仅交易了200股，所以我扣除佣金之后的盈利只有不到400美元。如果我是通过盈利数量来评价交易评级，这次交易显得微不足道，但是我抓住了32%的通道高度，交易评级是A。</p><p>克里·洛沃恩在尖峰交易(Spike Trade)2012年年会上的发言引起了我的注意：他向所有参会者提出了一个定义——“什么是A级交易”——建立卓越交易的标准。他说：“<strong>你必须为你自己定义这种模式，如果你不知道自己的A级交易是什么样子，在市场中你根本就没有自己的业务模式</strong>。”</p><p>我很清楚自己的A级交易是什么——“价格背离加上假突破”或“回调到价值区域”。但是，如果我一时找不到A级交易，我会去找B级交易，如果真的没有合适的机会，才会转向C级交易。</p><p>那次聚会回到家后我将一张塑料纸条贴到我的交易屏幕上，写着：“这是一笔A级交易吗？”从那以后，我每次交易下单时都要问一下自己这个问题。效果很快显现出来了：<strong>随着非A级交易的急剧减少，我的股票资产曲线开始陡峭地上升</strong>。</p><p>你需要有一个明确的概念，知道什么是你的完美交易——A级交易。完美不保证一定盈利——这个市场没有绝对的保证——但这意味的是有强烈盈利潜力的交易。这也是你之前感觉很舒服的交易模式。一旦你知道这种模式是什么样的，你就可以寻找符合这种交易模式的股票了。</p><p><strong>个人交易者比机构交易者为数不多的优势之一是，我们可以在喜欢时交易，在不喜欢时不交易。我们可以自由地等待优质的交易机会出现，这对机构交易者来说是很奢侈的。不幸的是，我们中的大多数人过于急切地进行交易，没有利用好这个优越的有利条件。</strong></p><p>我把“这是一笔A级交易吗？”这个问题加入到了我的“交易准则”之中——我们将在下一章中讨论相关的交易管理表格。无论什么时候我发现有潜力的交易机会，我都会问自己这个问题，如果答案为“是”，我再开始计算风险水平、头寸规模，谋划买入价位。但如果答案为“不是”，我就会翻过这一页，继续寻找下一个交易机会（见图55-2）。</p><p>我所说的“系统”和“策略”两个词是可以互换的——它们都表示交易的计划。就像从我的这份2013年9月的交易日志中可以看到，当时在策略箱中，我使用了三个交易系统，<strong>主要的一个是“价格背离+假突破”，我也有时使用“回调到价值区域”这个策略交易</strong>——在上升趋势中的回调时买入，或在下跌趋势中的反弹时卖出。在极少数情况下，我会“针对极值进行交易”——在股价降到极低的时候买入，或在股价疯狂上涨后减速时卖出。</p><p>你的系统可能很自动化，也可能只是很概括的一些关键原则——像我的三重滤网交易系统。无论哪种方式，在你计划下一次交易的时候，<strong>你必须知道你的A级交易是什么样的。</strong></p><p><img src="Pasted%20image%2020240129190057.png"> 图55-3是从我的交易记录中摘录的，它是波段交易策略的一个非常理想的例子，我将其缩写为“01 FB+BD”——伴随有牛市背离或熊市背离的假突破。图中，斯伦贝谢公司(Schlumberger,Ltd.,SLB)的股票处于很明显的下降趋势中，当它在A点到达新低时，看起来只是漫长下跌途中的阶段底。在我看来，在MACD柱图中标出的整个椭圆形区域是一个底部，因为它从来没有向上穿透过0值线。在B区域里，图线开始变得比较有意思了：MACD柱上升到0值线以上，“打断了熊市的后背”。动力系统的周线图（此图中并没有显示）在这之前都显示为红色，现在变成了绿色——禁止买入信号被移除了。在C区域，SLB股价创下了新低，但是MACD柱的新低点却很浅，出现了牛市背离。</p><p>仔细观察在C区域中连续几条红线之后的第一条蓝线，那是MACD柱上涨形成牛市背离的地方。另外，那条上涨的日线，收在前期向下突破位的上方，图中用紫色的虚线标出：这说明前期是向下假突破。</p><p>我是在这条日线中买入的（图中用垂直绿色箭头标出）——并没有等到收盘后才做决定，在60.80美元处买入了2000股，止损线设在59.12美元。几天后，当价格开始接近上通道线，也是前期高位时，我开始兑现盈利，在66.55美元的位置卖出了1000股，剩下的是第二天以67美元的价格卖出（图中都用红色箭头标出）。我每股盈利是6美元，5个交易日内扣除佣金前收益是11950美元，这个交易系统完成了一次出色的交易。</p><p>这幅图是我在寻找股票和期货的交易机会时，会浮现在脑海中的图表。我想找到类似的图形，完成了它们的A底和B顶，而且开始下跌有形成C底的趋势。在这个图形背后，动力系统的周线图不能显示为红色，因为那将禁止买入交易</p><p>如果你要扫描更大数量的股票，需要增加一些“负面规则”。比如，你需要剔除每日成交量少于50万股或100万股的股票。这些股票的图表通常很不规则，滑点也比其他交易活跃的股票的要大。你还可能会把高价股从买入名单或低价股从卖出名单中剔除。选择筛选标准的参数，依个人而定。这也是为什么扫描最好由有经验的交易者来做。就像在撒网捕鱼之前，首先要学会用渔竿来钓鱼。</p><h2 id="保持良好的记录习惯">保持良好的记录习惯</h2><p>市场在分发奖惩方面并不始终一致。这样的情况时有发生，比如一笔缺乏计划的交易赚钱了，而一个计划周密、执行认真的交易却亏钱了。这种随机性使我们颠覆了本应遵守的原则，鼓励草率地进行交易。</p><p>记录下你的交易计划可以确保你不会错过任何一个重要的市场影响因素。记录交易日志的习惯将帮助你避免掉入冲动交易的陷阱。交易纪律和控制体重一样，对于多数人来说是很困难的。如果你不知道自己今天的体重是多少，你的体重曲线在上升还是下降，你怎么能控制它？减肥是从坚持每个清早脱光站到秤上记录下当天体重开始的。</p><p>我们都会犯错误，但是如果你能坚持复习自己的交易日志，并且反思过去的错误，你不太可能会重蹈覆辙。好的交易日志记录习惯能让你成为自己的老师，并让你的账户净值出现奇迹。</p><p>让我们来回顾一下交易日志的三个核心要素： （1）纪律的第一步是完成功课（我会提供一份功课进度表的模板）。 （2）纪律的进阶是写下你的交易计划。 （3）纪律的高潮是执行这些计划并且完成交易日志（我会提供一个在线交易日志的链接）。</p><p>我的电子表格（见图57-1）目前还在继续使用中，我仍继续对其不断调整。如果你准备使用它，我确信你也会根据自己的需要进行调整。 <img src="Pasted%20image%2020240129201323.png"></p><p>（1）查看远东市场。这条链接将我带到雅虎财经的相关网页。我会写下隔夜澳大利亚及中国市场指数的百分比变化。每个人形成记忆的方式各不相同，对我来说写下来是最有效的办法。 （2）查看欧洲市场。这里我写下德国法兰克福指数及英国富时指数的百分比变化。市场闻鸡起舞，你会体会到在美国产生的风波在重新返回西海岸之前，如何波及亚洲，然后传到欧洲的。 （3）<strong>经济日历</strong>。这条链接将我带到Briefing.com的网页，这里把每天将要发布的基本面数据整理成列。同时也会显示之前发布的数据及市场对本次发布数据的预测值。当一份重要的数据，比如失业率或产能利用率，低于或超出市场预期，你便可以期待市场将出现绚丽的烟花秀。 （4）Marketwatch网站。这是一个大众流行的网站，我会看一下今早它正在关注什么。通常来说它是反向指标。 （5）欧元汇率。我会写下最活跃的期货合约的现价，后面用动力系统状态的首字母标记——绿色(G)、蓝色(B)或者红色(R)——前面是周线图的，然后是日线图的。下面提到的其他市场，我所采用的是同样的格式。我关注欧元期货走势有两个原因。第一个原因是无论与美国股市表现一致或相反，欧元期货的走势都能延续一段时间；另一个原因是欧元期货有时候能提供非常好的日内交易机会。 （6）日元汇率。上一条所述两个原因中，第二个原因比第一个在日元汇率上更适用。 （7）原油。它是经济的血脉，并且原油期货会随着其上涨下跌而变化，原油期货是可以用来交易的。 （8）黄金。它是市场恐慌情绪与通胀预期的一个敏感指标，同时也是很受欢迎的交易品种 （9）债券。利率的上涨或下跌是股市走势的主要驱动因素之一。 （10）波罗的海干散货运价指数(BDI)。对于世界经济而言，它是一个敏感的先行指标。BDI表示干散货的运送成本，例如把纺织品从越南运往欧洲，或是把木料从阿拉斯加运往日本。BDI的波动非常大，没有直接基于BDI的交易品种，这有助于BDI更准确地反应经济活动的实际情况。如果你交易航运业的股票，这个指标格外有用。 （11）<strong>新高-新低指数</strong>。我认为新高-新低指数是股票市场最好的先行指标。我喜欢每天早上写下这个指标最新的周数据及日数据来帮助记忆。 （12）芝加哥期货期权交易所波动率指数（VIX指数），也被称为“恐慌指数”。人们调侃：“VIX走高，放心买入；VIX走低，小心慢行。”横批是，“提防VIX的ETF”——VIX的ETF因在交易中与VIX指数不同步而臭名昭著。 <strong>（13）标准普尔500指数。我会写下前一个交易日指数的收盘价，并且将动力系统周线和日线显示状态的首字母标写在后面。</strong> <strong>（14）日线的价值。我转到标普指数的日线图，留意最新一根线柱是收在价值区域的上方、正中还是下方，以及它与通道线的关系。这帮助我识别现在市场是超买了还是超卖了。</strong> <strong>（15）强力指数指标。我会注意这个指标的13日EMA均线是在它中心线的上方还是下方（对应牛市或熊市）以及是否有背离。</strong> （16）对标普指数的预判。测验自己对市场预测的精准度：写下对今天收盘价会比开盘价高还是低的预测，如果没有观点就空着。根据自己的预测是否正确，次日我会给这一栏涂上绿色或红色。 （17）在电子表格的最后一行，我会总结今天将如何交易：积极地、保守地、防御地（仅进行平仓交易），日内的交易或者完全不进行交易。</p><h2 id="如何判断交易想法的可靠性">如何判断交易想法的可靠性</h2><p>每一个诞生的交易想法，在心中肯定都是可靠的，可能是踩中了几个关键点位，可能是基本面好转，但依赖感觉而不是客观数字的想法是不应该执行的，因此需要对交易想法进行评判</p><p>在展示我的阿氏交易评分之前，有一些注意事项：你将要看到的这个评分系统是为特定交易系统而设置的——我的“伴随背离的假突破”策略。如果是其他的交易系统则需要不同的评分测试方式，<strong>但你可以将我的交易阿氏评分作为设计自己评分系统的基础。</strong></p><p>交易阿氏评分需要对体现交易策略核心的五个问题给出明确的答案。随着你为自己的策略发展出了属于自己的阿氏评分，我建议保持问题数目不要超过五个，且答案得分仍是0分、1分和2分三种。简洁能够让这种测试更加客观、实用和快捷。</p><p>当看到交易机会时，我会抽出一张空白的交易单，圈出我对五个问题的回答。 在红色框画圈的得0分，在黄色框画圈的得1分，在绿色框画圈的得2分。 我在每个分数框里填上得分，然后将五个得分加总。如果我圈出的是红色框，我还会在其旁边写上价格到什么位置时我会将其改为更令人喜爱的黄色或绿色。那时，计划的评分会得到提升，在那个价格可能可以进行交易。 图58-1展示的是做多的交易阿氏评分，而图58-2展示的是空头交易的交易阿氏评分。</p><p><img src="Pasted%20image%2020240129202240.png"></p><p>（1）强力系统的周线图（前面章节有描述）——周线图是红色得0分，周线图是绿色得1分，周线图是蓝色得2分。强力系统为红色时，是禁止交易的；绿色时还可以进行交易，但是可能有些太晚；蓝色（紧跟在红色之后）表示恐慌正在褪去，是买入的好时机。 （2）强力系统的日线图——与上一条同样的问题、同样的评分，标记在日线图上 （3）日线价格——在日线图上，<strong>如果最新价格在其价值区间之上得0分；在价值区间范围内得1分；低于其价值得2分。</strong> 价格在价值区间之上时，买入已经有些迟了；在价值区间内还可以；在价值区间之下则是一笔好买卖。 （4）假突破——没有的话得0分；已经发生得1分；很有可能将要发生得2分。 （5）完备性——没有周期符合得0分；有一个符合得1分；两个周期看起来都很完备得2分。</p><p>我通常会用两个时间周期来分析市场。对任何策略来说必须有其中之一符合一种入场交易的完备形态。极少情况下两个时间周期的形态都是完备的——在一个完备，另一个可以接受的情况下就可以进行交易了。如果没有一个时间周期的形态看起来是完备的，则不是一笔A类交易——抛弃这只股票，转移到另一只上面去。</p><p><strong>计算任何一只股票的阿氏评分都不会花费超过一分钟。我只想进行那些得分在7分及以上，并且没有任何一个框是0分的交易机会</strong>。<strong>遇到这样的交易机会，我会继续执行我的交易计划，选择进场点、目标价、止损价和交易规模等</strong></p><p>交易的阿氏评分为潜在的交易提供了客观的评级。我们有成千上万的交易工具，没有必要将精力耗费在差劲的标的上。使用交易阿氏评分能帮助你聚焦于最有前景的机会上。</p><h3 id="如何使用交易表">如何使用交易表</h3><p><strong>当你对某只股票产生兴趣，并且交易的阿氏评分肯定了你的交易想法，完成交易表将有助于你专注于此交易最核心的部分。</strong></p><p><img src="Pasted%20image%2020240129202553.png"></p><h4 id="第一部分----交易鉴定">第一部分----交易鉴定</h4><p>绿色条纹标志为多头交易。 用一张指甲盖大小的、画有牛市背离伴随假突破的K线图作为图标，标示出这种策略。 第一个空格用来填写股票代码。 接下来一个空格用来记录下一个财报披露的日期。你可以在很多免费网站上找到它们。例如www.Briefing.com,www.earning.com，或者www.Finviz.com等。 很多交易者在股票将要公布财报时会避免持有该股票。因为差劲的盈利表现对你的持仓很不利。写下披露的日期，以强迫自己避免陷入麻烦。 再下一个空格用来记录除息日——如果有的话。我通常在http://finance.yahoo.com上查找。分红时，股票持有者需要缴税，而空头必须支付分红。所以人们都不希望在分红那天持有该股票。 最后一个空格是我做计划的日期。</p><h4 id="第二部分交易的阿氏评分">第二部分：交易的阿氏评分</h4><p>我的交易阿氏评分描述如上。记住，每种策略都需要符合其特点的阿氏评分。十分欢迎你用符合自己交易系统特点的问题来代替我设置的问题。例如，你的问题可能是随机摆动指标是处于哪种状态：超买（0分）、超卖（1分）或者超卖伴随着牛市背离（2分）。当你将交易阿氏评分的各项得分加总时，将下面这个重要问题的答案写下来：这会是一笔A级交易么？如果总分在7分以下，则放弃这只股票，去寻找其他的</p><h4 id="第三部分市场买入点目标价止损点和风险控制">第三部分：市场、买入点、目标价、止损点和风险控制</h4><p>最左边的五个空格要求我回答有关市场基本状况的问题。<strong>尖峰反弹信号</strong>是否有效，<strong>追踪股票均线的指标是看多还是看空，这只股票的空头净额是多少</strong>，<strong>需要多少天来补上</strong>，所有这些内容都已在本书前面描述过。</p><p><strong>最后一个空格是简短的总结。</strong></p><p><strong>用箭头所连接的三个空格是我决策制定过程的核心部分。它们所要的是每笔交易最重要的三个数字：买入价、目标价、止损价。</strong></p><p><strong>资金风险——这笔交易中，你愿意冒亏损多少钱的风险？这个数额永远不应该超过你账户资产的2%。我通常把它控制在远远低于这个门槛的位置。</strong></p><p><strong>持仓规模——根据持仓限额和入场点与止损点的差额，可以算出你能买多少数量。这已经在第50节“风险控制的铁三角”中详细论述过</strong></p><h4 id="第四部分买入之后">第四部分：买入之后</h4><p>A级盈利目标是在买入价上加日通道线高度的30%。软止损是记在脑海中的指令，而硬止损或灾难性止损是实在的指令。它不应该比第三部分中所写的止损价低。</p><p><strong>记下你将把止损位移到盈亏平衡位置的价格水平</strong>。当你执行这些必要步骤时，检查右手边的方框：设置止损价，创建一个日志，下达止盈订单。</p><p>当你开始制作自己的交易表时，只能复制第1、3和4这三个部分，但第2部分需要自己制作——制作符合你自己系统或策略的交易阿氏评分。</p><h2 id="交易日志">交易日志</h2><p><img src="Pasted%20image%2020240129203552.png"> A部分：交易日志需要我回答为何决定交易这只股票。我通常会空着这个格子，因为我喜欢用Snaglt软件在线图上写下这些观点。在欧特克(ADSK)的例子中，我附上了合成的线图，包括周线图、日线图和25分钟线图。 B部分：记录下入场和退出的日期和价格。记录滑点和买入量、卖出量及交易等级。 C部分：退出的原因，需要附上显示入场点和退出点的合成线图。 D部分：退出策略的清单要比交易策略的清单长。退出的原因可能是到了目标价或止损价，也可能是到了价值区间或包络线。我也可能会因为股票不再延续趋势方向或者开始掉转方向而选择退出。还有两种消极的退出：已无法承受下跌的痛苦，或是买入后发现这是一笔糟糕的交易。 E部分：交易后的回顾分析。我喜欢在退出交易两个月后回顾这笔交易。我设计了一个跟踪图表，用箭头标记出入场点和退出点，然后写下时过境迁后对这次交易的评论。这是吸取经验教训最好的方法。</p><p>我们中的大部分人会很快忘掉过去的交易，但是交易日志网站会提示你对它们进行回顾。当时你在K线图最右边区域艰难地决定买入卖出，如今这些K线已经到了图表的中间位置了，这个时候你可以重新审视你当时的决定，并学会如何改进它们。</p><p>记录交易日志会有三大好处。 第一个好处是即时的——写完日志能有更好的<strong>秩序感</strong>。 第二个好处是会在1～2个月后，当你开始回顾已经结束了的交易时。 第三个好处是，当你积累了几十个记录后，你会有多种方法去分析它们，并且能从你的资金曲线中有所成长。</p><p>在退出交易一两个月之后，回顾每笔交易是最好的学习方式之一。交易信号在图形右侧时，可能会显得模糊不定。而当你在图形中间看到它们时，已变得无比清晰。回顾你已经完成了的交易，并且加上一个“交易后”图表，能让你重新评估自己当时所做的决定。现在你可以清楚地看出自己做得对还是不对。你的日志能给你珍贵的经验和教训。</p><p><strong>回顾你的资产曲线是非常必要的（以月为单位），因为只有上升的曲线才能证明你是一位成功的交易者。如果你的资产曲线是下行的，说明或者你的系统可能有错误，或者你的风险管理十分薄弱，或者你缺乏交易纪律性——无论是什么，你都必须查找清楚并予以解决。</strong></p><p>但是，资产曲线将你所有的交易汇集到一起，是十分初级的分析工具。网页版交易日志能让你细化，追踪特定市场的资产曲线、交易策略、退出战术等。例如，我可以将做多和做空的操作分开来画资产曲线，也可以将采用不同策略、不同退出甚至不同交易想法来源的交易分别绘制资产曲线。相信我，一旦你看到退出的交易资产曲线的特点是“不能承受这样的痛苦”，你将再也不会不设置止损线了！</p>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以交易为生（中）</title>
    <link href="/2024/01/28/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
    <url>/2024/01/28/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>这部分主要包括如何构建交易系统</p><p>交易系统是寻找、进入和退出交易的一整套规则 一些人有着严格定制化的交易系统，给个人留有的决策空间很小——我们可以称他们为机械化的交易者。而另一些人给自我判断留下巨大的空间——我们称他们为自由决策的交易者</p><p>不管你采用什么样的交易方法，<strong>交易系统的重要优势是你可以在闭市的时间并且当你处于冷静的状态时，去设计它。交易系统会成为你在市场波动中的理性行为之锚。</strong></p><p>毋庸置疑，一个合适的交易系统是被写下来的。交易系统需要被记录下来是因为在现实的市场压力之下，一些重要的步骤很容易被遗忘</p><p>机械交易者建立了一整套准则，用历史数据进行测试，然后把它们放到系统中进行自动交易。再进一步，他的软件开始提示入场、目标和退出指令。一个机械交易者应该准确地按系统提示的进行操作。他们是否要遵循他的计划或者尝试扭曲、忽视这些信号便是另一番情况了，但是以上这些是系统应当运作的方式</p><p>自主决策的交易者在市场中每天都会更新交易策略。他会更倾向于比机械性交易者检查更多的因素，在不同时段给予它们不同的权重，并且更协调地跟随着最新市场行为的变化</p><p>谈及交易设置，在你交易操作之前，计划好所有相关的目标数值是非常重要的。<strong>在你还没有承担真实的风险之前，你是更加客观的</strong>；一<strong>旦你进入交易，你会倾向于认为“有更大的空间”。这也是失败者怎样从小的回撤变成灾难性损失的。我曾经建议过一个人在浮亏200美元时割肉，他拒绝了，直到账面损失98000美元时才清仓</strong></p><p>我们将会在后面章节讨论“风险控制的铁三角”概念的时候集中说明风险和资金管理。在这时候，我只想明确风险管理在严肃交易中是必不可少的。看着天花板说“我要交易500股”“我要交易1000股”，或诸如此类随意的数字，是不可取的。在本书后面的章节，你将学习到一些<strong>基于你的账户规模和风险容忍度之上的简单的公式，来计算交易持仓量。</strong></p><p>在写这本书的时候，我有三条投资的策略： （1）我最喜欢的是背离时的假突破； （2）第二条是股价在强势趋势中回调到价值区间时； （3）最后一条，我偶尔退到另一个极端——会在已过度扩张的趋势反转时下筹码。 每一个交易策略都有其准则，但是核心是——我只会进行符合其中之一策略的交易。对老手来说绝不会做过于随机的事情</p><p>请注意每个交易计划都需要以下几个重要特征： （1）交易设置——为每一笔交易计划好三个关键的数字：<strong>买入价位、盈利目标价位和止损价位</strong>。在进入市场进行交易之前，你需要决定你将愿意以什么价格成交，你期望从市场中获得的收益和你愿意遭受的风险。潜在收益与风险的比例通常最好要超过2∶1。唯一可以偏离这条准则的交易时机是，当技术指标的信号特别强烈的时候。当然，<strong>不要捏造你的目标来把一个不是很确定的交易转为一个可以接受的交易。你的交易目标需要贴近实际。</strong> （2）风险管理——事先确定你能承受在这笔交易中损失多少钱。用最大损失金额除以股数，得到每一股的可承受的损失——也就是你的买入价格和止损价格之间的差额。这将限制你交易的股数。 （3）最后同样重要的是，每一笔单独的交易都必须建立在特定的系统和战略之上。“在我看来很不错”这种想法并不是一个系统！当你听到一些股票提示或者看到脱缰而上的趋势时，会很容易变得激动。但是要告别像小狗追逐汽车那样去追逐股票了。如果你想以交易为生，你需要确定清楚自己的交易计划、战略或系统——用自己喜欢的方式来称它们——仅仅参与那些符合它们标准的交易机会。 注意：对每个计划的交易都要从三个重要的角度去考虑。我们会在这里做简短的介绍，之后在讲特定交易系统和风险管理的时候再做详尽的阐述。这三条要求对于严肃认真进行交易的任何人来说都是至关重要的。</p><h2 id="三重滤网交易系统">三重滤网交易系统</h2><p>三重滤网交易系统对每次操作进行三重测试或过滤。许多交易机会在一个蜡烛图界面看起来非常有吸引力，但在另一个时间周期的界面却看起来情况相反。通过三重滤网交易系统筛选的交易机会成功可能性要大很多。</p><p>实际上市场是如此复杂，很难用一种指标来分析，不同的指标在相同的市场之中给出相互矛盾的信号。趋势跟随指标随着股价的上升而上升并给出买入信号，然而此时震荡指标会显示为超买，而给出卖出信号。趋势跟随指标在股价下降的趋势中同步向下，并给出卖出的信号；但此时震荡指标却显示为超卖，并给出买入的信号。</p><p>趋势跟随指标在市场做趋势运动时能盈利，但在市场区间震荡时会导致受双倍的损失。震荡指标在震荡区间内能盈利，但是当市场开始形成趋势的时候，会给出过早的、危险的信号。交易者常说“学会和趋势做朋友”和“让你的盈利跑起来”。他们有时候也说“低买，高卖”。但是为什么要在趋势上升的时候卖？还有涨得多高算高呢？</p><p><strong>如果你更多地使用趋势跟随指标，结果将会指向一个方向，但如果你更多地使用震荡指标，结果会指向另一个方向。交易者总是能找到符合他所想听的信息的一组技术指标</strong></p><p>三重滤网交易系统设计出来就是为了过滤掉趋势跟随指标和震荡指标的缺陷，同时保留它们的优势</p><h4 id="选择时间周期">选择时间周期</h4><p>有一个重大的困境是交易品种的趋势在不同时间周期下很可能并非同时上升或下降的。任意品种的日线图可能展现的是向上的趋势，然而周线图显示的却是下降的趋势，反之亦然。我们需要一个系统来解决不同时间周期之间信号的冲突。</p><p><strong>三重滤网交易系统建立的基础是，市场的每一个时间周期对其大一号或小一号的时间周期，大概是五倍的关系</strong></p><p>开始时不妨问问自己，哪一个是你最喜欢的时间周期。周线图、日线图，还是10分钟或者其他线图？无论你喜欢用哪一个时间周期，三重滤网交易系统称之为中期时间周期。长其一号的是长期时间周期。短其一号的是短期时间周期。一旦你选定了中期时间周期，你先不用去看它，而是先去查看大一号的长期时间周期的线图，并且在长期时间周期线图里做好战略决策，然后再回到中期时间周期的线图中去</p><p>举个例子，如果有一笔交易你想持有几天或者几个星期，你的中期时间周期很可能被定义为日线图。周线图是尺度大一号的时间周期，即长期时间周期。1小时线图是尺度小一号的时间周期，因此是短期时间周期。</p><p>三重滤网交易系统首先要求你去检查长期时间周期图表，找出长期图表中的大趋势。它仅允许你顺着大趋势的方向进行交易。它使用中期图表中的趋势与长期趋势方向相反时的机会建立头寸。举个例子来说，就是当周趋势是上升的时候，则在日趋势下降时买入。当周趋势是下降的时候，则日趋势上升时是卖出的机会。</p><ol type="1"><li><p><strong>第一重滤网——市场潮流</strong> 三重滤网从分析长期图表开始——首先分析比你准备用以交易的时间周期大一个尺度的时间周期。大多数交易者仅仅对日线图给予关注，每个人都看着相同的几个月的数据。如果你开始分析周线图时，你的视角会比你的竞争者大出五倍。</p><p>开始的第一步，你需要选择你喜欢的时间周期作为中期时间周期。此时，甚至不用瞥一眼中期时间周期，因为先去看它会使你产生先入为主的偏见。直接去看大一个尺度的时间周期——你的长期时间周期图表。在那里你将做出市场是牛市还是熊市的战略决策。然后，再回到中期时间周期来，开始做策略性的决策，比如在什么位置买入和在什么位置设置止损。</p><p>最初版本的三重滤网使用周线MACD的斜率作为周线趋势的跟随指标（见图39-1）。它非常敏感并能给出许多的买卖信号。后来，我转而使用周线指数移动平均的斜率来作为长期图表的趋势跟随工具。再后来我发明了动力系统（后面章节将会对动力系统进行描述），并开始在第一重滤网中使用它。动力系统结合了前两者的优点。它不像MACD那样急剧变化但又要比EMA斜率的反应更加迅速。</p><p><strong>使用周线图MACD作为三重滤网中的第一重（我这里应该是月线图）</strong> 三重滤网要求我们在看日线图之前，先要去分析周线图。MACD的斜率由最近两根MACD线柱之间的关系确定。 这个指标会在它的斜率转而向上时发出买入的信号，在斜率向下时发出卖出的信号。 <strong>最佳的买入信号出现在MACD低于中心线位置，但方向转而向上的时候</strong> <strong>最佳的卖出信号出现在当MACD在中心线上方位置，但方向转而向下的时候</strong>（详见第32节的指标部分）。</p><p><strong>当MACD的斜率转而向上时（箭头A、C和E），它只允许我们在买入或者观望的方向上交易。当斜率转而向下时，它只允许我们在卖出或者观望的方向上交易。</strong> <img src="Pasted%20image%2020240128190043.png"> 注意在A点或者E点的买入信号要比在C点的买入信号质量高——因为C点的买入信号产生在中心线之上。在春天的时候买入总比在夏天的时候买入要好。在图表的右边界上，上升的趋势十分强势，因为信号E点伴随着涨背离：价格的底部变深（A和E）伴随着MACD指标的底部变浅了。</p></li></ol><p><strong>第一重滤网总结：使用趋势跟随指标识别周趋势并随着趋势的方向交易。</strong></p><p><strong>交易者有三种选择：买、卖或者观望。三重滤网交易系统的第一重会帮你排除其中一个选项。它的作用像监察员一样，在上升的趋势里只允许你选择买入或者观望；在下行的趋势里只允许你卖空或观望。你必须顺应潮流的方向，否则它会禁止你下水。</strong></p><ol start="2" type="1"><li><p><strong>第二重滤网——市场波浪</strong> 当周趋势是上升的，日趋势的回调正是很好的买入机会。当周趋势是下降的，日趋势的上升正是很好的卖出机会。</p><p>第二重滤网：将震荡指标应用于日线图之中。在周线的上升趋势中，利用日线的回调来寻找买入机会；在周线的下降趋势中，利用日线的反弹来寻找卖空机会。我喜欢在第二重滤网使用强力指数(force index)，这个指标在第30节已经介绍过。其他一些震荡指标，比如相对强弱指标(RSI)、埃尔德射线(Elder-ray)和随机指标(stochastic)等表现得也很不错。</p><p>当周趋势是上升的，三重滤网仅允许采用日线图震荡指标发出的买入信号，而不会允许采用其发出的卖空信号。2日强力指数指标EMA在降到0值以下的时候，只要它不是下降到了几周内的新低点，就会发出买入信号。当周趋势是下降的，强力指数指标会在上升到中心线上方的时候，只要它不是上升到几周内的新高点，就发出卖空的信号</p><p>2日强力指数指标EMA可以用作三重滤网交易系统第二重的众多震荡指标之一。当它下降到其中心线之下的时候，强力指数标记出买入的机会。当它上升到其中心线之上的时候，它会标记出卖出的机会。当周趋势是上升的（这里用绿色的水平线标出），在日线震荡指标中仅采用买入信号，以建立多头头寸。当周趋势是下降的（这里用红色的水平线标出），在日线震荡指标中仅采用卖出的信号，以建立空头头寸。</p><p>总结：在第一层滤网的趋势上进行交易，趋势是上涨，则在回调时利用震荡指标寻找买入机会</p></li><li><p><strong>第三重滤网——买入技术</strong> 后续再补充，暂时没看懂</p></li></ol><p><img src="Pasted%20image%2020240128190943.png"></p><h4 id="止损和止盈目标">止损和止盈目标</h4><p>对于成功的交易来说合适的资金管理是至关重要的。一个纪律严明的交易者会在盈利目标处兑现利润和快速止损，他们的表现远比那些抱有幻想和在错误交易上逗留的交易者要好。</p><p>在你进入一个交易之前，写下三个数字：<strong>买入价位、盈利目标价位和止损价位</strong>。<strong>没有定好这三个数字的交易便是赌博。</strong></p><p>三重滤网交易系统要求<strong>使用长期图表来设置止盈点</strong>，<strong>使用中期图表来设置止损点</strong>。如果你是使用周线图和日线图搭配的，则在周线图上设好盈利目标，在日线图上设好止损目标。当在日线图的回调中买入时，用周线图的价值区间（见两条EMA线）作为盈利目标是一个好的选择。用25分钟线和5分钟线搭配使用做日内交易时，在25分钟线上找到盈利目标，然后在5分钟线设置好止损位，当你控制住了风险的时候，你更容易得到一个好的结果。</p><p>三重滤网交易系统需要设置相对保守的止损价位。它既然让你按照市场大趋势的方向进行交易，就不允许为损失留太多空间。跟上潮流或者马上退出。我们之后将在第54节回到这个话题，“如何设置止损点”。</p><h2 id="动力系统">动力系统</h2><p>要度量任意交易品种的惯性，一个好的指标是短期EMA的斜率。上升的EMA意味着具有牛市惯性，而下降的EMA则说明具有熊市惯性。</p><p>任意趋势的能量可以用MACD柱状线的斜率来表示。如果它的最近一根线柱比其前一根线柱的高度要高（像字母m-M的高度变化），或者是比其前一根线柱的深度要浅（像字母y-v的深度变化），则MACD柱状线的斜率是上升的，所以它的能量是向上推动的。如果最近一根线柱比其前一根线柱要低（像字母M-m的高度变化或字母v-y的深度变化），则MACD柱状线的斜率是下降的，所以它的能量是向下推动的。</p><p>当我们使用MACD柱状线来定义能量时，它是否高于或者低于零是无关紧要的：真正重要的是最近两条MACD线柱之间的高低关系。 <img src="Pasted%20image%2020240129205211.png"></p><p>（1）EMA上升、MACD上升（特别是小于0时）=动力系统显示是绿色，牛市，禁止卖空，允许买入或观望。 （2）EMA下降、MACD下降（特别是大于0时）=动力系统显示是红色，熊市，禁止买入，允许卖出或观望。 （3）EMA上升、MACD下降=动力系统显示是蓝色，中性，无禁止事项。 （4）EMA下降、MACD上升=动力系统显示是蓝色，中性，无禁止事项。</p><p>最初，我想用这个系统完全实现自动化交易——绿色时买入，红色时卖空，当颜色变换后则兑现利润。<strong>对动力系统做的回测让我打消了这个主意</strong>。<strong>自动交易系统成功抓住了每一个趋势机会，但是在区间震荡时，它会在红色和绿色之间反复转换，结果两头都遭受亏损</strong>。</p><p>**动力系统不是一个自动交易系统，而是一个监测系统！能够加强任何一种寻找交易机会的方法，无论是技术分析还是基本面分析。</p><p><img src="Pasted%20image%2020240129213854.png"> <strong>垂直的绿色箭头标志的柱线后面紧跟着红色的柱线。红色禁止你买入。最好的买入时机是当红色消失的时候。你能看到这些绿色箭头指示出一个接一个的中期底部，包括在图表右边界的买入信号。拥有一个客观的方法能让你在市场下降停止的时候有买入的信心。</strong></p><p><strong>动力系统也会对兑现利润的好时机给出建议。倾斜的红色箭头指向蓝色柱线，蓝色柱线出现在一系列远离价值区域的绿色柱线之后。它们显示牛市上行受阻的位置——兑现盈利的好时机，并等待下一个买入机会。</strong></p><h4 id="入场时机">入场时机</h4><p><strong>在你将动力系统应用到最喜欢的市场时，记住三重滤网系统要求在多于一个时间周期内进行分析。选择你最喜欢的时间周期，并将之定为中期时间周期。将其周期乘以5倍，找到长期时间周期。==如果你最喜欢的图表是日线图，首先去分析周线图，并做出看多或看空的战略决策。再使用动力系统来决定何时允许进行买入或者卖空。</strong>==</p><p><strong>如果你认为市场正在形成顶部，趋势即将反转。监控周线图和日线图的动力系统，如果任意一个仍然显示是绿色，说明上升趋势依然没有消失，禁止卖空。当两个时间周期的绿色都消失了时，你才可以卖空。</strong></p><p>时间周期越短，它的信号就会越敏感：日线图上的动力系统开始改变颜色总会先于周线图。当做日内交易时，5分钟线图改变颜色要比25分钟线图早。</p><p>如果我的分析表明市场正在筑底，即将开始反转，我会等到日线图不再显示变红，开始变蓝，甚至变绿，然后我再去观察周线图，这时它仍然是红色的。<strong>一旦周线图从红色变蓝，系统会开始允许买入。这种技术防止我当市场仍在下降的时候过早买入。</strong></p><p><strong>记住，动力交易系统是一个监测系统。它不会告诉你应该做什么——但是它会很明确地告诉你不该做什么。不要违背这个监测。</strong></p><p>许多技术分析软件都包含一种功能，叫“条件格式”。它允许根据EMA和MACD的斜率给柱线或蜡烛图上色。<strong>如果你使用的软件平台不允许条件格式功能，你仍然有办法使用动力系统。直接观察EMA和MACD的斜率：将它们结合起来分析，你就知道最新一根线柱应该是什么颜色了。</strong></p><p>如果懂编程的话，你可以给动力系统加入更多的功能。你可以检验EMA的不同长度或者MACD的不同设置，来找到市场中最合适你的那些组合。日内交易者可以编制警示声音来协助监测多个市场中颜色的变化，而不必紧盯着屏幕。</p><h4 id="退出时机">退出时机</h4><p>如果你是个短期动量交易者，一旦动力系统显示的颜色不再支持你的交易方向，则马上了结你的交易，即使在两个时间周期中只有其中一个改变了颜色。通常，日线MACD的反转要快于周线MACD。当它在上升趋势中下降，表明上升的动量正在减弱。</p><p>当买入的信号消失时，马上兑现收益，而不是等待出现卖出的信号。在下降的趋势中将这个做法反转一下。一旦动力系统不再显示红色，即使两个时间周期中只有其中一个改变了颜色，也马上清空你的空头头寸。最有效的下降部分已经结束，动力系统已经完成了它的使命。</p><p>==<strong>动力交易系统鼓励你小心谨慎地入场，但快速地退出。这是专业的交易方法。初学者往往与之背道而行，猛然跳入交易中，然后永不再退出，期待市场改变方向。</strong>==</p><p>如果两个时间周期中的任意一个变成了蓝色，波段交易者或许仍会持有交易头寸。波段交易者要避免时间周期中任意一个的颜色与交易的方向变得相反。如果你是多头，时间周期中的一个变成红色，则是时候卖出并空仓观望了；如果你是空头，当动力系统开始变绿，它就发出了让你平掉空头头寸的信号。</p><p>动力系统通过展示通常什么情况下漫无目的、毫无组织的群体开始变得情绪化并开始奔跑，以帮助你在市场混乱的狂流中识别出秩序。在趋势的形态刚刚浮现时入场，并在其开始沉入混乱的海洋前退出。</p><h2 id="通道交易系统">通道交易系统</h2><p>当价格开始上升的时候，它经常在碰到隐形的天花板时停止上涨。它的下降似乎也在碰到隐形的地板时停止下跌。<strong>通道帮助我们预测未来在哪儿最可能遇到支撑线和阻力线。</strong></p><p>通道能帮助识别买卖机会和避免错误的交易。交易通道的最初研究者是薛斯，他在他1970年出版的《股票交易时机的获利法宝》一书中，进行了阐述。</p><p>后来，伟大的数学家本华·曼德博(Benoit Mandelbrot)被埃及政府聘请建立一个棉花价格的数学模型——棉花是埃及主要出口农产品。经过广泛的调研，他做出了结论：“价格围绕价值上下波动。”这听起来简单，但是事实上是很深刻的。</p><p><strong>如果我们接受了这个数学发现，并且如果我们能够有手段来定义价值，并且能测量平均的波动，我们将会拥有一个交易系统</strong>：只需要在价格低于价值的时候买入，在达到价值的时候兑现利润；在价格高于价值的时候卖空，然后在回到价值时回补空头头寸。</p><p>我有一个严格的 准则就是：==<strong>永远不要在上通道线之上买入，也不要在下通道线之下卖出</strong>==。 这 个准则会导致我错过一些趋势机会，但我的安全性得到了极大的提升</p><h3 id="构建通道的两种方法">构建通道的两种方法</h3><p>我们可以通过绘制两条平行于一条移动均线的线组，来构建一个通道：一条线在移动平均线上方，另一条线在移动平均线下方。我们可以根据市场的波动性来改变两条通道线之间的距离（标准背离通道）。</p><p>以移动均线为对称中心的通道线对股票和期货交易都很有用。标准背离通道（有时也叫作<strong>布林通道</strong>）对于期权交易十分有用。</p><p>通道界定了价格正常波动和不正常波动之间的界限。价格在通道中运行是正常的，只有非正常的时间驱动才会使价格波动到通道之外。价格在通道的下轨线之下的时候，是被低估了；价格在通道的上轨线之上的时候，是被高估了。 #### 对称的通道</p><p>之前我们已经讨论过使用两条移动均线为一组，来进行交易。使用这组移动均线，并将<strong>长期移动均线作为通道线的核心</strong>。举个例子来说，<strong>如果你使用13日和26日EMA这组线，则通道线是平行于26日EMA线的。</strong></p><p>通道的宽度依赖于交易者选择的系数。这个系数通常用EMA的百分比来表示。 上通道线=EMA+通道系数×EMA 下通道线=EMA-通道系数×EMA</p><p>当为任意市场设置通道线的时候，<strong>开始通道系数可以设置为3%或者5%，然后不断调整通道系数值，直到通道线把最近100根线柱的所有价格数据中大约95%的包含在内，在日线图上大约是5个月时间长度</strong>。这很像试穿衬衫：你寻找那些穿起来不是太松也不是太紧的衬衣，只把你的手腕和脖子露在外头。同样，只有极端的价格会跑到已经画好的通道外面。</p><p><strong>波动较大的市场需要较宽的通道，而沉寂的市场需要较窄的通道。</strong></p><p><strong>便宜的股票通常比高价股票有更高的波动率。</strong></p><p><strong>长时间周期的线图需要的通道更宽。根据经验，周线图的通道宽度会是日线图的两倍。</strong></p><p>我过去常常靠手动画通道线，直到我的程序员为几个软件包编写了一个插件，叫作<strong>自动包络</strong>。它能自动地为任意交易品种，在任意时间周期里，画出正确的通道线（见图41-1）。在为多款流行程序设计的“埃尔德盘”中可以找到它。</p><p><img src="Pasted%20image%2020240129221257.png"></p><p>这个图表展示了2014年3月期的欧元外汇期货(ESH14)最近几个月时间内的交易情况。期货要比不透明的外汇交易要透明和真实很多。只要我需要做外汇交易，我首选外汇期货。</p><p>指数移动平均反映了在一定时间内市场对于价值的一致认同。 当价格靠近移动均线时，市场定价是公允的。 当价格下降到靠近下通道线的时候，则是被低估的； 当价格上升到接近上通道线时，则是被高估的。 通道线帮助我们在市场便宜的时候找到买入机会，而在市场被高估的时候找到做空的机会。</p><p>在上通道线上，熊市的背抵着墙壁与牛市进行搏斗；而在下通道线，牛市的背抵着墙壁与熊市搏斗。当我们的背抵着墙壁的时候，我们都会更加努力地战斗，这也是为什么通道线通常能守住的原因。</p><p><strong>如果上涨的高度突破了上通道线，并且收盘价在通道线上方，这显示上升趋势异常强劲。当反弹未能触及上通道线时，则是熊市的信号，因为表明牛市变得更加虚弱</strong>。这反过来同样适用于下降的趋势。</p><p>最好的交易信号是用通道线和其他技术指标结合给出的 （1）当价格达到上通道线，而诸如MACD柱状线之类的指标却出现了熊市背离，则是卖出的信号。它说明多头正变得虚弱，价格上涨过度了 （2）当价格达到了下通道线，而指标出现了牛市背离，则是买入的信号。它表明熊市正变得弱势，价格已经到了低点。我们必须在多个时间周期中分析市场。当周线图是上升时，就要在日线图中寻找买入机会。当周线图是下降的时候，就要在日线图中寻找卖出机会。 （3）当通道是上升的时候，在接近移动均线的位置做多，当到达上通道线的时候兑现利润；当通道是下降的时候，在接近移动均线的位置做空，当到达下通道线的时候兑现利润。 当通道上升时，最好只在多头方向进行交易，在长期和短期移动均线之间的价值区间中买入，然后在上通道线位置上卖出；当通道是下降的，最好在价值区间内卖空，然后在下通道线位置回补头寸。</p><p>例子： <img src="Pasted%20image%2020240129222200.png"></p><p>区域A——当价格到达下通道线，MACD线的新低表明这个低点将会被再次确认或者突破。 区域B——通道线拒绝了突破，反弹有可能即将开始。 区域C——价格到达上通道线并且被弹回——有可能发生反转。 区域D——买入。价格已经到达下通道线，但MACD显示在A与D之间有牛市背离，中间由C点隔开 区域E——价格到达了上通道线，MACD创了新高，表明这个高点很有可能被再次确认或者突破。 区域F——完全回归价值区间；MACD向下突破到0值线之下，创造了一个熊市背离的迹象，但仍可买入等待回到前期高点 区域G——卖出并反向做空。价格已经到达了上通道线，然而MACD在高点E和G之间已经表现出熊市背离，中间由F点区隔开。</p><h4 id="标准背离通道布林通道">标准背离通道（布林通道）</h4><p>这个通道线的特别之处在于它的宽度和市场的波动有关。它们的交易规则和常规的通道不一样。</p><p>当市场的波动性增大的时候，布林通道的宽度会增加；当市场波动性减小的时候，布林通道会变窄。窄的布林通道表明市场处于休眠的、安静的状态。大的行情常常从平坦的底部位置上爆发。布林通道帮助我们发现市场从安静到活跃的转变。</p><p>这些布林通道对于期权交易者十分有用，因为期权价格很大部分是由市场波动性所驱动。狭窄的布林通道指导你在波动性低、期权相对便宜的时候买入。宽的布林通道指导你在波动性很高、期权价格很高的时候卖出。</p><h2 id="交易工具">交易工具</h2><p>交易工具被分为不同的门类。它们在电脑屏幕上的图表看起来可能很相似，但不要让它们的外表欺骗了你。它们每一类都有各自的优点和不足。它们提供的机会不同，具有的风险也不同。你所要做的最重要的市场决定之一就是选择什么品种去交易</p><p><strong>不管是哪一类，你需要确保所选交易工具满足两个重要的条件：流动性和波动性</strong></p><p><strong>流动性</strong>指与这一类别中的其他交易品种相比的日均成交量。日均成交量越大，你进入和退出交易就越容易。在流动性不好的股票中，你或许能建立浮盈的持仓，但当你退出时，却变成亏损，因为买卖价差特别大。</p><p><strong>波动性</strong>是交易品种短期运动的范围。交易品种的波动性越高，交易机会就越多。受欢迎的股票往往波动性很大。许多公共事业部门公司的股票流动性很好，但因为波动性很低，而很难交易——它们常常在狭窄的价格区间里震荡。</p><p>关于卖空可以看《以交易为生Ⅱ：卖出的艺术》 #### 股票</p><p>找到自己有精力可以关注的股票数量</p><h4 id="etf">ETF</h4><p>此时的ETF只能买卖净值，作者认为ETF有些远离市场，而且不能做空，不喜欢，认为这样白白被收买入费用，而且还不见得比股票跑的好。现在国内的情况反而反过来，场内ETF开户可以免5，而股票则要比较高的印花税，而且不免5，因此我目前资金支撑不起直接买贵的股票，比如五粮液一手就13000</p><h4 id="期权">期权</h4><h4 id="期货">期货</h4><p>期货是以确定时间和确定价格，交割确定数量特定商品的合约</p><p>买入股票的人会成为公司股东中的一员，但是当你买一份期货合约的时候，你没有拥有任何东西。你只是买入了一份有约束力的合约，在未来的时点要买入某种商品，它可能是一车小麦，也可能是一捆国债。而卖给你期货的人则承诺了交割的义务。你用来买股票的钱会转移到卖出股票的人手中，但是在期货市场中，你存放的保证金还在清算中心，作为担保品，确保期货到期时你会按时交割。那就是为什么过去叫它“诚实金”。在股票市场中，你会为借钱而付出利息，但是在期货市场中，你还能获取保证金的利息。</p><p>在股票市场中，大多数人都只做多，只有很少人做空。在期货市场中，与期权市场一样，多头的规模和空头的规模总是相等的，因为如果有人买入一份开仓期货合约，必须有另外一个人对应地卖出开仓，也就是做空。<strong>如果你想交易期货，要对做空操作很顺手。</strong></p><p>新手在期货市场的生存率很低——据说十分之九的新手在最初几个月就会被洗出局。要理解，危险的并不是期货本身，而是新手的风险管理能力欠缺。期货给成熟的交易者提供了非常好的交易机会，但是对业余交易者来说是很危险的。在你到期货市场中冒险之前，必须培养自己卓越的资金管理能力（将在第49～51节中详细讲述）。</p><p>对于有很强资金管理能力的交易者，期货是非常有吸引力的。高收益率需要铁一般的纪律。新手炒变化更慢的股票会更好一些。一旦成为成熟的交易者，你观察期货会更加清晰。另外，读一些介绍性的书，比如乔治·安杰尔(George Angell)的《期货市场取胜之道》(Winning in the Futures Market)就是一本很好的书，其他的还有特维莱斯(Teweles)和琼斯(Jones)的《期货交易实用指南》(The Futures Game)。</p><p>套期保值是持有与其商品现货头寸相反方向的期货头寸。例如，大糖果厂商就能预测未来几个月需要多少糖。在糖的价格合适时，他可以在纽约或伦敦的期货市场买入相应数量的糖期货。在未来的几个月，他们需要的糖，通过持有糖期货的方式套期保值了，当他们需要进货的时候就卖掉相同数量的期货合约。如果糖的价格上涨了，糖果厂买入原材料需要支付更高价格，但是他们持有的期货头寸的盈利大致抵消了现货的损失。如果糖的价格下跌了，他们在期货合约上是赔钱的，但买入原材料的成本下降了。而那些没有进行套期保值的竞争对手正在经历着风险。如果价格下降了，他们会买到便宜货，得到一笔意外之财，但是如果价格上升了，他们就亏惨了。进行套期保值的消费者可以集中注意力于他们的核心业务，不用受到未来价格波动的干扰。比如航空公司提前几年就可以知道未来需要多少航空燃油，买入期货合约可以保护他们免受燃油价格波动的影响，而原油价格暴涨暴跌是很常见的。</p><p>商品生产者同样可以从套期保值中获利。农业生产者可以在价格足以保证获利的时候，提前出售他们的小麦、咖啡和棉花。他们可以卖空足够的期货合约来覆盖他们预期的产量。从这点上来说，他们没有价格风险。如果价格下跌了，他们会通过期货市场的盈利来弥补现货市场的损失。如果价格上涨了，他们在期货市场的头寸会有所损失，但是在更高的价格上卖出真实的商品又把损失弥补回来了。</p><p>在美国，玉米、糖和平缓时期的铜等品种对初学者来说是比较好的市场。它们流动性好，波动性大而且单价不是很贵。</p><p>我们在第9章（风险管理），将再讲到期货市场。你将学到期货合约是否适合交易取决于标的资产的价格、波动性和你账户里的资金规模。</p><h4 id="外汇">外汇</h4>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以交易为生（上）</title>
    <link href="/2024/01/27/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2024/01/27/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本部分包括了以交易为生需要的： 心理建设 + 技术面指标</p><h2 id="个体心理">1. 个体心理</h2><p>要战胜市场，我们必须记住交易的三大要素：<strong>良好的心态、一套合逻辑的交易系统、 有效的风险管理计划</strong>。它们就像凳子的三条腿一样——缺了哪一条，凳子都会倒。新手的通病是——只关注技术指标和交易系统而忽略其他要素</p><p>你得清醒地意识到自己的自我毁灭倾向。不要把自己的损失归咎于坏运气或者是其他人，你应该为最终结果负责。开始坚持记日志吧——<strong>记录你全部的交易记录，记录你为什么买入卖出，寻找成功和失败的重复模式。那些不会向历史学习的人注定会重复历史</strong></p><p>在一波连胜之后，业余的交易者开始误认为自己是天才，自己如此擅长交易，每一次交易都能成功，这种感觉令人着迷。这正是他们开始偏离规则、损失资本的开始。</p><p>成功的交易者，他们有一个突出的标志，那就是能够让自己的资金稳步增长而非大起大落。</p><p>对于交易风险的定义会改变你管理资金的方法（详见第9章，风险管理）。单次交易的最大风险额度不应超过账户资产的2%。如果你有10000美元，则不应超过200美元。如果你的资金量较小，就限定自己少买一些股票，选择便宜一点的期货或迷你合约</p><p>你有保存自己的交易记录吗？股市赌徒的一个明显特征就是从来不做合格的交易记录。优秀的商人都会将交易记录保存完好。你的记录必须包括每次买入与卖出的价格和日期、滑点、佣金、止损点、对止损点的所有调整、买入的原因、目标价位、最大浮盈、达到止损点后的最大浮亏，以及任何有必要记录的数据——以便于以后回顾自己的交易</p><p>在交易风险覆盖范围内交易就像无酒精的生活。交易者在交易前必须先假设自己亏损，就像酒鬼必须承认自己是酒鬼才能开始戒酒一样</p><p><strong>市场不知道你的存在，你的存在也无法影响市场。它不会故意关照你的财富，也不会特意伤害你的资金。你要做的，只是控制自己的行为。</strong></p><p>金融市场是整个地球上最有娱乐性的地方，但是情绪化交易却是最致命的</p><p>道格拉斯曾警告说：“如<strong>果市场的行为让你觉得迷惑，那只是因为你自己的行为是古怪而失调的。当你连自己要做什么都不知道时，你怎么可能判断出市场的下一步动向</strong>？你唯一能够掌控的就只有你自己。作为一名交易者，你有权利决定是自己赚钱还是被别人赚钱。”他补充道：“能持续获利的交易者，都是将自律的态度应用到交易中的人。</p><p>想要成为专业的交易者，可以看看以下的单子： （1）坚定自己在市场中长期作战的意念——从现在开始至少交易20年 （2）像海绵一般地学习，关注专家的观点，但对任何事情都要保持有益的怀疑态度。遇到有疑问的地方要刨根究底，而不是简单地接受专家的观点，或只理解他们字面上的意思。 （3）不贪婪，不急于交易——要把你的时间用于学习，市场一直在这里，未来无尽的岁月中会有更多更好的机会 （4）培养分析市场的方法，换句话说，就是“<strong>如果A发生，那么B很可能会发生</strong>”。市场有很多维度，要使用多种解析方法来确认自己的交易决策。要学会用历史数据测试交易决策，随后在市场上真枪实弹地进行交易。市场瞬息万变，<strong>你需要的是根据牛市、熊市、震荡市等不同的特征采用不同的工具进行交易，同时还要有所区分</strong>（详情见技术分析章节） （5）建立一套资金管理计划。你的第一目标是必须长期生存下去，第二目标是资本的稳定增长，第三目标才是赚取高额利润 （6）要认识到交易者在任何交易系统中都是最为薄弱的一环，需要学会克制情绪化交易 （7）胜利者在思考、感受与行动上的方式与失败者是完全不同的。你必须深探自己的内心，驱赶那些幻觉，改变你原来的思考、感受与行动的方式。这样的改变通常都不容易，但如果你想成为一名专业交易者，你必须专注于自我改善和培养自己的个性</p><h2 id="群体心理">2、群体心理</h2><p>成功的交易者必须学会独立地思考问题，他需要强大到能独自分析市场并进行买卖决策</p><p>群众有着足够的力量来创造某种市场趋势，群众或许不够理智，但却比任何单个个体要强大很多。千万不要逆趋势交易。一旦上涨趋势得以确立，你能做的只有买进或者在一边观望。千万不要仅仅是因为感觉价格过高而去卖空——再次强调，不要和趋势作对。没有哪个规定说你一定要和人群一同奔跑，但你至少不应该逆着人群行进</p><p>大多数离开原有平台的交易者开始用自己的钱冒险时，他们便开始被困于恐惧、贪婪、兴奋或恐慌等负面情绪中，很少能成功地交易自己的账户——这证明了心态才是交易成败的关键</p><p>群体十分简单原始，所以交易策略也应该简单。你不用把自己当成一个火箭专家那样去设计复杂的计划。如果价格走势与你的预测相反，就止损退出。永远不要与群体叫板——你要做的很简单：利用自己的判断力，决定什么时候加入群体什么时候离开观望</p><p>你需要认真地准备好你的交易计划，切忌随着价格的瞬息万变而情绪化交易。最好是可以亲手将你的计划书写在纸面上，这样可以更确切地认识到自己应该在什么条件下开始交易或者退出交易。交易的过程中不要肆意制订交易计划，否则你就会很容易被群体情绪同化</p><p>在交易的过程中，你必须时刻留意自己，关注自己精神状态的变化。写出自己入场与出场的条件，包括资金管理规则。只要手上还有仓位头寸，就坚决不能修改计划。</p><p>当价格趋向上涨，多方将更为乐观，并不介意为此多花一些钱买入，他们在高位继续买入是因为他们预期价格将进一步上涨。当贪婪而乐观的多方遇到了恐惧而保守的空方，市场就会反弹。这样的感受愈强烈，反弹程度就会愈发剧烈。而只有当多方失去热情，这种反弹才会结束</p><p>当价格下跌，空方感受到乐观的情绪，从而不会介意在更低的价格上卖空。多方将感到恐惧，仅在折价条件下才会购买股票。当空方以胜利者自居时，他们继续在更低的价格上卖空，使得下跌趋势继续。当空方开始谨慎行事，拒绝在更低价格卖空时，这种下跌才会停止</p><p><strong>个人的自由行为难以预测，而群体行为更为简单，且易于被追踪：当你分析市场的时候，你便是在分析市场行为。你需要识别群体移动的方向以及多空双方改变的速度</strong>。</p><p><strong>持续上涨的时间越长，越多的分析师会被困在群体的无意识之中，忽视了危险的信号，并错失了最终的反转。持续下跌的时间越长，越多的分析师会被困在悲观看空的情绪之中，忽视了牛市的信号</strong></p><p>这儿有一个帮助你检测你的偏差的方法。如果你想买入，把你的行情图上下颠倒，观察是否像是卖出信号。如果仍然像是买入信号，在你再次翻转行情图之后，你就需要将多头的偏差移出你的系统。如果两张行情图都看着像是卖出信号，那你就需要将空头偏差移除你的体系</p><p><strong>在做金钱的交易的时候，你不需要预测未来。你需要从市场提取信息，来寻求是否空头和多头处于控制之中。你需要衡量市场上占主导地位的群体的力量并以此来决定现有趋势有多大可能会持续下去。你需要练习保守的金钱管理，从而获得长期的生存和财富积累。你必须观测你的思维的运作，避免倾向于贪婪或者恐惧。如果能够遵守这些原则，交易者会比大多数预测者要成功</strong></p><p>成功的交易建立在三大支柱之上。你需要分析多空力量的平衡。你需要实践资金管理。你需要严格服从你的交易计划，避免在市场中过于兴奋或者沮丧</p><h2 id="经典图表分析">3、经典图表分析</h2><p>在看了成千上万的图表之后，我发现市场根本不认同斜线，市场能够记住价位，这就是为什么水平支撑位和阻力位有意义，而斜线趋势却是主观的甚至是自欺欺人的</p><p>在我自己的交易过程中，我只用几个客观到足以让人信赖的图表模式。我关注基于水平的支撑区和阻力区、每日开盘价和收盘价的关系、蜡烛图高点和低点的关系，这些都是客观的</p><p>记住一条关键原则：“每一个交易价格都是所有的市场参与者价值认同瞬间达成一致的表现。”基于此，每一个价格柱状线都提供了多头和空头激烈博弈的重要的信息</p><p><strong>每日开盘价往往反映了业余者对价值的看法</strong>。业余者每天阅读早报，看前一天发生了什么，然后在开车去工作之前下订单。业余者总是在每天和每周的开始阶段异常活跃</p><p>在牛市中，市场通常在周一或周二时出现当周最低价——因为业余者会兑现前一周赚到的利润，然后市场会在周四或周五创出新高。而在熊市中，周一或周二通常会创出当周价格的高位，随后在接近周末时则会创出新低</p><p>每天或每周的收盘价则往往反映了专业交易者的行为。他们全天都在盯着市场交易，对市场变化做出反应，并倾向于主宰最后1小时的交易。他们当中的许多人在那段时间兑现利润，以避免持仓过夜</p><p>每一根柱状线的收盘价都是当天多方和空方博弈的最终结果，每根柱状线的最低点代表了最强空方的力量，多方反之</p><p><strong>柱线图中最高点和最低点的距离反映了多方和空方冲突的激烈程度</strong></p><p>一根平均长度的柱状线表明市场相对冷静。如果柱状线的长度只有平均长度的一半，说明市场疲软而冷清。如果柱状线是平均长度的两倍，则说明市场火爆，多方和空方的博弈遍及各个战场</p><p>人是有记忆的，人们记得过去的价格，而这些记忆会影响他们做出买或卖的决定。人们的记忆创造出市场价格之下的支撑位和市场价格之上的阻力位</p><p>混沌理论在最近的几十年来得到了推广。市场大部分时间段是混沌的，你只能在那些有序的时间段里才能取得一定优势，如果你在混沌时间进行交易，那么唯一赚钱的就是你的经纪商。</p><p><strong>你要时刻牢记的关键点是：一旦混沌中出现某种模式，你的交易系统应该能够迅速识别这种变化，这就是你入市交易的时候</strong>。之前我们说过，相对于专业的交易者，个人交易者的最大优势在于可以等待好的时机进行交易，而不必每天都保持活跃的交易</p><p>市场模式也具有分形结构，如果我向你展示同一市场的一些图表，一旦去掉了时间标签后，你就无法分辨出这些图表到底是月线图、周线图、日线图还是五分钟线图。下文（第39节）我们将回到这个主题，届时你就会发现为什么使用不同频率的时间进行分析如此重要。我们要确保在不同时间频率的图表中市场传达出的买卖信息能相互印证。如果不是如此，<strong>那么说明市场依然处在混沌之中，而我们则要保持观望。</strong></p><p><strong>在画支撑位线和阻力位线时，让其经过成交密集区的边缘，最好是众多柱状线主体的边缘，而非那些极限价格。交易密集区是大量交易者想法发生改变的位置，而极限价格仅仅是那些心理最脆弱的交易者恐慌的反映</strong></p><p>画水平线穿过密集区间的上边缘和下边缘。下边的线是支撑位，在这个位置买方将战胜卖方。上边的线是阻力位，在这里卖方的力量将压倒买方。每次价格触及这些界线又弹开，这些界线的力量会得到加强。要警惕支撑和阻力位附近的假突破</p><p><strong>小的支撑位或者阻力位会导致趋势的暂停，而主要的支撑位和阻力位则会造成趋势的反转</strong>。大量的交易者们在支撑位买入，在阻力位卖出，使得支撑位和阻力位的有效性变成了一种自我实现的预言</p><p>如何识别趋势呢？不是通过趋势线。我最喜欢的工具是<strong>指数移动平均</strong>，我们将在下一章中谈到这种方法。趋势线是非常主观的，它是最自欺欺人的一种工具。在趋势识别领域，计算机分析远胜于经典的图表分析方法</p><p>支撑位和阻力位之所以能够存在是因为大量交易者感到了痛苦和悔恨。在买卖中赔了钱的交易者会感到非常痛苦。</p><p>当价格跌破一个区间时，之前买进的多方就会感到痛苦。他们感觉被困住了，想等待价格回升，回本之后马上卖出股票。空方则相反，后悔自己卖出的太少。他们等待市场回升，有第二次做空的机会。多方的痛苦和空方的后悔就会形成阻力位——那是市场下降趋势中的天花板。支撑位和阻力位的强度取决于大量交易者感受的强度</p><h4 id="支撑位和阻力位的强度">支撑位和阻力位的强度</h4><p>价格在密集交易区波动越久，空方和多方投入的感情成本就越大。当多次趋势触及同一反复震荡区时，这一区域就成了一个布满弹坑的战场：防御者有大量的防御能够减弱任何攻势</p><p><strong>这些区域的力量取决于三个因素：区域的长度、高度，以及在区域内的成交量。你可以将这些因素作为交易区的长、宽、深进行可视化处理</strong> 1. 区域长度 阻力区或者支撑区持续时间越长——它持续的时间越长或者期间被冲击的次数越多——阻力或者支撑力度就越强。支撑位和阻力位就像好酒一样，时间越久越好。但是太久也没用，因为随着支撑位和阻力位变得过于久远，它们的力量就会逐渐减弱。由于失败者被不断洗出市场，由其他新进者代替，这些新进者并没有在老的价位上投入那么多感情 （1）持续两周的反复震荡区只会产生一个微小的阻力位或者支撑位； （2）持续两个月的阻力位或者支撑位会让人们习惯这个价位，并且产生一个中等强度的支撑位或者阻力位； （3）而一个持续两年的反复震荡区则会让人接受该价位是股票的真实价值，从而成为重要的阻力位或者支撑位 2. 区域高度 支撑和阻力区域越高，它的力量就越强。高大的密集成交区就像保护财产的高墙大院一样。如果一个密集成交区的高度仅有现在市场总价值的1%，那就只能提供一个弱小的支撑位和阻力位；如果有3%那么高，就会形成一个中等强度的支撑位或者阻力位；如果是7%或者更高，那么这个密集成交区能碾碎一个大的趋势 3. 区域深度 支撑区和阻力区的成交量越大，其力量越强。大成交量表示了交易者参与程度活跃——这是高的感情投入的信号。低成交量意味着交易者对在这个价位交易的兴趣不大，标志着支撑或阻力较弱</p><p><strong>如果用股票在密集交易区的天数乘以成交的平均价格和平均成交量，你就可以测算出支撑力量或阻力的总金额</strong>。当然，在做对比的时候，我们只能在同一只股票的支撑和阻力区间之间进行比较。你不能把苹果和橘子进行比较，所以也不能把苹果公司的股票和一家股价10美元、在活跃交易日也只有百万股票成交的小公司股票进行对比</p><h4 id="交易规则">交易规则</h4><ol type="1"><li>无论何时，当大盘走势逼近支撑位或者阻力位时，设定好你的保护性止损位 保护性止损是这样一种指令：当你有多仓时，在现在市场价格之下设定止损价格，一旦触及将卖出你的股票；而当你有空仓时，在市场价格之上设定止损价格，一旦触及将平掉你的空头头寸。保护性止损单能使你在趋势反转的时候不至于损失过大</li><li>阻力位和支撑位对于长期图表比对短期图表分析更重要 好的交易者会用不同的时间周期图表来监控市场，但会在长期图表分析中花更多的精力。周线图比日线图更重要。如果周线图的趋势很强势，那么日线图触及阻力位也并不用太担心。当周趋势线逼近阻力位或者支撑位时，你就应该考虑退出了</li><li>支撑位和阻力位意味着交易的机会 （1）技术分析中最重要的模式之一是“假突破”，如果价格微降至支撑位一下，然后又重回支撑区域，这意味着空方已经失去他们的机会。<strong>当出现向下假突破后，线柱的收盘价收回在密集成交区之内时，标志着这是买入的机会。你应该在近期假突破点底部附近设置一个保护性止损单</strong> （2）真正的向上趋势突破之后不会重新跌落入之前的密集交易区，就像火箭不应该在发射之后又落回发射台一样。当价格的蜡烛图又重回密集交易区时，向上的假突破发出了卖出的信号。你在做空时，在向上假突破的顶部附近设置一个保护性止损单</li></ol><p>如何设置保护性止损单　有经验的交易者总会避免在整数价格处设置保护性止损单。如果我以52美元买入一只股票，想把我的保护性止损单设置在51美元，那么我会把保护性止损单设得低于51美元几美分。如果我在一次日间交易中，在33.7美元的价位做多一只股票，并且想把保护性止损单设在33.5美元附近，我会把价格设置得比33.5美元低几美分。<strong>人们习惯使用整数，在这些整数价位会积累很多订单。我更喜欢让自己的订单远离这些订单的密集区</strong></p><h4 id="真假突破">真假突破</h4><p>在日线图上买入向上突破的最佳时机，是当你发现周线图出现新的上升趋势时。真正的突破一般伴随有巨额的成交量，而假突破则成交量很少。真正的突破时技术指标会在新的趋势方向上达到新的极限价位，而假突破则常令价格与技术指标直线出现背离。以上所述我们都将在本书之后的章节讨论</p><h4 id="趋势与交易范围">趋势与交易范围</h4><p>趋势指价格持续上涨或者下跌一段时间。<strong>在一个完美的上升趋势中</strong>，每一次上涨的高位都会突破之前的高位，而每一次下跌都会高于之前下跌的低位。而在完美的下跌趋势中，每一次下跌都会击穿上一次的低位，而每一次反弹又无法高于上一次反弹的最高点。在震荡区间内，每一次上涨都会抵达之前的高点，而每一轮下跌也回到以前的低位。<strong>完美的模式在金融市场里也没那么常见</strong></p><p><img src="Pasted%20image%2020240127205716.png"></p><p>在这个图表中可以看到12345构成了一次下跌趋势，F是一个假突破，突破30日均线后向上趋势逆转，678构成了上涨趋势，然后出现了两次假突破F，第二次假突破后，向下突破了均线，趋势再次反转。</p><p>即使只是粗略地扫一眼图表你也能发现，市场在大部分时间都处在震荡盘整中。趋势和震荡行情需要不同的交易技巧。当你在<strong>上升的趋势中做多或者在下降的趋势中做空</strong>时，你会因为对趋势的怀疑而损失一部分利润，此外你还得<strong>灵活运用宽松的保护性止损单</strong>，以免被迫出局。另外在<strong>震荡行情</strong>中，你必须运用<strong>收紧保护性止损单</strong>，时刻警惕着，一旦发生行情反转的微弱迹象，立即抛售手中的仓位</p><h4 id="难解的右侧">难解的右侧</h4><p>趋势和震荡在图表的中部很容易认出来，但是当你接近图表的右侧时，情况就越来越模糊了。过去是确定而清晰的，但是未来却是流动而不确定的。在历史的图表中趋势很容易分辨，但不幸的是经纪商不允许我们回到过去交易——我们得对右侧做出艰难的决定。</p><p>当趋势变得完全清晰起来时，趋势中一大部分赚钱的好时光已经过去了，当市场趋势消解变为震荡时，没人会为你拉响警报铃。许多图表的模式和技术指标会在右侧彼此矛盾。你必须在不确定的氛围中依靠概率做出决定。</p><p><strong>许多人在处理不确定性时都会感到不舒服。当趋势未如他们所料时，他们就会死死抱住赔钱的仓位，等待市场的反转让他们回本</strong>。<strong>专业交易者会很快从失败的交易中撤出。当市场和你的判断相反时，你应该毫不犹豫立刻止损</strong></p><h4 id="判断趋势的方法和技术">判断趋势的方法和技术</h4><p>你要牢记没有任何一种简单的魔法能够清晰明确地辨认出所有的趋势和震荡区域，你得<strong>将几种分析工具联合起来使用</strong>。没有方法是完美的，但是假<strong>如他们可以相互印证，传递出正确信息的概率上升。==当他们彼此矛盾时，你最好还是别进行交易了</strong>。==</p><p>（1）分析高点和低点的模式。当价格回升总是能达到更高的高位，而下跌总能停止在更高的低位，那就是一个上升的趋势。而更低的高位和更低的低位则意味着一个下降的趋势。而<strong>不规则的高点和低点则意味着震荡区域</strong>（见图19-1）。</p><p>（2）画一条20～30日的指数移动平均线（见第22节）。斜率的方向就显示出了趋势。<strong>如果移动平均曲线没有在月内达到一个新高或者新低，那么市场就可能处于震荡区间内</strong>。</p><p>（3）当摆动指标，比如MACD柱状线（指数平滑异同移动平均线）（见第23节）创下新高，那就预示着一个强力的趋势，表明市场上最近一次顶部要被试探或者被超过。</p><p>（4）几种市场指标，比如趋向系统（directional system，见第24节），也能帮助你判断市场趋势。趋向系统在捕捉新趋势的早期阶段尤为灵敏</p><p><img src="Pasted%20image%2020240127211129.png"></p><p>任何趋势确认的唯一标识是其高点和低点的模式。例如图19-2的联合太平洋公司日线图，一旦突破了震荡区间，其高点（绿色水平线标示）逐步抬高，同样的，其低点（红色水平线标示）底部也在抬高。<strong>试图画趋势线是很主观的，因为联合太平洋公司的低点不在一条直线上</strong>（趋势线不靠谱）。</p><p>22日指数平均线是一条叠加在价格线上的红色线，此时平稳的抬升确认了上升趋势。注意这里，当价格快速下降到移动均线时，出现了一次极佳的买入机会（我们在第22节将讲到这种模式）。</p><p>趋向系统（详见第24节）发出新趋势开始的信号的模式是，当平均趋向指标(ADX)跌落到20以下后又反弹到这个水平之上，向上穿透下趋向系统（以垂直绿色箭头标示）。</p><p>MACD柱状线（详见第23节）能识别非常强有力的趋势，当其上涨达到数月内的最高值（以绿色斜箭头标示），在图19-2的右边缘趋势是向上的，而价格略低于其前期高点。价格跌到EMA时很可能又是一次新的买入机会</p><h4 id="交易还是等待">交易还是等待</h4><p>当你已经认出一个上升趋势时，你要决定是立刻买进还是先等待一个回调。如果你快速买进，你就能跟上大盘，但是这样做不利的一面是，你的保护止损价位可能设置得很远，这就增加了你的风险</p><p>如果你等到了一次回调再入场，你的风险可能变小，但是你的对面将出现四组竞争者：想要加仓的多方，试图打平离场的空方，还没入场的交易者（比如你自己）和那些卖得太早、现在急切地想买回来的人。<strong>回调的等候区域是相当拥挤的。而且，一个深度回调可能预示着趋势开始反转而非买入的机会</strong>。同样的理由也适用于下跌趋势中的卖空情形</p><p>如果市场正处在震荡区间而你正在等待着突破，你得决定是在预期会突破时买入，还是在正突破的期间买入，又或者是在突破后的回调当中买入。<strong>如果你不确定，你可以分以下几个步骤买入：在突破迹象出现的时候买入三分之一，突破的时候再买入三分之一，回调时再买入三分之一</strong></p><p>你买入价格与保护性止损单的差距与你买入量的乘积不能超过你账户股票总价值的2% （也有设置止损的办法，就是将止损设置在关键点位以外的5-10个点）</p><p>在趋势中和震荡区间中所需要的风险管理技巧是不同的。<strong>在趋势中进行交易时，在宽松的保护性止损单上保持较小的头寸能帮你赚钱，你在控制好风险的同时也不太可能被反向波动震荡而出局。在震荡区间时，你得设置十分谨慎的止损策略，同时持有较大的头寸规模</strong>，因为此时的利润会更微博，所以止损策略要更谨慎</p><h4 id="相互冲突的时间周期">相互冲突的时间周期</h4><p>同一个市场在不同时间周期下的指标冲突是市场图表分析中的困惑之一。日线图上看似形成了趋势，可能却只是平缓周线图上的一个波动。而在日线图中的相对平缓的震荡区域却可能在小时线上显示出大量的向上或者向下的趋势，如此反复</p><p>明智的做法是这样的：在用你最喜欢的图表检验趋势前，先将图表上的时间周期提高一个尺度以验证趋势。从更高视角进行研究是<strong>三重交易系统</strong>的关键原则，这一系统我们将在后面章节中进行讨论</p><p>当专业交易者对市场产生怀疑时，他们会以长期视角来看市场，而业余的交易者往往关注短期图表。研究时视野放得越长效果越好——而且越轻松</p><h4 id="袋鼠尾">袋鼠尾</h4><p><img src="Pasted%20image%2020240127215014.png"></p><p>百健艾迪公司(BIIB)股价在出现向上翘的袋鼠尾之时，还处于稳定的上升趋势中。<strong>当日开盘价略低于前收盘价但走出了一根很高的线柱，是平时正常高度的三倍。当股价达到创纪录高位后开始回落，收盘在接近开盘的位置。第二天线柱高度是正常的高度</strong>——这样袋鼠尾的形态就完成了，趋势也反转了。</p><p>袋鼠尾在任何时候都可能出现，但是周线比日线，日线比五分钟线更靠谱</p><p><strong>袋鼠尾，也称“手指线”，是少数可信的图表信号</strong>。它们很有吸引力，也很容易辨认。<strong>如果你不能确定这是不是一个真正的袋鼠尾，那你就假定它不是，因为真正的袋鼠尾是不会出错的</strong>。它们会出现在大盘指标中也会出现在个股、期货和其他交易品种的图表中</p><p>市场总是在波动，寻找产生最大成交量的价位。如果价格上涨却没伴随着足够的成交量，市场很快就会反转，在更低的价格上寻找更多的交易。如果成交量在下降过程中萎缩，价格就会上涨，在更高的价位上寻找成交量</p><p>袋鼠尾反映了这种失败的突破。朝上的袋鼠尾反映了多方推高价格的努力失败。他们就像一队士兵，想要从敌人手里夺取一座山头，结果发现主力没有跟上来。所以他们就逃到半山腰以求保命了。而一旦丢失了山头，军队就会撤退到别处。</p><p>朝下的袋鼠尾反映了一次失败的空方突袭。空方激进地做空，打压价格——但是低价并没有吸引足够多的成交量，于是只能撤回震荡区间。在继续下跌的尝试失败之后，你觉得市场下一步会往哪儿走呢？既然低价位附近没有什么成交量，那么就上升回调吧。</p><p><strong>袋鼠尾意味着市场拒绝了某一价格</strong>。它通常会引导趋势的反转。一旦你发现了袋鼠尾，就马上朝相反方向操作吧</p><p><strong>记住逆袋鼠尾方向操作是一种短期策略。在日线图中，这些信号往往几天之后就会消失。你要在当前的市场背景下正确评估袋鼠尾。==比如当你长期看多一只股票时，一定要警惕袋鼠尾。向上的袋鼠尾意味着应该在当前的价位上兑现盈利，而向下的袋鼠尾则是一个加仓的好机会</strong>==</p><p>在市场中使用保护性止损单来防止损失和取得盈利是非常重要的。<strong>在袋鼠尾的末端设置保护性止损单会让保护性止损单太宽，承担过多风险</strong>。<strong>当你逆袋鼠尾方向交易时，将你的保护性止损单设置在袋鼠尾的中间价位</strong>。如果市场开始逼近这个价位，你就该离场了</p><p><strong>袋鼠尾形态不能预测价格走势的确切目标，但通常能持续几天，提供交易机会</strong></p><p>（看到这里，我赶紧回去看了一下最近的沪深300的线，确确实实出现了有点像袋鼠尾的形态，2024-01-18。这不是最重要的，最重要的是我发现沪深300已经站上了30日均线，布林线也已经突破了中值，然而就像前文说的，我似乎在恐慌中完全忘记了这一点，只知道前几次国家队救场大涨之后，没有止住趋势，继续出现了大跌，完全没有注意前面几次没有突破均线（也就是其实没有扭转趋势，将希望或者幻想寄托在了国家买入止住恐慌下跌，其实这都是没有意义的））</p><h2 id="计算机在交易中的应用">4、计算机在交易中的应用</h2><p>工具箱能画出MACD，移动平均，boll，RSI等指标，甚至创建自己的指标，如果你从事期权交易，工具箱还应该包括期权定价模型</p><p>好工具箱的另一个特征是其具有扫描股票的能力。比如说你想找出纳斯达克100指数成分股中，指数移动平均指标正在上涨的股票，并且其价格不超过其指数移动平均数的1%。你的软件能找出这些股票吗？它允许你把一些基本面数据加入到搜索条件中去吗，比如每股收益上升？想想你到底需要哪些指标，然后问问哪些软件开发者能够满足你的要求</p><p>这本书中的大部分图表都是用这种免费服务做出来的，如StockCharts.com，因为我想让你们看到即使花费很少也可以做到很多</p><p>无论何时你想交易时，你必须知道你的优势——<strong>是什么能让你赚钱</strong>。辨认图形模式的能力就是我的一种优势，但是如果一只股票的交易历史太短，就没有模式供你辨认。这就是我避免交易新近上市（上市时间短于一年）的股票的原因</p><p>收集和分析数据时，不要在同一时间追踪太多的市场。<strong>要关注数据的深度和质量而不是数量。首先从关注重要市场指数开始</strong>，比如道琼斯指数、纳斯达克指数以及标准普尔指数。许多专业交易者专注于相对较少的几只股票。他们了解了这些股票并且开始熟悉它们的交易模式</p><p>你可以从关注<strong>12只股票</strong>开始。许多专业交易人员都把他们关注的股票限制在100只以内，他们每周末都复盘这些股票并且在笔记本上记下关于它们的笔记。他们可能从这个股票池中选取不超过十只看起来在下周会有一波行情的股票，然后集中精力关注它们</p><p>新手应该避免日内交易。日内交易要求瞬时决策的能力，如果一旦停止思考你就死定了。在你考虑做日内交易前，首先要成为一个有竞争力的趋势交易者或者中长线交易者</p><p>趋势交易是个很好的起点。比如说，持有某个仓位几天。挑选那些趋势很好、成交量又不错的热门股票。开始时只买上几手</p><hr><p>技术指标能够帮助你识别趋势和反转。它们比图表模式更加客观，而且能够提供空方和多方之间力量均衡的洞见</p><p>一个巨大的挑战就是许多指标之间会相互冲突。一些指标在趋势形成的市场中有效，而一些指标则在波动的市场中有效。一些指标擅长抓住反转的点，而另一些指标则更擅长确定趋势的持续。这就是为什么从那么多指标中挑选出少数几个指标并将其联合使用是非常有必要的</p><p>大多数指标是基于5个相同的数据的：开盘价、最高价、最低价、收盘价和成交量。价格是最基本的，其他指标都是从中衍生出来的。用10个、20个、50个指标并不能让你的分析更深入，因为它们都是基于相同的东西</p><p>我们可以把所有指标分成3类：<strong>趋势跟随指标、震荡指标和其他指标</strong> （1）趋势跟随指标在大盘上涨或者下跌时最有效，但在大盘震荡区间效果急剧下降。包括移动平均值、MACD线（moving average convergence-divergence，指数平滑异同移动平均线）、趋向系统、能量潮(on-balance volume)以及收集派发指标等。趋势跟随指标属于<strong>同步或者滞后指标</strong>，<strong>它们在趋势反转之后才反转</strong> （2）震荡指标在震荡区间的市场中能判断出拐点，但是在大盘趋势逐渐形成时，它给出的信号是不成熟和危险的。它们包括<strong>MACD柱状线</strong>(MACD-histogram)、强力指数指标、随机指标、变化率、动能指标、相对力量指标、埃尔德射线指标(Elder-ray)、威廉百分比(Williams %R)以及其他指标。震荡指标是先行指标或者同步指标，常常比K线先反转 （3）其他指标能够提供有关大众心理的洞见。复合型指标能够提供多空双方强度的信息。它们包括新高-新低指标、看跌/认购期权比(put/call ratio)、好友指数(bullish consensus)、交易者指数以及其他指数。它们可以是先行或者同步指标。</p><p><strong>将不同组中的不同指标结合起来是很有用的，可以抵消各个指标的缺点同时保留它们的优点。这正是“三重滤网交易系统”的目标所在</strong></p><p>当我们开始探索技术指标时，我们最好谨慎行事。有时候它们的信号是非常明确的，有时候又很模糊</p><p>多年之前我就学会了，只有当我非常确定指标发出的信号时，我才会选择进场。<strong>如果我发现自己一直盯着图表试图理解其中的信号，那么我会翻到下一页去看另一只股票</strong>（！！！！）</p><p>如果你看到一个熟悉的指标，但不理解其中的意思，最可能的原因是你试图分析的这只股票<strong>正处在混乱阶段</strong>。（如果指标信号不明确，那就不要试图理解其中的意思，可以选择放弃，个人交易者最大的好处就是没有人逼着你交易——我们能够等待最好和最清晰的信号）</p><p>当你看到不同的指标的信号时，记住你不能把交易建立在一个单一的指标之上。我们要挑选几个我们理解并信任的指标，把它们结合到一个交易系统中。下一章我们将要考察这些指标，本书的后面我们会看到如何从这些指标中构建自己的交易系统</p><h3 id="移动平均">移动平均</h3><p>移动平均就是市场的一组摄影照片——它能把几天的价格结合起来。市场由大量的群体组成，而移动平均的斜率能够辨认出大众惯性的方向。</p><p>移动平均代表着股票价格在一段时间内平均一致的价值。移动平均值中最重要的信息就是其斜率的方向。当斜率上升时，表示大众正在变得乐观——倾向于看多。</p><p>它的斜率下降意味着大众开始变得悲观——倾向于看空。当价格升至移动平均值之上时，大众比之前乐观；当价格降至移动平均值之下时，大众比之前更悲观</p><p>在寻找交易机会的时候不能改变指标的时间长度。通过改变时间长度来创造出你想看到的信号恰恰会让你的指标失去其最具价值的特征——它们的客观性。最好的做法是设定一套参数，然后一直用它们</p><p>移动平均帮助我们顺着趋势进行交易。移动平均中最重要的信息是其斜率的方向（见图22-1）。它反映了市场的惯性。当EMA上涨时，最好是买入。当斜率下降时，卖空则会给你带来利润 （1）当EMA上涨时，作为多头进行市场交易。当价格下降到移动平均值附近时买入。一旦你成为多头，一定要在最近的低点下面设置保护性止损单。<strong>一旦价格接近高点时，就把保护性止损单移至盈亏平衡点。</strong> （2）当EMA下跌时，作为空头进行市场交易，当价格回升接近移动平均值时卖出，然后在最近的高点之上设置保护性止损单，当价格下跌时，将保护性止损单下移到盈亏平衡价位。 （3）<strong>当EMA走平，只是小幅波动时，那意味着一种漫无目的、没有趋势的市场。这种情况下不要使用趋势跟随方法</strong></p><p><strong>移动平均能帮助你分辨并追随趋势，但是它们也会在震荡区间内发出很多假突破信号。我们将在“三重滤网交易系统”那一节中找到这个困境的解决之道</strong></p><p>移动平均也能用来作为支撑位和阻力位</p><p>移动平均除了用于价格上，还可以用到其他指标上。比如，<strong>有些交易者喜欢用5日移动平均成交量。当成交量低于其5日平均成交量时，意味着人们对这只股票当前趋势的兴趣在减弱</strong>，也就是说其趋势可能会反转。当成交量超过其移动平均量时，表明大众对这只股票的兴趣很强烈，因此确认了价格的趋势。当我们考察强力指数（第30节）时，我们会用到指标的移动平均。</p><p>移动平均不但可以基于收盘价计算，也可以基于最高价和最低价的中间价来计算。这对日内交易者十分有用</p><p>我无论何时分析图表，都喜欢用两条而不是一条EMA线。长期EMA显示长期价值的连续变动，而短期EMA显示短期市场价值的连续变动。记住，保持两条EMA之间参数的比例大致为2∶1。想要更简单和高效，则最好在所有时间周期——周线图、日线图、甚至分时图，都用相同的一组参数。</p><p>因为短期EMA代表着短期内市场对价值的一致认同，而长期EMA代表着长期内市场对价值的一致认同，我相信价值就存在于这两条线之间。我将两条EMA之间的空间称为价值区间(value zone)</p><h4 id="价格价值以及价值区间">价格、价值以及价值区间</h4><p>我们买入价值被低估的股票，卖出价值被高估的股票——但是如何定义价值呢？</p><p>基本面分析师会研究它的资产负债表和年报，但是这些数据完全不像它们表面看起来那样客观。公司会粉饰它们的财务数据。并不只有基本面分析师才能使用“价值”这个概念。</p><p>技术分析师可以通过跟踪短期EMA和长期EMA之间的差价来定义价值。其中短期EMA反映短期的市场价值变动，另一个长期EMA反映长期的市场价值变动。价值就存在于两条移动平均曲线之间</p><p><strong>若准备买入一只股票，当其在价值区间时买入是比较有利的，而不是在价值区域之上多花钱去买</strong>。类似地，若是做空，待其反弹进入价值区域时再建立空头头寸，而不是在价格崩溃时卖空</p><p>非常重要的一点是：仅仅使用单一的指标或者一对移动平均指标是没法进行成功的交易的。市场是如此复杂，你不可能用一个单一的工具从其中赚钱。我们需要用多个指标来建立一个交易体系，并用多个时间周期来分析市场</p><p>记住这点能帮助你成为一个理智的交易者。一旦你懂得了如何定义价值，你就能低买高卖了。当我们在第41节（通道交易系统）仔细介绍价格通道，或者说包络线时，我们会回过头来继续寻找市场低估和高估时的交易机会</p><h3 id="macd线和macd柱状线">MACD线和MACD柱状线</h3><p>MACD线和信号线的交点表明了市场中空方和多方实力变换的平衡点。较快的MACD线反映的是短期内大众的心理变化，而较慢的信号线则反映了大众心理在较长期的变化</p><p>MACD线和信号线的交叉意味着市场趋势发生了变化。顺势的方向是沿着交点的方向进行交易。这个方法产生的假突破比基于简单移动平均的方法产生假突破要少很多 （1）当较快的MACD线穿越到较慢的信号线上方时，为买入信号。这时候要买多，<strong>然后在近期的次低点位置设置一个保护性止损单</strong>（千万不能忘记止损单）</p><p><img src="Pasted%20image%2020240128143105.png"> 注意该图表中其他几个形态。当ABX股价下跌到历史低点——图中B点，MACD线没有去确认：没有跌到新低而是走出了个双底。于是新低B点变成了向下假突破，是牛市来临的信号。在C点，空头试图最后一次把ABX股价压低，也没得到MACD线的确认，该线维持了稳定的上升趋势。在图表的右边缘，MACD线达到了上行运动的新高点，表现很强劲。两条EMA线都在上行，确认了牛市的趋势</p><p>相比原始的MACD线，MACD柱状线能够提供更深刻的关于多空力量均衡的信息。它不仅能分辨出哪种力量处于主导地位，而且能够分辨其力量是在逐渐增强还是在减弱。MACD柱状线是技术分析师最好用的工具之一。</p><p>MACD柱状线=MACD线-信号线 <img src="Pasted%20image%2020240128144049.png"></p><p>当两条MACD线交叉时，由两线衍生而出的MACD柱会穿过0线。你能在图中看到MACD线指示的买入和卖出信号（图中标识为绿色和红色箭头）。这些信号通常是滞后的，而MACD柱能给出很好的信号。</p><p>先看一个例子。比较道琼斯指数的低点D和F，指数的第二个底部只是稍稍更低（事实形成了一个向下假突破），<strong>但同时第二个底部附近的MACD柱比前一个底部的MACD柱浅多了，说明空头已经很虚弱，很可能会发生向上的反转</strong>。</p><p><strong>MACD柱状线揭示了市场长期价值和短期价值之间的差异。较快的MACD线反映的是短期内市场对价值的共识，而较慢的信号线反映的是长期市场对价值的共识。MACD柱状线对两者之间的差异进行了跟踪</strong>（所以可以比较两次低点或高点的MACD柱长度的变化）</p><p>当较快的MACD线上升得比较慢的信号线快时，MACD柱状线会上升。说明多方的力量比之前更强——这是做多的好时机。当较快的MACD线下降得比较慢的信号线快时，MACD柱状线会下降，说明空方的力量在增强——这是做空的好时机。</p><p>当MACD柱状线的斜率方向和价格的变动同向时，趋势就是稳定的。当MACD柱状线的斜率方向与价格的变动方向相反时，趋势的稳定程度就值得怀疑了</p><p><strong>MACD柱状线的斜率方向比柱状线的正负重要得多。最好是根据MACD柱状线的斜率方向来进行交易，因为它能告诉你在空方和多方中，到底是谁在主导市场。最好的买入信号是当MACD柱状线低于0值，而它的斜率方向是朝上的，表明空方的力量已经是强弩之末了；最好的卖出信号发生在MACD柱状线高于0值，而它的斜率方向是朝下的，表明多方已经耗尽了最后的力量。</strong></p><h4 id="交易规则-1">交易规则</h4><p>MACD柱状线能够发出两种交易信号。一种是<strong>普通信号</strong>，发生在每一个价格蜡烛线上；另一种信号很稀有——在一只股票的日线图上一年里可能只会出现几次，但是是<strong>非常强烈的信号</strong>。这种信号在周线图上更少见，但在日内图表中出现得比较频繁。</p><ol type="1"><li><p>普通信号： （1）当MACD柱状线停止下跌开始上升时就买入，在近期的次低点下方设置保护性止损单 （2）当MACD柱状线停止上升开始下跌时就卖出，在近期的次高点上方设置保护性止损单。</p><p>（周线更有意义！） <strong>MACD柱状线在日线图中频繁地上升下降，所以每次转向都进行交易是不切实际的。在周线图上MACD柱状线斜率的变动更有意义</strong>。这也是这个指标被纳入三重滤网交易系统（见第39节）的原因。将指数移动平均和MACD柱状线结合起来使用能帮你创造出“动力系统”，在第40节会详细介绍这一系统</p><p><strong>如果日线的MACD柱状线创出了三个月内的新高，说明多方的力量很强，价格还可以再创新高。如果日线的MACD柱状线创出了三个月内的新低，说明空方力量很强，价格可能会再次试探甚至突破之前的低点</strong></p><p>如果在价格上升的过程中，MACD柱状线创出新高，说明上升的趋势是健康的，可以预期市场会继续上涨，再次试探甚至超过之前的高点；如果在价格下降的过程中，MACD柱状线创出新低，说明空方力量很强，价格可能会再次试探甚至突破之前的低点。</p><p>当你在周线图上使用MACD线和MACD柱状线时，不必等到周五再去寻找信号。趋势可能在周中就已经发生了反转</p></li><li><p><strong>背离信号</strong></p><p><strong>注意：如果你需要用尺子去量一量看看这是不是背离信号，那么它肯定不是</strong></p><p><strong>要注意指标两个顶部之间的对0值线的突破，是真正背离所必需的因素。MACD柱状线在达到第二个顶点之前，必须低于0点</strong></p><p>MACD柱状线和价格出现背离的情形并不常见，但是它们却传达出了某些最强有力的信号。它们往往标志着重要的转折点。<strong>它们并不一定会出现在每个重要的顶部或底部，但是一旦你看到一个，你就知道一次大的反转可能即将到来</strong></p><p>（1）底背离（牛市背离）</p><p><img src="Pasted%20image%2020240128145922.png"></p><p>在A区域，当时雷曼兄弟破产了，一浪接一浪的卖出冲击着市场，道琼斯指数像自由落体一样下跌。MACD线柱图创出历史新低，说明空头极端强大，A区域的底部价格很可能会被重新试探甚至突破。</p><p>在B区域，MACD线柱图反弹到0值线之上，<strong>“打破了这个熊市”</strong>。<strong>要注意这个短暂的反弹触及到了两条移动平均线之间的“价值区间”</strong>——这是熊市反弹时一个比较常见的目标。</p><p>在区域C，道琼斯指数滑向了一个新的熊市低点，但MACD柱状线的底部则浅得多。而之后的回升，完成了一次牛市背离，这是非常强烈的买入信号。<strong>另一个关键点是，当MACD柱状线从第二个底部开始反转时，它就发出了买入的信号。它不必再次穿过0值线，在MACD柱状线低于0时，只要停止下降，负值开始缩小，就是买入信号了</strong></p><p>简单来说：底背离一般出现在股价的低位区。当股价 K 线图上的股票走势，股价还在下跌，底部不断下降，而 MACD 指标图形上的由绿柱构成的图形的走势是一底比一底高，即当股价的低点比前一次低点底，而柱子的低点却比前一次的低点高，<strong>同时出现了对0值的突破</strong>，<strong>反弹触及到了价值区间</strong>，这叫底背离现象。</p><p>（2）顶背离（熊市背离） <img src="Pasted%20image%2020240128151523.png"></p><p>简单来说：当股价 K 线图上的股票走势一峰比一峰高，股价一直在向上涨，而 MACD 柱的走势却一峰比一峰低，即当股价的高点比前一次的高点高、而 MACD 指标的高点比指标的前一次高点低，<strong>同时，出现了0值线的突破</strong>，<strong>中间的值穿透到了价值区间</strong>，这叫顶背离现象</p><p>在X区域，道琼斯指数和其MACD柱状线同时上升到牛市的新高点，说明多头的力量十分强大。这意味着未来很有可能会再次试探甚至突破顶部X点的价格。注意，MACD柱状线的X部分，其形态很复杂，但并不是一个背离，因为它的中间部分并未沉到0值线之下去。</p><p>在Y区域，MACD柱状线跌落到0值线之下了，<strong>“打破了这个牛市”</strong>。要注意，<strong>价格穿透到了两条移动均线之间的“价值区间”的下方</strong>。这是牛市中断时一个相当普遍的信号。同样要注意到在底部Y处，有一个“袋鼠尾”。在Z区域，道琼斯指数上升到一个牛市新高，但MACD柱状线的上升有点缺乏活力，反映出牛市的虚弱。在峰值处开始的跳水，完成了熊市背离，给出了强烈的卖出信号，预示着近30年最严酷的一个熊市。</p><p>另一个关键点是，当MACD柱状线从第二个顶点开始下降时，就已经是卖出的信号了。我们不必等到它再次穿越0值。虽然MACD柱状线仍然高于零点，只要停止上涨，并且新柱线长度比之前的柱线长度更短时，就发出了卖出信号了。</p><p><strong>三重牛市或熊市背离</strong>由三组价格和震荡指标的底部或者三组价格和震荡指标的顶部组成。它们比普通的背离更加强烈。要产生三重背离，普通的牛市背离或者熊市背离首先要出现失效。这也是需要做好审慎的资金管理的又一个理由！如果你在假突破时只损失了一小部分钱，那你能保持充足的资金和良好的心态再次入场交易。震荡指标第三次探顶或者探底一定比第一次浅，但并不一定要比第二次浅。</p></li></ol><h4 id="巴斯克维尔的猎犬">巴斯克维尔的猎犬</h4><p>这个信号产生在，当可信赖的图表或者指标的模式出现，但价格并没有走向你期望的方向时。比如，当背离模式出现，显示上升的趋势可能要结束了，但是价格却还在持续上涨，这种情形称为“巴斯克维尔的猎犬”。</p><p>当市场对一个完美的信号无动于衷时，那就是“巴斯克维尔的猎犬”的信号。这就表示在表象之下有更基础的东西在发生变化。这时候要做好准备，迎接一波新的大趋势</p><h3 id="趋向系统">趋向系统</h3><p>趋向系统是一种趋势跟随的方法，它能指明趋势，并显示什么时候趋势的运动值得去追逐。它能帮助交易者在大趋势的主体部分获利。</p><p>如何构建趋向系统？计算比较复杂，这里只放概念，方便查询 （1）确定“趋向运动”(directional movement,DM)：比较今天和昨天交易价格波动区间 （2）确定市场的“真实波幅”(true range,TR)。TR总是正值 （3）计算每日“趋向指数”（directional indicators,+DI和-DI）。通过计算DM占TR的百分比——从而可以比较各个不同市场的趋向指数大小。每个DI都是正值 （4）计算“平滑趋向线”（smoothed directional indicators,+DI13和-DI13），通过移动平均来平滑+DI和-DI （5）计算“<strong>平均趋向指标</strong>”(average directional indicator,ADX)。这个指标是趋向系统独特的组成部分</p><h4 id="交易规则-2">交易规则：</h4><p>（1）当+DI13高于-DI13时，做多头（PDI &gt; MDI）；当-DI13高于+DI13时（PDI &lt; MDI），做空头。同时，ADX上升的时候是最佳的交易时机，表示主导力量正在增强。 （2）当ADX下降时，表示市场的趋势正在减弱。这时可能产生很多假突破。当ADX下降时，最好不要用趋势跟随指标。 （3）当ADX降到两条趋向线之间时，表示市场是平静、死气沉沉的。此时不要用趋势跟随系统交易。但要做好交易的准备，因为这是暴风雨之前的平静，大趋势将会从这种平静中出现。 （4）当ADX落到两条趋向线之下时，则出现了趋向系统的最佳信号。它在此区域待得越久，那么下一次趋势的基础就越强。当ADX从两条趋向线下方开始回升时，意味着市场从平静中觉醒了。当ADX从趋向线下方的低点上升了4步（比如从9到13），这就是一个新趋势的号角（见图24-2）。<strong>那表示新的牛市或者熊市正在形成，到底是熊市还是牛市取决于在上面的是哪条趋向线。</strong></p><p><img src="Pasted%20image%2020240128160849.png"></p><p>（5）当ADX回升超过两条趋向线时，表示市场过热了。当ADX从高于两条趋向线的地方掉头向下，表示主要的趋势受到了阻碍，这正是趋势交易兑现利润的好时机</p><p>你或许发现了图中字母区域也发现了类似的做空信号，但一名严谨的交易者不会对每个见到的信号都去交易：在3美元价格附近做空一只从45美元掉下来的股票，意味着去追已经严重老化的趋势。在右边缘附近，你能看到价格回落到价值区间，提供了很好的多头加仓时机</p><p>市场指标既会给你一些硬指标，也会给一些软指标。例如，移动平均值改变方向就是一个硬指标，而ADX的下跌就是一个软指标。一旦你看到ADX下降，此时要加仓就应该非常小心。应该先兑现盈利，减轻仓位，然后再寻找出场的机会</p><h4 id="平均真实波幅来自波动率的帮助">平均真实波幅——来自波动率的帮助</h4><p>克里·洛沃恩喜欢在移动平均线附近画三组线：在高于和低于EMA1倍、2倍和3倍ATR的位置。它们能用于设定入场点、保护性止损位和盈利目标 <img src="%5BPasted%20image%2020240128162344.png"></p><h4 id="atr通道线">ATR通道线</h4><p>入场点：在“移动平均”那一节中，我们知道在价格低于价值的时候买入——低于EMA的时候，是一个好主意。但是要低于价值多远的距离？如果是普通回调往往会在负一倍的ATR处见底</p><p>保护性止损位：最好让你的保护性止损位在至少离入场点一倍ATR距离的地方。如果小于这个距离，会让你的保护性止损价位落入市场噪音区间之中，很可能被短期的随机波动所触及。所以把你的保护性止损位设置得远一点，使得只有真正的反转才能触及你的保护性止损单</p><p>盈利目标：你买入一只股票之后，可以根据那只股票的强势程度，在1倍、2倍甚至3倍ATR的位置，来设置你兑现利润的止盈价位。克里喜欢分几步兑现利润并退出，比如在1倍ATR处挂三分之一持仓量的卖单，在2倍的地方再挂三分之一，其余的挂在3倍ATR处。</p><p>在任何市场中，长时间价格波动超过3倍ATR——3倍的平均真实波幅——都非常少见。这通常意味着行情非常极端。无论何时你看到市场波幅超出3倍ATR之外，不论是上升还是下跌，你都有理由相信会出现一波回调</p><p>ATR通道的方法不仅在价格方面有用。我们也可以将它和其他指标结合起来，来判断趋势有可能在哪些极端价位出现反转。我在<strong>周线图的强力指数上会结合使用ATR通道</strong></p><h3 id="震荡指标">震荡指标</h3><p>趋势跟随指标能帮助我们辨认趋势——比如MACD线或者趋向系统，而震荡指标则能帮助我们抓住反转点。</p><p>震荡指标能识别市场大众的极端情绪，能够帮助你发现市场中乐观或悲观情绪难以持续的价位。专业交易者总会逆着极端情绪而来，他们会在衍生品上对赌价格将回归理性</p><p>超买意味着市场点位太高，随时可能回调。当震荡指标到达前期的高位水平时，就形成了超买。超卖意味着市场点位太低，随时可能反弹。当震荡指标到达前期的低位水平时，就形成了超卖</p><p>一定要记住，<strong>这些高低位水平并不是绝对的。当一波强力的上升趋势开始后，震荡指标可以持续几个星期的超买状态，这样给出的卖出信号是过早的</strong>。同样，在急剧的下跌趋势中，也可能保持几周的超卖状态，这样给出的买入信号是过早的。<strong>知道什么时候使用趋势跟随指标，什么时候使用震荡指标是成熟分析师的标志</strong>（见第39节）</p><p>我们已经考察过一个重要的震荡指标了——MACD柱状线。我们之所以提前考察MACD柱状线，因为它是从趋势跟随指标——MACD线中衍生出来的，马上我们将会探讨几个非常流行的震荡指标：<strong>随机指标(stochastic，KDJ指标</strong>)和<strong>相对强弱指标(relative strength index,RSI)</strong></p><h4 id="相对强弱指标rsi">相对强弱指标RSI</h4><p>随机指标考察的是每个收盘价和最近的高低价区间之间的关系。它由两条线组成：快速线K和慢速线D。它通过监测任意一种交易产品的收盘价变动来测量其强度。它是一个先行或者同步指标——从不滞后。 <img src="Pasted%20image%2020240128170348.png"></p><p>相对强弱指标仅仅基于收盘价，相比随机指标其噪声较小。当其上升到下参考线之上时，预示要上涨（图中以绿色垂直箭头标示）；当其下跌到上参考线之下时，预示要下跌（图中以红色垂直箭头标示）。</p><p>图中以倾斜实线箭头和虚线红色箭头标出的是相对强弱指标出现熊市背离给出的非常强的卖出信号。股价上升到新高，但相对强弱指标并没有触及其上参考线，显示这次上涨隐藏着的虚弱</p><p>图中右边缘处的尖锐跳空，不顾相对强弱指标发出的买入信号，将价格推向更低位。要避免受到伤害，我们必须使用保护性止损位，因为震荡区间里最后一笔交易，很容易在新趋势开始时造成亏损</p><p>超买和超卖的RSI位置随着市场的不同而不同，甚至在同一个市场中每年的情形也不相同。并没有一个神奇方法能够判断所有的顶部和底部。超买和超卖信号就像用窗口的温度计判断冷热一样，同样的温度在冬天和夏天有着不同的意义</p><p>水平参考线一定要能够穿过RSI的最高点和最低点。这些线通常是在30%和70%的地方。一些交易者在牛市中将其设置在40%和80%的水平上，或者在熊市中将其设置在20%和60%的地方。使用5%法则：每一条线都要保证RSI在过去的4～6个月中，位于参考线之上的时间少于5%。每3个月就调整一次参考线</p><p>RSI指标也存在背离的情况，和MACD相似</p><p>RSI通常比市场价格早几天突破阻力位或者支撑位，表现出了趋势可能要改变的迹象。RSI趋势线通常会比价格趋势线早1～2天被反转。 <strong>（1）当RSI的下降趋势反转时，在最近的价格高位上挂一个买单来抓住这一次向上的突破；</strong> <strong>（2）当RSI的上升趋势反转时，在最近的价格低位上挂一个卖单来抓住这一次向下的突破。</strong></p><p>当RSI上升超过其上参考线时，表明多方很强势，但是市场已经超买了而且已经进入了应该卖出的区域。当RSI下跌到其下参考线以下时，它表明空方力量很强，但是市场已经超卖了而且已经进入了应该买入的区域</p><p><strong>只有当周趋势上涨时，根据日线RSI指标发出的买入信号进行买入才比较有利。同样地，只有当周趋势是下降时，根据日线RSI指标发出的卖出信号进行卖出才比较有利。（见第39节）</strong> （周线趋势（均线） + RSI确定拐点） （1）当RSI击穿其下参考线，又回升到下参考线上方时买入； （2）当RSI上升到上参考线上方，又回落到上参考线下方时卖出。</p><p>一个典型的新手会犯的错误就是“采购各种指标”。交易者可能感觉股票市场会上涨，但是他却发现道琼斯指数和标准普尔指数的移动平均还在下跌。但他并不相信这些下跌的信号，他开始浏览软件里的菜单，然后找到了几个震荡指标，比如随机指标或者RSI。它们确实看起来已经超卖了（这在下跌的趋势中是常见的现象），这个急切的交易者就把它们看作买入的信号。下跌还在继续，他就赔钱了——然后他就开始抱怨技术分析没什么用</p><p><strong>用少数几个指标（包括多个时间周期），并有一个严格的分析体系，效果会好很多。我们会在“三重滤网交易系统”那一节再次回到这一重要的主题。</strong></p><h2 id="成交量和时间">成交量和时间</h2><p>（1）成交量：很多交易者只把注意力放在价格行情上，尽管价格行情十分重要，但市场所包含的远远不只有价格一个维度，成交量给我们提供了另一种极具价值的参考维度 （2）时间：市场在同一时刻按照不同的时间周期同时存在并发展着。<strong>不管你多么仔细地分析某个日线图，它的趋势都很可能被另一个时间周期的运动所颠覆</strong></p><p><strong>为经验法则，在任何一个市场上，“高成交量”意味着高于其过去两周成交量平均值25%以上的成交量，而“低成交量”意味着低于其过去两周成交量平均值25%以上的成交量</strong> （1）高成交量可以确认趋势。如果价格和成交量同时达到新的顶峰水平，价格将很可能保持高位或超过前期顶部后再创新高。 （2）如果市场价格创下新低但成交量却创下新高，则该底部将再次确认或者创新低。一个极高成交量的底部后面常常会跟着一个较小成交量的底部，这时便是绝佳的买入机会。 （3）如果在趋势持续的过程中成交量缩水，那该趋势将发生反转 （4）观察趋势中反弹的成交量情况。当上升趋势出现回落时，由于慌张的获利了结盘，成交量会增加。<strong>当这种回落持续但成交量缩水时，表明多头不再逃跑或者抛压被消耗</strong>。当成交量耗尽时，下跌带来的抛售效应已经接近其尽头，上升趋势将重新开始。</p><h3 id="以成交量为基础的指标">以成交量为基础的指标</h3><p>种种基于成交量的指标相对于成交量柱来说提供了更加精确的时机信号。这些指标包括下面将介绍的能量潮指标(OBV)和集散指标(A/D)。强力指数指标将价格和成交量数据结合起来，帮助我们发现在哪个区域价格可能发生反转</p><h4 id="能量潮指标obv">能量潮指标OBV</h4><p>一个创新高的OBV表明多头势力强大，空头受到重创，价格将会上升；一个创新低的OBV表明空头势力强大，多头受到重创，价格将会下降。当OBV的走势偏离了价格的走势时，这意味着大众的情绪和大众对价格的共识相偏离，人们将更可能跟随直觉而不是理性的思考，这也是为什么成交量经常先于价格变化而变化</p><h4 id="集散指标ad">集散指标(A/D)</h4><p>集散指标比OBV指标得到更好的调整，因为它只用当天交易量的一定比例归入到多头或空头势力中去，按照双方当日获胜的程度作为其比例</p><p>如果收盘价高于开盘价，当日多头获胜，则A/D值为正；如果收盘价低于开盘价，则当日空头获胜，A/D值为负；如果收盘价和开盘价一致，则当日多空双方打成平手，A/D值为0。所有日A/D值的滚动计算创造了累计A/D的指标</p><p>比如说，如果当日最高价与最低价之间差距是5个点，开盘价与收盘价之间的差距是2个点，则当日成交量的2/5归功于获胜方。就如同OBV一样，<strong>A/D高低的形态十分重要，而它的绝对值水平主要受计算基准日影响</strong></p><p>专业投资者全天都十分积极活跃，他们经常和业余投资者对着干，进行反向交易。随着交易不断进行下去，业余投资者和动作较慢的机构投资者买卖行为所引起的市场波澜也逐渐消退。在临近收盘时，专业投资者此时更可能主导市场。</p><p>收盘价显得尤为重要，因为交易账户的结算都以收盘价为准。A/D值追踪了业余投资者和专业投资者当日对战的结果，当收盘价高于开盘价时，即专业投资者比业余投资者更倾向于看多时，A/D值将上升；当收盘价低于开盘价时，即专业投资者比业余投资者更倾向于看空时，A/D值将下降。与专业投资者同方向下注、与业余者反方向下注比较有利。</p><p>最好的交易信号出现在A/D值背离价格走向时。 （1）如果价格上涨创新高但A/D值却没有随之创新高，则出现了卖出信号。这种熊市背离表明市场上专业投资者在上涨过程中卖出。 （2）牛市背离发生价格创新低但A/D值却没有创新低时，表明了市场上专业投资者在下跌过程不断买入并逐步建仓，反弹即将到来（见图29-2）。</p><p><img src="Pasted%20image%2020240128173246.png"></p><p>“大事发生之前总会有其征兆”是一句古老的谚语，这句话对于技术分析派来说意义重大。谷歌公司的股票GOOG持续下跌已经数月了，但是其上升的A/D值表明大资金正在不断地买入。该股票在B处创造了比A处更低的底部价格，但是其A/D值的底部却抬高了。同样重要的是，A/D值在价格暴涨之前还创了新高（在图中由垂直箭头标出），紧接着公司就公布了好得出人意料的业绩报告。一些人之前便知道了接下来将要发生的事，他们大规模的买入被累积A/D值形态和向上的突破所确认。技术分析有助于减少外部投资者和内幕信息知情人之间的信息地位差距</p><p>当你根据A/D值与价格之间的背离为依据，进行做多或做空的时候，<strong>记住就算是市场上专业的投资者也会犯错。你需要设置止损单并用巴斯克维尔的猎犬法则保护自己</strong></p>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FaceChain</title>
    <link href="/2024/01/26/FaceChain/"/>
    <url>/2024/01/26/FaceChain/</url>
    
    <content type="html"><![CDATA[<p>简述：论文主要是提出了一个框架，解决换脸的问题，即用户上传多张自己的个性化照片，让模型来完善其他细节（例如衣服，背景）。它通过集成了多个模型搭建了一套完整的脸部ID保留和处理流程 感想：这篇论文兼顾了学术创新和工业应用，非常值得参考</p><p><img src="Pasted%20image%2020240126132705.png"></p><p>整个流程是用户上传照片，然后： 1. 预处理（用户上传的图像可能不符合要求） （1）检测图像的方向，保证图像的角度正确，<a href="https://modelscope.cn/models/Cherrytest/rot_bgr">模型地址</a> （2）图像的方向正确后，人脸的方向可能不正确，使用<a href="https://modelscope.%20cn/models/damo/cv_ddsar_face-detection_%20iclr23-damofd">DamoFD</a>（一种人脸检测器）获得多个图像人脸的检测结果，然后使用最小二乘法，计算标准人脸模板的坐标和旋转矩阵，旋转图像 （3）使用DamoFD获得人脸框，再使用<a href="https://modelscope.cn/models/%20damo/cv_resnet101_image-multiple-humanparsing">M2FP</a>（Masked-attention Mask Transformer model for human parsing）裁剪人脸并缩放大小，控制在图像的0.35-0.45倍， （4）使用<a href="https://modelscope.cn/models/%20damo/cv_unet_skin-retouching">ABPN</a>（自适应混合金字塔网络）进行皮肤修饰</p><ol type="1"><li><p>给上传的图片打标签（训练lora时需要对应的文本标签，因此标签必须合适） （1）将人像输入<a href="https://github.com/KichangKim/DeepDanbooru">DeepDanbooru</a>（一个文本注释模型），可以得到初步的tag，然后删掉一部分人类身份相关的标签，比如嘴唇，眼睛耳朵等（<strong>这些特征需要通过参考图像引入，不能通过文本，否则身份一致性难保持</strong>） （2）再通过<a href="https://%20modelscope%20.%20cn%20/%20models%20/%20damo%20/%20cv%20_%20resnet34%20_%20face-attribute-recognition_fairface">FairFace</a>（人脸属性模型），预测每张图像的性别和年龄，根据所在区间确定关键词。 <img src="Pasted%20image%2020240126152208.png"></p></li><li><p>训练方法 分别训练一个face lora和一个style lora，前者用个性化肖像训练，后者用大量照片同类型照片训练，例如证件照、艺术照等，确定生成图像的风格</p></li><li><p>推理过程 （1）将face LoRA和style LoRA的权重融合到Stable Diffusion模型中，权重分别是0.25和1.0，生成多张个性化的图片 （2）这些图片可能还是不够精确，因此通过人脸质量评估模型<a href="https://www.modelscope.cn/models/damo/cv_manual_face-quality-assessment_fqa">FQA</a>（Face Quality Assessment）从训练数据重筛选出一个质量最好的人脸图像 （3）使用<a href="https://www.modelscope.cn/models/damo/cv_unetimage-face-fusion_damo">人脸融合模型</a>进一步改善面部细节。使得输出肖像能够保留主要的外观特征，同时显示更精致的面部细节生成（即生成的图像和训练图像融合到一起） （4）采用<a href="https://www.modelscope.cn/models/damo/cv_ir_face-recognition-ood_rts">随机温度缩放</a>（RTS）（一种针对分布内和分布外样本的鲁棒人脸识别模型）来计算面部相似度。选择面部相似度高的肖像作为输出</p></li></ol><h2 id="inpainting">inpainting</h2><p>利用专门针对独特面部 ID 进行训练的 LoRA 模型，再加上集成的风格背景，可以生成具有高 ID 保真度的相关肖像照片。但是，在现实场景和应用中，经常出现用户已经确定了他们满意的图像的情况——这些图像具有精心设计的构图、灯光和背景布置。在这种情况下，用户的要求是自然地用特定的ID替换所选图像中的人脸。为了解决这个问题，论文设计了一个基于SD的修复框架。这允许基于指定的模板图像自然地重绘指定的面部ID。</p><p>涉及到这种人脸替换问题，最容易想到的方法就是使用controlnet执行扩散完成修复，然而这样做会引发问题： （1）原始模板人脸和指定ID的人脸不兼容，使用canny得到的边缘进行扩散会导致人脸结构改变 （2）重绘的区域和原始图像的衔接出可能出现断层（不一致） （3）在扩散过程结合 ControlNet、LoRA 模型和模板的图像隐空间等多个控制会产生不利影响，尤其是在身份ID的保留方面，因此需要对ID进行更多的控制</p><p>为了解决问题，提出了一个二级修复流程： <img src="Pasted%20image%2020240126161225.png"></p><p>流程1： （1）面部变形算法来生成 68 个面部标志，作为OpenPose controlnet的输入 （2）生成一张保留了ID的图像 （3）计算仿射变换矩阵 M，将生成的面部标志与原始参考的面部标志完美对齐 矩阵M表示生成人脸和参考人脸之间的变形过程，解决了参考图像和ID面部特征点不匹配的问题</p><p>流程2： （1）使用M2FP human parsing model，生成面部mask并适当扩展 （2）OpenPose controlnet（使用上面变形后得到的面部特征点）（保留面部结构） + Canny controlnet（保留面部之外区域的结构） + 较大的inpainting strength（0.65）（保证重绘得到的图片仍然是指定ID） = 实现人脸的和谐替换</p><h2 id="facechain在虚拟试衣上的应用">FaceChain在虚拟试衣上的应用</h2><p>给定待试穿服装的真实或虚拟模特图像，以及经过训练的人脸LoRA模型，FaceChain可以重新绘制服装外部的区域，包括人物和背景，以获得虚拟试穿结果。</p><p>重绘过程也是基于SD的修复过程，和inpainting很相似。然而，由于这两个任务的要求不同，可以使用不同的空间条件控制。由于需要重新绘制衣服外部的所有区域而不仅仅是面部区域，因此面部标志与保留部分之间的交互要低得多。此外，服装外部区域的图像内容可能对图像生成有害，尤其是当我们尝试将输入模板的虚拟模型更改为真实模型时。因此，我们在OpenPose-ControlNet中不使用扭曲的人脸标志，并将修复强度调整为1.0以避免输入模板的图像潜在的影响。然后，在虚拟试穿中生成具有和谐身体姿势的肖像极其重要，尤其是手部的详细姿势，因为大多数现有的SD模型无法生成令人满意的手部姿势。</p><p>为了解决问题 （1）OpenPoseControlNet 使用全身姿势蒸馏（DWPose）估计器提取的骨骼和手部姿势，以获得更准确的手势 （2）Depth-ControlNet 在手部区域使用深度估计（论文Towards robust monocular depth estimation: Mixing datasets for zero-shot cross-dataset transfer） 以获取手部的 3D 细节 （3） Canny-ControlNet 使用身体区域的 Canny 边缘来实现更和谐的身体姿势。 （4）背景用提示词来控制 生成的虚拟试穿图像可以放入inpainting pipeline中，以进一步提高身份保留效果</p><h2 id="让证件照说话">让证件照说话</h2><p>用户选择一张人脸图像，然后用户提供一个音频片段，FaceChain使用它们输出说话的视频</p><p>论文选择sadtalker作为基模型，因为wav2lip和video-retalking只能改变面部的嘴唇，而SadTalker提出的PoseVAE和ExpNet可以改变头部姿势和面部分别表达，其中头部姿势可以进行控制，例如眨眼频率。</p><p>由于SadTalker的输入和输出分辨率为256或512，如果原始输入图像中的人脸分辨率比较大，或者用户只是想让整体分辨率更高，论文也支持使用GFPGAN作为后处理模块，可以将视频分辨率提高一倍。至于音频剪辑，支持三种选项来提供：(i) TTS 合成、(ii) 麦克风录音和 (iii) 本地文件上传。至于TTS合成，我们使用Microsoft Edge的API，因为它支持多语言混合输入，并且支持多语言合成，这使得FaceChain对全球用户更加友好 <img src="Pasted%20image%2020240126164700.png"></p><h2 id="未来值得探索的方向">未来值得探索的方向</h2><p>（1）能够处理不同年龄和性别的多个主题的个性化生成框架</p><p>（2）改进数据处理机制以完美地保留身材，这将需要更多样化的训练数据</p><p>（3）<strong>支持模型融合过程中风格和面部 LoRA 模型的自适应权重选择</strong></p><p>（4）将不同的风格信息编码为统一的模型，可以通过特定的触发提示激活</p><p>（5）为 FaceChain 开发定制的相似度排名和<strong>面部融合模型</strong></p><p>（6）<strong>探索用于定制肖像生成的免训练框架</strong>。目前 FaceChain 中使用的方法需要为每个人类 ID 训练一个新模型，这对于广泛采用来说计算成本可能很高</p>]]></content>
    
    
    <categories>
      
      <category>图像生成</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>研报阅读攻略</title>
    <link href="/2024/01/14/%E7%A0%94%E6%8A%A5%E9%98%85%E8%AF%BB%E6%94%BB%E7%95%A5/"/>
    <url>/2024/01/14/%E7%A0%94%E6%8A%A5%E9%98%85%E8%AF%BB%E6%94%BB%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>研报是投资者都会看的内容，但是大部分人也只是随便看看，不仅没有目的，也不成体系，其实没有太大用处。而且很多研报质量也不怎么样，但是通过正确的搜索和阅读方法，也会以了解到很多东西。</p><h2 id="研报的价值在哪">研报的价值在哪？</h2><p>研报是分析师对宏观、行业、公司做出的投资分析和结论。市场上最常见的是卖方研报，它主要是卖方（大部分是券商分析师）给买方（机构投资者，如基金经理）提供的投资分析服务，因此研报从一开始就不是为我们普通投资者准备的。</p><p>我们现在能在互联网上搜到的研报大部分都是他们的客户那里流出来的，<strong>我们并不是第一时间看到的研报的人，所以想要跟着研报去追热点就完全没必要了</strong>，我们已经在时间上被机构投资者甩下几个小时甚至是几天了</p><p>由于A股不能做空，因此几乎所有的研报都是看涨，因为看跌也没用。因此常见的研究报告评级都是“买入”或“增持”，“中性”都很少了，“减持”和“卖出”基本上很难看到。所以看跌和看涨某公司并不是研报的主要价值。研报的最大价值其实是：<strong>帮助投资者了解政策、行业和基本面</strong>。</p><h2 id="如何选择研报">如何选择研报？</h2><p>很多研报可能是证券公司的任务，甚至可能是实习生写的，而且数量众多，同质化严重。要想选出好的研报，最简单的方式就是看作者：<strong>新财富分析师榜单</strong>。虽然该榜单也有拉票等乱象，但我们可以重点关注排名靠前的分析师，它们的分析会靠谱一些。</p><p>就算结论可能有误，学习分析的逻辑思维也是相当重要的，看研报一定要记住：<strong>重逻辑，轻结论</strong></p><p>研报具体可以分为四类：宏观研报、策略研报、行业研报、个股研报</p><h2 id="如何阅读宏观研报">如何阅读宏观研报</h2><p>宏观分析的常见报告就是对各种经济数据点评预测，例如GPD、CPI、PPI、消费、投资数据等，通过发电量来推断生产活动，通过猪肉价格推断通胀水平，另外还有对一些新的政策和事件点评，这些报告的发表频率很高。</p><p>常见的标题： 《11月美国CPI点评：通胀创新高，但基本符合预期》 《中央经济工作会议点评:重回2018年底，买股票，恒指28000!》 《2021年11月金融数据点评:企业信贷继续下滑宽信用效果仍未体现》</p><p>这些研报的特点是<strong>同质化严重</strong>，如果关注某个数据或事件的点评（点评报告），看<strong>宏观研究领域的新财富分析师的研报</strong>就可以。宏观分析或多或少都会带一些预测，例如预测一下未来的流动性是宽松还是紧缩，未来的经济增速有多高等等，要学会综合多个知名分析师的观点而不是只听一家之言，看看他们的预测逻辑谁能说服自己。</p><p><strong>除了点评报告之外，宏观研报还有一种是深度报告</strong>，特点就是页数会多一点，通常15页以上。例如对人口的专题研究、大类资产配置建议、经济展望等。例如广发证券的《新经济：宏观视角分析纲要》这篇报告其中一部分就教我们跟踪新兴产业的景气度可以看哪些指标。</p><p><strong>这种深度报告非常值得阅读</strong>，不仅是报告，更是学习资料。可以慢慢模仿分析师的风格，建立自己的分析框架</p><h2 id="如何阅读策略研报">如何阅读策略研报</h2><p>策略研报说白了就是研究市场会涨还是跌（但基本上都是涨~），研究哪个板块、行业会有机会。</p><p>策略研报和其他类型的研报一个最大的不同就是它并不是千篇一律的看涨，而是会给出分析师自己对行业板块的选择，会有一些不同的结论，所以就很看分析师的能力了，首先当然还是看新财富分析师了，都是经过客户检验的</p><p>但是这些策略研报不见得靠谱，还是那句话，<strong>重逻辑轻结论</strong>。比如站在2024年01月14日，看2021年底对2022年的A股策略研报，都说看多价值股，看多医药消费。但是很明显，2022和2023是长达俩常年的熊市，价值不断创新低，五粮液跌到130以下。</p><p>所以策略的预测看看也就行了，研报一次推荐7，8个板块，总有几个表现好的。但是我们如果按他推荐的板块全部配置，还不如直接买宽基指数得了。所以策略研报看上去很有用，但是又感觉不是特别有用。</p><p>策略研报一般也分为月度，季度，年度。这个根据投资风格自己选择即可，多看分析师推荐的理由而不是推荐的结果。</p><h2 id="如何阅读行业研报">如何阅读行业研报</h2><p>行业研报应该是最有阅读价值的研报了，主要就是对各种细分行业进行研究，例如新能源行业、光伏行业、白酒行业等。有助于投资者了解一个行业的现状，例如渗透率，市场规模，竞争格局等。</p><p>我们知道，一般的<a href>投资框架</a>要求在购买股票时，判断是否是“好生意”，“好行业”。这就要求我们了解渗透率，市场规模等数据，而这些数据是普通投资者难以去统计收集的。</p><p>行业研报可以分为定期报告、行业点评、深度研究等。</p><h4 id="定期报告">定期报告</h4><p>定期报告可以按照时间分类，例如周报一般是更新这周该行业的数据、事件和公告，这些研报的数据往往滞后，价值不大。一般时间间隔越长的定期报告价值越大</p><h4 id="行业点评">行业点评</h4><p>行业点评报告是在重要数据发布或重要事件发生时，分析师给出自己的点评，它和定期报告不同的是它的时效性更强。</p><p>一般阅读行业点评和定期报告的目的是追踪数据，例如新能源汽车产量、销量，行业渗透率等。关注1-2个分析师的点评即可</p><h4 id="行业深度研究">行业深度研究</h4><p><strong>行业深度研究是价值最大的研报</strong>，分析师花那么多精力写几十页的报告，肯定看好这个行业。但是只看结论是不行的，投资者阅读深度报告最大的价值在于了解一个行业的形式，学习其中的逻辑思维能力。</p><p>因为深度报告的数量不多，因此新财富分析师以外分析师的报告也可以读一读。</p><p>一般这类的报告会在包括： 1. 介绍背景知识，行业概况，也包括了一些专业知识； 2. 然后从供给和需求两个角度去分析<strong>行业集中度</strong>、<strong>市场份额</strong>、行业各厂商之间的对比、国内外厂商的竞争优势对比； 3. 可能还会包括对市场空间的测算（这部分也是猜，知道即可，不必太当真）； 4. 最后还可能包含对行业重点公司的介绍，方便去读对应的个股研报</p><p><strong>通常了解一个行业都是从该类行业的深度报告开始</strong>，如果有新财富分析师近期写的深度报告最好</p><p>但是行业研究并不是阅读一篇深度报告就够了，这只是一个起始点，让我对这个行业有个初步印象，如果想要更全面的了解这个行业，还需要阅读更多的该行业深度报告作为补充，同时还要去查阅一些重点公司的财报以及通过其他的渠道去搜索想要知道的答案 （通过知乎、B站等渠道）</p><h2 id="如何读个股研报">如何读个股研报</h2><p>个股研报就是针对单只股票的研究报告，分为事件研报和个股深度研报</p><p>事件研报是个股研报的一种，一般在发生一些事件之后发出，这些报告的内容一般很少，只是针对事件做点评，很多都是实习生做的。适合了解该行业的人来看。</p><p>有些出名的公司也会有个股深度研报，一般包含以下内容： 1. 公司介绍，这部分一般是从招股说明书或者年报里抄的，包含发展历程、股权架构等 2. 分析公司的行业（多好多好），这里聊的比较浅，建议结合行业深度研报使用 3. 经营分析，一般就是在说公司的产品多有竞争力，业务多有发展潜力。这部分内容更多是梳理公司业务，其他的不必太在意 4. 财报分析，从总收入，净利润，EPS，毛利率等指标分析，让读者对公司业绩有个印象 5. 业绩预测模型，这部分看看就好，不必当真 6. 风险提示，这部分是提醒投资者后续跟踪这个公司需要关注的内容</p><p>个股深度研报通常都是普及型的作用，为我们搭建了一个公司的全景图，对于入门是有非常大的帮助的。但是如果想要搞清楚这个公司，还要看更多的报告，同时结合相关的行业分析，以及外部资料（例如财报、其他人的评论）来分析，必要时还要看宏观分析</p><h2 id="研报从哪里获得">研报从哪里获得？</h2><p>网上大多数找到的都是广告软文，所以不推荐直接搜索</p><p>雪球，东方财富一般会有一些个股的免费研报，但是比较少</p><p>发现研报：如果不开会员每天只能看几篇，开了之后可以看几百票</p><p>萝卜投研：800一年</p><p>慧博投研：几千一年</p><p>嗨皮土豆：免费</p><p>剩下的慢慢积累把</p><h2 id="总结">总结</h2><ol type="1"><li>看研报主要看行文逻辑和数据，别太在意预测结果</li><li>多看深度研报</li></ol><p><a href="https://haipitudou.com/">嗨皮土豆</a> <a href="https://wk.askci.com/ListTable">前沿知识库 (askci.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>积极型资产配置</title>
    <link href="/2024/01/11/%E7%A7%AF%E6%9E%81%E5%9E%8B%E8%B5%84%E4%BA%A7%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/01/11/%E7%A7%AF%E6%9E%81%E5%9E%8B%E8%B5%84%E4%BA%A7%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>本书的主要目的是为经济和市场建立一个分析框架，学习： （1）经济周期是如何更替的 （2）不同的经济周期应该如何配置资产</p><p>这是一本美国的书，因为国情的不同，在具体的<strong>宏观经济指标</strong>选择上会有所不同，本书采用美林时钟，可能以利率为轴会更有参考性，这部分的内容会通过<a href>宏观经济、利率趋势与资产配置</a>补充讲解</p><p>但总的来说，本书涉及到的理论知识和分析方法都是很有参考价值的</p><h2 id="货币管理的基本原则">1. 货币管理的基本原则</h2><h4 id="分散投资">（1）分散投资</h4><ul><li><p>使用分散投资可以减小<strong>投资个体公司的非系统性风险</strong>（不受市场波动影响的个体公司承担的风险） 大概6-8支股票即可。 <img src="Pasted%20image%2020231210154234.png"></p></li><li><p>使用分散投资可以减小来自市场波动的系统性风险（普遍的市场下降风险） 分散投资许多公司，不能避免自己受到市场普遍下降的影响，但通过分散投资不同的资产类别可以控制系统性风险。因此，一个好的分散投资应该是平衡的，包含了很多没有密切相关性的资产。 <strong>举个例子：如果股票的整体行情不好，那么分散买多只股票意义不大，但是买和股票相关性较低的其他资产例如贵金属和现金，那么风险会得到缓冲。</strong></p></li></ul><p>下表给出了不同资产之间的相关性： <img src="Pasted%20image%2020231210154904.png"></p><h4 id="时间与复利">（2）时间与复利</h4><p>这一点不用多说</p><h2 id="宏观经济指标">2. 宏观经济指标</h2><p>经济增长和经济紧缩之间的交替被成为经济周期，从一个波谷到另一个波谷的时间平均为42个月（基钦周期）。经济周期实质上是对人类心理的反应（谨慎，乐观，贪婪，恐惧），只要人性不变，则经济周期不变。</p><p>本章节的内容是理解经济周期，一般人对它的理解可能是：经济按照周期或多或少的重复出现。但其实这样是不对的，<strong>每个经济周期都有自己的特点</strong>，不论是持续时间还是强度，都会有不同。42个月只是一个平均值。 <strong>即：没有一个经济周期模式会以完全相同的方式重复出现</strong></p><p>造成这种现象的原因有三点： - （1）基钦周期受到另外两个大周期的支配---朱格拉周期（10年期周期）和康德拉季耶夫周期（50年期周期），技术驱动长周期的上升。 - （2）经济体包含了不同的部分，不同的部分上涨和下降的比例不同，周期也就不同 - （3）经济体系在不停的发生改变，例如美国先后经历农业主导、制造业主导、服务业主导</p><p>问题：既然经济体包含不同的部分，那我们应该分析一个周期？ 答案：经济体内部可以分为先行部分，中间部分，滞后部分，整体保持着经济周期的规律。</p><h4 id="经济事件的次序">经济事件的次序</h4><p>一个完整的经济流程：央行降息释放流动性，货币的使用价格变低，股市走出底部，利率敏感的先行指标上升（例如房地产），再之后是同步指标（比如制造业，非农就业人口上升），随着更多人就业，商品价格走出低谷，最后是经济滞后指标（厂房和设备）。</p><p><img src="Pasted%20image%2020231210162712.png"></p><p>个体对于经济环境中急剧且没有预料的变化所进行调整的意愿是理解经济周期变动的关键。因此关注经济活动的<strong>变动率</strong>比关注经济活动的现状更重要，下面是一个例子： <img src="%5BPasted%20image%2020231210163559.png"></p><p>利率的下降对经济的影响都有延时，毕竟过渡扩张的公司还需要时间偿还贷款、改进资产负债表等。就像利率上涨很快时，虽然心里感觉痛苦，但却不能触摸到利率的存在，但工业品和房地产都是可以触碰到的实物。房地产的低谷与经济复苏的开端之间平均间隔是6个月左右。</p><p>房地产对长期利率更敏感： <img src="Pasted%20image%2020231210170137.png"> 可以看出来，利率波动越剧烈，则收益率与住房开工率的相关性越强。尽管我们不能将证券市场的强烈反弹当作住房市场强势的信号，但可以说：<strong>除非债券市场反弹在前，即债券交易量增加，否则住房市场不太可能启动。</strong></p><p>房地产行业的低估会波及到其他高端、利率敏感的行业，比如汽车。虽然房地产本身的GDP占比不大，但非常重要。（1）它意味着消费者开始克服不愿意消费的心理状态；（2）住房数量增加会对经济有乘数效应，比如增加洗衣机之类的需求</p><h4 id="经济指标来展示经济事件的顺序">经济指标来展示经济事件的顺序</h4><p>这部分的指标都是美国的，国内需要替换为对应的其他指标 （1）先行指标 - BCI-01 制造业平均工时 雇主总是会在增加和减小劳动力数量前调整工人的工作时间 - BCI-05 每周平均失业保险金初始申请人数（国内不排除失真的情况） - BCI-08 制造商是所得到的消费品及原料新订单 - BCI-32 延迟交付扩散指数 - BCI-19 标准普尔500指数，股票是未来经济活动的风向标 - BCI-106 货币供应量，即M2 - BCI-129 10年期国债收益率与美联储基金的利率差 长期利率和短期利率的差别或价差通常被称为收益率曲线。这个指标是通过算出10年期国债利率与联邦基金利率之间的价差得到的，联邦基金利率是银行间市场的<strong>隔夜拆借利率</strong>。它被认为是货币政策和金融市场状况的指示器，因为当短期利率相对较低时，这个利率差就会增加。当这个利率差变成负数的时候（即短期利率高于长期利率，收益率曲线出现反转的时候)，这个指标被当作经济即将发生衰退的强烈指示信号。 - BCI-83 消费者预期指数，反应消费者对未来经济状况的态度变化。</p><p>（2）同步指标 - BCI-41 非农业就业人数，这个指标是最贴近经济健康状况的指标。 - BCI-51 扣除转移支付的个人收入，用来衡量所有人的真实工资，收入水平决定消费水平 - BCI-47 工业生产指数 - BCI-57 制造业和贸易销售额</p><p>（3）滞后指标 - BCI-91 平均持续性失业，当经济衰退开始后，这个指标会出现急剧上升 - BCI-77 制造业和贸易存货对销售额比率。当经济放缓时，存货会增加 - BCI-101 工商业贷款余额 - BCI-95 消费者劳务价格指数变化</p><p>下图展示了三个指标的变化，动量指标是根据KST公式计算（第三章讲解） <img src="Pasted%20image%2020231210173835.png"></p><p>紧缩货币供给指标可以看作流动性的替代指标，它=M2 / 工业原材料现货价格指数，比CPI更好，因为CPI受市场驱动，变化更快。使用多个指标的好处是，当一个指标发生偏移，其他指标可以交叉检验。 <img src="Pasted%20image%2020231210174053.png"></p><p>之前说到每个周期的构成是不同的，从指标之间的对比可以看出来。</p><p><img src="Pasted%20image%2020231210174557.png"></p><p>有的时候指标变化温和，有时变化很大。在多数时间下，这些指标是相互重叠的，这种方法不完美，但可以确定经济周期是经过了一系列按时间顺序发展的时间的。</p><p><strong>补充几个国内指标： 1、领先指标：PMI，利率，M2，新开工项目，房地产开发土地面积，商品房新开工面积，物流指数，恒生内地流通股指数，消费者预期指数，股票指数 </strong> <strong>2、同步指数：财政税收，居民可支配收入，工业增加值，工业从业人数，工业企业利润，固定资产投资，社零，进出口</strong></p><p><strong>3、滞后指标：财政收入，工商业贷款，居民储蓄，CPI，库存</strong></p><p>在实际应用时，可以对不同类型指标按特定权重加权处理，从而得到趋势线 <img src="Pasted%20image%2020231210192618.png"></p><p><strong>就像一列火车一样，经济事件发生的顺序：</strong></p><p>火车头：央行在经济衰退阶段向经济系统注入的流动性。货币量增加，商业银行可以给企业贷更多的钱。</p><p>第一列车厢：利率下跌，货币市场价格下跌，信贷宽松，消费者贷款和消费意愿增强。</p><p>第二列车厢：股市上涨，货币供应量增加和利率下降是经济稳定的基础，稳定后股市上涨。</p><p>第三列车厢：对利率敏感的经济先行部门，比如房地产和公共事业类的，因为它们的负债多。</p><p>第四列车厢：经济同步部门，比如制造业，同时非农就业人数增加，贸易额增加。</p><p>第五列车厢：滞后指标，比如商品价格的上涨，人工成本上涨，利率上涨</p><h2 id="资产配置">3. 资产配置</h2><p>每个市场都有两个转折点，一个顶部，一个底部，这意味着，一个典型的周期有6个转折点，我们称之为6个阶段。就像日历一样，每个阶段都有自己的特征。一个完整的周期时间长度就是基钦周期的长度，<strong>差不多41个月</strong>，阶段6一般时间比较段，差不多2~3个月，<strong>其他每个阶段约8个月</strong>，当然了这只是大致的时间，有的会长一些有的会稍短一些。从6个阶段我们可以看出，为上面我们投资的时间至少要6个月了，是因为至少要走完一个阶段。</p><p><strong>阶段一（只有债券是牛市）</strong> 这个阶段股票市场和商品还处于熊市，现金与股票和商品是负相关的，<strong>应该持有现金，同时开始配置债券</strong>，这个时间段由于货币供给的增加以及贷款需求降低导致短期利率开始走低，债券价格开始上涨，因为新债利率低，没人要，大家都抢老债，导致债券价格上涨。<strong>阶段一是配置债券的最佳时机</strong>。配置股票风险比较高，但是<strong>公共事业类和金融类</strong>以及日常消费品行业和公共运输类股票的<strong>股票偶尔在阶段一也会盈利</strong>。因为利率下降，对重资产和高负债的公共事业类和金融类企业就是业绩改善，股票会有好的表现。<strong>商品这个阶段还会下降，不要配置</strong>。</p><p><strong>阶段二（债券和股票是牛市，商品熊市）</strong> 阶段二不要配置现金，股票经历了阶段一的筑底开始最广泛，最快速增长。<strong>这个阶段配置股票收益高，风险低</strong>。股票市场发力意味着经济的复苏。这个阶段配置一些周期消费比如汽车，耐用消费品比如家电。这个阶段商品价格仍然在下跌，不建议配置。</p><p><strong>阶段三（债券股票商品三牛）</strong> 阶段三是黄金阶段，债券股票和商品都是牛市，但是这个阶段债券价格虽然还在上涨，但是涨幅已经没有股票和商品大，<strong>最好减少债券的比例，多配置股票和商品</strong>。另外<strong>持有的债券也要从长债换成短债</strong>。股票方面，大部分股票都在长，可以配置低贝塔指的股票组合，或者<strong>干脆配置指数</strong>。商品市场已经筑底，所以一些对通货膨胀敏感的股票也可以<strong>关注，比如采矿，石油等</strong>，如果你不习惯于做商品，那么可以<strong>通过连接性基金代替</strong>。</p><p><strong>阶段四（债券熊市，股票和商品牛市）</strong> 债券市场开始走熊，而股票和商品依然保持牛市。利率到达顶峰，通常是个尖头形状，而在底部，通常是一个杯托的形状，所以底部会更缓和一些，在第四个阶段，<strong>很显然利率即将触及顶部了，债券要尽早离手</strong>。<strong>股票</strong>要从早期的周期领先行业<strong>切换到业绩驱动型行业</strong>。这些行业包括资<strong>源型行业和基础行业，技术，卫生保健，耐用消费品和工业股表现强劲</strong>。商品此时也已经是牛市，所以买入一些大宗商品，也会有表现机会。</p><p><strong>阶段五（只有商品牛市）</strong> 利率达到顶峰开始回落，此时要更多的配置现金，而降低权益类资产的配置了。这个阶段持有债券，会受到比较大的损失，利率已倒顶点，债券向上空间不大，但向下的空间不小，另外，违约也开始增多，所以<strong>不建议在这个期间持有债券</strong>，可以完全用货币市场基金代替你的债券。 <strong>阶段Ⅴ股票表现最好的就是原材料</strong>。但这个阶段大部分股票都在下跌，上涨的股票越来越少。此时通胀会上升的比较厉害，<strong>商品的走势也会迭创新高</strong>。<strong>经济过热已经显现</strong>。</p><p><strong>阶段六（没有一个牛市，现金为王）</strong> 没有一个市场是牛市，此时就四个字<strong>现金为王</strong>，最好全都换成货币基金，躲避几个市场下跌的风险。这个时候通常都是加息的末尾，利率从高位开始下降，但市场已经形成了股债商品三杀，如果是保守的投资者，你可以一直持有现金，等待阶段一出现。 阶段六时间比较短，<strong>一般只有2~3个月或者稍长一点时间</strong>。尽管如此，<strong>大量的金融灾难都在这个极短的时间内发生</strong>，因此这个阶段一定要特别谨慎。</p><p>阶段六有个判断指标，就是<strong>铜价和PPI双下行的时候，基本就是阶段六</strong></p><p>总结如下： <img src="Pasted%20image%2020240113192332.png"></p><p>有人会问，<strong>我到底该如何去发现这6个阶段呢</strong>，其实有的是机会，只要记住这六个阶段的演化顺序，当利率即将触底，债券价格开始上升的时候，就是第一个阶段，而当债券已经上涨了，你就应该去考虑股市的问题了，用我们的周期理论，你就应该尽快想到，<strong>股市可能会在2年内有行情</strong>。而一旦股市牛市开始的时候，你就要抛售债券，转向商品强周期，而一旦股市到顶，你要远离债券，股市，并逐渐减仓商品，然后直到现金为王。所以，识别第一个阶段很重要，第一个阶段你识别出来，然后后面也就顺理成章，用逻辑推演就可以了。</p><p>不过也要说明一点，逻辑关系只是理论上的，有的时候可能会略有偏差，比如有的时候，股票会跟债券同时启动，也有的时候商品价格会比股票先涨。所以投资市场是科学也是艺术，而艺术就是他的随机性，大概率是按照这个逻辑推演的，但小概率也会发生奇葩的情况。</p><p><strong>长期持有股票，是最好的投资，也是唯一能够跑赢通货膨胀的方式</strong>，而持<strong>有股票最大的成本就是要承担他短期的波动性</strong>，从1926年到1991年，如果持有股票1年为周期计算，那么有60%的时间，股票的投资收益都超过了国债。然而如果持有股票时间增加到5年，那么股票好于债券的时间将超过7成，随着持有股票的时间增加，那么你的股票跑赢债券的概率也就越大。<strong>持有期20年的话，那么投资股票100%的跑赢债券</strong>。</p><p><a href="https://zhuanlan.zhihu.com/p/346676749">《积极型资产配置指南》 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构</title>
    <link href="/2023/12/19/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/12/19/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="slice和数组">1. Slice和数组</h2><p>新建数组必须指定长度，而且长度不可修改。所以在go中一般使用的是更具有灵活性的切片</p><h4 id="nil切片和空切片">nil切片和空切片？</h4><p>slice的底层数据结构是一个结构体，包含len，capacity和一个指向数组的pointer。nil在go中引用类型数据结构的零值（<strong>pointer、channel、func、interface、map或slice</strong>）。因此nil切片和空切片的本质区别在于，切片的pointer是否为nil。 <code>var s [] slice</code>是nil切片，<code>s := []int</code> 和 <code>s := make([]int,0)</code>是空切片 总结： - nil切片的长度和容量都是0，空切片的长度为0，容量由指向的底层数组决定<br>- 空切片 != nil切片<br>- nil切片的ptr指针是nil，而空切片的ptr指针指向底层数组的地址<br>- nil切片也切片，具有和普通切片相同的行为，所以nil切片具有切片同样的行为操作 - <strong>在判断切片是否为空时不能使用nil作为判断标准，应该使用len = 0作为标准</strong></p><h4 id="slice扩容">slice扩容</h4><p>切片使用<strong>runtime/slice.go</strong> 包下的<code>growslice()</code>方法进行扩容 如果当前切片的容量小于 1024,那么新切片的容量翻倍；<br>如果当前切片的容量大于 1024,那么新切片的容量每次增加25% 实际操作时还会根据结构体的情况进行内存对齐 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">newcap := old.<span class="hljs-built_in">cap</span> <br>doublecap := newcap + newcap<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;<br>   newcap = <span class="hljs-built_in">cap</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-keyword">if</span> old.<span class="hljs-built_in">cap</span> &lt; <span class="hljs-number">1024</span> &#123;<br>      newcap = doublecap <span class="hljs-comment">// * 2 </span><br>   &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123; <span class="hljs-comment">// 25%</span><br>         newcap += newcap / <span class="hljs-number">4</span> <br>      &#125;<br>      <span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;<br>         newcap = <span class="hljs-built_in">cap</span><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>当slice容量不足时，会根据切片元素的大小和新容量计算内存，将超出切片长度的内存清空，并拷贝旧切片的内存数据到新申请的内存中（<strong>这意味着底层的数组指针发生了改变</strong>），最后返回</p><h4 id="切片作为参数传递">切片作为参数传递</h4><p>理解了切片的数据结构就不难理解这个问题，当切片作为参数传递时，其实只是传了一个实参的拷贝，实参和形参的地址不同，但切片的pointer是相同的。</p><p>即slice有两个，地址不同，但是数据结构中的pointer是一样的，其他一个slice修改变量会导致另一个slice同步修改 如果触发了扩容机制，会返回一个新pointer，此时进行修改则不再同步 如果想要扩容后仍然同步，则需要在传参时传递切片的pointer <strong>注意：理解这一点非常重要，不然可能在函数运行时引发不知名bug</strong></p><h4 id="内存逃逸问题">内存逃逸问题</h4><p>Go的内存分配有栈（stack）和堆（heap）两种</p><p>内存逃逸的本质是<strong>内存被分配到了堆上</strong> 。堆内存的分配不如栈内存快，且需要gc进行内存回收。 由于Slice底层还是一个指针，当指针类型作为返回时，会发生内存逃逸</p><p>Golang的逃逸分析的基本原则是：如果函数返回了变量的引用，那么这个变量就会逃逸。 编译器可以通过分析代码，决定变量分配的地方： - 如果变量在函数外没有被引用，那么优先分配在栈（stack）上 栈的分配速度快，只需要CPU的两个指令“PUSH”和“RELEASE“进行分配和释放。 - 如果变量在函数外被引用，那么优先分配在堆（heap）上，没有在函数外被引用也可能分配在堆上，比如当变量过大时（Go栈的最大值为64位下1G，32位下250M） 堆的分配速度较慢，首先需要找到一块大小合适的内存块，还需要gc垃圾回收才能释放。</p><p>常见的内存逃逸情况： （1）函数内将局部变量指针返回，被外部引用，其生命周期大于栈，溢出 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUser</span><span class="hljs-params">()</span></span> *User&#123;<br>user := User&#123;&#125;<br><span class="hljs-keyword">return</span> &amp;user<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>_ = NewUser()<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>（2）对象太大，超过栈帧大小 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>    _ = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>) <br>    _ = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10000</span>) <br>&#125;<br></code></pre></td></tr></table></figure></p><p>（3）闭包引用逃逸 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    a, b := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>        a, b = b, a+b<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 在<code>Fibonacci()</code>函数中，a,b是一个本地的变量，因为被闭包引用，所以被分配在了堆上。</p><p>（4）动态类型逃逸 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>    a := <span class="hljs-number">1</span> <br>    fmt.Println(<span class="hljs-string">&quot;a逃逸，a:&quot;</span>, a) <br>&#125;<br></code></pre></td></tr></table></figure> 因为<code>fmt.Println</code>函数参数类型是interface{}，在 interface 类型上调用方法都是动态调度的，即方法的真正实现只能在运行时知道</p><p>（5）slice，map和channel的指针引用 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := <span class="hljs-built_in">make</span>([]*<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>    b := <span class="hljs-number">12</span><br>    a[<span class="hljs-number">0</span>] = &amp;b<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*<span class="hljs-type">int</span>)<br>    d := <span class="hljs-number">14</span><br>    c[<span class="hljs-string">&quot;aaa&quot;</span>] = &amp;d<br>    e := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>    f := <span class="hljs-number">15</span><br>    e &lt;- &amp;f<br>&#125;<br></code></pre></td></tr></table></figure> 变量<code>b</code>,<code>d</code>,<code>f</code>的内存都被移动到堆上，因为在Golang中，slice，map，channel引用指针的变量，一定会逃逸。 这是在Golang中，slice，map，channel对指针的引用性能低的根本原因</p><p>总的来说： 栈内存的分配和回收是非常快速的，只需要2条CPU指令,<code>PUSH</code> 和 <code>RELEASE</code>。而堆内存，分配需要找到合适大小的内存块，回收则是通过GC。因此，通过内存的逃逸分析，可以尝试将不必要分配在堆上的变量分配在栈上，减少分配堆内存的开销和GC的压力。</p><p>启示： 1. <strong>对于性能要求比较高且访问频次比较高的函数调用，应该尽量避免使用接口类型</strong> 2. <strong>不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销更大</strong> 3. <strong>预先设定好slice长度，避免频繁超出容量，重新分配</strong></p><h4 id="copy的使用">copy的使用</h4><p>在完成leetcode77.组合问题时出现的情况： 1. 使用slice作为一种全局的参考，必须使用深拷贝，否则后面修改了，前面添加进ans的结果也都会修改。 2. 使用copy( destSlice, srcSlice []T) int时，必须提前把长度开辟好，copy过程不会自动扩容 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    ans := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)<br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">var</span> backtrack <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>,k <span class="hljs-type">int</span>,level <span class="hljs-type">int</span>)</span></span><br>    backtrack = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>,k <span class="hljs-type">int</span>,level <span class="hljs-type">int</span>)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-built_in">len</span>(tmp)&#123;<br>            t := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,k) <span class="hljs-comment">//必须提前指定大小为k，因为在copy时不会自动扩容</span><br>            <span class="hljs-built_in">copy</span>(t,tmp) <span class="hljs-comment">//如果没有深拷贝，会存在所有答案都相同的问题</span><br>            ans = <span class="hljs-built_in">append</span>(ans,t)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> i:=level;i &lt;= n;i++&#123;<br>            tmp = <span class="hljs-built_in">append</span>(tmp,i)<br>            backtrack(n,k,i+<span class="hljs-number">1</span>)<br>            tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    backtrack(n,k,<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="参考资料">参考资料</h4><p><a href="https://juejin.cn/post/7095097471608553503">Golang | 深入理解数据结构之Slice - 掘金 (juejin.cn)</a></p><h2 id="链表">2. 链表</h2><p><a href="https://pkg.go.dev/container/list">官方文档</a></p><p>链表的知识没有切片那么繁琐，<strong>只要能随手手撕结构体+配套方法即可</strong>（可参见leetcode 707）。 go中自带的链表结构体定义在container/list/list.go中。 list本身是一个结构体，每个节点（element）也是一个结构体。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Element is an element of a linked list.  </span><br><span class="hljs-keyword">type</span> Element <span class="hljs-keyword">struct</span> &#123;  <br>    <span class="hljs-comment">// Next and previous pointers in the doubly-linked list of elements.  </span><br>    <span class="hljs-comment">// To simplify the implementation, internally a list l is implemented    // as a ring, such that &amp;l.root is both the next element of the last    // list element (l.Back()) and the previous element of the first list    // element (l.Front()).    next, prev *Element  </span><br>  <br>    <span class="hljs-comment">// The list to which this element belongs.  </span><br>    list *List  <br>  <br>    <span class="hljs-comment">// The value stored with this element.  </span><br>    Value any  <br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// List represents a doubly linked list.  </span><br><span class="hljs-comment">// The zero value for List is an empty list ready to use.  </span><br><span class="hljs-keyword">type</span> List <span class="hljs-keyword">struct</span> &#123;  <br>    root Element <span class="hljs-comment">// sentinel list element, only &amp;root, root.prev, and root.next are used  </span><br>    <span class="hljs-built_in">len</span>  <span class="hljs-type">int</span>     <span class="hljs-comment">// current list length excluding (this) sentinel element  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>go中的list是一个双向链表，下面是两种初始化方式 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;container/list&quot;</span><br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> <br>   <span class="hljs-comment">// 使用list.New()直接初始化</span><br>   l1 := list.New()<br>   l1.PushFront(<span class="hljs-number">1</span>)<br>   fmt.Println(l1.Front().Value) <span class="hljs-comment">// 1</span><br><br>   <span class="hljs-comment">// 使用list.List&#123;&#125;延迟初始化</span><br>   l2 := list.List&#123;&#125;<br>   l2.PushFront(<span class="hljs-number">2</span>)<br>   fmt.Println(l2.Front().Value) <span class="hljs-comment">// 2</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure></p><p>go链表包含哨兵节点，哨兵节点的两个指针next和prev分别指向第一个节点和最后一个节点，不保存其他有效数值。因此<strong>go的链表也可以当成栈和队列来使用</strong>。</p><h2 id="哈希表">3. 哈希表</h2><p>哈希是非常常见的数据结构，在C语言中有多种实现方式： <img src="20231211212721.png"> <img src="20231211212822.png"></p><p>哈希表底层基于数组实现，哈希函数的选择在很大程度上能够决定哈希表的读写性能 ，当发生哈希冲突时，哈希表的读写性能通常会下降到<code>O(logN)</code>甚至<code>O(N)</code>级别。 可以总结出影响哈希表性能的一些因素: - 哈希函数是否完美，是否能够尽量减少哈希冲突的发生 - 当哈希冲突发生时，如何解决哈希冲突 - 哈希表底层基于数组实现，当数组接近被填满时，发生哈希冲突的概率会大大增大，因此需要对数组做扩容。如何选择合适的<code>扩容阈值</code>并且如何做<code>数组扩容</code>也会影响哈希表的性能与稳定性</p><p>go map初始化： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></p><h4 id="map的遍历">map的遍历</h4><p>在使用go range遍历map时： - key是乱序的 - 每个key value使用的内存相同，每次将不同的key value值拷贝到那块内存中 - 遍历时，如果一个元素还没有被访问到就被删除或者新增了一个元素，该元素不会被访问到 - 被遍历的map是原map的copy，但共用同一片底层内存。在遍历过程中对此map元素的修改将体现到循环变量中</p><p>map的key值不能是func()，map和Slice，但可以是channel。因为channel创建后指针是不会再发生变化的，slice、map、func()可能会发生变化</p><p>如果将interface{}作为key，但是传入func()，则会抛出runtime.panic</p><h4 id="源码结构">源码结构</h4><p>map运行中主要使用 runtime/map.go中的hmap来表示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">//hmap的结构体</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br><br>   count     <span class="hljs-type">int</span>     <span class="hljs-comment">//  当前哈希表中的元素数量</span><br>   flags     <span class="hljs-type">uint8</span>   <span class="hljs-comment">// 扩容标志位</span><br>   B         <span class="hljs-type">uint8</span>   <span class="hljs-comment">// 哈希表中桶的数量为2的B次方</span><br>   noverflow <span class="hljs-type">uint16</span>  <span class="hljs-comment">// 记录溢出桶的大致数量 当溢出桶的数量不多时，值为精确值当;溢出桶的数量过多时， 为大致值</span><br>   hash0     <span class="hljs-type">uint32</span> <span class="hljs-comment">// hash种子</span><br><br>   buckets    unsafe.Pointer <span class="hljs-comment">// 容量为2^B的桶数组，存储具体 key/value 的 bucket 数组，里面每个 bucket 本质也是指向结构体的一个指针，其指向的结构体是 bmap</span><br>   oldbuckets unsafe.Pointer <span class="hljs-comment">// 扩容时保存旧的桶</span><br>   nevacuate  <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 用于记录数据转移的进度，低于此值的数据已经从旧桶转移到了新桶中</span><br><br>   extra *mapextra <span class="hljs-comment">// 溢出桶</span><br>&#125;<br><br><span class="hljs-comment">//溢出桶</span><br><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>   overflow    *[]*bmap <span class="hljs-comment">// 溢出桶</span><br>   oldoverflow *[]*bmap <span class="hljs-comment">// 旧的溢出桶</span><br>   nextOverflow *bmap <span class="hljs-comment">// 指向空闲溢出桶的指针</span><br>&#125;<br><br><br><span class="hljs-comment">// 源代码中的bmap，但不是实际运行的样子</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>tophash [bucketCnt]<span class="hljs-type">uint8</span><br>&#125;<br><span class="hljs-comment">// bmap在编译时计算大小，使用反射机制构成真正的bmap类型</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash     [bucketCnt]<span class="hljs-type">uint8</span> <span class="hljs-comment">//存放了Hash值的前8位，用于插入时候的快速比较等场景</span><br>    keys        [bucketCnt]keyType<br>    values      [bucketCnt]valueType<br>    pad         <span class="hljs-type">uintptr</span><br>    overflowPtr <span class="hljs-type">uintptr</span><br>&#125;<br><br><br><br><br></code></pre></td></tr></table></figure></p><p><img src="20231211214849.png"></p><p>代码太晦涩，看着图更容易理解，buckets是一个指向bmap指针数组的指针，每个bmap指针指向一个bmap结构体。bmap结构体内部包含key数组和value数组（<strong>分开存储而不是成对存储可以有效减少填充，节约内存</strong>）。 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">例如，有这样一个类型的 <span class="hljs-built_in">map</span>：`<span class="hljs-built_in">map</span>[int64]int8`，如果按照 `<span class="hljs-built_in">key</span>/value...` 这样的模式存储，那在每一个 <span class="hljs-built_in">key</span>/value 对之后都要额外 padding <span class="hljs-number">7</span> 个字节<br><br>而将所有的 <span class="hljs-built_in">key</span>，value 分别绑定到一起，这种形式 `<span class="hljs-built_in">key</span>/<span class="hljs-built_in">key</span>/.../value/value/...`，则只需要在最后添加 padding即可。<br></code></pre></td></tr></table></figure></p><p>一个bmap能存储8个k-v对，超过的部分会创建新的桶并通过overflow串联起来（拉链法）。</p><p>问题：既然bmap有了overflow串联溢出的桶，为什么还需要extra来保存溢出桶的指针？ 答案：这是一种优化。当<strong>map的key和val均不含指针</strong>并且可以内联(size &lt; 128字节)时，bmap可以被标注为不包含指针，这样可以<strong>避免GC时扫描整个map（扫描所有的bmap）</strong>。但是因为bmap本身就包含了一个指向溢出桶的指针<code>overflow</code>，因此<strong>hmap才增加了extra字段，用来保存溢出桶信息</strong>，这样如果bmap不包含指针(除了overflow指针)，那么<strong>GC扫描时只需要扫描extra字段中的溢出桶而不用扫描整个map</strong></p><h4 id="key的定位">key的定位</h4><p>go map的hash函数其实就是取余（但取余很慢，所以位运算代替）。</p><p>key经过hash得到的hash值总共有64个bit位： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">10010111</span> | <span class="hljs-number">000011110110110010001111001010100010010110010101010</span> │ <span class="hljs-number">01010</span><br><br>- 取后B个Bit位作为要存放的桶编号，例如上面的<span class="hljs-number">01010</span>，就是<span class="hljs-number">10</span>号桶<br>- 再用Hash值的高<span class="hljs-number">8</span>位，找到Key在桶内部的位置，这是在寻找已有的key<br><br>假定 B = <span class="hljs-number">5</span>，所以 bucket 总数就是 <span class="hljs-number">2</span>^<span class="hljs-number">5</span> = <span class="hljs-number">32</span>。首先计算出待查找 key 的哈希，使用低 <span class="hljs-number">5</span> 位 <span class="hljs-string">`01010`</span>，找到对应的 <span class="hljs-number">8</span> 号 bucket，使用高 <span class="hljs-number">8</span> 位 <span class="hljs-string">`10010111`</span>，对应十进制 <span class="hljs-number">151</span>，在 <span class="hljs-number">8</span> 号 bucket 中寻找 tophash 值（HOB hash）为 <span class="hljs-number">151</span> 的 key，找到了 <span class="hljs-number">2</span> 号槽位，这样整个查找过程就结束了。<br></code></pre></td></tr></table></figure></p><p>如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。</p><h4 id="hash函数">hash函数</h4><p>hash函数是在初始化时根据CPU确认的，默认AES。如果不支持AES，则使用mem hash</p><h4 id="map的访问">map的访问</h4><p>map的访问即通过给定的key在map中寻找其对应value，它的大致步骤如下： 1. 以64位操作系统为例，原始的key通过Hash函数映射成<strong>64位</strong>二进制。 2. <strong>末尾B位</strong>对应<code>bmap</code>的位置，从<code>[]bmap</code>中找到对应的<code>bmap</code>。 3. <strong>首8位</strong>对应该key的<code>tophash</code>，从步骤2所定位的<code>bmap</code>开始检索。首先会比较<code>bmap</code>顶层的<code>tophash</code>与原始key的<code>tophash</code>是否相同，若不相同则直接跳过比较下一个；若相同则进一步比较key是否相同。 4. 若当前的<code>bmap</code>中比较完，没有匹配到目标key，且<code>overflow</code>不为空，则继续从<code>overflow</code>指向的下一个<code>bmap</code>继续比较</p><h4 id="map的扩容与迁移">map的扩容与迁移</h4><p>map扩容的目的在于减少Hash冲突，防止算法复杂度<strong>退化</strong>，保持Hash算法O(1)的时间复杂度 - map的扩容对使用方<strong>不可见</strong>，开发者在使用map的过程中不会感知到map是否在扩容 - Go语言的map扩容是<strong>渐进式</strong>的，即整个扩容过程拆散在每一次的写操作里面，这样做的好处是保证每一次map的读写操作时间复杂度都是<strong>稳定</strong>的。</p><p>触发扩容的两个因素<br>（1）负载因子大于6.5（负载因子=元素个数/桶个数），说明桶快要装满；采用双倍扩容 （2）溢出桶太多，map 成了链表，性能大大降低；采用等量扩容，重新排列数据 - B &lt;=15，已使用的溢出桶个数 &gt;= (2^B) 时，引发等量扩容。 - B &gt; 15，已使用的溢出桶个数 &gt;= (2^15) 时，引发等量扩容。</p><p>扩容的具体方案： （1）双倍扩容：将旧桶中的数据分流至新的两个桶中（比例不定），B+1；扩容也不是申请一块内存，立马开始拷贝。而是每一次访问旧的 buckets 时，就迁移一部分，直到完成，旧 bucket 被 GC 回收。根据key重新生成哈希值，根据哈希值的底B位来决定位置中 （2）等量扩容：开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。在极端情况下，重新扩容也解决不了问题，map成了链表。这种情况可以通过哈希种子的设置避免</p><h4 id="map的迭代">map的迭代</h4><p>由于map存在<strong>渐进式扩容</strong>，因此map的迭代并不像想象中的那么直接，而需要考虑搬迁过程中的迭代。</p><p>map在搬迁过程中会通过nevacuate来记录搬迁进度，因此在迭代过程中需要同时考虑遍历旧的bmap和新的bmap。</p><p>由于map的删除是找到对应的bmap删除key/value并且清空tophash，但是并不会导致下标产生偏移。因此go map是可以在迭代时产生删除操作的</p><h4 id="float可以作为key吗">float可以作为key吗？</h4><p>可以，但是由于精度问题，所以可能出现一些诡异的问题，不建议使用</p><h4 id="参考资料-1">参考资料</h4><p>https://www.cnblogs.com/ling11/p/16318554.html https://blog.csdn.net/fengshenyun/article/details/100582529</p><h2 id="字符串">4. 字符串</h2><p>在 go 语言中，字符串实际上是一个<strong>只读</strong>的<strong>字节切片</strong>，其数据结构定义如下： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime/string.go</span><br><span class="hljs-keyword">type</span> stringStruct <span class="hljs-keyword">struct</span> &#123;<br>str unsafe.Pointer<span class="hljs-comment">// 指向底层byte数组的指针,byte是uint8的别名</span><br><span class="hljs-built_in">len</span> <span class="hljs-type">int</span><span class="hljs-comment">// 字节数组的长度 </span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>字符串常量会在编译期分配到只读段，对应数据地址不可写入，相同的字符串常量不会重复存储</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;hello&quot;</span><br>fmt.Println(a, &amp;a, (*reflect.StringHeader)(unsafe.Pointer(&amp;a)))<br>a = <span class="hljs-string">&quot;world&quot;</span><br>fmt.Println(a, &amp;a, (*reflect.StringHeader)(unsafe.Pointer(&amp;a)))<br><span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;hello&quot;</span><br>fmt.Println(b, &amp;b, (*reflect.StringHeader)(unsafe.Pointer(&amp;b)))<br>&#125;<br><br><span class="hljs-comment">/* output</span><br><span class="hljs-comment">字符串字面量 该变量的内存地址 底层字节切片</span><br><span class="hljs-comment">hello 0xc0000381f0 &amp;&#123;5033779 5&#125;</span><br><span class="hljs-comment">world 0xc0000381f0 &amp;&#123;5033844 5&#125;</span><br><span class="hljs-comment">hello 0xc000038220 &amp;&#123;5033779 5&#125;</span><br><span class="hljs-comment">*/</span><br><br>可以看到，hello在底层只存储了一份<br></code></pre></td></tr></table></figure><p>rune是int32的别名，在对字符串进行for range遍历时，是按照<strong>rune类型来解码</strong>的。rune和byte之间可以相互转换，但这个过程不是修改字节数组而是重新分配内存并copy。</p><h4 id="kmp算法是必会的">kmp算法是必会的</h4><p>如何更好地理解和掌握 KMP 算法? - 阮行止的回答 - 知乎 https://www.zhihu.com/question/21923021/answer/1032665486</p><h2 id="栈和队列">5. 栈和队列</h2><p>在go中没有现成的栈和队列结构，需要使用list来模拟。</p><p>https://xie.infoq.cn/article/e89e4df33f36f03e6d5d6116f</p><h2 id="二叉树">6. 二叉树</h2><p>二叉树需要熟记的是三种遍历方式，最主要是迭代的方式，用同一套模板：</p><p>中序遍历 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//中序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)<br>    stack := []*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span>&#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//出栈</span><br>        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span>&#123; <br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span>&#123;<br>                stack = <span class="hljs-built_in">append</span>(stack,node.Right)  <br>            &#125; <span class="hljs-comment">//右</span><br>            <br>            stack = <span class="hljs-built_in">append</span>(stack,node) <span class="hljs-comment">//中</span><br>            stack = <span class="hljs-built_in">append</span>(stack,<span class="hljs-literal">nil</span>)  <span class="hljs-comment">//中</span><br>            <br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span>&#123;<br>                stack = <span class="hljs-built_in">append</span>(stack,node.Left)<br>            &#125;<span class="hljs-comment">//左</span><br>            <span class="hljs-comment">//中序遍历从下往上数，左中右</span><br>            <span class="hljs-comment">//后序遍历从下往上数，左右中</span><br>            <span class="hljs-comment">//先序遍历从下往上数，中左右</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            node = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            ans = <span class="hljs-built_in">append</span>(ans,node.Val)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>层次遍历 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">//层次遍历</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    queue := list.New()<br>    queue.PushBack(root)<br>    ans := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>) <br>    <span class="hljs-keyword">for</span> queue.Len() &gt; <span class="hljs-number">0</span>&#123;<br>        length := queue.Len()<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">//每一层的节点列表</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i &lt; length;i++&#123;<br>            node := queue.Front().Value.(*TreeNode)<br>            queue.Remove(queue.Front())<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span>&#123;<br>                queue.PushBack(node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span>&#123;<br>                queue.PushBack(node.Right)<br>            &#125;<br>            tmp = <span class="hljs-built_in">append</span>(tmp,node.Val)<br>        &#125;<br>        ans = <span class="hljs-built_in">append</span>(ans,tmp)<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans  <br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Go进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构, 语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>商业模式的逻辑</title>
    <link href="/2023/12/06/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%BB%E8%BE%91/"/>
    <url>/2023/12/06/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<p>商业模式描述了企业如何创造价值、传递价值和获取价值的基本原理。</p><p>通俗来说：一个企业的商业模式，就是一个企业如何给客户带来价值，然后要把创造的价值很好的交付出去，最终赚到钱。</p><p><strong>创业的前提就是搞清楚自己的商业模式。</strong></p><p>本文会通过绘制一张商业画布的情况下，所讲述的内容在以下情况下适用： 1. 一家企业急需找到产品新方向和新模式时 2. <strong>有了一个idea，但不够产品化</strong> 3. 已经有了一个产品，但是销售情况不佳，需要进行整顿</p><p>总的来说，整篇文章的目的是帮助把一个idea产品化，体系化（可以做成PPT），同时也是教会大多普通人从体系的角度去看待商业行为（例如共享单车）</p><h2 id="概述">概述</h2><p>商业模式画布可以帮助理解商业模式的内在逻辑，这个画布从以下八个方面展开。 （回答清楚这几个问题就解答了商业模式是什么的问题） 1. 客户细分：任何的商业模式要有一个非常清晰的目标客户群。客户细分是所有商业模式逻辑上的起点，也是他的终点 2. 价值主张：客户购买或使用的理由，是整个商业模式的灵魂。营销就是围绕价值主张展开的 3. 渠道通路：如何把价值主张交付给客户 4. 客户关系：在整个闭环的商业模式中，最终致力于跟客户构建起一个什么样的关系 5. 收入来源：钱从哪里来 6. 关键业务（key activity）：为了前期的预想落地，应该做哪些行动？ 7. 核心资源：商业模式中固定不可被取消的资源体系 8. 重要伙伴： 9. 成本结构： 怎么有效的花钱，把每一笔钱最大化的、杠杆化的运用</p><p>1-5是整个商业模式的前端过程，对<strong>用户细分</strong>经过<strong>渠道通路</strong>传递<strong>价值主张</strong>，<strong>构建客户关系</strong>获取<strong>收入来源</strong></p><h2 id="客户细分">1. 客户细分</h2><p><strong>在要构建商业模式时，第一步最重要的是，要选准目标客户群体，且围绕此目标客户群体，精准分析他们的痛点，构成商业逻辑的第一步</strong>。</p><p>客户细分可以通过几种常见的角度： 1. 大众市场（不分类） 男女老少通吃的市场，例如微信、农夫山泉等都是面向大众市场</p><ol start="2" type="1"><li><p>利基市场（细分大众市场） （1）按照年龄切分，例如学而思面向K12群体（一年级到高三） （2）按照支付能力，例如法拉利和五菱宏光面对不同的收入人群 （3）按照偏好划分，例如面向旅游爱好者的马蜂窝，面向追剧爱好者的爱奇艺</p></li><li><p>区隔化市场 区隔化市场主要是体现在营销策略上，例如苹果主打高端手机，华为主打国产高端手机，小米主打性价比，vivo、oppo主打音乐手机，摄影手机。虽然手机行业面向的客户细分相似，但仍然可以细分出区隔化市场。</p></li><li><p>多元化市场 例如小米公司不只是做手机，手机有对应的客户细分，小米门锁，小米音箱，小米电视等都有对应的客户细分，这些一起够成了小米公司的多元化市场</p></li><li><p>双边或多边市场 单边市场是我买你卖的形式，双边则是不买也不卖，但提供给买卖双方的渠道。绝大多数互联网公司都是双边市场，例如淘宝入驻买家和卖家；滴滴有打车的人和司机。当双边市场逐渐复杂就会形成多边市场</p></li></ol><p>问题：如此之多的划分方法，如何知道划分方式是否好呢？ 答案：客户的购买密度</p><p>一个精准的划分会有较高的购买密度，即每百人购买我东西的人占比很高（例如30%）</p><p><img src="20231206143812.png"></p><h2 id="价值主张">2. 价值主张</h2><p>价值主张构造块用来描绘为特定客户细分创造价值的系列产品和服务。绝大多数创业项目失败在于没有一个好的价值主张</p><p>价值主张指的是，客户购买或者使用你这个产品或服务的理由。例如怕上火就喝王老吉（理由是凉茶去火），摩尔定律（微软的CPU性能高速更新），让出行更容易（滴滴打车解决出租车难的问题）</p><p>常用的价值主张类型如下，可以从中找到自己的idea的类型 1. 新颖性， 2. 性能，主打高性能 3. 定制化，主打根据个人情况定制 4. 设计感 5. 品牌身份和地位 6. 价格，主打平价亲民 7. 抑制风险 8. 便利性，主打让xxx更便利 9. 成本控制 10. 把事情做好</p><p>问题：什么叫好的价值主张： 答案：指向客户的痛点；与竞争对手的产品有明显的差异化；能够让团队变得更加兴奋，变得更加成功。</p><p>下面举几个根据价值主张开展营销的案例： 1. 农夫山泉有点甜 2. 主打除菌的舒肤佳干掉了力士香皂</p><h2 id="渠道通路">3. 渠道通路</h2><p>知道了东西要卖给谁，卖什么之后，还需要解决怎么卖的问题。</p><p>渠道通路构造块用来描绘公司是如何沟通、接触其客户细分而传递其价值主张。</p><p>一般来讲，在商业世界中，可以把商业模式分为两大类： 1. B2C（面向于个人消费者） 2. B2B（面向于政企客户）</p><p>B2C常见的类型： <img src="20231206153714.png"></p><p>B2B常见的类型： <img src="20231206153738.png"></p><p>在现在的互联网时代，APP成为了大多数创业项目的渠道通路</p><h2 id="客户关系">4. 客户关系</h2><p>客户关系构造块用来描绘公司与特定客户细分群体建立的关系类型。即：你对于客户来说是什么？</p><p>常见的客户关系： <img src="20231206153936.png"></p><p>GPT相当于顾问 有道云笔记、美图秀秀相当于个人助理 银行，证券公司等对应专属会员 马蜂和对应共创/众包，内容不是自己发布的</p><h2 id="收入来源">5. 收入来源</h2><p>收入来源构造块用来描绘公司从每个客户群体中获取的现金收入（包括一次性收入和经常性收入） <img src="20231206154312.png"></p><p>例如报纸杂志以订阅费为收入来源，谷歌以广告盈利</p><h2 id="核心资源">6. 核心资源</h2><p>核心资源构造块用来描绘让商业模式有效运转所必需的最重要因素。 <img src="20231206164804.png"></p><h2 id="关键业务">7. 关键业务</h2><p>关键业务构造块用来描绘确保其商业模式可行，企业必须做的最重要的事情。 <img src="20231206165119.png"></p><h2 id="重要伙伴">8. 重要伙伴</h2><p>重要伙伴构造块用来描绘让商业模式有效运作所需的供应商与合作伙伴的网络。 <img src="20231206165148.png"></p><p>供应商很容易理解 战略联盟指的是互相推进进步，是关系很深的合作 竞合是竞争合作，例如房地产商联合拿地分摊风险 生态伙伴是围绕一个体系一起发展，例如小米由很多周边产品，例如电视、门锁。很多不是自己开发的，是合作者开发，但是小米提供融资，分销渠道和流量支持等。大家都在小米主导的智能家居系统下</p><h2 id="成本结构">9. 成本结构</h2><p>成本结构构造块用来描绘运营一个商业模式所引发的所有成本。</p><p>通俗来讲，就是钱应该怎么花才最有效。</p><p><img src="20231206170853.png"></p><h2 id="案例">案例</h2><p><img src="20231206170906.png"></p><p><img src="20231206170919.png"></p><p><img src="20231206170933.png"></p><p><img src="20231206170941.png"></p><p><img src="20231206170946.png"></p><p><img src="20231206170957.png"></p>]]></content>
    
    
    <categories>
      
      <category>创业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>商业模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Concept Sliders</title>
    <link href="/2023/11/30/Concept-Sliders/"/>
    <url>/2023/11/30/Concept-Sliders/</url>
    
    <content type="html"><![CDATA[<p>论文标题：Concept Sliders: LoRA Adaptors for Precise Control in Diffusion Models 阅读时间：2023-11-30 阅读目的：师兄推荐</p><h2 id="introduction">Introduction</h2><p>现有的文生图方法无法精确的调节连续属性（例如人的年龄或天气强度）。</p><p>文章提出了一种可解释的概念滑块来满足这个需求。</p><p>概念滑块解决了以往方法未能很好解决的几个问题。直接修改提示语可以控制许多图像属性，但由于输出对提示语-种子组合的敏感性，改变提示语往往会大幅改变整体图像结构（imagic），</p><p>PromptToPrompt需要对每个新概念进行单独的推理，而且只能支持有限的同时编辑。这些方法需要设计一个适合单个图像的提示，而不是学习一个简单的通用控制，而且如果不仔细提示，可能会引入概念之间的纠缠，例如在修改年龄时改变种族。</p><p>相比之下，<strong>概念滑块提供了轻量级的即插即用适配器，适用于预先训练好的模型，能够在单次推理中对所需概念进行精确、连续的控制，并具有高效的组合和最小的纠缠</strong></p><p>概念滑块还可以用来解决两个文生图的关键问题： 1. 修复手部畸形 2. 增强图像逼真度</p><h2 id="related-work">Related Work</h2><h4 id="图像编辑">图像编辑</h4><h4 id="引导模型">引导模型</h4><h4 id="模型编辑">模型编辑</h4><p>本文的方法可以视为是一种模型编辑，通过应用lora将语义属性单列出来，并允许对属性进行持续控制</p><h4 id="生成模型中语义引导的发展趋势">生成模型中语义引导的发展趋势</h4><p>本文的方法直接训练与语义属性相对应的低阶子空间。通过使用文本或图像对作为监督来优化特定的全局方向</p><h2 id="background">Background</h2><h4 id="lora">lora</h4><p><img src="20231206102130.png"></p><p><img src="20231206102215.png"></p><h2 id="method">Method</h2><p><strong>概念滑块其实也就是一个学会了概念方向的lora模型，例如age关于（old，young）就构成了一个概念对，概念滑块的目的就是通过Lora的方式，当lora对应权重变大时，增加或减少特定属性的表达概念，让SD意识到生成的图像应该越来越老。</strong></p><p>其实SD从大量图片中可以学习到关于old和young的概念，但是一直没有办法引导出来。</p><h4 id="文本概念如图">文本概念（如图）</h4><ol type="1"><li>在SD上分三个文本生成三个噪声</li><li>在lora上使用目标概念作为本文生成噪声</li><li>优化两个步骤之间噪声的L2 loss</li></ol><p><img src="20231209132056.png"></p><h4 id="图像概念">图像概念</h4><p>图像概念就是用多个数据对来进行学习，这些数据对最好除了想要学习的概念外都保持一致。</p><p>训练时给图像对添加噪声，然后让SD+lora去预测噪声，优化lora，让噪声和添加的噪声差距最小。 <img src="20231209132201.png"></p><h2 id="experiments">Experiments</h2><p><img src="20231209133334.png"></p>]]></content>
    
    
    <categories>
      
      <category>图像生成</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式训练</title>
    <link href="/2023/11/21/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/"/>
    <url>/2023/11/21/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<p>大规模语言型（LLM）承载着AI时代的三大核心：数据、算力、算法。</p><p>现如今，AI发展进入大模型时代。想要训练出一个好的大模型： - 烧钱 - 高质量数据 - 高效的训练框架和硬件资源 - 优秀的算法 四者缺一不可，而本系列主要关注第三点，即那么大参数量的模型是如何高效训练的？</p><p>早期的深度学习不存在多卡，都是在一张显卡上跑出结果。现在我们有了很多张卡，我们想要做的事情是什么呢？ 1. 训练更大的模型：单个显卡的显存有限，现在显卡多了，我们可以训练更大的模型 2. 更快的训练模型：原本一张卡要跑很久，现在多张卡可以极大的加速训练时间。</p><p>这是一个并行计算的任务，我们要先要明白这个过程中遇到的最大困难是什么： 1. <strong>内存限制</strong>：训练更大的模型，每块GPU中不仅要保存模型的参数，还要保存来计算梯度的中间结果。越大规模的数据，中间结果也就越多， 2. <strong>带宽限制</strong>：并行计算的过程涉及到通讯，数据在卡之间传输是需要时间的。</p><p>本文的所有内容都是围绕着解决这两个问题展开。</p><p>目前的并行方法有三种，各有不同的应用场景 1. 流水线并行 2. 数据并行（DP）、分布式数据并行（DDP），零冗余优化（Zero） 3. 张量并行</p><h2 id="流水线并行">流水线并行</h2><p>拿到多张显卡，一个很朴素的想法就是把模型拆成很多块，分别放到不同的显卡中。所有显卡串行连接起来，构成一个完整的模型。</p><p>第一块显卡上的模型forward结束，将结果发送给第二块，以此类推；最后一块显卡forward完成后开始backward，同理把计算的结果发送给倒数第二块显卡，以此类推。</p><p>如果学习过CPU的流水线计算的话，就知道这样的方式会浪费很多计算资源，例如，当第一个显卡完成forward过程后，就处于空闲状态，一直等到最后一块显卡将backward传播过来。</p><p>刚刚的情况下，显卡直接的数据传输是整个batch。流水线操作就是将这个mini-batch，拆分成多个micro-batch再操作：第一块显卡先运行第一个micro-batch，然后传输给第二块显卡，但是这之后他不闲着，立刻开始运行第二个micro-batch，以此类推。再一个epoch结束后再把micro-batch合并在一起。这样提高了GPU的使用率</p><p>流水线并行的原理很简单，但是并不常用。它面临着不同的模型不知道如何均匀拆分的问题，需要依赖算法工作人员手动调整，非常不方便，毕竟将算力分配均匀，知道以哪一层为界限分割模型，并不是一件简单的事情</p><p><a href="https://zhuanlan.zhihu.com/p/613196255">图解大模型训练之：流水线并行（Pipeline Parallelism），以Gpipe为例 - 知乎 (zhihu.com)</a></p><h2 id="数据并行dp">数据并行(DP)</h2><p>https://zhuanlan.zhihu.com/p/617133971</p><h2 id="分布式数据并行ddp">分布式数据并行（DDP）</h2><h3 id="理论部分">理论部分</h3><p>DDP是当下主流的数据并行方案，也是本文的重点。DDP不同于DP，简单来说它会将模型都拷贝到多GPU上，不像DP只会在gpu0上加载模型，因此速度在绝大多数情况下都比DP快，而且加速比例接近于GPU数量</p><p>关键参数如下： - <strong>world_size</strong>：总的进程数量，几乎在所有的DDP情况下都是使用一个GPU对应一个Process; - <strong>local_rank</strong>：当前进程对应的GPU号，它是<code>to_device()</code>方法的一个重要参数（指定加载到哪个GPU）; - <strong>global_rank(rank)</strong>：在单节点的情况下，rank和local_rank是一致的；<br><code>torch.distributed.get_rank() # 获取全局rank,单节点就是local_rank</code> - 特别注意，DDP的Batch_size就是像原本一样设定，因为DP计算实际上是收集多个GPU上的梯度汇总，平均，然而DDP其实在不加入“多GPU累积操作”的情况下，batch_size就是设置的那个，不过是进行有多少个GPU就进行多少次而已。</p><h3 id="实践部分">实践部分</h3><h4 id="单卡代码">单卡代码</h4><p>学习DDP代码最好的方式是把一段现有的单卡深度学习代码改为DDP训练的方式。我们先看一段单卡代码： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torch.utils.data.distributed<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># 数据加载部分，直接利用torchvision中的datasets</span><br>    trans = transforms.Compose([transforms.ToTensor(), transforms.Normalize((<span class="hljs-number">0.5</span>,), (<span class="hljs-number">1.0</span>,))])<br>    data_set = torchvision.datasets.MNIST(<span class="hljs-string">&quot;./&quot;</span>, train=<span class="hljs-literal">True</span>, transform=trans, target_transform=<span class="hljs-literal">None</span>, download=<span class="hljs-literal">True</span>)<br>    data_loader_train = torch.utils.data.DataLoader(dataset=data_set, batch_size=<span class="hljs-number">256</span>)<br>    <br>    <span class="hljs-comment"># 模型搭建部分，调用torchvision中的resnet</span><br>    net = torchvision.models.resnet101(num_classes=<span class="hljs-number">10</span>)<br>    net.conv1 = torch.nn.Conv1d(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>, (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), bias=<span class="hljs-literal">False</span>)<br>    net = net.cuda() <span class="hljs-comment">#把模型放到cuda上</span><br>    <br>    <span class="hljs-comment"># 定义loss与opt</span><br>    criterion = torch.nn.CrossEntropyLoss()<br>    opt = torch.optim.Adam(net.parameters(), lr=<span class="hljs-number">0.001</span>)<br>    <br>    <span class="hljs-comment"># 网络训练  </span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_loader_train):<br>            images, labels = data<br>            images, labels = images.cuda(), labels.cuda() <br>            opt.zero_grad()  <span class="hljs-comment">#清空梯度</span><br>            outputs = net(images)<br>            loss = criterion(outputs, labels)<br>            loss.backward()<br>            opt.step()<br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;loss: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(loss.item()))<br>                <br>    <span class="hljs-comment"># 保存checkpoint</span><br>    torch.save(net, <span class="hljs-string">&quot;my_net.pth&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure></p><h4 id="单机多卡">单机多卡</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torch.distributed <span class="hljs-keyword">as</span> dist<br><span class="hljs-keyword">import</span> torch.utils.data.distributed<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">from</span> torch.multiprocessing <span class="hljs-keyword">import</span> Process<br><br><span class="hljs-comment">#配置文件，指定master的位置和端口</span><br>os.environ[<span class="hljs-string">&#x27;MASTER_ADDR&#x27;</span>] = <span class="hljs-string">&#x27;localhost&#x27;</span><br>os.environ[<span class="hljs-string">&#x27;MASTER_PORT&#x27;</span>] = <span class="hljs-string">&#x27;12355&#x27;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">rank</span>):<br>    <span class="hljs-comment">#多出了ddp初始化部分</span><br>    dist.init_process_group(<span class="hljs-string">&quot;nccl&quot;</span>, rank=rank, world_size=<span class="hljs-number">3</span>)<br>    torch.cuda.set_device(rank)<br>    <br>    trans = transforms.Compose([transforms.ToTensor(), transforms.Normalize((<span class="hljs-number">0.5</span>,), (<span class="hljs-number">1.0</span>,))])<br>    data_set = torchvision.datasets.MNIST(<span class="hljs-string">&quot;./&quot;</span>, train=<span class="hljs-literal">True</span>, transform=trans, target_transform=<span class="hljs-literal">None</span>, download=<span class="hljs-literal">True</span>)<br>    <br>    <span class="hljs-comment">#多了一个sampler参数，对应ddp的sampler过程</span><br>    train_sampler = torch.utils.data.distributed.DistributedSampler(data_set)<br>    data_loader_train = torch.utils.data.DataLoader(dataset=data_set, batch_size=<span class="hljs-number">256</span>, sampler=train_sampler)<br><br>    net = torchvision.models.resnet101(num_classes=<span class="hljs-number">10</span>)<br>    net.conv1 = torch.nn.Conv1d(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>, (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), bias=<span class="hljs-literal">False</span>)<br>    net = net.cuda()<br><br><span class="hljs-comment">#模型被DistributedDataParallel包裹，并且指定使用的GPU（rank可以理解为GPU id）</span><br>    net = torch.nn.parallel.DistributedDataParallel(net, device_ids=[rank])<br>    criterion = torch.nn.CrossEntropyLoss()<br>    opt = torch.optim.Adam(net.parameters(), lr=<span class="hljs-number">0.001</span>)<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_loader_train):<br>            images, labels = data<br>            images, labels = images.cuda(), labels.cuda()<br>            opt.zero_grad()<br>            outputs = net(images)<br>            loss = criterion(outputs, labels)<br>            loss.backward()<br>            opt.step()<br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;loss: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(loss.item()))<br>    <span class="hljs-keyword">if</span> rank == <span class="hljs-number">0</span>: <span class="hljs-comment">#指定GPU保存模型</span><br>        torch.save(net, <span class="hljs-string">&quot;my_net.pth&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    size = <span class="hljs-number">3</span><br><br><span class="hljs-comment">#启动的时候引入多进程机制</span><br>    processes = []<br>    <span class="hljs-keyword">for</span> rank <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>        p = Process(target=main, args=(rank,))<br>        p.start()<br>        processes.append(p)<br><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> processes:<br>        p.join()<br></code></pre></td></tr></table></figure><p>综上，主要的变动如下： 1. 配置文件：多了master的配置文件 2. 启动过程：引入多进程机制 3. DataLoader：多了一个sampler参数 4. 模型：net被DistributedDataParallel包裹 5. 模型保存：原本直接保存，现在改为由0号GPU保存</p><p>单机多卡还有其他写法： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#import torch.multiprocessing as mp</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>world_size= <span class="hljs-number">3</span><br>mp.spawn(main,<br>args=(world_size,),<br>nprocs=world_size,<br>join=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></p><p>spawn相当于简化了process的书写。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">注意：<span class="hljs-built_in">spawn</span>函数要放入 <span class="hljs-keyword">if</span> <span class="hljs-variable">__name__</span>==<span class="hljs-string">&quot;__main__&quot;</span>: 中，不然会引发错误<br></code></pre></td></tr></table></figure><h4 id="多机分布式">多机分布式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.distributed <span class="hljs-keyword">as</span> dist<br><span class="hljs-keyword">import</span> torch.multiprocessing <span class="hljs-keyword">as</span> mp<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">from</span> torch.nn.parallel <span class="hljs-keyword">import</span> DistributedDataParallel <span class="hljs-keyword">as</span> DDP<br><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-comment">#用于获取命令行参数</span><br><span class="hljs-comment">#argparse模块是命令行选项、参数和子命令解析器</span><br><span class="hljs-comment">#argparse可以让人轻松编写用户友好的命令行接口，适用于代码需要频繁地修改参数的情况</span><br>parser = argparse.ArgumentParser()<br>parser.add_argument(<span class="hljs-string">&quot;--world_size&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)<span class="hljs-comment">#  #添加参数</span><br>parser.add_argument(<span class="hljs-string">&quot;--node_rank&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)<br>parser.add_argument(<span class="hljs-string">&quot;--master_addr&quot;</span>, default=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>)<br>parser.add_argument(<span class="hljs-string">&quot;--master_port&quot;</span>, default=<span class="hljs-string">&quot;12355&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>)<br>args = parser.parse_args()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">example</span>(<span class="hljs-params">local_rank, node_rank, local_size, world_size</span>):<br>    <span class="hljs-comment"># 初始化</span><br>    rank = local_rank + node_rank * local_size<br>    torch.cuda.set_device(local_rank)<br>    dist.init_process_group(<span class="hljs-string">&quot;nccl&quot;</span>,<br>                            init_method=<span class="hljs-string">&quot;tcp://&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(args.master_addr, args.master_port),<br>                            rank=rank,<br>                            world_size=world_size)<br>    <span class="hljs-comment"># 创建模型</span><br>    model = nn.Linear(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>).to(local_rank)<br>    <span class="hljs-comment"># 放入DDP</span><br>    ddp_model = DDP(model, device_ids=[local_rank], output_device=local_rank) <br>    loss_fn = nn.MSELoss()<br>    optimizer = optim.SGD(ddp_model.parameters(), lr=<span class="hljs-number">0.001</span>)<br>    <span class="hljs-comment"># 进行前向后向计算</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>        outputs = ddp_model(torch.randn(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>).to(local_rank))<br>        labels = torch.randn(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>).to(local_rank)<br>        loss_fn(outputs, labels).backward()<br>        optimizer.step()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    local_size = torch.cuda.device_count()  <span class="hljs-comment">#获取当前所有的GPU</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;local_size: %s&quot;</span> % local_size)<br>    mp.spawn(example,<br>        args=(args.node_rank, local_size, args.world_size,),<br>        nprocs=local_size,<br>        join=<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>假设一共有两台机器（节点1和节点2），每个节点上有8张卡，节点1的IP地址为192.168.0.1 占用的端口22335（端口可以更换），启动的方式如下： <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#节点1</span><br>python python demo.py <span class="hljs-attribute">--world_size</span>=16 <span class="hljs-attribute">--node_rank</span>=0 <span class="hljs-attribute">--master_addr</span>=<span class="hljs-string">&quot;192.168.0.1&quot;</span> <span class="hljs-attribute">--master_port</span>=22335<br><span class="hljs-comment">#节点2</span><br>python python demo.py <span class="hljs-attribute">--world_size</span>=16 <span class="hljs-attribute">--node_rank</span>=1 <span class="hljs-attribute">--master_addr</span>=<span class="hljs-string">&quot;192.168.0.1&quot;</span> <span class="hljs-attribute">--master_port</span>=22335<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式训练</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AdimateDiff</title>
    <link href="/2023/11/20/AdimateDiff/"/>
    <url>/2023/11/20/AdimateDiff/</url>
    
    <content type="html"><![CDATA[<p><a href="%5Bguoyww/AnimateDiff:%20Official%20implementation%20of%20AnimateDiff.%20(github.com)%5D(https://github.com/guoyww/animatediff/)">AnimateDiff: Animate Your Personalized Text-to-Image Diffusion Models without Specific Tuning</a></p><p>阅读时间：2023-11-20 阅读目的：在做视频大模型相关的项目，涉及到解决<strong>视频一致性</strong>问题，SD+AnimateDiff是一个比较成熟的方式，通过阅读论文看看他是怎么做的</p><h2 id="abstract">Abstract</h2><p>SD + lora和dreambooth等下游配套已经使得用户可以画出好看的图片，现在如今让图片动起来的需求越来越大。</p><p>文章提出了一个框架，让图片在现有模型下运动起来。</p><p>该框架的核心是在T2I模型中插入一个初始化的运动建模模块，并利用视频数据进行训练</p><h2 id="introduction">Introduction</h2><p>现在有文本生成视频的需求，但是现有的T2V太复杂了（引用了Gen1、VDM、magicVideo三篇论文），个性化程度不高，用户不好使用，因此论文提出了一个运动建模模块，给定个性化T2I模式，例如用户训练或从Huggingface下载的DreamBooth或LoRA，目标是在保留其原始领域知识和质量的同时，将其转换为几乎没有训练成本的动画生成器</p><p>例如：如果T2I模型是经过个性化操作的（引入了lora），在这种情况下，模型应该能够生成个性化的动画片段。能做到前景/背景分割、角色身体运动等</p><h2 id="preliminaries">Preliminaries</h2><p>让图片动起来的核心是学习到时序特征，这点T2V模型可以做到。但是个性化的图片常有，个性化的视频却不常有，使用大量个性化的视频训练一个模型并不合理。因此作者选择训练一个可推广的运动建模模块，并在推理时将其插入个性化的T2I模型。</p><figure><img src="20231120183911.png" alt="框架图"><figcaption>框架图</figcaption></figure><p>运动建模模块的细节 <img src="20231120183927.png" alt="模块细节"></p><p>大体和VDM等没区别，主要在于AnimateDiff冻结SD，只训练自己的模块</p><h2 id="我的看法">我的看法</h2><p>作者通过插入额外的初始化运动建模模块，并在视频数据上进行训练。这种方法其实和magicEdit类似：SD就负责生成图片、额外再训练一个用来保证结构完整的模块和用来时序建模的模块。将视频生成的三个核心（图像语义、运动一致性、结构控制）解耦。</p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MasaCtrl</title>
    <link href="/2023/11/18/MasaCtrl/"/>
    <url>/2023/11/18/MasaCtrl/</url>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2304.08465">[2304.08465] MasaCtrl: Tuning-Free Mutual Self-Attention Control for Consistent Image Synthesis and Editing (arxiv.org)</a></p><p>阅读时间：2023-11-17 阅读目的：知名的图像编辑算法，提出了一个新颖的观点</p><h2 id="abstract">Abstract</h2><p>现有的编辑方法要么无法在保持整体纹理和身份的同时实现有效的复杂编辑，要么需要耗时的微调来捕捉图像特定的外观。</p><p>论文提出了一种无需微调的方法，可以完成复杂的图像编辑任务，具体来说， 1. MasaCtrl将扩散模型中现有的Self-attention转换为mutual self-attention（相互自注意），这样它就可以从源图像中查询相关的局部内容和纹理以获得一致性。 2. 当前景和背景相似时，图像编辑过程容易发生混淆，因此论文进一步提出了一种mask引导的mutual self-attention。（mask可以从cross-attention中提取）（cross-attention 只有64 * 64怎么提取？）</p><h2 id="introduction">Introduction</h2><p>现有的编辑方法无法在<strong>保持整体纹理和身份的同时更改姿势和视图</strong>（例如让狗坐下，让鸟张开翅膀），从而导致编辑结果不一致。</p><p>Imagic可以完成这个任务，在进行复杂的编辑时保留原始特性。但是他需要微调整个T2I模型，然后优化文本embedding，以捕捉每次编辑的特定外观，这显然对于现实应用来说不切实际。</p><p>对于T2I问题，现实生活中存在大量应用场景，要求模型生成多个具有不同视图，但主体相同的图片，例如漫画生成和短视频生成。</p><p>本文提出了一种新方法，解决的核心问题是：如何在不微调的情况下进行复杂的编辑，同时让编辑前后主体身份保持一致（感觉视频领域也可以用上？）</p><p>具体来说： 1. 将原本T2I的self-attention替换为mutual self-attention，这样就可以通过从源图像的query中查询相关的局部结构和纹理特征以获得一致性（<strong>解决了图像编辑和图像生成一致性的问题</strong>） - 先对real image进行DDIM inversion，得到从源图像到真实图像的扩散过程（DP1） - 再在成新图像（或编辑现有图像）的扩散过程中（DP2），使用DP2中self-attention的Q来查询DP1中self-attention的K和V 2. 但是如果直接应用1.中的方法，会生成几乎与源图像相同的图像，并且不能符合target prompt。因此在应用mutual self-attention时，还需要注意控制去噪步长和选择具体的Unet层。 3. 以上方法可以很好的应用在前景和背景不纠缠的图像上，但在前景背景相似时（例如颜色和图案相似），mutual self-attention会混淆前景背景。因此还需要进一步使用交叉注意力来提取与图像中的主要对象相关联的mask，用mask来分离前景背景，并限制前景特征仅Query源图前景，背景特征仅Query背景。</p><h2 id="preliminaries">Preliminaries</h2><figure><img src="20231117214339.png" alt="整体框架图"><figcaption>整体框架图</figcaption></figure><h4 id="mutual-self-attention">mutual self-attention</h4><p>方法其实非常简单： <img src="20231118183614.png" alt="细节图"> 既然图像编辑的任务，是在保留原图身份的基础上进行运动。那么在生成图片时，可以直接去原图查询（query）相关特征，<strong>即：在特定的layer和特定的T下，使用原图的K和V</strong>。</p><p>具体使用的层数如下，按照S=4，L=10的设置。 <img src="20231118183956.png"> #### Mask-Guided Mutual Self-Attention</p><p>但是上述的方法无法分辨前景和背景，P2P告诉我们，可以利用语义cross-attention来创建mask区分源图像和目标图像中的前景背景</p><p>先以16×16的空间分辨率对所有head和layer的cross-attention map进行平均，得到N个cross-attention map。N表示文本token的数量。</p><p>这个过程可以获得前景对象相关token的平均cross-attention map，进而获得了前景mask。有了mask就可以限制生成图像仅从原图像的主体区域query相关信息</p><p><img src="20231118185145.png"></p><h2 id="我的理解">我的理解</h2><p>文章开头提出问题：无法在保持整体纹理和身份的同时更改姿势和视图</p><p>随后抛出应用场景，证明用途：漫画、生成短视频等</p><p>再提出解决方案：用mutual self-attention来保证图像主体身份的同时，改变动作。</p><p>可以扩展思考的内容主要有两条： 1. mutual self-attention可在<strong>保持特色、纹理和身份的同时改变姿态、视图、结构</strong>。似乎也可以用在短视频领域，因为短视频正面临编辑对象闪烁的问题。它（imagic + mutual self-attention 可能可以完成一个简单的动作生成） 2. 使用cross-attention map来提取前景背景的掩模，完成前景背景分离（可以用于解耦，联想到ACR中的背景前景选取内容）</p>]]></content>
    
    
    <categories>
      
      <category>图像生成</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>I2VGen-XL</title>
    <link href="/2023/11/14/I2VGen-XL/"/>
    <url>/2023/11/14/I2VGen-XL/</url>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2311.04145">I2VGen-XL: High-Quality Image-to-Video Synthesis via Cascaded Diffusion Models</a></p><p>阅读时间：2023-11-10 阅读目的：阿里出的开源视频生成模型，看看和腾讯的有什么不同</p><h2 id="我的看法">我的看法</h2><p>如何建立高质量的T2V模型？ 作者其实给出了一种解法，由于缺乏高质量的文本-视频对，因此实现视频文本对齐比图像文本对齐要难很多。因此专注建立I2V模型，以T2I + I2V 的形式实现T2V是一个很好的解法。因为现有的图像生成技术（SD）比较成熟，可以生成高质量的图像，且可控性更好。</p><p>顺着这种思路，显而易见的，I2V模型的核心就是让&quot;图像动起来&quot;。</p><p>为了让图像动起来的视频更真实，论文设计了一个二阶段级联模型，从两个角度分别解决语义一致性和时空连续性。</p><p>除了这些观点，论文其实还揭示了一些现象，而这些现象可能就是值得解决的问题： 1. 图像语义的保持程度和运动强度之间呈现出一定的权衡关系 Gen2的动作幅度很小，所以想要生成真实的长视频，运动幅度其实是一个痛点。可能需要引入一些其他技术，比如光流？ 2. 使用VQGAN做图像结构和细节提取，CLIP做语义提取，然后融合。这种技术还可以用在图像生成领域的Inversion问题上（P+） 3. 基础阶段其实就可以生成大体看起来像那么回事的模型，但是细致看就不行了。或许SDEdit相关的，基础 + 优化的结构才是解决细致问题更有效的方法（相较于直接在一个模型上拔高参数量） 4. 细化模型的作用是保留低频分量，增强高频分量，减少中频分量，低频主要是图像细节，高频是边缘和噪声。而伪影主要存在于中频</p><h2 id="abstract">Abstract</h2><p>扩散模型在视频生成领域的应用发展很快，但是语义准确性、视频清晰度和时空连续性一直面临一些问题。视频数据结构复杂、缺少对齐良好的文本视频对，使得模型难以产出高质量且符合语义视频</p><p>这篇文章提出了一种叫I2VGen-XL的方法，通过解耦这两个因素增强模型性能，并且通过静态图像作为重要指导，确保输入图像数据对齐。算法包括两个阶段： 1. 基础阶段有两个encoder，一个用来保证生成对象的语义连贯性，另一个用来保留输入图像内容 2. 精炼阶段通过加入额外的简短文本来增强视频的细节，并将分辨率提高到1280 * 720</p><p>文章总共使用了3500w个文本视频对和60亿个文本图像对来优化模型</p><h2 id="introduction">Introduction</h2><p>扩散模型在图像生成领域效果显著，使得视频生成技术也取得重大进步，但在空间一致、语义一致、视频的细节连续性上仍然存在很大不足</p><p>目前有两种解决方法： 1. 多个模型级联来逐步提高视频质量，例如<a href>Imagen video</a>。这种方法主要在每个阶段使用相同的输入来优化目标，没有明确的解耦，因此导致在每个阶段学习相似的分布，生成的视频中会产生不可忽视的噪声 2. 引入额外的指导和训练过程，例如Codef和Videocomposer。目前取得了不错的成果，但是因为缺乏充分对齐的文本-视频对，所以发展较慢</p><p>I2VGen XL首先通过利用单个静态图像作为主要条件来减少对对齐良好的文本-视频对的依赖，具体分为两个阶段： 1. 基础阶段旨在确保低分辨率生成视频的语义一致性，同时保留输入图像的内容和身份信息 通过一个CLIP编码器（语义） + 一个可学习的编码器（内容） 实现，分别提取高级语义和低级细节，然后将其合并到视频扩散模型中 2. 精炼阶段是将视频分辨率提高到1280×720，并精炼生成视频中存在的细节和伪影 用一个简单的文本作为输入来训练一个独特的视频扩散模型，优化最初的600个去噪步骤。通过去噪，从低分辨率视频中生成具有时间和空间相关性性的高清晰度视频</p><p>文章总共使用了3500w个文本视频对和60亿个文本图像对来优化模型</p><h2 id="related-works">Related Works</h2><p>原文是从扩散模型，图像生成，视频生成三个子标题展开的，我归纳如下：</p><p>上游任务：DDPM，DDIM等采样器，解决扩散模型耗时等基础问题 中游任务：各种视频生成模型（大模型） 下游任务：研究可控性（<a href>composer</a> 和 controlnet）</p><h2 id="i2vgen-xl">I2VGen-XL</h2><p>I2VGen XL的目的是从静态图像生成高质量的视频。因此，它需要实现两个关键目标 <strong>1. 语义一致性，即准确预测图像中的意图，然后生成精确的运动，同时保持输入图像的内容和结构</strong> <strong>2. 高时空连贯性和清晰度，这是视频的基本属性</strong></p><p>这两个问题分别通过基础阶段和细化阶段解决，框架图如下： <img src="image%2020231114211959.png" alt="I2VGen-XL 框架图"></p><h4 id="base-stage基础阶段">Base stage（基础阶段）</h4><p>基于VLDM训练了一个低分辨率模型，聚焦语义和细节学习 1. High-level semantics learning CLIP可以提取语义信息，但是它只能学习高级语义，会忽视参考图像中提供的细节信息，因此还需要引入一个保留图像结构和细节的encoder 2. Low-level details 为了减轻细节损失，可以<strong>从VQGAN的encoder（D.Enc）提取特征并添加到第一帧的输入噪声</strong>中。做出这样的选择是基于encoder完全重建原始图像的能力，实验证明使用local encoder可以比其他复杂的语义编辑器更好的保存图像内容，但是随着video的播放，图像畸变会更显著。即语义信息变弱，这与CLIP形成互补</p><h4 id="refinement-stage提纯阶段">Refinement stage（提纯阶段）</h4><p>在基础模型可以得到语义准确的低分辨率视频。但是面临噪声、时间和空间抖动变形的问题。因此精炼阶段的任务目标是： 1. 提高视频分辨率，从448 * 256到1280 * 720 2. 提高时空连续性，解决伪影问题</p><p>为了达成目标，训练了一个单独的VLDM，专门处理高质量、高分辨率的数据。在第一阶段生成视频的基础上使用SDEdit方法、</p><p>精炼模型与基本模型不同，使用用户提供的简单文本（比如几个单词）作为条件，而不是使用参考图像，因为当两阶段输入条件相同时，实验发现视频矫正的有效性显著降低，可能是因为引入了类似的映射削弱了模型的恢复能力，</p><p>总的来说，先使用CLIP对文本进行编码，并通过cross-attention注入3D Unet，再基于基础阶段的模型，使用高质量video训练一个high-resolution模型</p><h4 id="train-and-inference">Train and Inference</h4><ol type="1"><li>基础模型：使用<a href="https://arxiv.org/abs/2304.08818">SD2.1</a>的预训练参数初始化3D Unet，使I2VGen-XL具有初始的空间生成能力。然后再进行训练，空间层的参数更新通过一个系数γ = 0.2控制，这个系数按比例缩小</li><li>精炼模型：使用基础模型的参数初始化，然后采用相同的训练方法。为了提高模型的时空建模能力，专门再初始噪声图上采用两阶段进行训练。 （1）再整个high-resolution数据集上训练 （2）对精挑细选的100w个高质量视频子集进行一轮微调</li></ol><p>在图像生成过程中，使用去噪过程连接两个模型（类似SD2.1）。根据生成效率、生成质量以及分辨率的不同，采用DDIM和DPMsolver++</p><p>在基础模型运行结束后，将视频resize到1280 * 720，执行DDIM去噪的反向过程，再使用精炼模型去噪来获得最终的high-resolution视频，公式如下： <img src="20231114210548.png"> $ c_i $ 和 $ c_t $ 分别表示输入的参考图像和文本prompt，$ _{θ,i} $ 和 <span class="math inline">\(\epsilon_{θ,t}\)</span> 分别表示基础模型和精炼模型的去噪过程</p><h2 id="experiments">Experiments</h2><h4 id="数据集">数据集</h4><ol type="1"><li>WebVid10M</li><li>LAION-400M</li><li>其他相同类型的视频文本对和图像文本对构成的私有数据集</li></ol><h4 id="参数">参数</h4><p>优化器：AdamW，固定学习率</p><p>使用1:1:1:5的比例提供1、8、16、32帧的视频 使用1:2:4:1的比例提供1、4、8、16FPS的视频 即，当FPS=1时，输入的是静态图像</p><p>对于基础模型：使用中心裁剪得到H=256，W=448的视频 对于精炼模型：使用中心裁剪得到H=720，W=1280的视频</p><h4 id="模型对比情况">模型对比情况</h4><p>I2VGen-XL和现在最强的Gen2和Pika对比，分别生成三种视频（伪现实，现实，抽象）。优点运动性更好（Gen2和Pika用过的都知道，生成的虽然说是视频，但其实更接近静态图像），输入图像仍然会丢失一些细节。另外实验中还发现，<strong>图像语义的保持程度和运动强度之间呈现出一定的权衡关系</strong>（运动幅度大了，自然结构就不容易保持） <img src="20231114221142.png" alt="大模型对比"></p><h4 id="消融实验">消融实验</h4><p>精炼前后生成的视频差别：一眼看过去好像差别不大，但细节差距很大，比如更精致的面部和身体特征 <strong>（商用的要求）</strong>。这说明精炼后的模型空间特征的提取和表达显著增强 <img src="20231114221820.png"></p><h4 id="定性分析">定性分析</h4><figure><img src="20231114222453.png" alt="实验结果"><figcaption>实验结果</figcaption></figure><p>生成稳定的人体运动仍然是视频合成中的一个主要挑战。论文还专门验证了I2VGen XL在<strong>人体图像</strong>上的稳健性 <img src="20231114222524.png"></p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Video Diffusion Models</title>
    <link href="/2023/11/10/Video-Diffusion-Models/"/>
    <url>/2023/11/10/Video-Diffusion-Models/</url>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2204.03458">Video Diffusion Models</a></p><p>阅读时间：2023-11-10 阅读目的：在图像生成领域，学者在SD架构的基础上，通过研究Cross-attention，Self-attention等模块，诞生了很多图像编辑算法。VDM在2022-04提出，现在是各种大规模视频生成模型的主流架构。因此，想要在现在的开源大模型基础上做些什么，必须要对最基础的架构有了解</p><h2 id="introduction">Introduction</h2><p>扩散模型很有用，但是没办法用在视频生成领域，因此论文提出一种扩展Unet模型的方法，让Unet可以时序建模，应用在视频生成领域</p><h2 id="background">Background</h2><p>写了扩散模型的推导过程</p><h2 id="method">Method</h2><p><img src="20231110155354.png"></p><p>结构很简单，就是w 一个Unet结构</p><p>常规部分： 1. 先进行空间下采样（spatial downsampling），再进行空间上采样（spatial upsampling） 2. 在每一层空间上通过跳跃连接（skip connections）在上采样时同步下采样过程的特征图 3. 为了引入文本这类的条件信息，每个2D卷积残差块后面还跟着一个注意块或者说空间注意块（spatial attention block）和交叉注意力块（cross-attention block）</p><p>总结Unet的零件结构如下图：<img src="unet.jpg"></p><p>如果要细致解析Unet或学习它在AIGC领域的作用，可以看以下两篇博客： <a href="https://zhuanlan.zhihu.com/p/642354007">深入浅出完整解析Stable Diffusion中U-Net的前世今生与核心知识 - 知乎 (zhihu.com)</a> <a href="https://zhuanlan.zhihu.com/p/632809634">深入浅出完整解析Stable Diffusion（SD）核心基础知识 - 知乎 (zhihu.com)</a></p><p>改变的部分： 1. 将原UNet中的2D卷积替换成了space-only 3D卷积（space-only 3D convolution），举例来说，如果原来用的是3x3卷积，那么现在就要把它替换为1x3x3卷积（其中第一个维度对应视频帧，即时间维度，第二个和第三个维度对应帧高和帧宽，即空间维度 2. 空间注意块仍然保留，但只针对空间维度进行注意力操作，也就是把时间维度flatten为batch维度。即[B, T, C, H, W] -&gt; [B * T, C, H, W] 3. 在每个空间注意块后面，新插入一个时间注意块（temporal attention block），在第一个维度即时间维度上执行注意力，并将空间维度flatten为batch维度。 5. 在每个时间注意力块中使用相对位置嵌入（relative position embeddings），以便让网络能够不依赖具体的视频帧时间也能够区分视频帧的顺序（<a href="https://www.zhihu.com/tardis/bd/art/577855860?source_id=1001">Swin Transformer之相对位置编码详解 (zhihu.com)</a>）</p><p>这种时空分离注意力有一个好处是可以<strong>对视频和图片生成进行联合建模训练</strong>。就是说可以在每个视频的最后一帧后面添加随机的多张图片，然后通过掩码的方式来将视频以及各图片进行隔离（比如填充0），从而让视频和图片生成能够联合训练起来</p><h2 id="我的看法">我的看法</h2><p>VDM带来的贡献： 1. 时空分离注意力可以对视频和图片生成进行联合建模训练 截止2023-11-10，数据集一直是文本视频模型研究钟面临的一个重大问题。因此在大模型训练时需要辅以大量的文本图片对来学习语义信息。 2. 原本SD对应的Unet架构很有潜力，在此基础上进行微调，就可以得到一个视频生成模型</p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VideoCrafter1</title>
    <link href="/2023/11/09/VideoCrafter1/"/>
    <url>/2023/11/09/VideoCrafter1/</url>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2310.19512">VideoCrafter1: Open Diffusion Models for High-Quality Video Generation</a></p><p>阅读时间：2023-11-09 阅读目的：这是2023年10月腾讯才出的开源视频生成大模型，具有研究价值</p><h2 id="我的看法">我的看法</h2><p>作为可以上榜单的开源大模型，后续有很多可以围绕着展开的工作，相比于在SD上微调，显然在VideoCrafter1上微调会有更好的效果</p><h2 id="abstract">Abstract</h2><p>提出了第一个开源的I2V基础模型，能够将给定的图像转换为视频剪辑，同时保持内容保存约束，希望可以给社区的技术进步做出贡献</p><h2 id="introduction">Introduction</h2><p>T2I模型有：SD T2V模型有：Make-A-video、Imagen video 基于级联模型 LVDM、Magic video、ModelScope、Align your Latents 基于SD，扩展时间层 Make-A-video、Imagen video、效果还不错，但是都是闭源的，Gen-2（Gen-1的论文阅读记录<a href="https://zhuanlan.zhihu.com/p/573407864">点这里</a>）、Pika Labs、Moonvalley只能使用，没有开源模型和论文</p><p>ModelScope只能生成256 * 256的视频 Hotshot XL旨在将SDXL扩展到视频模型中，并生成8帧分辨率为512×512的gif AnimateDiff提出将LORA SD模型的时间模块与空间模块相结合，但LORA模型在风格和概念构成能力方面限制了范围。</p><p><strong>现在仍然缺乏能够生成高分辨率和高质量视频的开源通用T2V基础模型</strong></p><p>I2V模型有：Gen-2和I2VGen XL</p><p>Gen2支持I2V，但是生成的运动方式很少，并且不开源。唯一的开源通用I2V模型是I2VGen XL，模型使用图像embedding来代替文本embedding来调整预训练的T2V模型。但是，它不能很好的遵循参考内容和结构。因此，<strong>开源社区迫切需要一个良好的I2V模型</strong></p><p>所以文章分别提出了两个高质量视频生成的扩散模型：一个T2V模型，一个I2V模型</p><p>T2V模型建立在SD 2.1的基础上，通过将时间注意力层纳入SD UNet来捕捉时间一致性，采用图像和视频联合训练的策略来防止概念遗忘，可以生成1024 * 576、持续两秒的视频。</p><p>I2V模型基于T2V模型，接受文本和图像输入，使用Clip提取图像embedding并通过cross-attention注入SD的Unet结构（和SD的文本embedding注入一样）</p><h2 id="related-works">Related Works</h2><p>Imagen video和VDM提供了不错的级联方法</p><h2 id="methodology">Methodology</h2><figure><img src="20231109185415.png" alt="模型结构"><figcaption>模型结构</figcaption></figure><p>整体是在SD的Unet结构基础上做更改： 1. VAE（来自SD）负责将视频逐帧编码到隐空间 2. 讲2D卷积扩展为3D卷积，每一层还包括spatial transformers 和 temporal transformers 3. 语义注入调整为文本embedding和图像embedding的混合注入（也可以只有图像或者文本） 4. 去噪过程T和视频fps均正弦编码后通过MLP映射再相加融合</p><p>对于T2V扩散模型，条件文本embedding对最终输出视频的视觉内容起着至关重要的作用。为了以兼容的方式向视频模型提供图像信息，必须将图像投影到文本对齐的embedding空间中。我们建议学习这种具有丰富细节的嵌入，以增强视觉逼真度。</p><p>文本embedding和图像embdding的混合注入过程： <img src="20231109191442.png"> 对文本而言：通过Clip就可以得到文本embedding 对图像而言：虽然clip对齐了文本和图像，但主要是在语义级别上对齐，捕获细节的能力较弱。因此可以使用Clip VIT结构中最后一层的patch表示图像信息。然后再训练一个投影网络，将patch转化为图像embedding</p><p>最后结合文本embedding和图像embedding，注入cross-attention： <img src="Pasted%20image%2020231109195107.png"></p><h2 id="experiments">Experiments</h2><p>这种大规模通用模型，从训练细节中我们也可以学到很多东西 #### 数据集 LAION COCO：包含6亿张图像的高质量文本图像数据集 WebVid-10M：由文本描述和来自视频网站的视频所构成的短视频数据集 自己收集的数据集：包含1千万个分辨率大于1280 * 720视频的大规模高质量视频 #### 训练方法 采用SD使用的训练方法，从低分辨率到高分辨率训练 1. 用256 * 256分辨率的图像对从图像模型扩展而来的模型训练80K轮，batch_size=256 2. 用512 * 320分辨率的视频微调模型136k轮，batch_size=128 3. 用1024 * 576分辨率的视频微调模型45k轮，batch_size=64</p><p>对于I2V模型则是训练一个映射，从图像embedding到cross-attention的embedding空间</p><h4 id="评估指标">评估指标</h4><p><a href="https://evalcrafter.github.io/">EvalCrafter</a>于2023-10-17挂在arXiv上，提出了一种大型视频生成模型的测试基准和评估指标</p><p>截止写文时的榜单，Floor33就是本文对应的模型 <img src="20231109172629.png" alt="榜单"></p><h4 id="实验结果">实验结果</h4><figure><img src="20231109195235.png" alt="定量分析"><figcaption>定量分析</figcaption></figure><figure><img src="20231109195321.png" alt="人类偏好实验"><figcaption>人类偏好实验</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>投资框架</title>
    <link href="/2023/11/07/%E6%8A%95%E8%B5%84%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/11/07/%E6%8A%95%E8%B5%84%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>为了避免家庭收入下滑，也为了财务自由的梦想，理财是避不开的一条路。为了系统学习投资理财，陆陆续续看了很多书，踩了很多坑，无论投资基金还是投资股票，如果没有系统化的知识结构，没有自己的交易系统，就难免被各种消息影响，让情绪主导自己的判断。我总结出了自己的交易系统架构</p><h2 id="基本面分析">1、基本面分析</h2><p>基本面分析分为宏观基本面分析和公司基本面分析。</p><h3 id="宏观基本面分析">（1）宏观基本面分析</h3><p>宏观经济分析其实就是抓住经济周期，在经济下行期，股市大盘难以取得合适的收益。通过分析GDP增速，房地产销售面积增速，PMI，CPI，PPI，MLF并结合政策面消息可以大致定位宏观周期情况，并作出合适的资产配置 1. 利率下调（宽货币）+ M2增速下降（紧信用） = 萧条期 2. 利率下调（宽货币）+ M2增速上升（宽信用） = 复苏期 3. 利率上调（紧货币）+ M2增速上升（宽信用） = 过热期 4. 利率上调（紧货币）+ M2增速下降（紧货币） = 衰退期</p><p>单论大盘而言，有很多指标可以判断现在股市的位置： 1. 股债性价比 - 股债性价比= （1/PE）/ 十年国债收益率， 常年在1.5-3.0之间波动。利率太低时不适用 - 股债利差 = （1/PE）-  十年国债收益率，05年以来，最大值7.1%，最小值-2.6% - 大盘成长、大盘价值、小盘成长、小盘价值可能产生不一致的结构行情。前面两者加起来是沪深300，后面两者加起来是中证1000 2. 看头部公司（茅台）有没用跌到位，如果茅台一直在震荡，没有怎么下杀，下跌可能还没结束 3. 分析市场情绪（上证50ETF看跌期权隐含波动率），这个我没怎么研究过</p><h3 id="公司基本面分析">（2）公司基本面分析</h3><p>判断了整个行业周期，如果想要买股票，还要选出合适的公司，A股大量的公司中可能只有少数是值得我们长期投资的，我们需要筛选出这些公司，并且长期跟踪它们的业绩和股价情况</p><p>公司基本面的分析实际上是财务分析，因为做分析的目的说到底还是挑选出赚钱的公司。</p><p><strong>好公司 = 好数据 + 好行业 + 好生意</strong></p><h4 id="好数据">好数据</h4><p>好数据是指有好的财务报表，其中ROE是一个关键指标。</p><p>ROE的分母是净资产，也就是股东自己投入的钱，分子则代表净利润，因此，净资产收益率在数学上表示的就是“股东每投入一元钱，能产生多少净利润”，这就衡量了一家公司“用投入的钱赢得利润”的能力</p><p>ROE=净利润/平均净资产=销售净利率×总资产周转率×权益乘数 - 销售净利率 = 净利润 / 营业总收入 - 总资产周转率 = 营业总收入 / 平均总资产 - 权益乘数 = 平均总资产 / 平均净资产 从公式看，根据ROE的三个乘子，可以将赚钱的公司分为三种不同类型： （1）销售净利率高代表盈利能力很强的“茅台型”公司。消费、医疗、科技是其中的代表。护城河一般是品牌、准入门槛等 （2）周转能力很强的“沃尔玛型”公司，常出现在工业贸易和零售业。护城河一般是规模效应</p><p>具体的方法是基于3-5原则使用七步分析法： <strong>3-5原则</strong>：至少对比3-5家状况最接近的同行，看看它3~5年的历史数据（一个短周期基本就是3-5年）。如果一家公司的上市时间很短，公开披露的数据不足5年甚至不足3年，则可以放一放，。该原则贯彻在七步分析法中 <strong>七步分析法：</strong> 1. 将连续5年ROE&gt;15%的公司加入股票池 - 根据具体情况根据周期的位置可以调整，看三年还是五年，ROE是15%还是10%都没有固定的标准，选择15%是因为大盘常年的ROE在10%左右。 - 连续5年ROE都达标说明公司的盈利比较稳定 1. 现金收入比率 = 销售商品、提供劳务收到的现金/营业收入 这个指标说明了 1 元营业收入里有多少是现金。该指标值最好维持在 1 左右，即营业收入与收到的现金相近，如果达不到 0.8，说明这家公司有部分收入没有收现，盈利质量不容乐观 3. 毛利率 毛利率可以反应产品的竞争率（茅台高达90%），它不一定要比同行高，但一定不能低太多，但是当某种产品的毛利率明显高于同行时，我们要找到其中的逻辑，否则公司很有可能存在造假行为 4. 净利率 净利率和毛利率之间的差距在于期间费用，是造假重灾区，我们需要判断净利率的含金量 - 净利润的水平如何？ 和同行相比，净利润情况如何 - <strong>净利润的现金含量有多少？</strong>(造假照妖镜) 净利润现金含量 = 经营活动产生的现金流量净额 / 净利润。净利润现金含量衡量的是：一家公司的净利润里有多少为现金。该数字最好常年维持在 1 左右，笔者个人的最低限度为 0.8。<strong>现金含量低说明可能有些不好的情况，要小心！</strong> - 净利润水分如何？ <strong>扣非净利润占比 = 扣非净利润 / 净利润</strong>。数值越接近1说明盈利中的水分越少，有的公司可能通过出售一些资产来提高净利润，提高非经常性损益，显得净利率高，财务报表好看，但这其实对经营没有帮助 5. 公司周转能力（同行之间对比） - 应收账款周转率 = 营业总收入 / 平均应收账款余额 晶瑞电材、中环股份、隆基股份都是半导体材料生产商，它们是2B模式，下游都为半导体器件供应商。查询“晶瑞电材、中环股份、隆基股份最近 5 年应收账款周转率”，会发现中环股份在 2016—2018 年有最高的应收账款周转率，1 年周转达 6 次以上，这意味着中环股份只需要 2 个月就能收回客户的尾款 - 存货周转率 = 营业成本 / 平均存货余额 海天味业、恒顺醋业、千禾味业都是 A 股的调味品公司，商业模式都为 2C 模式，我们在问财上查询“海天味业、恒顺醋业、千禾味业最近 5 年存货周转率”可以发现，海天味业的存货周转率明显高于同行 6. 公司杠杆情况 - 衡量每一块钱债务有多少块现金担保 = 现金及其等价物 / 带息债务 只有带息债务是危险的，因此资产负债率仅考虑了公司整体负债水平，并没有将负债区分为有息负债或是无息负债，无法客观地评价一家公司的真实负债情况 7. 财务之外的因素？ 财务分析可以筛选出来一个数据合格的公司，但是投资还需要考虑一些财务报表之外的事情，例如是否存在护城河？<strong>别人没有，也很难拥有的那个优势就是护城河</strong>。例如茅台五粮液的护城河是社会认可度；沃尔玛的护城河是规模效应，可以把商品成本压低；医疗行业的护城河是准入门槛，病人和医生一般倾向于使用更熟悉的器械。</p><p>通过了上述关卡的公司可以认为是有好数据的公司，但只有好数据还不够。如果公司在一个夕阳行业，那么现有的好数据就只是落日余晖罢了</p><h4 id="好行业数据可以从行业研报中获取">好行业（数据可以从<a href="%5B前沿知识库%20(askci.com)%5D(https://wk.askci.com/ListTable)">行业研报</a>中获取）</h4><p>对满足好数据要求的公司，我们要进一步判断它处在什么行业。我们可以从以下三个方面来分析一个行业： 1. 行业规模 行业规模是蛋糕的大小。每个行业都是有生命周期的，有的行业处于成长期，而有的行业处于衰退期。我们要用动态的视角看待行业规模，除了这块蛋糕现在有多大，我们还应判断其未来能做到多大 2. 渗透率 渗透率衡量的就是蛋糕还有多少能吃。即使行业规模很大，但如果已经被吃掉了大部分，留下的份额也就不多了，渗透率被用来衡量一个市场的成熟度如何，例如银行业规模很大，每个人都有存款需求，但是渗透率很高 - 行业的渗透率在 <strong>10%~50%为宜</strong>，渗透率落在这个区间的行业往往会进入高速成长期（2021年10月新能源车16.4%），低渗透率意味着行业不成熟，需要观望，例如VR眼镜 3. 竞争格局 如果蛋糕足够大，而且渗透率远未饱和，那么就会有很多人想来分一杯羹，市场竞争将不可避免，商家充分竞争之后呈现的结果就是竞争格局，我们通常以<strong>市场占有率</strong>作为衡量竞争格局状况的主要指标 - 三四定律：在一个稳定的市场中，有影响力的竞争者数量不会超过三个，且最大竞争者的市场份额不会超过几者中市场份额最小者的四倍。 也就是说，在一个成熟的行业中，真正能获得理想回报率的公司只有行业前三名，剩下的公司都将挣扎在生存边缘。前三家龙头公司亦将呈现出明显的马太效应，即前一名的份额为下一名的 1.5~2 倍，第四名及以后的公司将只能吃到残羹冷炙。三四定律并非绝对，它只是亨德森在观察各个行业的发展历史后总结的经验法则，但是在许多成熟行业中，我们确实可以看到这种“赢家通吃”的现象 - 要避开的行业： （1）要避开竞争格局不明朗的行业，因为你无法确定谁会成为行业龙头 （2）要避开竞争格局永远无法集中的行业，例如餐饮业</p><h4 id="好生意">好生意</h4><p>一个身处好行业，有好数据的公司就已经值得投资了，但是我们还要进一步判断一些主观的东西。即这家公司的生意情况如何，有没有行业护城河？</p><p><strong>好公司 = 好数据 + 好行业 + 好生意</strong> 通过上述检验后脱颖而出的三好公司就是值得投资的好公司，对待这些进入投票池的但是我们仍然需要客观的回答四个问题： 1. 这家公司靠销售什么商品或服务获得利润？ 2. 它的客户为什么从它这里采购而不是其他地方？ 3. 资本逐利，为什么其他资本没有抢占它的市场份额？ 4. 假设其他产业巨头携巨资参与竞争，该公司能否保住份额?</p><h2 id="估值分析">2、估值分析</h2><p>通过了基本面分析，我们知道了现在的经济形式，也筛选出了值得投资的公司，但这并不意味就要立刻买入。价值投资很重要的一点就是给公司做估值建模。</p><h3 id="dcf自由现金流贴现法">DCF（自由现金流贴现法）</h3><p>将未来的现金流都折算到今天，但是DCF计算起来繁琐，而且结果对贴现率和增长率都很敏感，因此可以优化一下（从某博主那里学到），宁愿要模糊的正确不要精准的错误。</p><p>首先，我们需要明确一个原则：有成长性的公司，可以使用成长性对冲安全边际，但收益率（PE的倒数）绝对不能低于无风险收益率。</p><p>这一条的意思也就是说，如果按照格雷厄姆的投资标准，在广泛高估的A股市场可能挑不出来几个合适的公司，优秀的公司（例如茅台）始终等不到合适的安全边际。如果一家公司有明确的成长性，那么可能只需要收益率刚刚好高于无风险收益率就可以买入，成长性就是它的安全边际。至于如何判断有没有成长性......这只能做定性判断。</p><p>优化后的DCF认为一家资本支出低的公司，净利润可以近似为现金流，在这种情况下： 1. 合理估值上限 = 无风险利率的倒数（2.74%的十年期国债收益率 = 36.5PE），通常选25-30 2. 现在的合理估值（买入价格） = 三年后净利润（或EPS） * 合理估值上限 / 2 3. 卖出原则：50、55、60市盈率分三次清仓</p><p>注意事项： 1. 企业利润是真的吗？利润可持续吗？是否需要大量资本支出维系盈利水平？、 2. 估测三年后净利润不要使用30%以上的增速 3. 单只股票持仓不要高于40% 4. 确定性越高的企业，越倾向于在估值上限就买；确定性越低，越倾向于更低的买点。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">格雷厄姆：只要有钱投资股票，就不要推迟购买；除非整体市场估值水平超出合理估值标准<br></code></pre></td></tr></table></figure><h2 id="技术分析">3、技术分析</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">问题：在合适的经济周期选出了符合估值要求的公司，是不是就要买入了呢？<br>答案：<span class="hljs-keyword">No</span>！<br></code></pre></td></tr></table></figure><p>一家公司的股票涨跌和我们当下是否买入没有任何关系，价值投资者很容易陷入的误区就是算出了股票的合适估值，但是买入之后仍然跌跌不休。</p><p>在经济下行期，大多数公司的业绩都比较一般，就算业绩仍然保持的不错，也很难在整体下挫的大盘中独善其身，哪怕是茅台也一样。这时候市场上的投资者被情绪裹挟，基本面属于某种程度上的失效状态。</p><p>这个时候有两种解决方案： 1. 定投：由于确定了进入低估范围，用定投分散投资化解风险 2. 引入技术分析</p><p>炒股有句话不接下跌的飞刀。技术分析的核心是心理学，在平时意义不大，但是在连续下跌或者上涨过程中，大众的情绪失控时，可以作为参考指标。</p><p>提供两种指标： 1. BBI在漫长的下跌过程中，突然上穿 2. 60日均线 3. <a href="https://zhuanlan.zhihu.com/p/641622153">放量行情中展现的信息</a> 行情反转需要供需双方出现本质上的力量变化，需求减少不代表反转，顶多涨得慢，但<strong>供给增加才是，表现为放量</strong> - <strong>牛市结束的大背景下，长K+放量，考虑止盈</strong></p><h2 id="总结">总结</h2><p>投资是一门必修课，也是一门要钻研一辈子，一直关注的事业。市场先生是不会错的，会错的只有自己。本文系统总结了投资时的筛选、估值、确认买点这三个流程，心中有锚点，投资自然不慌。</p><p>最后放一些分析时可能会用到的网页</p><p>工具类： - <a href="%5B前沿知识库%20(askci.com)%5D(https://wk.askci.com/ListTable)">研报</a> - <a href="%5B财经数据%20_%20居民消费价格指数(CPI)%20_%20数据中心%20_%20东方财富网%20(eastmoney.com)%5D(https://data.eastmoney.com/cjsj/cpi.html)">PPI CPI PMI M2 新房价指数</a>和 <a href="https://tradingeconomics.com/china/indicators">China Indicators</a> - <a href="https://cn.investing.com/rates-bonds/china-10-year-bond-yield">十年期国债收益率</a> - <a href="https://www.dashiyetouzi.com/tools/stock.php?stock_id=601318">股债性价比</a> - <a href="https://eniu.com/">亿牛网----PE PB 股息率</a></p><p>知识类： - <a href="%5B自由现金流折现法（DCF）详尽讲解（附公式）%20前文：估值的方法——自由现金流贴现法（DCF）常用的估值方法有自由现金流折现法、股利贴现法、市盈率估值法、市净率估值、市...%20-%20雪球%20(xueqiu.com)%5D(https://xueqiu.com/2524803655/244192476)">DCF详解</a> - <a href="https://xueqiu.com/2598256636/236422531">如何基于投资理念和投资框架，细分基金经理的投资风格？——基金风格专题报告</a></p>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book Chapter3</title>
    <link href="/2023/09/20/xv6-book-Chapter3/"/>
    <url>/2023/09/20/xv6-book-Chapter3/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter3-页表">Chapter3 页表</h1><p>之前的内容围绕进程展开，大概了解了操作系统是什么，第一个进程如何运行，操作系统提供的系统如何工作，学习了进程隔离的概念。但是既然每个进程都有自己单独的内存空间，那么这些空间到底是怎么被分配使用的？本章的所有内容都围绕物理内存和虚拟内存展开。</p><h2 id="内存">内存</h2><p>内存是计算机的核心组件，由RAM组成，断电后数据会丢失。我们可以将内存看作是一个<code>[0,max]</code> 的<strong>字节</strong>数组（RISC-V加载与储存数据都是以字节为单位，取单字或双字），那么内存地址，也就是这个大数组的索引，知道内存地址就可以快速的访问某个具体的字节。</p><p>我们知道通过ld sd等汇编指令，程序可以很轻松的访问内存空间，那么一个进程是否可以读取或写入另一个进程对应内存空间的内容？答案当然是否定，为了避免这种危险的行为，操作系统提供了虚拟内存的概念：每个进程都拥有自己独立的虚拟内存空间，虚拟内存地址从0开始，给了一种进程在使用整个内存的错觉。</p><p>由于使用的地址空间是虚拟的，自然也就不存在危险行为，不同的进程被天然隔离开。</p><p>但是如果需要CPU完成指令，终究是需要依托内存硬件的。这就涉及到虚拟地址到物理地址的映射。这个映射过程可以将虚拟地址（VA）映射到实际的物理地址（PA）上，程序运行时不需要关心物理内存到底是多少，只需要专注自己的内容即可，CPU会更根据映射关系表，从虚拟地址找到对应的物理地址，实现前后解耦。</p><p>这个映射的过程是通过CPU提供的<strong>分页硬件</strong>MMU实现的。 <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">MMU:是集成到CPU内的一个组件，主要是负责读取虚拟内存的映射表<span class="hljs-comment">(查看页表)</span>，并通过映射表将虚拟地址转换为物理地址。  <br>RISC-V指令可以操作虚拟地址<span class="hljs-comment">(VA,virtual address)</span>。<br></code></pre></td></tr></table></figure></p><p>注意：从CPU的角度来说，一旦MMU打开了，它执行的每条指令中的地址都是虚拟内存地址。 <img src="20230920190826.png"></p><p>a0寄存器中的0x1000是一个虚拟地址（VA），通过MMU映射为物理地址（PA）0xFFF0，然后再利用这个物理地址再内存中找到对应的位置。</p><p>satp(Supervisor Address Translation and Protection Registers)是存放映射表物理地址的寄存器。由于映射表保存在内存中，satp记录了这张表的开始位置，所以MMU可以通过satp迅速找到内存中保存的映射表。例如在上图中VA = 0x1000，其中satp = 0x10的物理地址中保存的是这个VA的映射表。</p><p>每个程序都会有自己独立的映射表，并且这个映射表定义了应用的地址空间。当进程上下文切换时，同时也需要切换satp寄存器的内容，从而获得新的表单。这样的话就可以将相同的虚拟地址翻译为不同的物理地址了（读写satp寄存器在CPU管理者模式，也就是操作系统内核态才可以使用）。</p><p>这个映射表被称为页表（page table），页表带来了以下好处： 1. 增强了进程间的隔离性 2. 实现了物理内存的复用</p><h4 id="内存管理">内存管理</h4><p>建立了将虚拟地址和物理地址解耦的方案，那么如何分配与管理内存空间就成为了一件需要考虑的事情，一般来说有两种方法： 1. 分段；将空间分割成<strong>不同长度</strong>的分片，这样使用灵活但是<strong>空间碎片化</strong>的问题会变得更加严重 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">外部碎片：物理内存中的空闲空间被分割成不同大小的小块，后续分配请求可能失败，因为没有一块足够大的连续空闲空间，尽管总的空闲空间超出了请求的大小。  <br>内部碎片：分配程序给出的内存块超出请求的大小，在块中超出请求的空间可能因此而未被使用，造成了发生在已分配单元内部的浪费。<br></code></pre></td></tr></table></figure> 2. 分页；将空间切成<strong>固定长度</strong>的分片，彻底解决了外部碎片的问题。每个固定长度的单元我们称之为<strong>页Page</strong>，然后我们将物理内存看成是定长槽块的阵列，这些槽块大小与页相同，每个槽块叫做<strong>页帧Page Frame</strong>，每个页帧都可以装载一个<strong>虚拟内存页</strong>。同时，分页很灵活，能很好地支持稀疏虚拟地址空间。分页的逻辑如下图所示：</p><p><img src="20230920202213.png" alt="分页"> CPU接受到一个地址（一般是uint64类型变量），由索引p + 偏移量d组成，根据p在页表中找到对应的物理页地址f。物理页地址 + 页内偏移量就可以索引到一个具体字节的物理地址。</p><p>总结：RISC-V指令（用户指令或内核指令）对<strong>虚拟地址</strong>进行操作，物理地址则是用于寻址实际物理内存RAM的（注意：RISC-V可以处理64位的虚拟地址，但物理地址只被设计成56位（够用了）），两者之间通过页表建立映射关系，页表保存在satp寄存器中，每个进程都有一个变量存储各自satp的值（注意：不是说每个进程都有自己的satp寄存器，而是每个进程有自己的页表，使用时，赋值给satp寄存器，供CPU使用）</p><p>xv6使用分页的方式管理内存，具体如下： <img src="20230920202919.png" alt="VA映射到PA"></p><p>xv6运行在Sv39 RISC-V处理器上，因此64位虚拟地址中，只有低39位在被使用，剩下的25位都暂时保留，供日后的设计者利用。蓝色部分EXT表示不被使用，剩下的39位被划分为27位索引和12位偏移量（2的12次方正好是4K，用来表示一个页内偏移量，所以一个页的大小是4KB）</p><p>前文说到，RISC-V的分页硬件，将每个虚拟地址映射到一个物理地址，页表会以某种形式的表项来保存这种映射关系，这种表项我们称之为<strong>页表条目PTE</strong>（Page Table Entry）。虚拟地址的高27位索引会指向了一个PTE。每个PTE由44位的<strong>物理页帧号PPN</strong>和10位的<strong>标志位Flags</strong>组成。总归54位，因此一个PTE可以用8个字节来存储（uint64）</p><p>PPN + Offset（偏移量） ，构成一个虚拟地址对应的物理地址，共56位。</p><p>总结：在页表转换一个虚拟地址时，首先提取出有效的39位，用高27位来索引对应的PTE，从PTE中我们可以得到44位的PPN，并且根据Flags检查一些权限，最后将44位的PPN和原虚拟地址的低12位Offset加在一起，得到最后56位的有效物理地址，接着就可以访问物理内存。</p><p>上述提到的内容是经过<strong>简化的页表的方案</strong>，实际的RISC-V页表采用的是三级页表。那么一级页表，页就是上面提到的图有什么问题呢？先给出PTE的计算公式：</p><p><strong><em>PTE 地址 = 页目录的地址 + 4 * 虚拟内存地址 / 4KB</em></strong></p><p>一级页表情况下，页目录地址由satp寄存器，虚拟内存地址也就是27位的index，这意味着每个进程需要使用2的27次方个PTE，每个PTE占8字节，总共1GB，这显然太大了，我们最终需要的仅仅是一个4KB的页（xv6进程的内存空间默认分配为4KB）。那<strong>是否可以不把所有 PTE 都放到页表中，当进程需要访问某段虚拟内存时，再把对应的 PTE 加载到内存中？</strong></p><p>答案是不行：因为 MMU 进行过虚拟内存映射时。按照公式，PTE是根据虚拟内存连续放置的，假设我们允许某些 PTE 不在物理内存，其他的PTE位置由于是计算出来的而不是查找出来的，因此这些PTE该放在哪还是放在哪，相当于那些被允许不在物理内存里的PTE，虽然人不在，但是座位却占住了，所以这种做法毫无意义。如果不按照公式，虽然PTE可以随处放了，但是查询PTE时只能顺序查找，时间复杂度从O(1)变成O(n)，性能大幅度降低</p><p>但是在三级页表的情况下，情况不一样了。 <img src="20230920212642.png" alt="三级页表"></p><p>整体的运行逻辑和一级页表没什么不同，把27位的索引平分成了9+9+9的三级索引， - 第一次页目录地址由satp提供，9位刚好可以表示512个PTE，因此L2表示偏移量，两者结合找到L1对应页目录所在位置 - L1页目录结合L1偏移量找到L0页目录的位置 - L0页目录结合L0偏移量，找到物理地址的PPN - 物理地址PPN，结合offset得到最后物理地址</p><p>问题：这个过程实际上涉及到的PTE数量似乎并不比一级页表少，为什么可以节省空间？ 1. 根据局部性原理，进程访问内存时，大部分时候只访问某一段内存，比如（8～16KB）。 2. 对于多级页表来说，因为需要按照公式计算定位，所以第一级页表，需要完整的加载所有 PTE 到内存中。按照上图，也就是 3 个 PTE，这一点也容易理解。 3. 剩下第二级第三级页表的 PTE，可以等到程序真实访问时，再加载到内存中。</p><p><strong>总而言之，多级页表情况下，只有一级页表的 PTE 条目需要完全加载到内存中（用来定位二级页表），而不同的二级页表之间，因为没有按照公式去快速定位的需求，所以二级页表可以选择是否加载到物理内存中。三级页表同理。</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**举个生动的例子**</span><br>学校有一百万个学生，每个学生都有自己的学号和手机号码，每个学生之间的学号都是连续的，也就是 1 ～ 100万。如果只有一级页表，也就是这张表里得有所有学生的信息（学号+家庭地址），校长想查找某个学生的手机号码时，先根据学号，利用公式快速算出它在表中的位置，然后找到这个位置，这个位置就记录了该学生的手机号码。<br><br><span class="hljs-strong">**但是这是一张巨大无比的表，打印出来的话，校长的公文包估计放不下去。**</span><br><br><span class="hljs-strong">**校委会就想出了多级页表的方法，将这一百万学生，按照连续的学号，分成一千个班，每个班一千个学生和一个班主任。比如 1 班学号是 1～1000，2 班是 1001～2000。**</span><br><br>校长的公文包里，每次只需要带上一张表，这张表记录了一千个班，每个班的班主任手机号。<br><br>当校长想找某个学生时，<br><br><span class="hljs-bullet">1.</span> 先根据学号，计算出他在哪个班。<br><br>2.在表中找到这个班，里面有这个班的班主任手机号。<br>（找到第二级页目录）<br><br>3.打电话给班主任，班主任再送来他们班的一张表，表中记录了这个班每个学生的手机号。<br>(等到程序真实访问时，再加载到内存中)<br><br>4.校长再根据学号，再这个班的班级表中找到这个学生和他的手机号。<br><br>上述这个过程是一个二级页表运行的过程<br></code></pre></td></tr></table></figure><h2 id="内存初始化">内存初始化</h2><p>如果没有代码，即使理解了页表运行的原理，也依然不明白如何实现，很容易忘记。在之前的文章中，我讲到了在start.c代码中，CPU特权从机器级变为特权等级，然后跳转到main.c中。<code>userinit()</code>，即运行第一个进程是main.c的最后一件事情（启动进程调度死循环不算），那么第一件事是什么呢？正是内存相关的初始化操作。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// start() jumps here in supervisor mode on all CPUs.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    、、、、、、、、、、、、<span class="hljs-comment">//省略</span><br>    kinit();         <span class="hljs-comment">// 初始化物理页</span><br>    kvminit();       <span class="hljs-comment">// 创建内核页表</span><br>    kvminithart();   <span class="hljs-comment">// 打开分页机制</span><br>    procinit();      <span class="hljs-comment">//为每个进程分配一个内核栈</span><br>    、、、、、、、、、、、、<span class="hljs-comment">//省略</span><br>  scheduler();        <br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="物理页初始化">物理页初始化</h4><p> Qemu 启动的时候会跳转到<code>0x80000000</code>，然后执行相应的指令，xv6 也就运行起来了，此时的第一件事就是初始化物理内存。所有的内容都包含在kalloc.c文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">kinit</span><span class="hljs-params">()</span>  <br>&#123;  <br>  initlock(&amp;kmem.lock, <span class="hljs-string">&quot;kmem&quot;</span>);   <span class="hljs-comment">//初始化锁，也就是给锁赋初值</span><br>  freerange(end, (<span class="hljs-type">void</span>*)PHYSTOP);  <br>&#125;<br><br><span class="hljs-comment">// extract the three 9-bit page table indices from a virtual address.  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXMASK          0x1FF <span class="hljs-comment">// 9 bits  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span><br><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa_start, <span class="hljs-type">void</span> *pa_end)</span>  <br>&#123;  <br>  <span class="hljs-type">char</span> *p;  <br>  p = (<span class="hljs-type">char</span>*)PGROUNDUP((uint64)pa_start);     <span class="hljs-comment">//使内存按照4K对齐，也就是将末尾的12位置为0</span><br>  <span class="hljs-keyword">for</span>(; p + PGSIZE &lt;= (<span class="hljs-type">char</span>*)pa_end; p += PGSIZE)  <span class="hljs-comment">//将内存按照PGSIZE（4KB）分页</span><br>    kfree(p);    <span class="hljs-comment">//初始化（或者说释放）内存空间并加入空闲列表</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>问题</strong>：什么是空闲列表（可利用空间表）？ <strong>答案</strong>：“空闲列表” 是动态内存管理的一种方法。通过把空闲内存划分成固定大小的数据块，而且利用指针字段把这些数据块链接起来，并使用一个指针指向首结点，这样就形成了一个单链表，即空闲列表（FreeList）</p><p><strong>好处</strong>：常常会有频繁申请、释放内存的需求，比如在发送网络报文时，每次都要分配内存以存储报文，等报文发送完成后又需要删除报文。为了避免频繁的new/delete对系统带来的开销，需要实现一个通用的FreeList机制。使用者总是从FreeList中分配内存，如果存在没有使用的内存块就直接摘出来使用，如果没有的话再从系统中分配。使用完毕后并不去直接delete该内存块，而是交给FreeList保管。</p><p>当用户请求分配时，系统从FreeList中删除一个结点分配之；当用户释放其所占内存时，系统即回收并将它插入到FreeList中，因此，FreeList亦称为“存储池”</p><p>FreeList有三种结点结构： 1. <strong>结点大小相同</strong>：把内存分为大小相同的若干块，将各块链接起来，分配时从头上摘取，用完后插入到头上，这实际是链式栈。 2. <strong>结点有若干规格</strong>：当用户所需内存量不同，但只允许在几种规格间选取。这种情况下，可利用空间表中可以维护几条链表，同一链表中的结点大小相同。如大小为2、4、8字节，可以构造3个链表。 3. <strong>结点大小不等</strong>：内存块大小不固定，只有一个链表。通常操作系统的可利用空间表属于此类。即FreeList中只有一个大小为整个存储区的结点。随着分配和回收的进行，FreeList的结点大小和个数也随之而变化。—— 由于结点的大小不同，在分配时并不是FreeList中的任一结点都能满足，而需要按照申请的长度在FreeList中进行检索，找到其长度大于等于申请长度的结点，从中截取合适的长度。这就涉及到分配策略 - 首次适配法：从链表头指针开始查找，找到第一个大于等于所需空间的结点即分配。（分配时查询，释放时插入表头）。优点是速度快，缺点是可能把较大块拆分成较小的块，导致后来对大块的申请难以满足，这种分配策略适合于系统事先不掌握运行期间可能出现的请求分配和释放的信息的情况。 - 最佳适配法：要求结点从小到大排列，找到第一个大于等于所需空间的结点即分配。（分配和回收时都需要查询）。优点是使无法满足大请求块的可能性降到最低，但可能导致严重的外部碎片问题 —— 这种分配策略适合请求分配内存大小范围较广的系统 - 最差适配法：要求结点从大到小排列，总从第一个结点开始分配。（分配时不需查询，回收时查询）。最佳适配法的。最差适配法的优点是使得空闲块长度趋于一致，适合于分配请求长度比较均匀的情况。</p><p>在xv6中，内存以4KB位标准大小，被切割成若干个块，不同的块之间按照单向链表的方式连接，每次进程申请内存时，就分配一个4KB的块给它。</p><figure><img src="20230921144414.png" alt="空闲链表freelist"><figcaption>空闲链表freelist</figcaption></figure><p>更深入的看kfree()代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[]; <span class="hljs-comment">// first address after kernel.  </span><br>                   <span class="hljs-comment">// defined by kernel.ld.</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> &#123;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">next</span>;</span>  <br>&#125;;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span>  <br>&#125; kmem;<br><br><span class="hljs-comment">// Free the page of physical memory pointed at by v,  </span><br><span class="hljs-comment">// which normally should have been returned by a  </span><br><span class="hljs-comment">// call to kalloc().  (The exception is when  </span><br><span class="hljs-comment">// initializing the allocator; see kinit above.)  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span>  <br>  <br>  <span class="hljs-comment">//确认是否对齐  </span><br>  <span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)  <br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);  <br>  <br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.  </span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);  <br>  <br>  r = (<span class="hljs-keyword">struct</span> run*)pa;  <br>  <br>  acquire(&amp;kmem.lock);  <br>  r-&gt;next = kmem.freelist;  <br>  kmem.freelist = r;  <br>  release(&amp;kmem.lock);  <br>&#125;  <br>  <br><br></code></pre></td></tr></table></figure> next是一个嵌套指针，自己占用了一段空间并指向一个内存块，kmem是链表的头节点，表示整个需要管理的物理内存块，访问时需要上锁。</p><p>kfree函数接收一个物理地址pa（physical address），pa指向了一个4KB大小的内存块，函数检查这个内存块是否4KB对齐，是否越界，然后填充上无效信息，将其插入到空闲列表中，表示这块空间以及被释放了，下次有进程再申请内存时可以将它分配出去。</p><p>有释放内存的函数，自然就有分配内存的函数： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate one 4096-byte page of physical memory.  </span><br><span class="hljs-comment">// Returns a pointer that the kernel can use.  </span><br><span class="hljs-comment">// Returns 0 if the memory cannot be allocated.  </span><br><span class="hljs-type">void</span> *  <br><span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span>  <br>  <br>  acquire(&amp;kmem.lock);  <br>  r = kmem.freelist;  <br>  <span class="hljs-keyword">if</span>(r)  <br>    kmem.freelist = r-&gt;next;  <br>  release(&amp;kmem.lock);  <br>  <br>  <span class="hljs-keyword">if</span>(r)  <br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk  </span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)r;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>kalloc不需要接收任何参数，直接从空闲列表取出来一块内存空间（同样是4KB），填充上无用信息并返回内存地址。</p><p>综上所述，kinit()函数是xv6初始化内存空间的函数，它将内存以4KB位单位切割成块，并串联成空闲列表，每次需要使用时直接分配即可。这个过程需要锁机制来保证安全。</p><h4 id="创建内核页表">创建内核页表</h4><p>内核使用各种设备也需要使用空间，而现代CPU允许时都必须经过MMU，因此内核页是需要页表的，但是这部分空间的映射并不是随机的，而是虚拟地址=物理地址，因此不需要额外的PTE进行表示，直接建立对应关系就可以了。例如内核本身虚拟地址和物理地址都位于<code>KERNBASE=0x80000000</code>，如何建立映射关系？看函数kvmmake <img src="20230921152857.png" alt="内核的虚拟地址映射情况"> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// qemu -machine virt is set up like this,  </span><br><span class="hljs-comment">// based on qemu&#x27;s hw/riscv/virt.c:  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">// 00001000 -- boot ROM, provided by qemu  </span><br><span class="hljs-comment">// 02000000 -- CLINT  </span><br><span class="hljs-comment">// 0C000000 -- PLIC  </span><br><span class="hljs-comment">// 10000000 -- uart0 </span><br><span class="hljs-comment">// 10001000 -- virtio disk </span><br><span class="hljs-comment">// 80000000 -- boot ROM jumps here in machine mode  </span><br><span class="hljs-comment">//             -kernel loads the kernel here  </span><br><span class="hljs-comment">// unused RAM after 80000000.  </span><br>  <br><span class="hljs-comment">// the kernel uses physical memory thus:  </span><br><span class="hljs-comment">// 80000000 -- entry.S, then kernel text and data  </span><br><span class="hljs-comment">// end -- start of kernel page allocation area  </span><br><span class="hljs-comment">// PHYSTOP -- end RAM used by the kernel</span><br></code></pre></td></tr></table></figure></p><p>kvmmake通过调用kvmmap，建立虚拟地址和硬件地址的关联，此调用发生在 xv6 启用 RISC-V 上的分页之前，因此地址直接引用物理内存。UART0，VITRIO0，PLIC的位置是通过宏定义设定好的常量，具体可参见memlayout.h文件。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Make a direct-map page table for the kernel.  </span><br><span class="hljs-type">pagetable_t</span>  <br><span class="hljs-title function_">kvmmake</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">pagetable_t</span> kpgtbl;  <br>  <br>  kpgtbl = (<span class="hljs-type">pagetable_t</span>) kalloc();  <br>  <span class="hljs-built_in">memset</span>(kpgtbl, <span class="hljs-number">0</span>, PGSIZE);  <br>  <br>  <span class="hljs-comment">// uart registers  </span><br>  <span class="hljs-comment">//因为没有打开分页功能，因此UART0此时实际表示的是物理地址</span><br>  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W); <br>  <br>  <span class="hljs-comment">// virtio mmio disk interface  </span><br>  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);  <br>  <br>  <span class="hljs-comment">// PLIC  </span><br>  kvmmap(kpgtbl, PLIC, PLIC, <span class="hljs-number">0x400000</span>, PTE_R | PTE_W);  <br>  <br>  <span class="hljs-comment">// map kernel text executable and read-only.  </span><br>  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);  <br>  <br>  <span class="hljs-comment">// map kernel data and the physical RAM we&#x27;ll make use of.  </span><br>  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);  <br>  <br>  <span class="hljs-comment">// map the trampoline for trap entry/exit to  </span><br>  <span class="hljs-comment">// the highest virtual address in the kernel.  </span><br>  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);  <br>  <span class="hljs-comment">//另外 `TRAMPOLINE` 页面是映射到物理地址 `trampoline` 上了</span><br>  <br>  <span class="hljs-comment">// map kernel stacks  </span><br>  proc_mapstacks(kpgtbl);  <br>    <br>  <span class="hljs-keyword">return</span> kpgtbl;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>具体来说，kvmmake 首先调用kalloc()函数分配一个物理内存页来保存根页表页 <strong>（kpgtbl是根目录页，也就是前文举例子时校长随身携带的那张表）</strong>。然后将 <code>UART0</code> 、<code>VIRTIO0</code>、<code>PLIC</code>、<code>KERNBASE</code> 和 <code>etext</code> 都做了直接映射（即虚拟地址和物理地址一样）；另外 <code>TRAMPOLINE</code> 页面是映射到物理地址 <code>trampoline</code> 上了，关于<code>etext 和 trampoline</code> 可以在链接脚本 <code>kernel/kernel.ld</code> 中查看到： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">OUTPUT_ARCH( <span class="hljs-string">&quot;riscv&quot;</span> )<br>ENTRY( _entry )<br><br>SECTIONS<br>&#123;<br>  . = <span class="hljs-number">0x80000000</span>;<br>  .text : &#123;<br>    *(.text .text.*)<br>    . = ALIGN(<span class="hljs-number">0x1000</span>);<br>    _trampoline = .;<br>    *(trampsec)<br>    . = ALIGN(<span class="hljs-number">0x1000</span>);<br>    ASSERT(. - _trampoline == <span class="hljs-number">0x1000</span>, <span class="hljs-string">&quot;error: trampoline larger than one page&quot;</span>);<br>    PROVIDE(etext = .);<br>  &#125;<br>  ...<span class="hljs-comment">// 后面内容省略</span><br>&#125;<br><br></code></pre></td></tr></table></figure> <code>etext</code> 是 .text 段结束位置，<code>_trampoline</code> 也是写在 .text 段中；</p><p>继续深挖kvmmap如何是如何建立映射关系的： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// add a mapping to the kernel page table.  </span><br><span class="hljs-comment">// only used when booting.  </span><br><span class="hljs-comment">// does not flush TLB or enable paging.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">kvmmap</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="hljs-type">int</span> perm)</span>  <br>&#123;  <br>  <span class="hljs-keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="hljs-number">0</span>)  <br>    panic(<span class="hljs-string">&quot;kvmmap&quot;</span>);  <br>&#125;  <br>  <br><span class="hljs-comment">// Create PTEs for virtual addresses starting at va that refer to  </span><br><span class="hljs-comment">// physical addresses starting at pa. va and size might not  </span><br><span class="hljs-comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t  </span><br><span class="hljs-comment">// allocate a needed page-table page.  </span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">mappages</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>  uint64 a, last;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  <span class="hljs-comment">// 需要映射的大小为0，panic</span><br>  <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;mappages: size&quot;</span>);<br>  <br>  a = PGROUNDDOWN(va);               <span class="hljs-comment">// 需要映射的虚拟地址的下边界</span><br>  last = PGROUNDDOWN(va + size - <span class="hljs-number">1</span>); <span class="hljs-comment">// 需要映射的虚拟地址的上边界</span><br>  <span class="hljs-comment">// 遍历每个4KB的页面</span><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">// 得到最后一级页表项</span><br>    <span class="hljs-keyword">if</span>((pte = walk(pagetable, a, <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// 如果页表项已经有效了，说明这个页表之前已经被映射过了，panic</span><br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_V)<br>      panic(<span class="hljs-string">&quot;mappages: remap&quot;</span>);<br>    <span class="hljs-comment">// 页表项存放对应的物理地址，并设置页表项的标志位</span><br>    *pte = PA2PTE(pa) | perm | PTE_V;<br>    <span class="hljs-comment">// 映射完成</span><br>    <span class="hljs-keyword">if</span>(a == last)<br>      <span class="hljs-keyword">break</span>;<br>    a += PGSIZE;<br>    pa += PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure> 在讲MMU的原理时提到，想要定位一个PTE，需要<strong>页目录的地址+索引</strong>，pagetable参数就是页目录的地址。va和pa分别表示需要建立关联的虚拟地址和物理地址的起始位置，size用来计算结束的位置，perm则是在建立PTE关系时可以用来设定标志位。</p><p>mappages将范围虚拟地址到同等范围物理地址的映射装载到一个页表中。它以页面大小为间隔，为范围内的每个虚拟地址单独执行此操作。对于要映射的每个虚拟地址，mappages调用walk来查找该地址的PTE地址。然后，它初始化PTE以保存相关的物理页号、所需权限（PTE_W、PTE_X和/或PTE_R）以及用于标记PTE有效的PTE_V</p><p>mappages还涉及到了一些宏定义的内容，他们的定义位于riscv.h例如PGROUNDDOWN。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSIZE 4096 <span class="hljs-comment">// bytes per page  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSHIFT 12  <span class="hljs-comment">// bits of offset within a page  </span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))  <span class="hljs-comment">//向上取整对齐</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1)) <span class="hljs-comment">//向下取整对齐</span></span><br></code></pre></td></tr></table></figure></p><p>在map中涉及到了walk函数，这是内存管理的核心函数，<strong>是上文提到的三级页表原理的具体实现。</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return the address of the PTE in page table pagetable  </span><br><span class="hljs-comment">// that corresponds to virtual address va.  If alloc!=0,  </span><br><span class="hljs-comment">// create any required page-table pages.  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">// The risc-v Sv39 scheme has three levels of page-table  </span><br><span class="hljs-comment">// pages. A page-table page contains 512 64-bit PTEs.  </span><br><span class="hljs-comment">// A 64-bit virtual address is split into five fields:  </span><br><span class="hljs-comment">//   39..63 -- must be zero.  </span><br><span class="hljs-comment">//   30..38 -- 9 bits of level-2 index.  </span><br><span class="hljs-comment">//   21..29 -- 9 bits of level-1 index.  </span><br><span class="hljs-comment">//   12..20 -- 9 bits of level-0 index.  </span><br><span class="hljs-comment">//    0..11 -- 12 bits of byte offset within the page.  </span><br><br><br><span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">walk</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-type">int</span> alloc)</span><br>&#123;<br>  <span class="hljs-comment">// 访问的虚拟地址超过规定的最大值</span><br>  <span class="hljs-keyword">if</span>(va &gt;= MAXVA)<br>    panic(<span class="hljs-string">&quot;walk&quot;</span>);<br><br>  <span class="hljs-comment">// 模拟三级页表访问过程，从L2-&gt;L1</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> level = <span class="hljs-number">2</span>; level &gt; <span class="hljs-number">0</span>; level--) &#123;<br>    <span class="hljs-comment">// PX(level, va)得到页表中的虚拟页号</span><br>    <span class="hljs-comment">// 根据虚拟页号来得到对应的页表项</span><br>    <span class="hljs-type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];<br>    <span class="hljs-comment">// 如果页表项是有效的</span><br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_V) &#123;<br>      <span class="hljs-comment">// 将页表项转为物理地址，并更新此时的页表</span><br>      pagetable = (<span class="hljs-type">pagetable_t</span>)PTE2PA(*pte);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果页表项是无效的</span><br>      <span class="hljs-comment">// 看是否需要分配新的页表（alloc==1)</span><br>      <span class="hljs-comment">// 需要分配，并且物理内存足够则分配新的页表</span><br>      <span class="hljs-keyword">if</span>(!alloc || (pagetable = (<span class="hljs-type">pde_t</span>*)kalloc()) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 将页表对应的4KB物理内存清空</span><br>      <span class="hljs-built_in">memset</span>(pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>      <span class="hljs-comment">// 将分配的物理地址存放在上一级页表项中，并设置页表标志位V=1</span><br>      *pte = PA2PTE(pagetable) | PTE_V;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 返回最后一级对应的页表项</span><br>  <span class="hljs-keyword">return</span> &amp;pagetable[PX(<span class="hljs-number">0</span>, va)];<br>&#125;<br><br><br>以下是这个过程使用的宏定义，被定义在riscv.h：<br><span class="hljs-comment">// shift a physical address to the right place for a PTE.  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10) <span class="hljs-comment">//右侧12位是偏移量，这个过程相当于抹掉偏移量，取出了物理地址所在页的物理地址，并空出低位10位用于设置标志位  </span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12) <span class="hljs-comment">//PTE低10位是标志位，这个操作抹掉了标志位，然后腾出来12位变成物理地址所在页的地址，与偏移量拼接后即可得到物理地址  </span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF) <span class="hljs-comment">//0x3FF表示低10位，而低10位正好是标志位，这个操作用来取出pte中的标志位  </span></span><br><span class="hljs-comment">//对位运算的运行真的很巧妙  </span><br>  <br><span class="hljs-comment">// extract the three 9-bit page table indices from a virtual address.  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXMASK          0x1FF <span class="hljs-comment">// 9 bits  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level))) <span class="hljs-comment">//level表示索引的层级，xv6有三级索引，这个操作是得到当前需要的索引所在的位置，例如L2位于12 + 9 * 2 =30位  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK) <span class="hljs-comment">//获得索引，例如获得L2索引则需要虚拟地址右移12 + 9 * 2 = 30位，这样最低位的9位就是L2索引的地址</span></span><br><br></code></pre></td></tr></table></figure> 函数是根据虚拟地址来找到最后一级对应的页表项，返回 0 表示没找到；alloc 参数规定了页表遍历的过程，如果遇见无效的页表是否需要分配一块新的物理内存当做页表，体现了按需分配的原则。</p><p>综上，经过上述一系列函数的操作，完成了最初那张图片所展示的内存空间映射关系。下一步就是打开分页功能。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Switch h/w page table register to the kernel&#x27;s page table,  </span><br><span class="hljs-comment">// and enable paging.  </span><br><br><br><span class="hljs-comment">//riscv.h文件下</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SATP_SV39 (8L &lt;&lt; 60) <span class="hljs-comment">// use riscv&#x27;s sv39 page table scheme.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) &gt;&gt; 12))</span><br><span class="hljs-comment">// flush the TLB.  </span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span>  <br><span class="hljs-title function_">sfence_vma</span><span class="hljs-params">()</span>  <span class="hljs-comment">//这是一条RISCV指令</span><br>&#123;  <br>  <span class="hljs-comment">// the zero, zero means flush all TLB entries.  </span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;sfence.vma zero, zero&quot;</span>)</span>;  <span class="hljs-comment">//刷新TLB</span><br>&#125;<br><br><br><span class="hljs-comment">//vm.c文件下</span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">kvminithart</span><span class="hljs-params">()</span>  <span class="hljs-comment">//被main.c调用</span><br>&#123;  <br>  w_satp(MAKE_SATP(kernel_pagetable));  <span class="hljs-comment">//kernel_pagetable是前文分配的根目录页</span><br>  sfence_vma();   <span class="hljs-comment">//刷新TLB，打开分页功能</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>问题：什么是TLB？ 答案：Translation Lookaside Buffer。TLB又称快表，在三级页表中，对于PA寻址，需要读取三次内存，代价也十分高。但在实际中，每一个处理器都会缓存最近使用VA对应的PPN，这个缓存也被称作为TLB，通常保存PTE的缓存。因此当CPU第一次翻译VA，通过三次查找页表可以获得最终的PPN，TLB会保存虚拟地址到物理地址的映射关系。那么下一次访问同一个VA时，查看TLB就会直接通过映射得到PA。(应该保存的是<strong>VA的index</strong>与<strong>最终的PPN</strong>的映射)，这种方案因为程序的局部性原理而有效。</p><h2 id="从进程的创建过程看虚拟内存">从进程的创建过程看虚拟内存</h2><p>前文讲述了xv6启动时的内存初始化操作，整个地址空间已经映射完毕，可用物理内存也已经切成块加入到Freelist中。下面我们以fork和exec为例，看一个新进程产生过程中地址分配是如何运作的。</p><h4 id="fork">fork</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create a new process, copying the parent.  </span><br><span class="hljs-comment">// Sets up child kernel stack to return as if from fork() system call.  </span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> i, pid;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span>            <span class="hljs-comment">//计划创建的子进程</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <span class="hljs-comment">//第一步，获取当前正在允许的进程</span><br>  <br>  <span class="hljs-comment">// Allocate process.  </span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;   <span class="hljs-comment">//为子进程分配内存空间</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-comment">// Copy user memory from parent to child.  </span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//创建用户内存，下文详解该函数</span><br>    freeproc(np);  <br>    release(&amp;np-&gt;lock);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br><br><span class="hljs-comment">//下文将父进程的内容都copy给子进程，包括进程大小sz，保存上下文的trapframe结构体，文件，名称</span><br>  np-&gt;sz = p-&gt;sz;  <br>  <br>  <span class="hljs-comment">// copy saved user registers.  </span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);  <br>  <br>  <span class="hljs-comment">// Cause fork to return 0 in the child.  </span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;  <br><br><span class="hljs-comment">//文件相关，暂时不管</span><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.  </span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)  <br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])  <br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);  <br>  np-&gt;cwd = idup(p-&gt;cwd);  <br>  <br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));  <br>  <br>  <span class="hljs-comment">//lab2 trace  </span><br>  np-&gt;trace_mask = p-&gt;trace_mask;  <br>  <br>  pid = np-&gt;pid;  <br><br><br><span class="hljs-comment">//新进程创建完毕，修改新建的状态，将子进程指向父进程，修改进程状态（这个过程需要上锁）</span><br>  release(&amp;np-&gt;lock);  <br>  <br>  acquire(&amp;wait_lock);  <br>  np-&gt;parent = p;  <br>  release(&amp;wait_lock);  <br>  <br>  acquire(&amp;np-&gt;lock);  <br>  np-&gt;state = RUNNABLE;  <br>  release(&amp;np-&gt;lock);  <br>  <br>  <span class="hljs-keyword">return</span> pid;  <br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，涉及到内存相关的内容就是下面这段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">// Copy user memory from parent to child.  </span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;  <br>    freeproc(np);  <br>    release(&amp;np-&gt;lock);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;<br><br><span class="hljs-comment">// vm.c</span><br><span class="hljs-comment">// Given a parent process&#x27;s page table, copy  </span><br><span class="hljs-comment">// its memory into a child&#x27;s page table.  </span><br><span class="hljs-comment">// Copies both the page table and the  </span><br><span class="hljs-comment">// physical memory.  </span><br><span class="hljs-comment">// returns 0 on success, -1 on failure.  </span><br><span class="hljs-comment">// frees any allocated pages on failure.  </span><br><br><span class="hljs-comment">//每个进程都有一个根页目录，old和new是父进程和子进程指向根页目录的指针，sz是父进程占用内存大小</span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">uvmcopy</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> old, <span class="hljs-type">pagetable_t</span> new, uint64 sz)</span>   <br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;  <br>  uint64 pa, i;  <br>  uint flags;  <br>  <span class="hljs-type">char</span> *mem;  <br><br><span class="hljs-comment">//因为进程可能大于4kB，也就是由多个页组成，在虚拟内存机制下，页内部是连续的，但是不同页之间不一定连续，因此需要循环找到每一页进行拷贝</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;   <br>    <span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)    <span class="hljs-comment">//根据old页目录地址 + 虚拟地址找到PTE</span><br>      panic(<span class="hljs-string">&quot;uvmcopy: pte should exist&quot;</span>);  <br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)             <span class="hljs-comment">//PTE有效性检查</span><br>      panic(<span class="hljs-string">&quot;uvmcopy: page not present&quot;</span>);  <br>    pa = PTE2PA(*pte);               <span class="hljs-comment">//根据PTE找到物理页的首地址</span><br>    flags = PTE_FLAGS(*pte);         <span class="hljs-comment">//设置PTE标识位</span><br>    <span class="hljs-keyword">if</span>((mem = kalloc()) == <span class="hljs-number">0</span>)        <span class="hljs-comment">//分配一页物理内存</span><br>      <span class="hljs-keyword">goto</span> err;  <br>    memmove(mem, (<span class="hljs-type">char</span>*)pa, PGSIZE);   <span class="hljs-comment">//拷贝</span><br>    <span class="hljs-keyword">if</span>(mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//在虚拟地址和新分配的物理地址之间建立映射关系，这样新进程的页表就构建好了</span><br>      kfree(mem);  <br>      <span class="hljs-keyword">goto</span> err;  <br>    &#125;  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  <br> err:  <br>  uvmunmap(new, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">1</span>);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>整个函数的思路是 1. 因为进程可能大于4kB，也就是由多个页组成，在虚拟内存机制下，页内部是连续的，但是不同页之间不一定连续，因此需要循环找到每一页进行拷贝。i从0开始一直到SZ停止，意味着需要拷贝整个进程的内存空间。 2. old是父进程的页目录虚拟地址，new是新建的子进程页目录虚拟地址（暂未赋值），通过walk函数找到进程的物理地址 3. 为子进程分配新的物理内存，并设置PTE标志位，再将父进程的物理内存复制到子进程的内存 4. 建立子进程虚拟地址与子进程物理地址的映射关系、 5. <code>uvmunmap</code>函数，如果在分配内存或者建立映射关系时出现错误，说明这次拷贝任务失败，需要将循环过程中之前已经分配的内容都释放（这一步在工程上非常重要，不然会出现看起来已经被分配，但无法使用的，也无法被回收的内存）</p><h4 id="exec">exec</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>  <br><span class="hljs-title function_">exec</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> **argv)</span>  <br>&#123;  <br>  <span class="hljs-type">char</span> *s, *last;  <br>  <span class="hljs-type">int</span> i, off;  <br>  uint64 argc, sz = <span class="hljs-number">0</span>, sp, ustack[MAXARG], stackbase;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> <span class="hljs-title">elf</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> <span class="hljs-title">ph</span>;</span>  <br>  <span class="hljs-type">pagetable_t</span> pagetable = <span class="hljs-number">0</span>, oldpagetable;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  begin_op();  <br>  <br>  <span class="hljs-keyword">if</span>((ip = namei(path)) == <span class="hljs-number">0</span>)&#123;  <br>    end_op();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>  ilock(ip);  <br>  <br>  <span class="hljs-comment">// Check ELF header  </span><br>  <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;elf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(elf)) != <span class="hljs-keyword">sizeof</span>(elf))  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <span class="hljs-keyword">if</span>(elf.magic != ELF_MAGIC)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <br>  <span class="hljs-keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <br>  <span class="hljs-comment">// Load program into memory.  </span><br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="hljs-keyword">sizeof</span>(ph))&#123;  <br>    <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;ph, off, <span class="hljs-keyword">sizeof</span>(ph)) != <span class="hljs-keyword">sizeof</span>(ph))  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    <span class="hljs-keyword">if</span>(ph.type != ELF_PROG_LOAD)  <br>      <span class="hljs-keyword">continue</span>;  <br>    <span class="hljs-keyword">if</span>(ph.memsz &lt; ph.filesz)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    <span class="hljs-keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    uint64 sz1;  <br>    <span class="hljs-keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    sz = sz1;  <br>    <span class="hljs-keyword">if</span>((ph.vaddr % PGSIZE) != <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    <span class="hljs-keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>  &#125;  <br>  iunlockput(ip);  <br>  end_op();  <br>  ip = <span class="hljs-number">0</span>;  <br>  <br>  p = myproc();  <br>  uint64 oldsz = p-&gt;sz;  <br>  <br>  <span class="hljs-comment">// Allocate two pages at the next page boundary.  </span><br>  <span class="hljs-comment">// Use the second as the user stack.  sz = PGROUNDUP(sz);  </span><br>  uint64 sz1;  <br>  <span class="hljs-keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="hljs-number">2</span>*PGSIZE)) == <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  sz = sz1;  <br>  uvmclear(pagetable, sz<span class="hljs-number">-2</span>*PGSIZE);  <br>  sp = sz;  <br>  stackbase = sp - PGSIZE;  <br>  <br>  <span class="hljs-comment">// Push argument strings, prepare rest of stack in ustack.  </span><br>  <span class="hljs-keyword">for</span>(argc = <span class="hljs-number">0</span>; argv[argc]; argc++) &#123;  <br>    <span class="hljs-keyword">if</span>(argc &gt;= MAXARG)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    sp -= <span class="hljs-built_in">strlen</span>(argv[argc]) + <span class="hljs-number">1</span>;  <br>    sp -= sp % <span class="hljs-number">16</span>; <span class="hljs-comment">// riscv sp must be 16-byte aligned  </span><br>    <span class="hljs-keyword">if</span>(sp &lt; stackbase)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    <span class="hljs-keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="hljs-built_in">strlen</span>(argv[argc]) + <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    ustack[argc] = sp;  <br>  &#125;  <br>  ustack[argc] = <span class="hljs-number">0</span>;  <br>  <br>  <span class="hljs-comment">// push the array of argv[] pointers.  </span><br>  sp -= (argc+<span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(uint64);  <br>  sp -= sp % <span class="hljs-number">16</span>;  <br>  <span class="hljs-keyword">if</span>(sp &lt; stackbase)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <span class="hljs-keyword">if</span>(copyout(pagetable, sp, (<span class="hljs-type">char</span> *)ustack, (argc+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(uint64)) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <br>  <span class="hljs-comment">// arguments to user main(argc, argv)  </span><br>  <span class="hljs-comment">// argc is returned via the system call return  // value, which goes in a0.  p-&gt;trapframe-&gt;a1 = sp;  </span><br>  <br>  <span class="hljs-comment">// Save program name for debugging.  </span><br>  <span class="hljs-keyword">for</span>(last=s=path; *s; s++)  <br>    <span class="hljs-keyword">if</span>(*s == <span class="hljs-string">&#x27;/&#x27;</span>)  <br>      last = s+<span class="hljs-number">1</span>;  <br>  safestrcpy(p-&gt;name, last, <span class="hljs-keyword">sizeof</span>(p-&gt;name));  <br>      <br>  <span class="hljs-comment">// Commit to the user image.  </span><br>  oldpagetable = p-&gt;pagetable;  <br>  p-&gt;pagetable = pagetable;  <br>  p-&gt;sz = sz;  <br>  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="hljs-comment">// initial program counter = main  </span><br>  p-&gt;trapframe-&gt;sp = sp; <span class="hljs-comment">// initial stack pointer  </span><br>  proc_freepagetable(oldpagetable, oldsz);  <br>  <br>  <span class="hljs-keyword">return</span> argc; <span class="hljs-comment">// this ends up in a0, the first argument to main(argc, argv)  </span><br>  <br> bad:  <br>  <span class="hljs-keyword">if</span>(pagetable)  <br>    proc_freepagetable(pagetable, sz);  <br>  <span class="hljs-keyword">if</span>(ip)&#123;  <br>    iunlockput(ip);  <br>    end_op();  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;  <br>  <br><span class="hljs-comment">// Load a program segment into pagetable at virtual address va.  </span><br><span class="hljs-comment">// va must be page-aligned  </span><br><span class="hljs-comment">// and the pages from va to va+sz must already be mapped.  </span><br><span class="hljs-comment">// Returns 0 on success, -1 on failure.  </span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  <br><span class="hljs-title function_">loadseg</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-keyword">struct</span> inode *ip, uint offset, uint sz)</span>  <br>&#123;  <br>  uint i, n;  <br>  uint64 pa;  <br>  <br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;  <br>    pa = walkaddr(pagetable, va + i);  <br>    <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)  <br>      panic(<span class="hljs-string">&quot;loadseg: address should exist&quot;</span>);  <br>    <span class="hljs-keyword">if</span>(sz - i &lt; PGSIZE)  <br>      n = sz - i;  <br>    <span class="hljs-keyword">else</span>  <br>      n = PGSIZE;  <br>    <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)pa, offset+i, n) != n)  <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>我们拆开了看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">begin_op();  <br><br><span class="hljs-comment">//path是可执行文件的位置</span><br><span class="hljs-keyword">if</span>((ip = namei(path)) == <span class="hljs-number">0</span>)&#123;   <span class="hljs-comment">//namei是文件系统的内容，没学，暂时搁置</span><br>  end_op();  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;  <br>ilock(ip);<br><br></code></pre></td></tr></table></figure><p>exec通过路径名打开文件，然后读取该文件的<strong>ELF Header</strong>（kernel/elf.h）。</p><p>xv6的所有应用程序以通用的<strong>ELF格式</strong>来描述。一个ELF二进制文件大概这样组成（更准确的定义，建议查阅相关资料，这里进行简单的不严谨的说明）：一个ELF Header，后面紧跟一系列的Program Section Headers。每个Program Section Header都对应一段需要加载到内存中的程序，xv6的应用程序只有一个Program Section Header，而在其它操作系统上可能有好几个。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// File header</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> &#123;</span><br>  uint magic;  <span class="hljs-comment">// must equal ELF_MAGIC</span><br>  uchar elf[<span class="hljs-number">12</span>];<br>  ushort type;<br>  ushort machine;<br>  uint version;<br>  uint64 entry;<br>  uint64 phoff;<br>  uint64 shoff;<br>  uint flags;<br>  ushort ehsize;<br>  ushort phentsize;<br>  ushort phnum;<br>  ushort shentsize;<br>  ushort shnum;<br>  ushort shstrndx;<br>&#125;;<br><br><span class="hljs-comment">// Program section header</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> &#123;</span><br>  uint32 type;<br>  uint32 flags;<br>  uint64 off;<br>  uint64 vaddr;<br>  uint64 paddr;<br>  uint64 filesz;<br>  uint64 memsz;<br>  uint64 align;<br>&#125;;<br><br><span class="hljs-comment">// Format of an ELF executable file</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_MAGIC 0x464C457FU  <span class="hljs-comment">// &quot;\x7FELF&quot; in little endian</span></span><br><br><span class="hljs-comment">// Values for Proghdr type</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_LOAD           1</span><br><br><span class="hljs-comment">// Flag bits for Proghdr flags</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_EXEC      1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_WRITE     2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_READ      4</span><br><br></code></pre></td></tr></table></figure></p><p>exec读取了文件系统上的文件之后，第一件事就是先检查该文件是否包含ELF二进制文件 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Check ELF header  </span><br><span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;elf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(elf)) != <span class="hljs-keyword">sizeof</span>(elf))  <span class="hljs-comment">//readi用来从inode获取数据</span><br>  <span class="hljs-keyword">goto</span> bad;  <br><span class="hljs-keyword">if</span>(elf.magic != ELF_MAGIC)  <br>  <span class="hljs-keyword">goto</span> bad;  <br></code></pre></td></tr></table></figure></p><p>完成检验后，exec为用户进程调用<code>proc_pagetable（proc.c）</code>，该函数通过<code>uvmcreate</code>创建一个空的用户页表，然后在该用户页表上添加了trampoline（位于虚拟地址最高位）和trapframe（trampoline下面）的映射，其它的虚拟地址空间都暂时为空。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">  <br><span class="hljs-keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="hljs-number">0</span>)  <br>  <span class="hljs-keyword">goto</span> bad;<br><br><span class="hljs-comment">//proc.c</span><br><span class="hljs-comment">// Create a user page table for a given process,</span><br><span class="hljs-comment">// with no user memory, but with trampoline pages.</span><br><span class="hljs-type">pagetable_t</span><br><span class="hljs-title function_">proc_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>&#123;<br>  <span class="hljs-type">pagetable_t</span> pagetable;<br><br>  <span class="hljs-comment">// An empty page table.</span><br>  pagetable = uvmcreate();<br>  <span class="hljs-keyword">if</span>(pagetable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// map the trampoline code (for system call return)</span><br>  <span class="hljs-comment">// at the highest user virtual address.      </span><br>  <span class="hljs-comment">// only the supervisor uses it, on the way</span><br>  <span class="hljs-comment">// to/from user space, so not PTE_U.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,<br>              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,<br>              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> pagetable;<br>&#125;<br><br><span class="hljs-comment">// create an empty user page table.</span><br><span class="hljs-comment">// returns 0 if out of memory.</span><br><span class="hljs-type">pagetable_t</span><br><span class="hljs-title function_">uvmcreate</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">pagetable_t</span> pagetable;<br>  pagetable = (<span class="hljs-type">pagetable_t</span>) kalloc();<br>  <span class="hljs-keyword">if</span>(pagetable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>  <span class="hljs-keyword">return</span> pagetable;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>一个可执行二进制程序（在 linux 下为一个进程单元），在存储时（<strong>没有加载到内存运行</strong>），至少拥有三个部分，分别是代码段(text)、数据段(data)、和bss段（未初始化的全局变量，不占用可执行文件的空间）。当应用程序运行时（<strong>运行态</strong>），此时需要另外两个域：<strong>堆</strong>和<strong>栈</strong>。正在运行的程序：**代码段 + 数据段 + bss 段 + 堆 + 栈。 - 代码段：程序执行的指令 - 数据段：已初始化的全局变量和静态局部变量 - bss段：存放程序中未初始化和初始化为 0的全局变量的一块内存区域，在程序载入时由内核清零 - 堆：动态分配的内存，FIFO的数据结构 - 栈：局部变量，参数，返回值，LIFO的数据结构</p><figure><img src="20231016200329.png" alt="一个可执行程序的内存结构"><figcaption>一个可执行程序的内存结构</figcaption></figure><p>exec对于每个程序段，先是调用<code>uvmalloc</code>分配足够的物理帧，更新了用户页表。然后调用<code>loadseg</code>加载程序段到这些物理帧中。<code>loadseg</code>将虚拟地址传给<code>walkaddr</code>，<code>walkaddr</code>又通过<code>walk</code>查找相关PTE，将va转换为pa，最后<code>walkaddr</code>成功返回<code>uvmalloc</code>分配的物理帧的物理地址，<code>loadseg</code>再调用<code>readi</code>，真正地将程序段加载到物理内存中。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// Load program into memory</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="hljs-keyword">sizeof</span>(ph))&#123;<br>  <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;ph, off, <span class="hljs-keyword">sizeof</span>(ph)) != <span class="hljs-keyword">sizeof</span>(ph))<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>(ph.type != ELF_PROG_LOAD)<br>    <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-keyword">if</span>(ph.memsz &lt; ph.filesz)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)<br>    <span class="hljs-keyword">goto</span> bad;<br>  uint64 sz1;<br>  <span class="hljs-comment">// 再通过uvmalloc为每个ELF段分配内存</span><br>  <span class="hljs-keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  sz = sz1;<br>  <span class="hljs-keyword">if</span>(ph.vaddr % PGSIZE != <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-comment">// 然后通过loadseg把段的内容载入物理内存中</span><br>  <span class="hljs-comment">// loadseg通过walkaddr找到写入ELF段的内存的物理地址；通过readi来将段的内容从文件中读出</span><br>  <span class="hljs-keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>&#125;<br><br><br><span class="hljs-comment">// Load a program segment into pagetable at virtual address va.</span><br><span class="hljs-comment">// va must be page-aligned</span><br><span class="hljs-comment">// and the pages from va to va+sz must already be mapped.</span><br><span class="hljs-comment">// Returns 0 on success, -1 on failure.</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">loadseg</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-keyword">struct</span> inode *ip, uint offset, uint sz)</span><br>&#123;<br>  uint i, n;<br>  uint64 pa;<br><br>  <span class="hljs-keyword">if</span>((va % PGSIZE) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;loadseg: va must be page aligned&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    pa = walkaddr(pagetable, va + i);<br>    <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;loadseg: address should exist&quot;</span>);<br>    <span class="hljs-keyword">if</span>(sz - i &lt; PGSIZE)<br>      n = sz - i;<br>    <span class="hljs-keyword">else</span><br>      n = PGSIZE;<br>    <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)pa, offset+i, n) != n)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// Look up a virtual address, return the physical address,</span><br><span class="hljs-comment">// or 0 if not mapped.</span><br><span class="hljs-comment">// Can only be used to look up user pages.</span><br>uint64<br><span class="hljs-title function_">walkaddr</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va)</span><br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  uint64 pa;<br><br>  <span class="hljs-keyword">if</span>(va &gt;= MAXVA)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  pte = walk(pagetable, va, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(pte == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_U) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  pa = PTE2PA(*pte);<br>  <span class="hljs-keyword">return</span> pa;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="缺页中断">缺页中断</h2><p>前文提到，节省空间是计算机使用三级页表的原因之一。因为局部性原理，部分PTE被用到的概率不大，因此存储在外部存储硬件上，既然没有装进去所有的PTE，那自然可能会存PTE不在内存中的情况，这时就需要触发缺页中断，将PTE从外部存储加载到内存中</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab2 system calls</title>
    <link href="/2023/09/04/Lab2-system-calls/"/>
    <url>/2023/09/04/Lab2-system-calls/</url>
    
    <content type="html"><![CDATA[<p><a href="%5B%5BLab:%20System%20calls%20(mit.edu)%5D(https://pdos.csail.mit.edu/6.S081/2021/labs/syscall.html)%5D">课程地址</a>_</p><p>本次实验是需要完成一些系统调用功能，在开始前需要先理解进程相关的概念和系统调用的原理</p><h2 id="系统调用的原理">系统调用的原理</h2><p>回顾第二章书本上的知识，我们知道程序一般运行在用户态，只有遇到以下三种情况才会陷入中断进入内核态： 1. <strong>系统调用</strong>：当用户程序执行<strong>ecall</strong>指令要求内核为其做某事时。 2. <strong>异常</strong>：一条指令(用户或内核)做了一些非法的事情，如除以零或使用无效的虚拟地址。 3. <strong>中断</strong>：当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时。</p><p>所以研究系统调用，其实也就是研究中断（trap）过程是如何发生的。宏观上可分为四个步骤，本文会针对这四个步骤，结合xv6系统进行详细的讲解： 1. 中断请求 2. 保护现场 3. 中断处理 4. 中断返回</p><p>以上过程自然离不开与寄存器打交道，例如<strong>satp寄存器用于控制分页系统</strong>，以下是与trap相关的寄存器概述，这些寄存器可以分为两类： <strong>1. 发生中断时，硬件自动写入的寄存器</strong> - <code>sepc</code>：当trap发生时，RISC-V会将程序计数器保存在这里(因为<code>PC</code>会被<code>stvec</code>覆盖)。<code>sret</code>(从trap中返回)指令将<code>sepc</code>复制到<code>pc</code>中。内核可以写<code>sepc</code>来控制<code>sret</code>的返回到哪里。 - <code>scause</code>：RISC -V在这里放了一个数字，描述了trap的原因。 - <code>stval</code>：<code>scause</code> 不足以存下中断所有的必须信息。例如缺页异常，就会将 <code>stval</code> 设置成需要访问但是不在内存中的地址，以便于操作系统将这个地址所在的页面加载进来。</p><p><strong>2. 指导硬件处理中断的寄存器</strong> - <code>stvec</code>：保存内核中断处理流程的入口地址，内核在这里写下trap处理程序的地址；RISC-V跳转到这里来处理trap。 - <code>sstatus</code>：具有许多状态位，控制全局中断等。<code>sstatus</code>中的<strong>SIE</strong>位控制设备中断是否被启用，如果内核清除<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核设置<strong>SIE</strong>。<strong>SPP</strong>位表示trap是来自用户模式还是supervisor模式，并控制<code>sret</code>返回到什么模式。 - <code>sie</code>：即 Supervisor Interrupt Enable，用来控制具体类型中断，例如其中的 STIE 控制时钟中断 - <code>sip</code>：即 Supervisor Interrupt Pending，和 <code>sie</code> 相对应，记录每种中断是否被触发。仅当 <code>sie</code> 和 <code>sip</code> 的对应位都为 1 时，意味着开中断且已发生中断，这时中断最终触发。 - <code>sscratch</code>：内核在这里放置了一个值，在trap处理程序开始时可以方便地使用。在用户态保存内核栈的地址，在内核态值为 0。为什么需要内核栈？因此中断处理流程也需要利用内存空间，很可能需要使用栈，而程序当前的用户栈是不安全的（说不定指针不断运行到其他进程的空间，破坏了隔离性）。因此，我们还需要一个预设的安全的栈空间，存放在这里。</p><p>有了上述与中断相关的寄存器，自然也就有与中断相关的指令： <strong>1. 进入和退出中断</strong> - <code>ecall</code>：触发中断，进入更高一层的中断处理流程之中。用户态进行系统调用进入内核态中断处理流程，内核态进行 SBI 调用进入机器态中断处理流程，使用的都是这条指令。 - <code>sret</code>：从内核态返回用户态，同时将 <code>sepc</code> 的值赋值给 <code>pc</code>。（如果需要返回到 <code>sepc</code> 后一条指令，就需要在 <code>sret</code> 之前修改 <code>sepc</code> 的值） - <code>ebreak</code>：触发一个断电 - <code>mret</code>：从机器态返回内核态，同时将 <code>pc</code> 的值设置为 <code>mepc</code>。</p><p><strong>2. 操作CSR</strong> 只有一系列特殊的指令（CSR Instruction）可以读写 CSR - <code>csrrw dst, csr, src</code>（CSR Read Write）同时读写的原子操作，将指定 CSR 的值写入 <code>dst</code>，同时将 <code>src</code> 的值写入 CSR。 - <code>csrr dst, csr</code>（CSR Read）：仅读取一个 CSR 寄存器。 - <code>csrw csr, src</code>（CSR Write） ：仅写入一个 CSR 寄存器。</p><p>微观上，RISC-V硬件对每一个trap操作（除定时器中断外），都会执行如下步骤： 1. 如果该trap是设备中断，且sstatus SIE位为0，则不执行以下任何操作 2. 通过清除 SIE 来禁用中断 3. 复制 pc 到 sepc 4. 将当前模式(用户态或特权态)保存在 sstatus 的 SPP 位 5. 在 scause 设置该次trap的原因 6. 将模式转换为特权态 7. 将 stvec 复制到 pc 8. 从新的pc开始执行</p><h4 id="中断请求">中断请求</h4><p>当使用到<code>write，read，open</code>等系统调用时，会使用<code>ecall</code>指令发起中断请求 - <code>ecall</code>是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用</p><p>在xv6中，<code>user/cat.c</code>文件是<code>cat shell</code>指令的源码，其中涉及到了<code>read</code>函数，它声明在<code>user/user.h</code>文件中，但是<code>read</code>函数的实现在<code>kernel/sysfile.c</code>文件中。显然<code>cat</code>并不是直接调用<code>sysfile.c</code>文件中的函数来达成目标的，毕竟一个在用户态，一个在内核态。</p><p>既然<code>read</code>在用户态的角度看不见具体的逻辑实现，那它为什么能正常运行呢？只声明不实现的函数是无法正常使用的呀？</p><p>仔细观察user文件架，我们可以发现虽然没有<code>read</code>函数的c语言实现，但其实存在汇编实现。用户在c代码中使用<code>read</code>函数时，其实是在运行<code>usys.S</code>文件（由<code>usys.pl</code>文件得来，make指令才能看见）中<code>read</code>函数。 <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">c</span>语言如何调用汇编函数？步骤：<br><span class="hljs-number">1</span>、先在汇编程序中声明函数属性为GLOBAL<br><span class="hljs-number">2</span>、在<span class="hljs-keyword">c</span>文件开头声明该函数<br><span class="hljs-number">3</span>、按照C语言正常调用函数的方式调用该函数<br></code></pre></td></tr></table></figure></p><p>当然，这个汇编函数虽然名称也叫<code>read</code>，但并不是在执行读取文件的逻辑，而是在建立用户态与内核态的桥梁。<code>usys.pl</code>脚本的实现如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">#!/usr/bin/perl -w  <br>  <br># Generate usys.S, the stubs <span class="hljs-keyword">for</span> syscalls.  <br>  <br>print <span class="hljs-string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;  <br>  <br>print <span class="hljs-string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;  <br>  <br>sub entry &#123;  <br>    my $name = shift;  <br>    print <span class="hljs-string">&quot;.global $name\n&quot;</span>;  <br>    print <span class="hljs-string">&quot;$&#123;name&#125;:\n&quot;</span>;  <br>    print <span class="hljs-string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;  <br>    print <span class="hljs-string">&quot; ecall\n&quot;</span>;  <br>    print <span class="hljs-string">&quot; ret\n&quot;</span>;  <br>&#125;  <br>     <br>entry(<span class="hljs-string">&quot;fork&quot;</span>);  <br>entry(<span class="hljs-string">&quot;exit&quot;</span>);  <br>entry(<span class="hljs-string">&quot;wait&quot;</span>);  <br>entry(<span class="hljs-string">&quot;pipe&quot;</span>);  <br>entry(<span class="hljs-string">&quot;read&quot;</span>);  <br>entry(<span class="hljs-string">&quot;write&quot;</span>);  <br>entry(<span class="hljs-string">&quot;close&quot;</span>);  <br>entry(<span class="hljs-string">&quot;kill&quot;</span>);  <br>entry(<span class="hljs-string">&quot;exec&quot;</span>);  <br>entry(<span class="hljs-string">&quot;open&quot;</span>);  <br>entry(<span class="hljs-string">&quot;mknod&quot;</span>);  <br>entry(<span class="hljs-string">&quot;unlink&quot;</span>);  <br>entry(<span class="hljs-string">&quot;fstat&quot;</span>);  <br>entry(<span class="hljs-string">&quot;link&quot;</span>);  <br>entry(<span class="hljs-string">&quot;mkdir&quot;</span>);  <br>entry(<span class="hljs-string">&quot;chdir&quot;</span>);  <br>entry(<span class="hljs-string">&quot;dup&quot;</span>);  <br>entry(<span class="hljs-string">&quot;getpid&quot;</span>);  <br>entry(<span class="hljs-string">&quot;sbrk&quot;</span>);  <br>entry(<span class="hljs-string">&quot;sleep&quot;</span>);  <br>entry(<span class="hljs-string">&quot;uptime&quot;</span>);<br></code></pre></td></tr></table></figure></p><p><code>usys.pl</code>是一个Perl语言文件。即使对Perl语言并没有深入了解，但根据语法规则可以大概了解它的作用：这个脚本文件将根据输入的字符名，通过<code>entry()</code>格式化生成文本文件。</p><p><code>usys.pl</code>的输入是系统调用的名称，输出内容则保存为<code>kernel/usys.S</code>。这样每个系统调用都在<code>usys.S</code>文件中都有一个实现，通过<code>global</code>声明后，用户在使用同名的函数时，会执行这里的<code>entry()</code>中的逻辑： 1. 将系统调用的ID存入a7寄存器 - 虽然输入的是名称（字符串），但是<code>kernel/syscall.h</code>文件下将字符串映射为了编号 2. 执行ecall命令 - <code>ecall</code>是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用</p><p>这样就通过<code>ecall</code>指令（中断请求）将需要的系统调用从用户态传递给了内核态。在ecall调用过程中会发生（和前文中讲到的微观操作一致，但这里只写主要内容）： 1. 关中断 2. 代码从<code>user mode</code>改到supervisor mode 3. 程序计数器<code>PC</code>的值保存进 <code>SEPC</code> 寄存器 4. CPU执行<code>STVEC</code>寄存器指向的指令（<code>PC</code>重置为 <code>STVEC</code> 寄存器的值）</p><p>问题：那么<code>STVEC</code>寄存器的值到底是多少？ 答案：<code>STVEC</code>是一个特权寄存器，只能在supervisor mode下执行，每次从内核空间返回到用户空间之前，内核会设置<code>STVEC</code>寄存器指向内核希望中断代码运行的位置（由<code>trap.c</code>中的代码设置）。</p><p>Xv6在内核页表和每个用户页表中的<strong>同一个虚拟地址</strong>上映射了 <code>trampoline page</code> 。<code>STVEC</code> 寄存器保存的地址是 <code>trampoline page</code> 的起始位置，主要执行一些保护用户态寄存器的操作。<code>trampoline page</code> 的首地址是 <code>uservec</code> 函数。所以其实<code>STVEC</code>指向了<code>kernel/trampoline.S</code>文件中的<code>uservec</code>函数。</p><p><strong>综上，其实操作系统伪装了一个系统调用的实现，当使用<code>read</code>等函数时并没有真正的读写逻辑，而是利用ecall发起中断，并通过寄存器将函数的ID告知内核，方便在内核找到函数真正的实现。</strong></p><h4 id="保护现场">保护现场</h4><p>上文讲到CPU将执行<code>uservec</code>函数（<code>kernel/trampoline.S</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c">.globl uservec  <br>uservec:      <br>   #  <br>        <span class="hljs-meta"># trap.c sets stvec to point here, so  </span><br>        <span class="hljs-meta"># traps from user space start here,  </span><br>        <span class="hljs-meta"># in supervisor mode, but with a  </span><br>        <span class="hljs-meta"># user page table.  </span><br>        #  <br>        <span class="hljs-meta"># sscratch points to where the process<span class="hljs-string">&#x27;s p-&gt;trapframe is  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # mapped into user space, at TRAPFRAME.  </span></span><br><span class="hljs-string"><span class="hljs-meta">        #  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # swap a0 and sscratch  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # so that a0 is TRAPFRAME  </span></span><br><span class="hljs-string"><span class="hljs-meta">        csrrw a0, sscratch, a0 </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # save the user registers in TRAPFRAME  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd ra, 40(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd sp, 48(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd gp, 56(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd tp, 64(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t0, 72(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t1, 80(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t2, 88(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s0, 96(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s1, 104(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a1, 120(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a2, 128(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a3, 136(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a4, 144(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a5, 152(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a6, 160(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a7, 168(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s2, 176(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s3, 184(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s4, 192(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s5, 200(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s6, 208(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s7, 216(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s8, 224(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s9, 232(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s10, 240(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s11, 248(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t3, 256(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t4, 264(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t5, 272(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t6, 280(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">   # save the user a0 in p-&gt;trapframe-&gt;a0  </span></span><br><span class="hljs-string"><span class="hljs-meta">        csrr t0, sscratch  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t0, 112(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld sp, 8(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld tp, 32(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld t0, 16(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld t1, 0(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        csrw satp, t1  //切换到内核页表</span></span><br><span class="hljs-string"><span class="hljs-meta">        sfence.vma zero, zero  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # a0 is no longer valid, since the kernel page  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # table does not specially map p-&gt;tf.  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # jump to usertrap(), which does not return  </span></span><br><span class="hljs-string"><span class="hljs-meta">        jr t0</span></span><br></code></pre></td></tr></table></figure><p>在进程的结构中有一个结构体变量名为<code>trapframe</code>，它的作用是： 1. 发生中断时，保存进程在用户态使用的各种寄存器的值，以便于到时候恢复进程运行状态。 2. 保存完成后，加载进程在内核态运行需要使用的寄存器的值</p><p>在上面的代码中： 1. 先使用<code>csrrw</code>指令，将a0寄存器设置为<code>sscratch</code>寄存器的值，此时a0指向进程的<code>trapframe</code>结构。按照特定的顺序，保存寄存器的值。从偏移量40开始是因为，0到40（5 * 8）之间保存了5个内核态相关的值<code>（kernel_satp，kernel_sp，kernel_trap，epc，kernel_hartid）</code>，具体可参考<code>proc.h</code>文件中<code>trapframe</code>的结构。 2. 恢复内核栈指针，将5个内核态相关的值加载进寄存器中，然后强制跳转执行<code>usertrap</code>函数（地址存储在<code>p-&gt;trapframe-&gt;kernel_trap</code>）。</p><h4 id="中断处理">中断处理</h4><p>在保存好上下文之后就要开始执行中断处理的逻辑了，这里使用的栈已经从用户栈变成了内核栈 <code>usertrap</code>函数的代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  </span><br><span class="hljs-comment">// handle an interrupt, exception, or system call from user space.  </span><br><span class="hljs-comment">// called from trampoline.S  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;  <br>  <br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)   <span class="hljs-comment">//判断中断是否合法</span><br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);  <br>  <br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),  </span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.  </span><br>  w_stvec((uint64)kernelvec);  <br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>    <br>  <span class="hljs-comment">// save user program counter.  </span><br>  p-&gt;trapframe-&gt;epc = r_sepc();  <span class="hljs-comment">//保存sepc寄存器的值，前文提到了ecall指令执行后会将当前的PC保存到sepc中，因此 p-&gt;trapframe-&gt;epc其实指向ecall的最后一条指令</span><br>    <br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;   <span class="hljs-comment">//scause记录了发生中断的原因，8是系统调用的代号</span><br>    <span class="hljs-comment">// system call  </span><br>  <br>    <span class="hljs-keyword">if</span>(p-&gt;killed)  <br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);  <br>  <br>    <span class="hljs-comment">// sepc points to the ecall instruction,  </span><br>    <span class="hljs-comment">// but we want to return to the next instruction.    </span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;   <span class="hljs-comment">//此时epc指向ecall，我们恢复上下文后执行下一条指令，因此+4</span><br>  <br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,  </span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.    </span><br>    intr_on();   <span class="hljs-comment">//开中断，允许内核在执行系统调用时嵌套中断</span><br>  <br>    syscall(); <br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;  <br>    <span class="hljs-comment">// ok  </span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());  <br>    p-&gt;killed = <span class="hljs-number">1</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-keyword">if</span>(p-&gt;killed)  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);  <br>  <br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.  </span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)  <br>    yield();  <br>  <br>  usertrapret();  <br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>usertrap</code>负责中断处理，主要通过调用三个函数完成<code>syscall,yield,usertrapret</code></p><p><code>yield</code>是在发生时钟中断时的处理逻辑，进程修改自己的状态并自愿放弃CPU使用权 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Give up the CPU for one scheduling round.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  acquire(&amp;p-&gt;lock);  <br>  p-&gt;state = RUNNABLE;  <br>  sched();  <br>  release(&amp;p-&gt;lock);  <br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>syscall()</code>是在发生系统调用时的处理逻辑： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> num;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  num = p-&gt;trapframe-&gt;a7;  <br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;  <br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <span class="hljs-comment">//执行系统调用</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,  <br>            p-&gt;pid, p-&gt;name, num);  <br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>前文讲到在使用函数<code>read</code>时，并没有真正的实现代码，而是一步一步走到了这里，现在终于可以开始执行具体的<code>read</code>逻辑了。在<code>syscall</code>函数中，a7寄存器中保存了<code>read</code>的编号，系统调用表提供了一个从编号到对应函数指针的实现，通过函数指针就能找到对应需要执行的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//syscalls是一个函数指针数组</span><br><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;  <br>[SYS_fork]    sys_fork,   <span class="hljs-comment">//sys_fork是一个宏定义，其实是数字1</span><br>[SYS_exit]    sys_exit,   <span class="hljs-comment">//同理</span><br>[SYS_wait]    sys_wait,  <br>[SYS_pipe]    sys_pipe,  <br>[SYS_read]    sys_read,  <br>[SYS_kill]    sys_kill,  <br>[SYS_exec]    sys_exec,  <br>[SYS_fstat]   sys_fstat,  <br>[SYS_chdir]   sys_chdir,  <br>[SYS_dup]     sys_dup,  <br>[SYS_getpid]  sys_getpid,  <br>[SYS_sbrk]    sys_sbrk,  <br>[SYS_sleep]   sys_sleep,  <br>[SYS_uptime]  sys_uptime,  <br>[SYS_open]    sys_open,  <br>[SYS_write]   sys_write,  <br>[SYS_mknod]   sys_mknod,  <br>[SYS_unlink]  sys_unlink,  <br>[SYS_link]    sys_link,  <br>[SYS_mkdir]   sys_mkdir,  <br>[SYS_close]   sys_close,  <br>&#125;;<br></code></pre></td></tr></table></figure><p><code>sys_read</code>代码如下，此时才执行真正的<code>read</code>逻辑 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_read</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span>  <br>  <span class="hljs-type">int</span> n;  <br>  uint64 p;  <br>  <br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;n) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;p) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  <span class="hljs-keyword">return</span> fileread(f, p, n);  <br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code>完成了系统调用过程并将返回值保存在a0寄存器，系统调用逻辑执行完毕，因此需要开始中断返回。</p><h4 id="中断返回">中断返回</h4><p><code>usertrapret</code>函数被<code>usertrap</code>调用，用来从内核态返回用户态 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  </span><br><span class="hljs-comment">// return to user space  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();   <br>  <br>  <span class="hljs-comment">// we&#x27;re about to switch the destination of traps from  </span><br>  <span class="hljs-comment">// kerneltrap() to usertrap(), so turn off interrupts until  </span><br>  <span class="hljs-comment">// we&#x27;re back in user space, where usertrap() is correct.  </span><br>  intr_off();  <span class="hljs-comment">//关中断，不能在执行中断恢复过程时嵌套中断</span><br>  <br>  <span class="hljs-comment">// send syscalls, interrupts, and exceptions to trampoline.S  </span><br>  <span class="hljs-comment">// 因为在执行ecall指令后，CPU几哦执行STVEC寄存器指向的指令（PC重置为 STVEC寄存器的值）</span><br>  <span class="hljs-comment">// 所以设置STVEC寄存器的值为我们想要中断发生时执行的代码的地址（前文提到的uservec函数）</span><br>  w_stvec(TRAMPOLINE + (uservec - trampoline));  <br>  <br>  <span class="hljs-comment">// set up trapframe values that uservec will need when  </span><br>  <span class="hljs-comment">// the process next re-enters the kernel.  </span><br>  <span class="hljs-comment">// 和发生中断时保存上下文类似，内核使用完毕，即将进入用户态，要将目前的值保存起来，</span><br>  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="hljs-comment">// kernel page table  </span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack  </span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;  <br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid()  </span><br>  <br>  <span class="hljs-comment">// set up the registers that trampoline.S&#x27;s sret will use  // to get to user space.     // set S Previous Privilege mode to User.  </span><br>  <span class="hljs-comment">// 设置CPU特权等级，从supervisor mode 到user mode（也就是将操作系统从内核态修改为用户态）</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_sstatus();  <br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// clear SPP to 0 for user mode  </span><br>  x |= SSTATUS_SPIE; <span class="hljs-comment">// enable interrupts in user mode  </span><br>  w_sstatus(x);  <br>  <br>  <span class="hljs-comment">// set S Exception Program Counter to the saved user pc.  </span><br>  w_sepc(p-&gt;trapframe-&gt;epc);   <span class="hljs-comment">//修改sepc寄存器的值，在sret指令后，sepc的值会写入pc，此时sepc指向ecall的下一条指令</span><br>  <br>  <span class="hljs-comment">// tell trampoline.S the user page table to switch to.  </span><br>  uint64 satp = MAKE_SATP(p-&gt;pagetable);  <br>  <br>  <span class="hljs-comment">// jump to trampoline.S at the top of memory, which   </span><br>  <span class="hljs-comment">// switches to the user page table, restores user registers,  </span><br>  <span class="hljs-comment">// and switches to user mode with sret.  </span><br>  uint64 fn = TRAMPOLINE + (userret - trampoline);  <br>  <br>  <span class="hljs-comment">//调用userret函数（trampoline.S），userret(TRAPFRAME, pagetable)</span><br>  ((<span class="hljs-type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp); <br>&#125;<br><br></code></pre></td></tr></table></figure></p><p><code>userret</code>函数如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c">.globl userret  <br>userret:  <br>        <span class="hljs-meta"># userret(TRAPFRAME, pagetable)  </span><br>        <span class="hljs-meta"># switch from kernel to user.  </span><br>        <span class="hljs-meta"># usertrapret() calls here.  </span><br>        # a0: TRAPFRAME, in user page table.   函数传参时使用a0，a1寄存器<br>        # a1: user page table, <span class="hljs-keyword">for</span> satp.  <br>  <br>        <span class="hljs-meta"># switch to the user page table.  </span><br>        csrw satp, a1  <br>        sfence.vma zero, zero  <br>  <br>        <span class="hljs-meta"># put the saved user a0 in sscratch, so we  </span><br>        <span class="hljs-meta"># can swap it with our a0 (TRAPFRAME) in the last step.  </span><br>        ld t0, <span class="hljs-number">112</span>(a0)  <br>        csrw sscratch, t0  <br>  <br>        <span class="hljs-meta"># restore all but a0 from TRAPFRAME  </span><br>        ld ra, <span class="hljs-number">40</span>(a0)  <br>        ld sp, <span class="hljs-number">48</span>(a0)  <br>        ld gp, <span class="hljs-number">56</span>(a0)  <br>        ld tp, <span class="hljs-number">64</span>(a0)  <br>        ld t0, <span class="hljs-number">72</span>(a0)  <br>        ld t1, <span class="hljs-number">80</span>(a0)  <br>        ld t2, <span class="hljs-number">88</span>(a0)  <br>        ld s0, <span class="hljs-number">96</span>(a0)  <br>        ld s1, <span class="hljs-number">104</span>(a0)  <br>        ld a1, <span class="hljs-number">120</span>(a0)  <br>        ld a2, <span class="hljs-number">128</span>(a0)  <br>        ld a3, <span class="hljs-number">136</span>(a0)  <br>        ld a4, <span class="hljs-number">144</span>(a0)  <br>        ld a5, <span class="hljs-number">152</span>(a0)  <br>        ld a6, <span class="hljs-number">160</span>(a0)  <br>        ld a7, <span class="hljs-number">168</span>(a0)  <br>        ld s2, <span class="hljs-number">176</span>(a0)  <br>        ld s3, <span class="hljs-number">184</span>(a0)  <br>        ld s4, <span class="hljs-number">192</span>(a0)  <br>        ld s5, <span class="hljs-number">200</span>(a0)  <br>        ld s6, <span class="hljs-number">208</span>(a0)  <br>        ld s7, <span class="hljs-number">216</span>(a0)  <br>        ld s8, <span class="hljs-number">224</span>(a0)  <br>        ld s9, <span class="hljs-number">232</span>(a0)  <br>        ld s10, <span class="hljs-number">240</span>(a0)  <br>        ld s11, <span class="hljs-number">248</span>(a0)  <br>        ld t3, <span class="hljs-number">256</span>(a0)  <br>        ld t4, <span class="hljs-number">264</span>(a0)  <br>        ld t5, <span class="hljs-number">272</span>(a0)  <br>        ld t6, <span class="hljs-number">280</span>(a0)  <br>  <br>   <span class="hljs-meta"># restore user a0, and save TRAPFRAME in sscratch  </span><br>        csrrw a0, sscratch, a0  <br>          <br>        <span class="hljs-meta"># return to user mode and user pc.  </span><br>        <span class="hljs-meta"># usertrapret() set up sstatus and sepc.  </span><br>        sret<br></code></pre></td></tr></table></figure></p><p><code>userret</code>代码的主要功能和<code>uservec</code>正好相反，后者是将用户运行时的寄存器信息保存起来，切换到内核页表；前者是将这些保存起来的寄存器值恢复回去，切换到用户页表</p><p>随着<code>sret</code>指令的调用，整个中断过程完成，sepc寄存器中的值填回pc，用户程序恢复正常执行</p><h2 id="system-call-tracing">System call tracing</h2><p>参照教程，在实验2前应该： - 仔细阅读<code>Chapter 2、 Chapter 4 的 Sections 4.3 and 4.4</code> - 仔细阅读<code>user/user.h</code>,<code>user/usys.pl</code>，学习xv6中工具函数和系统调用原型 - 仔细阅读<code>kernel/syscall.h</code>,<code>kernel/syscall.c</code>,系统调用实现 - 仔细阅读<code>kernel/proc.h</code>,<code>kernel/proc.c</code>，进程代码实现</p><p>如果是从前文一步一步看到这里，那么这些代码相当于已经看过了，下面直接看练习要求： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">实验要求：<br><br>实现一个系统调用追踪的功能：trace mask command命令，<br>- mask 表示系统调用号的掩码<br>- command 表示命令<br>- 能够实现如下效果<br><br><span class="hljs-comment">//因由于read的系统调用号是5，因此（1 &lt;&lt; 5,10000) 如果输入的数字从右往左第六位为1，则需要追踪read，即十进制数字32表示仅需要追踪read系统调用</span><br>$ trace <span class="hljs-number">32</span> grep hello README<br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">1023</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">966</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">70</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">0</span><br><br><span class="hljs-comment">//2147483647的二进制是1111111111111111111111111111111，因为所有位都为1，说明所有系统调用都需要追踪</span><br>$ trace <span class="hljs-number">2147483647</span> grep hello README<br><span class="hljs-number">4</span>: syscall trace -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">4</span>: syscall exec -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">4</span>: syscall open -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">1023</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">966</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">70</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">4</span>: syscall close -&gt; <span class="hljs-number">0</span><br><br><span class="hljs-comment">//没有trace指令，不追踪，不能影响其他程序的正常运行</span><br>$ grep hello README<br>$<br><br><span class="hljs-comment">//fork的系统调用号是1，因此(1 &lt;&lt; 2，2)如果输入的数字从右往左第二位为1，则仅需要追踪fork，</span><br>$ trace <span class="hljs-number">2</span> usertests forkforkfork<br>usertests starting<br>test forkforkfork: <span class="hljs-number">407</span>: syscall fork -&gt; <span class="hljs-number">408</span><br><span class="hljs-number">408</span>: syscall fork -&gt; <span class="hljs-number">409</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">410</span><br><span class="hljs-number">410</span>: syscall fork -&gt; <span class="hljs-number">411</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">412</span><br><span class="hljs-number">410</span>: syscall fork -&gt; <span class="hljs-number">413</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">414</span><br><span class="hljs-number">411</span>: syscall fork -&gt; <span class="hljs-number">415</span><br><br></code></pre></td></tr></table></figure></p><p>理解了需求，再结合前文提到的系统调用过程，可以想想我们为了完成任务可以做些什么？ 首先，一个完整的系统调用从一个用户态的<code>shell</code>函数开始，trace.c文件已经提供给了我们： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br>  <br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>  <br>&#123;  <br>    <span class="hljs-type">int</span> i;  <br>    <span class="hljs-comment">//存储待跟踪程序的名称和参数  </span><br>    <span class="hljs-type">char</span> *nargv[MAXARG];  <br>  <br>    <span class="hljs-comment">//保证trace的参数不少于三个，并且跟踪的系统调用号在0-99之间  </span><br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">3</span> || (argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-string">&#x27;9&#x27;</span>))&#123;  <br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: %s mask command\n&quot;</span>, argv[<span class="hljs-number">0</span>]);  <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br>    <span class="hljs-comment">//调用trace系统调用，传入待跟踪系统调用号  </span><br>    <span class="hljs-keyword">if</span> (trace(atoi(argv[<span class="hljs-number">1</span>])) &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="hljs-number">0</span>]);  <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br>    <span class="hljs-comment">//保存待跟踪程序的名称和参数  </span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;  <br>        nargv[i<span class="hljs-number">-2</span>] = argv[i];  <br>    &#125;  <br>    <span class="hljs-comment">//运行待跟踪的程序  </span><br>    exec(nargv[<span class="hljs-number">0</span>], nargv);  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <br>&#125;<br></code></pre></td></tr></table></figure> 由于trace的语法规定了，第二个参数必须是待追踪系统调用的数字，因此具体的执行逻辑就是通过<code>argv[2]</code>取出这个数字，然后传递到内核态，然后执行一系列的操作。</p><p>当我们需要完成一个系统调用，有了用户态的代码，自然需要增加对该系统调用的用户态声明，即在<code>user/user.h</code>文件中新增trace的系统调用声明<code>int trace(int);</code></p><p>有了声明就需要有实现，但这个实现不是真正的函数实现，而是凭借<code>ecall</code>指令进入内核态，这个部分是<code>usys.pl</code>负责完成，因此需要在代码中增添<code>entry(trace)</code></p><p><code>entry(trace)</code>，将trace的系统调用名称放入a7寄存器，下一步就是通过系统调用名称在系统调用表中找到对应的系统调用编号。因此需要在<code>kernel/syscall.h</code>中新增<code>#define SYS_trace  22</code>，并且在<code>kernel/syscall.c</code>中增添<code>sys_trace</code>的函数声明<code>extern uint64 sys_trace(void);</code>，在系统调用表中新增<code>SYS_trace</code>（即22号调用）到函数实现的映射关系，<code>[SYS_trace]   sys_trace,</code></p><p>最后，这是个和进程相关的系统调用，因此在<code>kernel/sysproc.c</code>中新增<code>sys_trace</code>函数的实现。</p><p>完成了前面的步骤，看着下面空荡荡的函数代码，我们应该怎么去完成一个trace任务呢？ <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>由于我们可能会追踪任何一个系统调用，但我们不可能修改所有系统调用的代码，因此可以想到从他们共有的内容下手，<strong>由于所有的系统调用都是通过<code>syscall.c中的syscall</code>函数来执行的，并且所有系统调用的运行参数和结果均保存在<code>proc</code>结构体中的<code>trapframe</code>结构体中，例如a7保存当前进程系统调用的编号，a0表示系统调用执行的结果。因此只需要<code>proc结构体 + syscall函数</code>，我们就可以达成任务目标。</strong></p><p>可以考虑先在proc结构体中添加一个标记，作为判断执行trace的判断标准，然后在syscall添加一段逻辑：如果当前proc对应的标记为真，则打印输出当前系统调用的结果。</p><p>总结以上过程： 1. 在proc结构体中添加标记：<code>int trace_mask;</code> 2. 修改<code>syscall</code>函数：<code>num</code>是系统调用号，如果<code>（1 &lt;&lt; num）与mask（用户输入的值）的&amp;运算结果为1</code>，则说明需要执行<code>trace</code>操作，例如如果<code>mask</code>的第二位和第六位都为1，则<code>num</code>为<code>read</code>和<code>fork</code>时就需要执行<code>trace</code>操作。 注意：由于在内核态只能拿到系统调用编号，但是用户希望在看到的是系统调用的名称，因此还需要一个表格，建立从系统调用编号到系统调用名称的映射，也就是下面代码中的<code>syscalls_name</code> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//lab2 trace 添加识别名  </span><br>   <span class="hljs-type">char</span>* syscalls_name[<span class="hljs-number">23</span>] = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;fork&quot;</span>, <span class="hljs-string">&quot;exit&quot;</span>, <span class="hljs-string">&quot;wait&quot;</span>, <span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>, <span class="hljs-string">&quot;kill&quot;</span>,                <span class="hljs-string">&quot;exec&quot;</span>,  <span class="hljs-string">&quot;fstat&quot;</span>, <span class="hljs-string">&quot;chdir&quot;</span>, <span class="hljs-string">&quot;dup&quot;</span>, <span class="hljs-string">&quot;getpid&quot;</span>, <span class="hljs-string">&quot;sbrk&quot;</span>, <span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-string">&quot;uptime&quot;</span>,                   <span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;write&quot;</span>, <span class="hljs-string">&quot;mknod&quot;</span>, <span class="hljs-string">&quot;unlink&quot;</span>, <span class="hljs-string">&quot;link&quot;</span>, <span class="hljs-string">&quot;mkdir&quot;</span>, <span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-string">&quot;trace&quot;</span>&#125;;<br>   <br>   <span class="hljs-type">void</span>  <br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> num;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  num = p-&gt;trapframe-&gt;a7;  <br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;  <br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <br>    <span class="hljs-comment">//---------------------添加的部分--------------------------------------</span><br>    <span class="hljs-keyword">if</span>(p-&gt;trace_mask &amp; (<span class="hljs-number">1</span> &lt;&lt; num))&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid,syscalls_name[num],p-&gt;trapframe-&gt;a0);  <br>    &#125;  <br>    <span class="hljs-comment">//--------------------------------------------------------------------</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,  <br>            p-&gt;pid, p-&gt;name, num);  <br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>由此可见，trace操作的核心代码并不在<code>sys_trace</code>函数中，而是在<code>syscall</code>函数，那么<code>sys_trace</code>函数是干什么用的？</p><p>答案：取参数。用户态的trace.c代码中写明，使用trace时会传递一个参数，表示需要监视的系统调用号，而函数传参则是通过寄存器，第一个参数保存在a0寄存器，取参数需要使用<code>syscall.c中的argraw，argaddr，argint</code>三个函数，具体的实现可以看代码，<code>argraw(n)</code>是获取了发生中断时，<span class="math inline">\(a_n\)</span>寄存器对应的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> uint64  <br><span class="hljs-title function_">argraw</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <span class="hljs-keyword">switch</span> (n) &#123;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a0;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a1;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a2;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a3;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a4;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a5;  <br>  &#125;  <br>  panic(<span class="hljs-string">&quot;argraw&quot;</span>);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;<br> <br><span class="hljs-comment">// Fetch the nth 32-bit system call argument.  </span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">argint</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> *ip)</span>  <br>&#123;  <br>  *ip = argraw(n);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>sys_trace</code>代码如下，将取回的参数放入proc结构体 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> mask;  <br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;mask) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  myproc()-&gt;trace_mask = mask;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>另外，实验要求fork新诞生的子进程执行系统调用时也要打印出来，因此需要修改fork代码，子进程的<code>trace_mask</code>值应与父进程保持一致：<code>np-&gt;trace_mask = p-&gt;trace_mask;</code></p><p>这样整个实验就完成了</p><h2 id="section"></h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab1 Xv6 and Unix utilities</title>
    <link href="/2023/08/14/Lab1-Xv6-and-Unix-utilities/"/>
    <url>/2023/08/14/Lab1-Xv6-and-Unix-utilities/</url>
    
    <content type="html"><![CDATA[<p><a href="%5BLab:%20Xv6%20and%20Unix%20utilities%20(mit.edu)%5D(https://pdos.csail.mit.edu/6.828/2021/labs/util.html)">课程地址</a>_</p><h2 id="配置环境">1. 配置环境</h2><ul><li><p>安装依赖 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu<br></code></pre></td></tr></table></figure> 出现网速不够的情况自行换源</p></li><li><p>git获取课程配套代码 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021<br></code></pre></td></tr></table></figure> 在根目录下运行<code>make qemu</code>，看见如下输出即启动成功 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m <span class="hljs-number">128</span>M -smp <span class="hljs-number">3</span> -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.<span class="hljs-number">0</span><br><br><span class="hljs-attribute">xv6</span> kernel is booting<br><br><span class="hljs-attribute">hart</span> <span class="hljs-number">1</span> starting<br><span class="hljs-attribute">hart</span> <span class="hljs-number">2</span> starting<br><span class="hljs-attribute">init</span>: starting sh<br></code></pre></td></tr></table></figure></p></li></ul><h2 id="sleep指令">2. sleep指令</h2><p><strong>实验要求</strong>：为 xv6 系统实现 UNIX 的 sleep 程序。你的 sleep 程序应该使当前进程暂停相应的时钟周期数，时钟周期数由用户指定。例如执行 sleep 100 ，则当前进程暂停，等待 100 个时钟周期后才继续执行。</p><p>安装好xv6系统内核后，观察项目代码（我这里已经编译过，所以实际可能有所不同），可以发现用户态的代码聚集在user文件夹下，内核态的代码聚集在kernel文件夹下</p><p>课程需要我们仿照user目录下的命令（例如ls），写一个sleep命令，在开始这个任务前，我们有一些前置工作需要完成 1. 阅读<a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6 book</a>中的Chapter 1 2. 阅读user/目录下的所有程序，理解如何编写一个命令行程序</p><p><a href>这个链接</a>包含了我对整本书的阅读理解</p><p>通过观察user文件夹下的其他代码，可以发现如果想要实现自己的函数，需要将代码放在user文件夹下，然后将文件名称写入makefile的UPROGS <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">UPROGS=\  <br>   $U/_cat\  <br>   $U/_echo\  <br>   $U/_forktest\  <br>   $U/_grep\  <br>   $U/_init\  <br>   $U/_kill\  <br>   $U/_ln\  <br>   $U/_ls\  <br>   $U/_mkdir\  <br>   $U/_rm\  <br>   $U/_sh\  <br>   $U/_stressfs\  <br>   $U/_usertests\  <br>   $U/_grind\  <br>   $U/_wc\  <br>   $U/_zombie\<br>   $U/_sleep\  <span class="hljs-comment">//新的代码要按格式加在这里</span><br></code></pre></td></tr></table></figure></p><p>所有实验都只能使用XV6所提供的函数，记录在user.h文件下 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// system calls  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((<span class="hljs-keyword">noreturn</span>))</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">void</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">exec</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>**)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">mknod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">short</span>, <span class="hljs-type">short</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> stat*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">getpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">sbrk</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;   <span class="hljs-comment">//本次实验需要使用的系统调用</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">uptime</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <br>  <br><span class="hljs-comment">// ulib.c  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-keyword">struct</span> stat*)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">void</span> *<span class="hljs-title function_">memmove</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">strchr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">char</span> c)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*, ...)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, ...)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">gets</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">int</span> max)</span>;  <br>uint <span class="hljs-title function_">strlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">void</span>* <span class="hljs-title function_">memset</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">int</span>, uint)</span>;  <br><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(uint)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">memcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *, uint)</span>;  <br><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *, uint)</span>;<br></code></pre></td></tr></table></figure></p><p>模仿其他文件例如rm.c，我们可以发现，需要使用int等数据类型，因此需要引入kernel/types.h头文件，还需要包含系统调用声明的头文件user.h，stat.h中包含了与文件相关的结构体。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//rm.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>   <br><span class="hljs-comment">//程序入口，argc表示参数个数，argv分别表示每个具体参数,argv[0]是命令本身</span><br>&#123;  <br>  <span class="hljs-type">int</span> i;  <br>  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;   <span class="hljs-comment">//error处理</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: rm files...\n&quot;</span>);  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);   <br>  &#125; <br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;   <span class="hljs-comment">//循环获取参数然后执行操作</span><br>    <span class="hljs-keyword">if</span>(unlink(argv[i]) &lt; <span class="hljs-number">0</span>)&#123;  <br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;rm: %s failed to delete\n&quot;</span>, argv[i]);  <br>      <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>  &#125;  <br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//正常退出</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>通过观察rm.c以及其他要求观察的代码，我们可以发现实现一个可以在shell中运行程序需要按照如下模板： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从kernel和user中获取需要的头文件，sleep不需要文件操作，所以不需要stat.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br><br><span class="hljs-comment">//程序入口，argc表示参数个数，argv分别表示每个具体参数,argv[0]是命令本身</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>   <br>&#123;  <br><span class="hljs-comment">//参数处理模块</span><br><span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;  <br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: xxx files...\n&quot;</span>);  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);   <br>&#125; <br><br><span class="hljs-comment">//获取参数，执行程序的模块</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;   <br><br>    &#125;  <br><br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//正常退出</span><br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>按照要求完成sleep代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: sleep &lt;ticks&gt;\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> ticks = atoi(argv[<span class="hljs-number">1</span>]); <br>    sleep(ticks);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure> 在目录下使用执行测试：./grade-lab-util sleep 结果如下： <img src="20230718234029.png" alt="实验结果"></p><h2 id="pingpong">3. pingpong</h2><p><strong>实验要求</strong>：使用 UNIX 系统调用编写一个程序 pingpong ，在一对管道上实现两个进程之间的通信。父进程应该通过第一个管道给子进程发送一个信息 “ping”，子进程接收父进程的信息后打印 <pid>: received ping ，其中是其进程 ID 。然后子进程通过另一个管道发送一个信息 “pong” 给父进程，父进程接收子进程的信息然后打印 <pid>: received pong ，然后退出。</pid></pid></p><p><strong>实验提示</strong>： - 使用 pipe 创建管道。 - 使用 fork 创建一个子进程。 - 使用 read 从管道读取信息，使用 write 将信息写入管道。 - 使用 getpid 获取当前 进程 ID 。 - 将程序添加到 Makefile 中的 UPROGS 。 - xv6 上的用户程序具有有限的库函数可供它们使用。你可以在 user/user.h 中查看，除系统调用外其他函数代码位于 user/ulib.c 、user/printf.c 、和 user/umalloc.c 中。</p><p><strong>实验代码</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br>    pipe(p);<br>    pipe(p1);  <span class="hljs-comment">//开启两个管道，p用于父进程向子进程传输，p1则相反</span><br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;  <br>        close(p[<span class="hljs-number">1</span>]);       <span class="hljs-comment">//子进程关闭p的写入端，管道不能有多余的端口</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];  <br>        read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-number">10</span>);  <span class="hljs-comment">//利用p从父进程读取信息</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf);  <span class="hljs-comment">//打印读取到的信息</span><br>        close(p[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//关闭p的读取端，完成一次传输</span><br>        close(p1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//子进程关闭p1的读取端，准备向父进程传输信息</span><br>        write(p1[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">//写入信息</span><br>        close(p1[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//写入完成，关闭p1的写入端</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        close(p[<span class="hljs-number">0</span>]);     <span class="hljs-comment">//父进程关闭p的读取端，管道不能有多余的端口</span><br>        write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;pong&quot;</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment">//向子进程传输信息</span><br>        close(p[<span class="hljs-number">1</span>]);   <span class="hljs-comment">//写入完成，关闭p的写入端口</span><br>        close(p1[<span class="hljs-number">1</span>]);    <span class="hljs-comment">//关闭p1管道的写入端，准备从子进程读取信息</span><br>        <span class="hljs-type">char</span> buf1[<span class="hljs-number">10</span>];  <br>        read(p1[<span class="hljs-number">0</span>], buf1, <span class="hljs-number">10</span>); <span class="hljs-comment">//利用p1从子进程读取信息 </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf1); <br>        close(p1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//读取完成，关闭读取端</span><br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//正常结束，退出</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>整个实验其实是考察对管道的理解程度，让我们熟练应用管道</p><h2 id="primes">3. primes</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc make makefile概述</title>
    <link href="/2023/08/07/gcc-make-makefile%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/08/07/gcc-make-makefile%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>MIT6.S081的实验都是基于C语言完成的，每当完成一个新函数（例如Lab1的sleep函数），都需要将它加入到makefile文件中编辑，那么弄清楚makefile，gcc相关的一些编译知识就非常有必要了。</p><h2 id="gcc概述">GCC概述</h2><p>gcc是一个编译器，将一个c语言代码编译为可执行文件的流程如下： <img src="20230714160858.png"></p><p><strong>1. 预处理（pre-processing）</strong> <code>gcc -E hello.c -o hello.i</code>，将引入的头文件（#include）和定义的宏（#define）扩展到代码中，预处理之后的程序还是文本，可以用文本编辑器打开，上述命令中-E是让编译器在预处理之后就退出，不进行后续编译过程</p><p><strong>2. 编译（compilation）</strong> <code>gcc -S hello.i -o hello.s</code>，将预处理过的文件编译成汇编程序，在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error）</p><p><strong>3. 汇编（assembly）</strong> <code>gcc -c hello.s hello.o</code>，将汇编程序转换成目标文件，二进制格式机器码，每一个源文件都需要产生一个目标文件</p><p><strong>4. 链接（linker）</strong> <code>gcc hello.o -o hello</code>，将一个或多个目标文件连接成最终的可执行文件</p><h2 id="gcc常用参数">GCC常用参数</h2><ol type="1"><li>--version 查看版本</li><li>-v（verbose冗长的），输出编译的详细信息</li><li>-std 指定标准</li><li>-o 指定输出文件的名称</li><li>-Wall 输出所有的警告信息</li><li>-c 只将源文件编译为 object 文件（*.o），而不进行链接，之后可以使用 <code>gcc -o myprog.exe file1.o file2.o</code> 将多个 object 文件连接成可执行文件</li><li>-shared 编译为共享库（<em>.dll，</em>.so）</li><li>-S 编译为汇编代码</li></ol><h2 id="makefile">Makefile</h2><p><strong>会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力</strong>。因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按<strong>类型、功能、模块</strong>分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作</p><p>因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile成为了一种在工程方面的编译方法。</p><p>但是不同的厂商make各不相同，本介绍只对GNU的make进行介绍。</p><h4 id="makefile里有什么">Makefile里有什么？</h4><p>Makefile里主要包含了<strong>五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</strong></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book Chapter2</title>
    <link href="/2023/07/27/xv6-book-Chapter2/"/>
    <url>/2023/07/27/xv6-book-Chapter2/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter2-操作系统组织结构">Chapter2 操作系统组织结构</h1><p>Chapter 1中主要提到了操作系统提供的常见接口（系统调用），并且利用这些接口实现了一些可以在shell窗口运行的程序，但是并没有进入到内核中去。</p><p>一个操作系统最核心的功能就是给用户提供使用硬件的环境，可以井井有条的运行多个程序。这个过程涉及到了几个问题： 1. 操作系统如何为进程分配资源？（资源分配） 2. 操作系统如何确保所有进程都能执行？即使进程数量大于CPU数量（进程调度）， 3. 一个进程发生故障怎样才能不影响其他进程？（隔离） 4. 进程之间如何拥有安全的交互渠道?（管道） 总的来说，上面的问题可以展现出人们对操作系统的三个核心需求：多路复用，隔离和交互</p><p>Chapter 2的主要目标就是： 1. 理解如何组织操作系统（单片内核）以实现这三个核心需求 2. 弄清楚xv6系统启动时运行的第一个进程（xv6系统的隔离单元）</p><p>注意：Xv6运行在多核RISC-V微处理器上，它的许多底层功能（例如进程实现）是针对于RISC-V的。RISC-V是64位CPU，而xv6是用“LP64”C语言编写的，这意味着C编程语言中的long数据类型和指针大小是64位，而int是32位。本书假设读者已经在某些架构上做了一些机器级编程，并将介绍risc - v特定的思想</p><h2 id="操作系统抽象硬件资源的意义">操作系统抽象硬件资源的意义</h2><p>为什么要有操作系统？能不能让应用程序直接和硬件发生交互？ 答案是肯定的，在这种情况下，每个应用程序都有自己定制的库，可以根据硬件的特性，以最适合的方式组织应用程序的代码设计，例如嵌入式设备的操作系统</p><p>但是这样做的缺点是：如果有多个应用程序同时执行（通用PC需要同时执行很多程序），每个程序必须定期的放弃自己目前占用的CPU，使得其他程序可以运行。这个过程要求程序相互信任且不会发生错误，在普遍的计算机设备上显然是不现实的</p><p>因此在大多数情况下，将应用程序隔离，禁止直接访问敏感的硬件资源，并将资源抽象成一种服务，是更好的方案</p><p>举个例子，假如有甲乙丙丁四个人去办公室盖公章，操作系统就像一个公章管理者，提供一种叫做&quot;盖公章&quot;的服务，甲乙丙丁四人只需要请求这个服务，操作系统就会将公章交给他使用并进行监督，一旦使用时间到了就交给下一个人。如果没有操作系统，那么每个人都可以来争抢公章并使用，一旦甲抢到了公章并且长时间使用不归还，那么其他人就一直无法完成盖公章的任务</p><p>再从计算机的角度考虑，Unix应用程序仅通过文件系统的open、write、read和close四个系统调用与存储交互，具体的磁盘管理由操作系统来完成</p><p>再比如，Unix在进程之间切换CPU，即使A程序陷入死循环，不用担心其他程序无法运行。看起来A一直死循环占用CPU，但其实每过一定时间，A会被迫暂停运行，由其他程序占用CPU</p><p>总的来说，使用操作系统抽象硬件资源的好处和API编程时&quot;封装&quot;的好处类似（方便好用，隐藏内部复杂的实现细节，可移植性，可维护性等等）</p><h2 id="cpu对进程隔离的硬件级别支持">CPU对进程隔离的硬件级别支持</h2><p>我们需要一个操作系统来为应用程序提供底层硬件的抽象服务，而系统调用接口就是操作系统具体提供服务的方式，这既为程序员提供了便利，又提供了强隔离的可能性。</p><p>为了达成这一点，操作系统必须使得应用程序不能访问其他进程的内存以及操作系统的数据结构和指令，即不同的进程之间需要相互隔离。<strong>CPU的特权等级机制为这一要求的实现提供了硬件级别的支持</strong>（通过设置一个模式位来实现）</p><p>例如，RISC-V有三种执行CPU指令的模式：User级中运行用户程序；Supervisor级中运行操作系统内核（和设备驱动）；Machine级中运行BootLoader和其它固件。 正常情况下，处理器一直在某个特权等级下运行，除非进入trap（诸如软硬件中断、异常等）才有可能发生特权等级的转换</p><p>对于现代操作系统（如Linux、Windows等）而已，用户程序都运行在用户态，当它们需要切换到内核态以获得更高权限时，需要向操作系统申请；而操作系统内核和设备驱动程序则默认就运行在内核态。每个用户线程也拥有两个栈，一个是用户态栈，一个是内核态栈，分别当处于用户态和内核态时使用。操作系统的用户态和内核态对应到处理器的硬件层面上，即为不同的特权等级。在RISC-V中，用户态一般对应User Mode，而内核态一般对应Supervisor Mode。</p><p>一般来说用户程序一直运行在用户态中，只有当发生中断才会转到内核态中 中断可以分为三类： 1. 系统调用（又称陷入），在程序中使用系统调用引起； 2. 异常，当应用程序运行时出现异常时（比如最常见的缺页异常）也会切换到内核态进行处理； 3. 外部中断，由CPU外部引起的中断（或者说与CPU执行指令无关的事件），如I/O中断、时钟中断</p><h2 id="单片内核与微内核">单片内核与微内核</h2><p>我们已经知道了操作系统的一些重要指令只有在Supervisor模式下才能执行，那么究竟操作系统的哪些指令应该放在Supervisor模式运行？一种可能性是整个操作系统驻留在内核中，因此所有系统调用的实现都以Supervisor模式运行，这种组织方式被称为<strong>单片内核</strong>。整个操作系统以完全硬件特权运行。</p><p>这种组织使得操作系统的不同部分更容易协作，例如一个操作系统可能有一个缓冲缓存，它可以被文件系统和虚拟内存系统共享；缺点是操作系统不同部分之间的接口通常很复杂，而且内核中出现错误时会导致所有应用程序崩溃（例如windows蓝屏），计算机必须重新启动。</p><p>为了减少在内核中出错的风险，操作系统设计者可以尽量减少在管理模式下运行的操作系统代码的数量，并在用户模式下执行大部分操作系统。这种内核组织称为<strong>微内核</strong>，如下图所示。 <img src="20230718182913.png" alt="微内核"></p><p>文件系统作为用户级进程运行。作为进程运行的操作系统服务称为服务器。为了允许应用程序与文件服务器交互，内核提供了一个进程间通信机制，将消息从一个用户模式进程发送到另一个用户模式进程。例如，如果像shell这样的应用程序想要读取或写入文件，它会向文件服务器发送消息并等待响应，内核中只保留最基本的功能（进程管理、内存管理和通信）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown">微内核和单片内核（宏内核）的区别：<br>微内核：将非基本的操作系统功能从内核移到用户态，内核中只保留最基本的功能（进程管理、内存管理和通信）<br>缺点：效率低，需要频繁地在用户态和内核态之间切换<br>优点：<br><span class="hljs-bullet">1.</span> 便于扩展操作系统，新服务可以在用户空间增加，几乎不需要修改内核。<br><span class="hljs-bullet">2.</span> 精简内核，代码量减少，更容易实现，更好debug。<br><span class="hljs-bullet">3.</span> 微内核相比于宏内核更加稳定，因为大部分功能外移，内核中可能出现的错误也相应地减少。<br><br>宏内核：将操作系统的所有功能最为一个紧密的整体都放在内核中。<br>缺点：不易扩展，内核出错概率更大，debug难<br>优点：执行效率高<br><br>微内核的操作系统有：Window,Minix,Mac等等。<br>宏内核的操作系统有：Unix，Linux等等。<br></code></pre></td></tr></table></figure><p>XV6的内核源文件（位于kernel文件目录下）如下图所示，按照模块化的概念，源代码被粗略的分成多个文件，每个文件都注释了各自的作用。defs.h文件下定义了模块间的接口。 <img src="20230718183155.png" alt="xv6源文件结构"></p><p>虽然kernel实现的比较简单，代码量甚至比一般的微内核还少，但因为XV6在内核中实现了<strong>整个操作系统</strong>，内核接口就是操作系统接口，所以XV6属于宏内核</p><h2 id="操作系统的启动过程">操作系统的启动过程</h2><p>虽然已经明白了理解了操作系统内核的概念，但是它看起来仍然是一个虚无缥缈的东西，只有先弄清楚操作系统宏观意义上是如何启动的，我们才能进一步深入操作系统内部去理解它提供的服务。</p><p>因此我们需要先弄清楚，一台计算机在刚刚通电，<strong>内存为空的情况下</strong>，CPU是如何一步一步将操作系统运行起来的？</p><p>当risc-v计算机通电后， 1. 首先把CPU所有寄存器初始化（初始值由CPU制造商设置），除了CS寄存器的值设为0xFFFF，其他寄存器的值都为0，这样，根据CS 和 IP的值就可以找到指令的物理地址0xFFFF:0x0000，也就是0xFFFF0。这个地址存放CPU的第一条指令。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">CS的全拼为Code segment，即代码段寄存器，对应于内存中的存放代码的内存区域，用来存放内存代码段区域的入口地址（段基址）<br>IP全称instruction Pointer，指针寄存器，用来记录偏移量<br>CPU在执行指令时，通过CS和IP来确定要执行的下一条指令的内存地址，计算方式一般为CS左移<span class="hljs-number">4</span>位然后加上IP寄存器<br><br>例如：<span class="hljs-number">0xFFFF0</span> = <span class="hljs-number">0xFFFF</span> &lt;&lt; <span class="hljs-number">4</span> + <span class="hljs-number">0x0000</span><br></code></pre></td></tr></table></figure> 2. CPU开始从寄存器读取并运行指令，0xFFFF0存放的是一条无条件跳转指令JMP，跳转到BIOS的位置。（Bios是一段写在ROM中的程序，内容不会随着断电小时） 3. BIOS首先先进行POST（Power－On Self Test，<strong>加电后自检</strong>）。POST主要检测系统中一些关键设备例如内存和显卡等设备是否正常工作；如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。 4. 之后CPU开始寻找引导扇区，将引导扇区中的指令加载到物理内存 0x7C00处， 修改IP寄存器的值跳转到0x7C00执行指令，从而实现了将 CPU的使用权交给引导扇区中的 Boot 程序。 5. 引导加载器装载XV6内核到内存0x8000000开始的存储空间中，然后在machine mode下，CPU从kernel/entry.s处的_entry处开始执行指令</p><h3 id="entry.s">entry.S</h3><p>进入到entry.S <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">        <span class="hljs-meta"># qemu -kernel loads the kernel at 0x80000000  </span><br>        <span class="hljs-meta"># and causes each hart (i.e. CPU) to jump there.  </span><br>        <span class="hljs-meta"># kernel.ld causes the following code to  </span><br>        <span class="hljs-meta"># be placed at 0x80000000.  </span><br>.section .text<br>.global _entry  <br>_entry:  <br>        <span class="hljs-meta"># set up a stack for C.  </span><br>        # stack0 is declared in start.c,  <br>        <span class="hljs-meta"># with a 4096-byte stack per CPU.  </span><br>        <span class="hljs-meta"># sp = stack0 + (hartid * 4096)</span><br><br>#将stack0读取到SP寄存器<br>        la sp, stack0  <br>#把<span class="hljs-number">4096</span>这个立即数存放到a0寄存器中<br>        li a0, <span class="hljs-number">1024</span>*<span class="hljs-number">4</span>  <br>        #将CPU的id读取到寄存器a1<br>        csrr a1, mhartid<br>        <span class="hljs-meta">#addi mul add三条运算指令完成sp = stack0 + (hartid * 4096)计算     </span><br>        addi a1, a1, <span class="hljs-number">1</span><br>        mul a0, a0, a1  <br>        add sp, sp, a0  <br>        #指令跳转，jump to <span class="hljs-title function_">start</span><span class="hljs-params">()</span> in start.c  <br>        call start  <br>spin:  <br>        j spin<br></code></pre></td></tr></table></figure></p><p>entry.s其实干了这些事情：为每个CPU分配了栈空间。 stack0是一个声明的外部符号，把它作为CPU的上栈的起始地址，然后按照公式，<code>sp = stack0 + (hartid * 4096)</code>，算出每个CPU对应的栈起始地址（sp是堆栈指针寄存器，hartid是CPU id，csr是控制和状态寄存器，csrr是读取csr寄存器的内容，la是地址加载指令，li是立即数加载指令）。</p><p>注意：此时CPU仍然处于machine mode，还没有切换到Supervisor Mode</p><h3 id="start.c">start.c</h3><p>代码比较长，因此会分成三个部分讲解</p><ul><li><strong>第一部分</strong> 完成了栈初始化后，CPU接下来要干什么？看看start.c的第一部分代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;param.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memlayout.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span>  </span><br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">timerinit</span><span class="hljs-params">()</span>;  <br>  <br><span class="hljs-comment">// entry.S needs one stack per CPU.  </span><br>__attribute__ ((aligned (<span class="hljs-number">16</span>))) <span class="hljs-type">char</span> stack0[<span class="hljs-number">4096</span> * NCPU];  <br>  <br><span class="hljs-comment">// a scratch area per CPU for machine-mode timer interrupts.  </span><br>uint64 timer_scratch[NCPU][<span class="hljs-number">5</span>];  <br>  <br><span class="hljs-comment">// assembly code in kernelvec.S for machine-mode timer interrupt.  </span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timervec</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li></ul><p>__attribute__定义了entry.S中的栈，要求16bit对齐</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">什么是内存对齐？<br>计算机中内存空间是按照<span class="hljs-built_in">byte</span>划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是：在访问特定类型变量的时候通常在特定的内存地址访问，这就需要对这些数据在内存中存放的位置有限制，各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。<br>内存对齐是编译器的管辖范围。表现为：编译器为程序中的每个“数据单元”安排在适当的位置上。<br><br>如果放置数据不考虑对齐，<span class="hljs-number">32</span>位的<span class="hljs-meta">CPU</span>读取一个<span class="hljs-number">4</span>字节的interesting最多需要两次内存访问（左图），如果对齐则只需要一次（如右图）<br></code></pre></td></tr></table></figure><p><img src="20230727122632.png" alt="内存对齐"> timer_scratch是一组共享变量，用于每个CPU的machine mode定时器中断 timervec是timer中断处理函数，在接下来的timerinit中会用到</p><ul><li><strong>第二部分</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// entry.S jumps here in machine mode on stack0.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">start</span><span class="hljs-params">()</span>  <br>&#123;  <br>  <span class="hljs-comment">// set M Previous Privilege mode to Supervisor, for mret.  </span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_mstatus();  <br>  x &amp;= ~MSTATUS_MPP_MASK;  <br>  x |= MSTATUS_MPP_S;  <br>  w_mstatus(x);  <br>  <br>  <span class="hljs-comment">// set M Exception Program Counter to main, for mret.  </span><br>  <span class="hljs-comment">// requires gcc -mcmodel=medany  </span><br>  w_mepc((uint64)main);  <br>  <br>  <span class="hljs-comment">// disable paging for now.  </span><br>  w_satp(<span class="hljs-number">0</span>);  <br>  <br>  <span class="hljs-comment">// delegate all interrupts and exceptions to supervisor mode.  </span><br>  w_medeleg(<span class="hljs-number">0xffff</span>);  <br>  w_mideleg(<span class="hljs-number">0xffff</span>);  <br>  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);  <br>  <br>  <span class="hljs-comment">// configure Physical Memory Protection to give supervisor mode  </span><br>  <span class="hljs-comment">// access to all of physical memory.  w_pmpaddr0(0x3fffffffffffffull);  </span><br>  w_pmpcfg0(<span class="hljs-number">0xf</span>);  <br>  <br>  <span class="hljs-comment">// ask for clock interrupts.  </span><br>  timerinit();  <br>  <br>  <span class="hljs-comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().  </span><br>  <span class="hljs-type">int</span> id = r_mhartid();  <br>  w_tp(id);  <br>  <br>  <span class="hljs-comment">// switch to supervisor mode and jump to main().  </span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;mret&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>CPU在entry.S定义了栈，然后从entry.S代码发生跳转，目的地是start.c文件中的start函数，这一段代码出现了很多读写寄存器的函数，下面进行讲解。 <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">注意：<span class="hljs-built_in">start</span>.c代码不像其他程序有main入口，因此<span class="hljs-built_in">start</span>不会像一个调用一样返回(没有returning)。由于它处于machine <span class="hljs-built_in">mode</span>下，因此其实是通过操作寄存器将这些事情设置的像一个正常执行的普通调用一样。<br></code></pre></td></tr></table></figure></p><p>无论何时，一个 RISC-V 硬件线程（hart）总是会运行在某一个特权级，而这个信息则是通过两个二进制位编码记录在了多个 <strong>CSR</strong> 寄存器（control and status registers）中，其中就包括状态寄存器（Status Register）</p><p>状态寄存器分为两种（mstatus/sstatus）作用在于记录并控制当前 CPU 的运行状态，<code>mstatus</code> 对应 M 模式，<code>sstatus</code> 对应 S 模式，具体字段如下图所示，本代码通过操作mstatus寄存器的MPP和SPP字段来达到修改CPU特权等级的目的。 <img src="20230727125258.png" alt="mstatus寄存器"></p><p>如下是代码中不容易理解的一些函数： 1. <strong>mstatus</strong>(Machine Status Registers)：保存了上一个特权模式，调用mret指令就立刻进入保存好的特权模式。因此设置好mstatus寄存器的值，再调用mret指令可以达到切换特权等级的目的。w_mstatus即write mstatus，写入mstatus寄存器，同理r_mstatus即read mstatus，表示读取mstatus寄存器的内容。 2. <strong>mepc</strong>(Machine Exception Program Counter Registers)：设置mret的返回地址。本代码将它设置为内核main函数的地址，因此mret指令完成，CPU会查询mepc寄存器，开始执行main函数。 3. <strong>satp</strong>(Supervisor Address Translation and Protection Registers)：页表寄存器，写入0就禁用了页表硬件。w_satp表示写入页表寄存器。 4. <strong>asm</strong> <strong>volatile</strong>(“xxx”); “<strong>asm</strong>” 表示后面的代码为内嵌汇编, “<strong>volatile</strong>” 表示编译器不要优化代码,后面的指令保留原样。括号里面的xxx是汇编指令。 通过这些函数，我们大概能猜到整个代码的逻辑：通过设置mstatus的模式为Supervisor Mode，mret的返回地址设置为main，再调用mret成功设置特权等级，并且让CPU紧接着准备执行main代码，这样xv6就在Supervisor Mode中进入内核程序主函数了。</p><p>具体过程如下： 1. 通过在寄存器<code>mstatus</code>中，设置之前的特权模式为Supervisor Mode(24-27行) <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_mstatus();  <br>  x &amp;= ~MSTATUS_MPP_MASK;  <br>  x |= MSTATUS_MPP_S;  <br>  w_mstatus(x);  <br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSTATUS_MPP_MASK (3L &lt;&lt; 11) <span class="hljs-comment">// previous mode.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSTATUS_MPP_M (3L &lt;&lt; 11)   3L表示long 3，3是machine mode的编码</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSTATUS_MPP_S (1L &lt;&lt; 11)   1是super</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSTATUS_MPP_U (0L &lt;&lt; 11)</span><br>riscv.h文件中定义了这几个<br></code></pre></td></tr></table></figure> 2. 通过写入main地址到寄存器<code>mepc</code>，设置返回地址为main的地址(31行) <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">w_mepc((uint64)main);  <br></code></pre></td></tr></table></figure> 3. 通过写入0到页表寄存器<code>satp</code>，在Supervisor Mode中将<strong>虚拟地址禁用</strong>(34行) <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// disable paging for now.  </span><br>w_satp(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure> 4. 将所有的异常与中断托付给Supervisor Mode(37-39行) <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// delegate all interrupts and exceptions to supervisor mode.  </span><br>w_medeleg(<span class="hljs-number">0xffff</span>);  <br>w_mideleg(<span class="hljs-number">0xffff</span>);  <br>w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);<br></code></pre></td></tr></table></figure> 事实上，在RISC-V的标准定义中，所有陷阱默认都是由机器模式(M-mode)来处理的。然而，在支持操作系统的设备上往往都实现了监管者模式(S-Mode)，如果按照默认模式发生中断则应该首先陷入M-Mode下的中断处理程序，然后触发一个S-Mode下的中断再mret回S-Mode下处理，这个过程过于繁琐且需要程序员自己实现，所以：</p><p>RISC-V标准为了应对这种情况提出了陷阱委派机制。也就是说在M-Mode下可以配置寄存器，从而使得S-Mode下的所有陷阱都被S-Mode下的陷阱处理函数自动接管。有两个寄存器，medeleg和mideleg，分别用来管理异常和中断的委派。</p><ol start="5" type="1"><li>使Supervisor Mode能够接触到所有物理内存(43-44行)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// configure Physical Memory Protection to give supervisor mode  </span><br><span class="hljs-comment">// access to all of physical memory.  </span><br>w_pmpaddr0(<span class="hljs-number">0x3fffffffffffff</span>ull);  <br>w_pmpcfg0(<span class="hljs-number">0xf</span>);<br></code></pre></td></tr></table></figure></li><li>请求时钟中断，clock初始化（具体实现在后文讲解） <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ask for clock interrupts.  </span><br>timerinit();  <br></code></pre></td></tr></table></figure></li><li>获取CPU的ID并保存在tp寄存器中 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().  </span><br>  <span class="hljs-type">int</span> id = r_mhartid();  <br>  w_tp(id);  <br></code></pre></td></tr></table></figure></li></ol><ul><li><strong>第三部分</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arrange to receive timer interrupts.  </span><br><span class="hljs-comment">// they will arrive in machine mode at  </span><br><span class="hljs-comment">// at timervec in kernelvec.S,  </span><br><span class="hljs-comment">// which turns them into software interrupts for  </span><br><span class="hljs-comment">// devintr() in trap.c.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">timerinit</span><span class="hljs-params">()</span>  <br>&#123;  <br>  <span class="hljs-comment">// each CPU has a separate source of timer interrupts.  </span><br>  <span class="hljs-type">int</span> id = r_mhartid();  <br>  <br>  <span class="hljs-comment">// ask the CLINT for a timer interrupt.  </span><br>  <span class="hljs-type">int</span> interval = <span class="hljs-number">1000000</span>; <span class="hljs-comment">// cycles; about 1/10th second in qemu.  </span><br>  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;  <br>  <br>  <span class="hljs-comment">// prepare information in scratch[] for timervec.  </span><br>  <span class="hljs-comment">// scratch[0..2] : space for timervec to save registers.  // scratch[3] : address of CLINT MTIMECMP register.  // scratch[4] : desired interval (in cycles) between timer interrupts.  uint64 *scratch = &amp;timer_scratch[id][0];  </span><br>  scratch[<span class="hljs-number">3</span>] = CLINT_MTIMECMP(id);  <br>  scratch[<span class="hljs-number">4</span>] = interval;  <br>  w_mscratch((uint64)scratch);  <br>  <br>  <span class="hljs-comment">// set the machine-mode trap handler.  </span><br>  w_mtvec((uint64)timervec);  <br>  <br>  <span class="hljs-comment">// enable machine-mode interrupts.  </span><br>  w_mstatus(r_mstatus() | MSTATUS_MIE);  <br>  <br>  <span class="hljs-comment">// enable machine-mode timer interrupts.  </span><br>  w_mie(r_mie() | MIE_MTIE);  <br>&#125;<br></code></pre></td></tr></table></figure><p>第三部分是时钟中断的初始化，可以先放着不管，后续有实验内容帮助理解中断的过程。</p><h3 id="main.c">main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;param.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memlayout.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span>  </span><br>  <br><span class="hljs-keyword">volatile</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> started = <span class="hljs-number">0</span>;  <br>  <br><span class="hljs-comment">// start() jumps here in supervisor mode on all CPUs.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">main</span><span class="hljs-params">()</span>  <br>&#123;  <br>  <span class="hljs-keyword">if</span>(cpuid() == <span class="hljs-number">0</span>)&#123;  <br>    consoleinit();  <br>    printfinit();  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xv6 kernel is booting\n&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    kinit();         <span class="hljs-comment">// physical page allocator  </span><br>    kvminit();       <span class="hljs-comment">// create kernel page table  </span><br>    kvminithart();   <span class="hljs-comment">// turn on paging  </span><br>    procinit();      <span class="hljs-comment">// process table  </span><br>    trapinit();      <span class="hljs-comment">// trap vectors  </span><br>    trapinithart();  <span class="hljs-comment">// install kernel trap vector  </span><br>    plicinit();      <span class="hljs-comment">// set up interrupt controller  </span><br>    plicinithart();  <span class="hljs-comment">// ask PLIC for device interrupts  </span><br>    binit();         <span class="hljs-comment">// buffer cache  </span><br>    iinit();         <span class="hljs-comment">// inode table  </span><br>    fileinit();      <span class="hljs-comment">// file table  </span><br>    virtio_disk_init(); <span class="hljs-comment">// emulated hard disk  </span><br>    userinit();      <span class="hljs-comment">// first user process  </span><br>    __sync_synchronize();  <br>    started = <span class="hljs-number">1</span>;  <br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-keyword">while</span>(started == <span class="hljs-number">0</span>)  <br>      ;  <br>    __sync_synchronize();  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hart %d starting\n&quot;</span>, cpuid());  <br>    kvminithart();    <span class="hljs-comment">// turn on paging  </span><br>    trapinithart();   <span class="hljs-comment">// install kernel trap vector  </span><br>    plicinithart();   <span class="hljs-comment">// ask PLIC for device interrupts  </span><br>  &#125;  <br>  <br>  scheduler();          <br>&#125;<br></code></pre></td></tr></table></figure><p>在执行完 start 函数后，开始执行 main 函数。首先，判断当前的 CPU 的 ID 是否为主 CPU（cpuid() == 0） 。</p><p>如果是主 CPU ，则执行一系列的初始化操作，包括： - <code>consoleinit();</code>控制台初始化； - <code>printfinit();</code>打印模块初始化； - <code>kinit();</code>和 <code>kvminit();</code>创建内核页表； - <code>kvminithart();</code>打开分页机制； - <code>procinit();</code>创建进程表； - <code>trapinit();</code>和 <code>trapinithart();</code> 和<code>plicinit();</code> 设置系统中断向量和系统中断初始化； - <code>plicinithart();</code>设备中断初始化； - <code>binit();</code>和<code>iinit();</code>磁盘缓冲和磁盘节点的初始化； - <code>fileinit();</code>文件系统的初始化； - <code>virtio_disk_init();</code>磁盘初始化； - <code>userinit();</code>创建第一个用户进程，第一个进程执行一个小程序 user/initcode.S ，该程序通过调用 exec 系统调用重新进入内核； - <code>sync_synchronize();</code> 是 gcc 提供的原子操作，保证内存访问的操作都是原子操作； - <code>started = 1;</code> 是设置初始化完成的标志。</p><p>如果不是主 CPU ，首先循环等待主 CPU 初始化完成，当主 CPU 初始化完成，则初始化完成标志 started 为 1 ，跳出循环。然后同样是： - <code>sync_synchronize();</code> gcc 提供的原子操作，保证内存访问的操作都是原子操作。 - <code>kvminithart();</code> 打开分页功能 - <code>trapinithart();</code>和 <code>plicinithart();</code>设置系统和设备的中断初始化。</p><p>以上函数的声明都包含在kernel/defs.h文件中。</p><h2 id="第一个用户进程">第一个用户进程</h2><p>从main.c代码中我们可以发现在启动第一个进程之前，还有很多准备工作。我们暂时不去看他们，先学习第一个进程对应的代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Set up first user process.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">userinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>    <span class="hljs-comment">//新建进程的结构体</span><br>  <br>  p = allocproc();   <span class="hljs-comment">//第一个进程分配空间等初始化步骤基本都在该函数中进行，具体看下文</span><br>  initproc = p;  <br>    <br>  <span class="hljs-comment">// allocate one user page and copy init&#x27;s instructions  </span><br>  <span class="hljs-comment">// and data into it.  </span><br>  uvminit(p-&gt;pagetable, initcode, <span class="hljs-keyword">sizeof</span>(initcode));   <br>  p-&gt;sz = PGSIZE;   <span class="hljs-comment">//sz变量表示进程的最大内存空间</span><br>  <br>  <span class="hljs-comment">// prepare for the very first &quot;return&quot; from kernel to user.  </span><br>  <span class="hljs-comment">// user program counter</span><br>  <span class="hljs-comment">//指令指针指向初始化代码的入口点，即地址0。</span><br>  p-&gt;trapframe-&gt;epc = <span class="hljs-number">0</span>;  <br>  <span class="hljs-comment">// user stack pointer </span><br>  <span class="hljs-comment">//栈指针被设置为虚拟空间最大值（初始化）</span><br>  p-&gt;trapframe-&gt;sp = PGSIZE;  <br>  <br>  safestrcpy(p-&gt;name, <span class="hljs-string">&quot;initcode&quot;</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;name));   <span class="hljs-comment">//设置进程的名称，方便调试</span><br>  p-&gt;cwd = namei(<span class="hljs-string">&quot;/&quot;</span>);   <span class="hljs-comment">//指定进程的工作目录</span><br>  <br>  p-&gt;state = RUNNABLE;   <span class="hljs-comment">//进程已经初始化完毕，修改状态，表示它可以被调度了</span><br>  <br>  release(&amp;p-&gt;lock);   <span class="hljs-comment">//完成对进程的操作，释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure></p><hr><p>这段代码内部完成了很多事情，把他拆开来看：</p><p><strong>1. allocproc函数</strong>（构建新进程） <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//进程表，NPROC表示支持的最大进程数量，xv6设置为64</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> <span class="hljs-title">proc</span>[<span class="hljs-title">NPROC</span>];</span><br><br><span class="hljs-comment">// Look in the process table for an UNUSED proc.  </span><br><span class="hljs-comment">// If found, initialize state required to run in the kernel,  </span><br><span class="hljs-comment">// and return with p-&gt;lock held.  </span><br><span class="hljs-comment">// If there are no free procs, or a memory allocation fails, return 0.  </span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc* <br><span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>  <br><br><span class="hljs-comment">//proc是进程表，&amp;proc[NPROC]是获取数组首地址，循环通过递增指针的方式遍历进程表</span><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    acquire(&amp;p-&gt;lock);  <span class="hljs-comment">//每个表格中的进程要加锁才能进行操作，同时该函数会关闭中断避免死锁</span><br>    <span class="hljs-keyword">if</span>(p-&gt;state == UNUSED) &#123;   <span class="hljs-comment">//寻找第一个state为UNUSED（未使用的）进程</span><br>      <span class="hljs-keyword">goto</span> found;   <span class="hljs-comment">//找到空位，可以执行初始化进程的操作</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;   <br>      release(&amp;p-&gt;lock);   <span class="hljs-comment">//未找到空位，释放当前指针所指向进程的锁，然后继续循环寻找</span><br>    &#125;  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  <br>found:   <br>  p-&gt;pid = allocpid();   <span class="hljs-comment">//为进程分配pid（进程的编号，唯一标识）</span><br>  p-&gt;state = USED;   <span class="hljs-comment">//将state设置为USED（已使用），state用于描述进程的状态</span><br>  <br>  <span class="hljs-comment">// Allocate a trapframe page.  </span><br>  <span class="hljs-comment">//为进程分配trapframe（用于保存中断时的进程上下文），这个结构在中断章节会进一步讲解</span><br>  <span class="hljs-comment">//kalloc函数可以分配物理内存，失败则返回0，这里是</span><br>  <span class="hljs-keyword">if</span>((p-&gt;trapframe = (<span class="hljs-keyword">struct</span> trapframe *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p);   <span class="hljs-comment">//如果分配失败，则将设置的pid等信息全部还原</span><br>    release(&amp;p-&gt;lock);   <span class="hljs-comment">//释放锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-comment">// An empty user page table.</span><br>  p-&gt;pagetable = proc_pagetable(p);  <span class="hljs-comment">//为进程分配页表</span><br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable == <span class="hljs-number">0</span>)&#123;  <br>    freeproc(p);  <span class="hljs-comment">//如果分配失败，则将设置的pid等信息全部还原</span><br>    release(&amp;p-&gt;lock);   <span class="hljs-comment">//释放锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-comment">// Set up new context to start executing at forkret,  </span><br>  <span class="hljs-comment">// which returns to user space.  memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));  </span><br>  <span class="hljs-comment">//context是保存内核中进程上下文切换时寄存器值的结构体</span><br>  <span class="hljs-comment">//当调用ret指令时，指令寄存器pc会被重置为ra寄存器所保存的地址</span><br>  <span class="hljs-comment">//进程调度切换上下文后会有ret指令，所以此处ra其实指定了CPU加载该进程后运行的程序是什么</span><br>  p-&gt;context.ra = (uint64)forkret;   <br>  p-&gt;context.sp = p-&gt;kstack + PGSIZE;   <br>  <span class="hljs-comment">//sp 栈指针,kstack是内核栈的地址，PGSIZE是常量，表示每个页的大小（4096 字节）</span><br><br>  <span class="hljs-keyword">return</span> p;  <br>&#125;<br></code></pre></td></tr></table></figure> 这是一个使用static修饰的函数，返回一个进程结构体指针的。static 常在两种情况下使用： 1. 变量：static变量不会在函数重新进入时再次赋初值；不会在函数结束时而释放（存储在全局区） 2. 函数：static函数只能在本文件中调用，不能在其他文件中调用</p><p>函数的逻辑如下图：</p><p><img src="20230816182438.png" alt="运行流程图"> 在新建进程时有三个结构体非常重要，后续会进一步讲解，这里只需要知道它们是干什么的即可： 1. 保存进程运行情况的trapframe（栈帧） 2. 上下文切换时记录状态的context 3. pagetable（页表）</p><p><strong>2. 分配物理内存（虚拟地址映射）</strong></p><p>在申请完进程结构体后，进程中保存的栈指针其实是个虚拟地址，让进程有自己在使用整个内存空间的错觉，其实要真正使用，还需要为进程分配真实的物理地址 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Load the user initcode into address 0 of pagetable,  </span><br><span class="hljs-comment">// for the very first process.  </span><br><span class="hljs-comment">// sz must be less than a page.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">uvminit</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uchar *src, uint sz)</span>  <br>&#123;  <br>  <span class="hljs-type">char</span> *mem;  <br>  <br>  <span class="hljs-keyword">if</span>(sz &gt;= PGSIZE)  <br>    panic(<span class="hljs-string">&quot;inituvm: more than a page&quot;</span>);  <br>  mem = kalloc();   <span class="hljs-comment">//kalloc会分配一个4k大小的物理内存并返回指针</span><br>  <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);   <span class="hljs-comment">//将物理内存初始化为0</span><br>  <span class="hljs-comment">//mappages将进程结构体中的虚拟内存pagetable映射到物理内存mem</span><br>  mappages(pagetable, <span class="hljs-number">0</span>, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);  <br>  memmove(mem, src, sz);  <span class="hljs-comment">//src指向位置的，大小为sz的内容，复制到mem指向的空间中</span><br>&#125;<br></code></pre></td></tr></table></figure> 上述代码涉及到虚拟内存和页表相关的知识，后续会进一步讨论</p><hr><p>在介绍完第一个进程创建过程中非常重要的两个函数调用后，我们可以回头再看第一个进程初始化的代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Set up first user process.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">userinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>    <span class="hljs-comment">//新建进程的结构体</span><br>  <br>  p = allocproc();   <span class="hljs-comment">//第一个进程分配空间等初始化步骤基本都在该函数中进行，具体看下文</span><br>  initproc = p;  <br>    <br>  <span class="hljs-comment">// allocate one user page and copy init&#x27;s instructions  </span><br>  <span class="hljs-comment">// and data into it.  </span><br>  uvminit(p-&gt;pagetable, initcode, <span class="hljs-keyword">sizeof</span>(initcode));   <br>  p-&gt;sz = PGSIZE;   <span class="hljs-comment">//sz变量表示进程的最大内存空间</span><br>  <br>  <span class="hljs-comment">// prepare for the very first &quot;return&quot; from kernel to user.  </span><br>  <span class="hljs-comment">// user program counter</span><br>  <span class="hljs-comment">//指令指针指向初始化代码的入口点，即地址0（虚拟地址）。</span><br>  p-&gt;trapframe-&gt;epc = <span class="hljs-number">0</span>;  <br>  <span class="hljs-comment">// user stack pointer </span><br>  <span class="hljs-comment">//栈指针被设置为虚拟空间最大值（初始化），进行压栈操作，sp会减小（xv6的栈是倒着的）</span><br>  p-&gt;trapframe-&gt;sp = PGSIZE;  <br>  <br>  safestrcpy(p-&gt;name, <span class="hljs-string">&quot;initcode&quot;</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;name));   <span class="hljs-comment">//设置进程的名称，方便调试</span><br>  p-&gt;cwd = namei(<span class="hljs-string">&quot;/&quot;</span>);   <span class="hljs-comment">//指定进程的工作目录</span><br>  <br>  p-&gt;state = RUNNABLE;   <span class="hljs-comment">//进程已经初始化完毕，修改状态，表示它可以被调度了</span><br>  <br>  release(&amp;p-&gt;lock);   <span class="hljs-comment">//完成对进程的操作，释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure> 上述代码中，完成了进程创建和虚拟地址映射两个操作后，剩下的就是对进程的细微调整 1. 初始化栈帧的epc指针和sp指针 2. 为进程命名 3. 指定工作目录 4. 修改进程状态为就绪态，随时等待CPU&quot;宠幸&quot; 5. 完成对进程结构体的更改，释放锁</p><p>然而完成了对第一个进程结构体的创建，不代表第一个进程已经运行起来了。我们还需要理解进程这个结构体是怎么运行起来的（如何被CPU使用）</p><p><strong>2. scheduler（进程调度）</strong></p><p>在main.c函数中，我们可以发现完成userinit后会调用scheduler()函数，这个函数是一个死循环： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-CPU process scheduler.  </span><br><span class="hljs-comment">// Each CPU calls scheduler() after setting itself up.  </span><br><span class="hljs-comment">// Scheduler never returns.  It loops, doing:  </span><br><span class="hljs-comment">//  - choose a process to run.  </span><br><span class="hljs-comment">//  - swtch to start running that process.  </span><br><span class="hljs-comment">//  - eventually that process transfers control  </span><br><span class="hljs-comment">//    via swtch back to the scheduler.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">scheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();  <br>    <br>  c-&gt;proc = <span class="hljs-number">0</span>;  <br>  <span class="hljs-keyword">for</span>(;;)&#123;  <br>    <span class="hljs-comment">// Avoid deadlock by ensuring that devices can interrupt.  </span><br>    intr_on();  <br>  <br>    <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;  <br>      acquire(&amp;p-&gt;lock);  <br>      <span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE) &#123;  <br>        <span class="hljs-comment">// Switch to chosen process.  It is the process&#x27;s job  </span><br>        <span class="hljs-comment">// to release its lock and then reacquire it        // before jumping back to us.        p-&gt;state = RUNNING;  </span><br>        c-&gt;proc = p;  <br>        swtch(&amp;c-&gt;context, &amp;p-&gt;context); <br>  <br>        <span class="hljs-comment">// Process is done running for now.  </span><br>        <span class="hljs-comment">// It should have changed its p-&gt;state before coming back.        c-&gt;proc = 0;  </span><br>      &#125;  <br>      release(&amp;p-&gt;lock);  <br>    &#125;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>每个CPU都会执行这个代码，在初始化CPU结构体之后开始循环。具体的逻辑很容易理解： - 打开中断（在之前的操作中，中断是关闭的，在开始执行进程前要打开中断避免死锁） - 遍历进程表，找到就绪态的进程 - 给进程上锁，运行进程 - 运行结束，释放锁 - 继续遍历</p><p>可以发现核心代码就是循环体中的<code>swtch(&amp;c-&gt;context, &amp;p-&gt;context);</code> 为什么把进程结构体的上下文和CPU结构体的上下文传入swtch就可以实现进程的切换了？ <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"># Context <span class="hljs-keyword">switch</span>  <br>#  <br><span class="hljs-meta">#   void swtch(struct context *old, struct context *new);  </span><br>#   <br># Save current registers in old. Load from new.      <br>  <br>  <br>.globl swtch  <br>swtch:  <br>        sd ra, <span class="hljs-number">0</span>(a0)   <span class="hljs-comment">//0(a0)的意思是a0寄存器的内容作为基址 + 0得到真正的地址</span><br>        sd sp, <span class="hljs-number">8</span>(a0)  <br>        sd s0, <span class="hljs-number">16</span>(a0)  <br>        sd s1, <span class="hljs-number">24</span>(a0)  <br>        sd s2, <span class="hljs-number">32</span>(a0)  <br>        sd s3, <span class="hljs-number">40</span>(a0)  <br>        sd s4, <span class="hljs-number">48</span>(a0)  <br>        sd s5, <span class="hljs-number">56</span>(a0)  <br>        sd s6, <span class="hljs-number">64</span>(a0)  <br>        sd s7, <span class="hljs-number">72</span>(a0)  <br>        sd s8, <span class="hljs-number">80</span>(a0)  <br>        sd s9, <span class="hljs-number">88</span>(a0)  <br>        sd s10, <span class="hljs-number">96</span>(a0)  <br>        sd s11, <span class="hljs-number">104</span>(a0)  <br>  <br>        ld ra, <span class="hljs-number">0</span>(a1)  <br>        ld sp, <span class="hljs-number">8</span>(a1)  <br>        ld s0, <span class="hljs-number">16</span>(a1)  <br>        ld s1, <span class="hljs-number">24</span>(a1)  <br>        ld s2, <span class="hljs-number">32</span>(a1)  <br>        ld s3, <span class="hljs-number">40</span>(a1)  <br>        ld s4, <span class="hljs-number">48</span>(a1)  <br>        ld s5, <span class="hljs-number">56</span>(a1)  <br>        ld s6, <span class="hljs-number">64</span>(a1)  <br>        ld s7, <span class="hljs-number">72</span>(a1)  <br>        ld s8, <span class="hljs-number">80</span>(a1)  <br>        ld s9, <span class="hljs-number">88</span>(a1)  <br>        ld s10, <span class="hljs-number">96</span>(a1)  <br>        ld s11, <span class="hljs-number">104</span>(a1)  <br>          <br>        ret<br></code></pre></td></tr></table></figure></p><p>swtch函数其实是用汇编代码实现的（swtch.S），它的作用就是切换CPU运行时使用的寄存器的值，也就是进程的context结构体中记录的内容。具体来说，上面的代码就是实现了先保存现在寄存器的值到<strong>a0寄存器</strong>指向的位置，再加载新的值到<strong>a1寄存器</strong>指向的位置： - sd是指store doubleword，将寄存器的值存入存储器 - ld则是load doubleword，将存储器的值加载进寄存器 - ret指令，CPU会将PC重置为ra寄存器的值 a0寄存器对应了swtch函数的第一个参数，是当前进程的context对象的地址，保存它的意义在于当前进程因为各种原因被调度走了，下次还可以在上次CPU中断的位置继续完成任务。 a1寄存器对应了swtch函数的第二个参数，是即将要CPU执行的进程对应的context结构体地址</p><p>注意：一般来说，ra寄存器存放目前进程代码执行到的位置，方便下一次CPU调度该进程时可以接着执行，但由于是第一个进程，ra寄存器实际指向了我们想要执行的第一个程序</p><p>还记得吗？在新建第一个进程的时候，<code>p-&gt;context.ra = (uint64)forkret;</code> 新进程的ra寄存器的值被设定为forkret函数的地址，所以第一个进程实际上会先完成forkret函数的工作 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// A fork child&#x27;s very first scheduling by scheduler()  </span><br><span class="hljs-comment">// will swtch to forkret.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">forkret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> first = <span class="hljs-number">1</span>;  <br>  <br>  <span class="hljs-comment">// Still holding p-&gt;lock from scheduler.  </span><br>  release(&amp;myproc()-&gt;lock);  <br>  <br>  <span class="hljs-keyword">if</span> (first) &#123;  <br>    <span class="hljs-comment">// File system initialization must be run in the context of a  </span><br>    <span class="hljs-comment">// regular process (e.g., because it calls sleep), and thus cannot    // be run from main().    first = 0;  </span><br>    fsinit(ROOTDEV);  <br>  &#125;  <br>  <br>  usertrapret();  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>forkret函数会初始化文件系统，注意：文件系统的初始化代码因为涉及到sleep系统调用，因此必须通过一个常规的进程运行，而不是再上文的main.c中进行</p><p>完成初始化后，程序会执行usertrapret()函数，这是一个从内核态返回用户态的函数。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  </span><br><span class="hljs-comment">// return to user space  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  <span class="hljs-comment">// we&#x27;re about to switch the destination of traps from  </span><br>  <span class="hljs-comment">// kerneltrap() to usertrap(), so turn off interrupts until  // we&#x27;re back in user space, where usertrap() is correct.  intr_off();  </span><br>  <br>  <span class="hljs-comment">// send syscalls, interrupts, and exceptions to trampoline.S  </span><br>  w_stvec(TRAMPOLINE + (uservec - trampoline));  <br>  <br>  <span class="hljs-comment">// set up trapframe values that uservec will need when  </span><br>  <span class="hljs-comment">// the process next re-enters the kernel.  p-&gt;trapframe-&gt;kernel_satp = r_satp();         // kernel page table  </span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack  </span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;  <br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid()  </span><br>  <br>  <span class="hljs-comment">// set up the registers that trampoline.S&#x27;s sret will use  // to get to user space.    // set S Previous Privilege mode to User.  </span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_sstatus();  <br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// clear SPP to 0 for user mode  </span><br>  x |= SSTATUS_SPIE; <span class="hljs-comment">// enable interrupts in user mode  </span><br>  w_sstatus(x);  <br>  <br>  <span class="hljs-comment">// set S Exception Program Counter to the saved user pc.  </span><br>  w_sepc(p-&gt;trapframe-&gt;epc);  <br>  <br>  <span class="hljs-comment">// tell trampoline.S the user page table to switch to.  </span><br>  uint64 satp = MAKE_SATP(p-&gt;pagetable);  <br>  <br>  <span class="hljs-comment">// jump to trampoline.S at the top of memory, which   </span><br>  <span class="hljs-comment">// switches to the user page table, restores user registers,  </span><br>  <span class="hljs-comment">// and switches to user mode with sret.  uint64 fn = TRAMPOLINE + (userret - trampoline);  </span><br>  ((<span class="hljs-type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>这部分代码涉及到了中断的内容，会在后续章节学习，只需要知道： 1. 在这段代码中先将内核层级设定为用户态 2. 通过<code>w_sepc(p-&gt;trapframe-&gt;epc);</code> 设置PC（程序计数器）的值为寄存器中预先存好的值 3. CPU因为从PC处执行指令，因此执行<code>p-&gt;trapframe-&gt;epc</code>指向的代码。</p><p>在第一个进程中，epc指向虚拟地址0，该虚拟地址绑定的物理地址实际指向initcode <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a user program that calls exec(&quot;/init&quot;)  </span><br><span class="hljs-comment">// od -t xC initcode  </span><br>uchar initcode[] = &#123;  <br>  <span class="hljs-number">0x17</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x02</span>,  <br>  <span class="hljs-number">0x97</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0x02</span>,  <br>  <span class="hljs-number">0x93</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,  <br>  <span class="hljs-number">0x93</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,  <br>  <span class="hljs-number">0xef</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0x9f</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0x2f</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x69</span>,  <br>  <span class="hljs-number">0x74</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,  <br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>  <br>&#125;;<br></code></pre></td></tr></table></figure> 这其实是initcode二进制代码的十六进制显示，也就是说CPU要开始加载initcode代码</p><p>也就是下面的汇编代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"># Initial process that execs /init.  <br># This code runs in user space.  <br>  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;syscall.h&quot;</span>  </span><br>  <br><span class="hljs-meta"># exec(init, argv)  </span><br>.globl start  <br>start:  <br>        la a0, init    <span class="hljs-comment">//la将一个内存地址的值加载到rd寄存器中</span><br>        la a1, argv    <br>        li a7, SYS_exec <span class="hljs-comment">//li可以将任意的32位数据或者地址加载到指定的寄存器中</span><br>        ecall  <br>  <br><span class="hljs-meta"># for(;;) exit();  </span><br><span class="hljs-built_in">exit</span>:  <br>        li a7, SYS_exit  <br>        ecall  <br>        jal <span class="hljs-built_in">exit</span>  <br>  <br><span class="hljs-meta"># char init[] = <span class="hljs-string">&quot;/init\0&quot;</span>;  </span><br>init:  <br>  .<span class="hljs-built_in">string</span> <span class="hljs-string">&quot;/init\0&quot;</span>  <br>  <br><span class="hljs-meta"># char *argv[] = &#123; init, 0 &#125;;  </span><br>.p2align <span class="hljs-number">2</span>  <br>argv:  <br>  .<span class="hljs-type">long</span> init  <br>  .<span class="hljs-type">long</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure> 这段汇编代码的主要作用是触发系统调用exec（这个系统调用的作用前文已经讲过），执行名为init的程序（由user/init.c编译得到），如果exec失败，则循环运行一个不会返回的系统调用exit</p><p>init的代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// init: The initial user-level program  </span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/spinlock.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/sleeplock.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/file.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span>  </span><br>  <br><span class="hljs-type">char</span> *argv[] = &#123; <span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-number">0</span> &#125;;  <br>  <br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> pid, wpid;  <br>  <br>  <span class="hljs-keyword">if</span>(open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="hljs-number">0</span>)&#123;  <br>    mknod(<span class="hljs-string">&quot;console&quot;</span>, CONSOLE, <span class="hljs-number">0</span>);  <br>    open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR);  <br>  &#125;  <br>  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stdout  </span><br>  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stderr  </span><br><br>  <span class="hljs-comment">//启动shell</span><br>  <span class="hljs-keyword">for</span>(;;)&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: starting sh\n&quot;</span>);   <br>    pid = fork();  <br>    <span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>)&#123;  <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: fork failed\n&quot;</span>);  <br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;  <br>      exec(<span class="hljs-string">&quot;sh&quot;</span>, argv);  <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: exec sh failed\n&quot;</span>);  <br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br><br><span class="hljs-comment">//shell启动成功，进入死循环，</span><br>    <span class="hljs-keyword">for</span>(;;)&#123;  <br>      <span class="hljs-comment">// this call to wait() returns if the shell exits,  </span><br>      <span class="hljs-comment">// or if a parentless process exits.      wpid = wait((int *) 0);  </span><br>      <span class="hljs-keyword">if</span>(wpid == pid)&#123;  <br>        <span class="hljs-comment">// the shell exited; restart it.  </span><br>        <span class="hljs-keyword">break</span>;  <br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wpid &lt; <span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: wait returned an error\n&quot;</span>);  <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>      &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// it was a parentless process; do nothing.  </span><br>      &#125;  <br>    &#125;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>init会在需要的情况下创建一个新的控制台设备文件，然后把它作为描述符0，1，2打开。接下来它将不断循环，开启控制台 shell，处理没有父进程的僵尸进程，直到 shell 退出，然后再反复。系统就这样运行起来了。</p><h2 id="现实情况">现实情况</h2><p>大多操作系统都采用了进程这个概念，而大多的进程都和 xv6 的进程类似。但是真正的操作系统会利用一个显式的链表在常数时间内找到空闲的 <code>proc</code>，而不像本文 <code>allocproc</code> 中那样花费线性时间；xv6 使用的是朴素的线性搜索，找第一个空闲的 <code>proc</code>（详情见前文的scheduler.c代码）。</p><p>注意：xv6 的地址空间结构有一个缺点，即无法使用超过 2GB 的物理 RAM。当然我们可以解决这个问题，不过最好的解决方法还是使用64位的机器。</p><h2 id="结尾">结尾</h2><p>完成了对书籍第二章内容的阅读和扩展阅读，写成了这一篇笔记，在开始第三章学习之前，要先进入到系统调用相关的练习中了。</p><p>感谢你能看到这里！幸苦了！！</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book Chapter1</title>
    <link href="/2023/07/14/xv6-book-Chapter1/"/>
    <url>/2023/07/14/xv6-book-Chapter1/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter1-操作系统接口">Chapter1 操作系统接口</h1><p>操作系统是硬件的抽象表示，需要通过接口对用户程序提供服务。unix的接口设计十分成功，而xV6是一个模仿unix设计的操作系统，理解xv6是理解现代操作系统的良好开端。</p><p>但是哪怕是简单的xv6系统，我们也需要一个框架形的学习方式，Chapter 1主要从用户使用操作系统的角度出发，先介绍操作系统提供的接口，即系统调用。</p><p>用户的程序运行在用户态，内核执行的程序运行在内核态，如果用户需要发起需要操作系统参与的活动时（例如读写磁盘，删除文件），不能直接执行操作，而是要利用操作系统的提供的接口，这个接口被成为系统调用（系统调用是一串预先实现好的函数）。如下图所示</p><p><img src="20230711210052.png"></p><p>为什么要这样做呢？ 1. <strong>它为用户空间提供了一种统一的硬件的抽象接口</strong>，用户程序不必关心底层的具体实现。例如对于读写操作，用户不关心存储介质是固态硬盘还是机械硬盘，只需要往文件中读写即可，至于信息到底保存在哪里，如何与硬件对接，由操作系统负责完成 2. <strong>系统调用保证了系统的稳定和安全</strong>。作为硬件设备和应用程序之间的中间人，内核可以基于权限和其他一些规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确地使用硬件设备，例如窃取其他进程的资源。 3. <strong>假设没用内核，应用程序可以随意访问硬件，几乎就没法实现多任务和虚拟内存</strong></p><p>下图列出了xv6操作系统的所有系统调用，本章的其余部分概述了xv6的服务——进程、内存、文件描述符、管道和文件系统——并通过代码片段对它们进行了说明，并讨论了shell (Unix的命令行用户界面)如何使用它们。 注意：进入unix系统看到的<strong>shell窗口是一个用户程序</strong>而不是内核的一部分，xv6的shell代码可以在user/sh.c找到。 <img src="20230711215725.png" alt="系统调用列表"></p><h2 id="进程与内存">进程与内存</h2><p>xv6进程由用户空间内存(指令、数据和堆栈)和内核私有的每个进程状态组成。 <figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">进程 </span>=<span class="hljs-string"> 占用的内存空间 + 进程状态</span><br></code></pre></td></tr></table></figure></p><p>每个进程可以使用fork()系统调用创建一个新的子进程。其内存内容与父进程完全相同，父进程执行的fork会返回子进程的pid（进程的唯一标识符），子进程的fork返回0。以下面的代码为例： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = fork();    <span class="hljs-comment">//创建子进程</span><br><span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;         <span class="hljs-comment">//如果是父进程则执行下面的语句</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: child=%d\n&quot;</span>, pid);<br>pid = wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>);  <span class="hljs-comment">//wait系统调用返回当前进程退出子进程的PID，并将子进程的退出状态复制到传递给wait的地址,如果调用者的子进程都没有退出，则等待其中一个退出,如果调用者没有子进程，wait立即返回-1, 如果父进程不关心子进程的退出状态，它可以传递一个0地址来等待</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d is done\n&quot;</span>, pid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//如果是子进程则执行下面的语句</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child: exiting\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//exit系统调用导致调用进程停止执行，并释放资源</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>&#125;<br><br>这个代码的输出结果，前两行可能交换顺序:<br>parent: child=<span class="hljs-number">1234</span><br>child: exiting<br>parent: child <span class="hljs-number">1234</span> is done<br></code></pre></td></tr></table></figure></p><p>exec系统调用从存储在文件系统中加载新的内存映像替换调用进程的内存(可以理解为把一个程序替换为另一个程序)，一般搭配fork使用</p><p>shell就是一个特殊的程序，当你在shell界面输入命令时，shell会fork一个子进程，然后使用exec将子进程的内存空间替换为你输入的命令的内存空间（也就是把子进程变成你想要执行的进程），如果内存空间不够，可以使用sbrk这一系统调用扩宽。</p><p>如下方代码所示，主循环使用getcmd从用户那里读取一行输入。然后调用fork，创建shell进程的副本。父进程调用wait，而子进程运行该命令。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Read and run input commands.  </span><br><span class="hljs-keyword">while</span>(getcmd(buf, <span class="hljs-keyword">sizeof</span>(buf)) &gt;= <span class="hljs-number">0</span>)&#123;  <br><span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;  <br><span class="hljs-comment">// Chdir must be called by the parent, not the child.  </span><br>buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// chop \n  </span><br><span class="hljs-keyword">if</span>(chdir(buf+<span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>)  <br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="hljs-number">3</span>);  <br><span class="hljs-keyword">continue</span>;  <br>&#125;  <br><span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)  <br>runcmd(parsecmd(buf));   <span class="hljs-comment">//子进程执行指令</span><br>wait(<span class="hljs-number">0</span>);  <span class="hljs-comment">//父进程等待</span><br>&#125;    <br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <br><br><br>fork1(<span class="hljs-type">void</span>)  &#123;  <br><span class="hljs-type">int</span> pid;  <br>pid = fork();  <br><span class="hljs-keyword">if</span>(pid == <span class="hljs-number">-1</span>)  <br>panic(<span class="hljs-string">&quot;fork&quot;</span>);  <br><span class="hljs-keyword">return</span> pid;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="io和文件描述符">I/O和文件描述符</h2><p>文件描述符（File Descriptor，简称FD）是一个小整数，linux使用它来作为文件的唯一标识（文件是一个抽象概念，表示文件描述符引用的对象，不仅仅是文件夹里的文件，也可以是管道和设备），内核为每个进程维护了一个文件描述符表，这个表以为索引，再进一步指向文件的详细信息。 <img src="20230713134913.png" alt="IO描述符"></p><p>在Unix系统中，每个进程都有STDIN、STDOUT和STDERR这3种标准I/O（分别对应文件描述符0、1、2），它们是程序最通用的输入输出方式。几乎所有语言都有相应的标准I/O函数，比如，C语言可以通过scanf从终端输入字符，通过printf向终端输出字符 在这一部分内容中，主要涉及到两个系统调用，open，read和write可以<a href="%5BLinux系统中I/O操作的数据读写流程介绍%20-%20知乎%20(zhihu.com)%5D(https://zhuanlan.zhihu.com/p/435406445)">看这里</a></p><h4 id="io重定向详解">I/O重定向详解</h4><p>unix通过将fork和exec分离，实现了IO重定向（让已创建的FD指向其他文件）。 具体来说，fork复制父进程的文件描述符表及其内存，这样子进程打开的文件与父进程完全相同。系统调用exec替换调用进程的内存，但保留文件表，就使得shell命令输入的IO操作可以灵活的运用。只看概念很晦涩，不妨碍看看下面案例：</p><p>dup和dup2是IO重定向的涉及的核心系统调用 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">内核在进程中创建一个新的文件描述符(目前可用文件描述符的最小值）newfd，并且使newfd指向oldfd所指向的文件表项</span><br><span class="hljs-comment">**/</span><br><br><span class="hljs-comment">//eg：</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello world!\n&quot;</span>;<br><span class="hljs-type">int</span> newfd = <span class="hljs-number">-1</span>;<br>newfd = dup(<span class="hljs-number">1</span>);    <span class="hljs-comment">//将newfd重定向到标准输出，0、1、2是默认存在的FD，3是目前可用的最小描述符，因此newfd=3</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;newfd = &quot;</span>&lt;&lt;newfd&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//输出newfd=3</span><br>write(newfd,str,<span class="hljs-built_in">strlen</span>(str));    <span class="hljs-comment">//向newfd中写入字符串，由于newfd重定向到1，因此newfd和标准输出有相同的指向，会在屏幕上输出hello world!</span><br>    close(newfd); <br>    <span class="hljs-comment">//close系统调用释放一个文件描述符，使其可以被将来的open、pipe或dup系统调用重用。新分配的文       件描述符总是当前进程中编号最低的未使用描述符</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">让传入的参数newfd与参数oldfd指向同一文件表项，如果newfd已经被open过，那么就会先将newfd关闭，然后让newfd指向oldfd所指向的文件表项，如果newfd本身就等于oldfd，那么就直接返回newfd。因此，传入的newfd既可以是open过的，也可以是一个任意非负整数，</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">总之，dup2函数的作用就是让newfd重定向到oldfd所指的文件表项上</span><br><span class="hljs-comment">如果出错就返回-1，否则返回的就是newfd</span><br><span class="hljs-comment">**/</span><br><br><span class="hljs-comment">//eg:</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello world!\n&quot;</span>;<br> <br>dup2(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);    <span class="hljs-comment">//将“5”重定向到标准输出</span><br>write(<span class="hljs-number">5</span>,str,<span class="hljs-built_in">strlen</span>(str));   <span class="hljs-comment">//向文件描述符5写入数据,此时相当于输出到文件描述符1对应的文件表项上，也就是输出到屏幕</span><br>close(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面可以讲几个具体的样例： <strong>1. 重定向标准输入</strong> 标准输入（文件描述符0）所对应的设备是键盘，当read指定FD=1时，实际上是read键盘输入的数据，那如果不想让键盘作为标准输入呢？比如说让程序从某个文件中读取输入数据，这就需要重定向标准输入 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">string</span> rdstr;<br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//打开想要读取数据的文件，open返回新的FD，这个fd指向test.txt这一文件表项</span><br><span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR)) == <span class="hljs-number">-1</span>) <br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;open failed !&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//重定向标准输入到外部文件test.txt中（即0重定向到fd，指向fd对应的文件表项）</span><br>dup2(fd,<span class="hljs-number">0</span>); <br><br><span class="hljs-keyword">while</span>(getline(<span class="hljs-built_in">cin</span>,rdstr))     <span class="hljs-comment">//用getline从标准输入中获取数据，也就是从此时的fd读取</span><br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;rdstr&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//通过标准输出将读入的数据打印出来</span><br>&#125;<br> <br>    close(fd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p><strong>2. 重定向标准输出</strong> 标准输出（文件描述符1）的设备是显示器，通过标准输出进行write时，数据会直接输出到显示器上。那么如果想让cout、printf直接将数据输出到文件，而不是显示屏上呢？那么就需要重定向标准输出。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//创建test.txt并清空文本（O_TRUNC是清空之前内容的标志），并生成文件描述符fd</span><br><span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC)) == <span class="hljs-number">-1</span>)  <br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;open failed !&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>dup2(fd,<span class="hljs-number">1</span>);   <span class="hljs-comment">//重定向标准输出到外部文件test.txt</span><br><span class="hljs-comment">//向标准输出输出数据，此时的标准输出指向了fd指向的文本表项，也就是test.txt</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;重定向标准输出测试！&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;   <br>    close(fd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 扩展：</p><p><strong>3. 重定向错误输出</strong> 标准错误输出实际上与标准输出类似，都是将数据输出到显示器上，只不过标准错误输出是输出错误信息，C语言中常用的错误输出就是perror了，如下面打开一个不存在的文件，就会直接在显示器上输出报错信息，因此重定向的方式与重定向标准输出一样。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>open(<span class="hljs-string">&quot;123.txt&quot;</span>,O_RDWR); <br>perror(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>4. 重定向恢复</strong> 在进行重定向后，如果想要恢复到重定向之前的状态，可以在重定向之前用dup函数保留该文件描述符对应的文件表项，然后在需要恢复重定向的时候使用dup2重定向到原来的文件表项，以重定向后恢复标准输出为例： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC)) == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;open failed !&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-type">int</span> oldfd = dup(<span class="hljs-number">1</span>);     <span class="hljs-comment">//保存标准输出对应的文件表项</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">注意：并不是保存了文件表项本身，而是生成并保存了一个指向标准输出对应文件表项的文件描述符（oldfd）</span><br><span class="hljs-comment">**/</span><br>dup2(fd,<span class="hljs-number">1</span>);    <span class="hljs-comment">//重定向标准输出到外部文件test.txt中</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;重定向标准输出测试！&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//重定向测试</span><br>dup2(oldfd,<span class="hljs-number">1</span>);   <span class="hljs-comment">//将重定向后的文件描述符1再次重定向到一开始保存的标准输出对应的文件表项中</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;重定向标准输出恢复测试！&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;   <span class="hljs-comment">//重定向恢复测试</span><br>close(fd);<br>close(oldfd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//在第一次重定向后，cout输出信息是输出到了外部文件中，当再次重定向进行恢复之后，此时的cout就将数据输出到显示器上了，回到了最原始的标准输出</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="管道pipe">管道（pipe）</h2><p>管道是一个小的内核缓冲区，作为一对文件描述符公开给进程，一个用于读取，一个用于写入。将数据写入管道的一端，使该数据可用于从管道的另一端读取。<strong>管道为进程提供了一种通信方式</strong>。</p><p>下面的示例代码运行程序wc，标准输入连接到管道的读取端: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>]; <span class="hljs-comment">//用来存储管道的两个文本描述符</span><br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>]; <span class="hljs-comment">//argv表示命令行输入</span><br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;wc&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>pipe(p); <span class="hljs-comment">//此时生成了管道，pipe是生成管道的系统调用</span><br><span class="hljs-comment">//在执行fork操作前已经生成了管道，那么fork操作后，父进程和子进程并行执行，每个进程中都有一个管道，且管道的文本描述符是相同的</span><br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//如果是子进程，执行如下分支的程序</span><br>close(<span class="hljs-number">0</span>);  <span class="hljs-comment">//关闭标准输入，此时0成为了最小的文本描述符</span><br>dup(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//上文讲到了dup的作用，生成了个新的指向p[0]对应文本表项的文本描述符，由于0是最小的文本描述符，所有dup会生成0作为文本描述符，标准输入对应了p[0]原本（管道用于读取的那一端）对应的文本表项。可以形象的理解为标准输入和管道的读取端对接上了（用水的事物和水管的出水口接上了）。</span><br>close(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//p[0]和0指向的表项相同，不再需要</span><br>close(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">//读取端不需要写入，所以关闭</span><br>exec(<span class="hljs-string">&quot;/bin/wc&quot;</span>, argv); <span class="hljs-comment">//子进程执行读取操作，读取被写入到管道的数据</span><br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//如果是父进程，执行如下分支的程序</span><br>close(p[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//写入端不需要读取管道的数据</span><br>write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>, <span class="hljs-number">12</span>) <span class="hljs-comment">//p[1]是管道的进水口，程序向管道中写入数据（水龙头往管道中放水</span><br>close(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">//数据写完了，关闭管道（水龙头关闭了，水管也可以撤走了）</span><br>&#125;<br><br></code></pre></td></tr></table></figure> 上述的例子中，如果管道的缓冲区中没有可用的数据，管道上的读操作要么等待数据被写入，要么等待指向写端的所有文件描述符被关闭，在后一种情况下，read将返回0。 <strong>注意：由于父进程和子进程共有两对管道文本描述符，但整个数据传输过程中只会用到一对描述符，如果读取端不关闭多余的写入端口，那么wc将永远不会结束，即读取端永远等待自己没有使用的那个写入端写入数据</strong>。 <img src="20230713171305.png" alt="管道"></p><h2 id="文件系统">文件系统</h2><p>暂时没看懂</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
