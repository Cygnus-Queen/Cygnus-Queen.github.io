<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Golang垃圾回收</title>
    <link href="/2024/04/23/Golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2024/04/23/Golang%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<p>详情见go专家编程 https://books.studygolang.com/GoExpertProgramming/chapter04/4.2-garbage_collection.html</p><p>https://xargin.com/impl-of-go-gc/</p><p>本文主要是进行了浓缩并加上自己的理解</p><hr><p>Golang的垃圾回收（GC）也是内存管理的一部分，了解垃圾回收最好先了解前面介绍的<a href="https://cygnus-queen.github.io/2024/04/22/Golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">内存分配</a>原理</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">问题：什么是垃圾回收？<br>答案：内存中即有已分配掉的内存，也有未分配的内存，垃圾回收的目标就是把那些已经分配的但没有对象引用的内存找出来并回收掉<br></code></pre></td></tr></table></figure><h2 id="业界常见的垃圾回收算法">业界常见的垃圾回收算法</h2><p>业界常见的垃圾回收算法有以下几种： （1）引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0是回收该对象。（xv6文件管理也是这样） - 优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收。 - 缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价。 - 代表语言：Python、PHP、Swift</p><p>（2）标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为&quot;被引用&quot;，没有被标记的进行回收。 - 优点：解决了引用计数的缺点。 - 缺点：需要STW，即要暂时停掉程序运行。 - 代表语言：Golang(其采用三色标记法)</p><p>（3）分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不能的回收算法和回收频率。 - 优点：回收性能好 - 缺点：算法复杂 - 代表语言： JAVA</p><h2 id="golang内存管理">Golang内存管理</h2><p>go将堆空间划分成三层，依次满足不同的分配需求： （1）将与操作系统申请内存对接分装成堆（mheap）层 （2）为用户程序分配内存的逻辑分装成mcentral层 （3）为了实现无锁分配，在每个调度资源P上增加了mcache层</p><p><img src="Pasted%20image%2020240423141732.png"></p><p>go将从操作系统申请的页划分成多种规格，分配时根据对象大小到对应规格的页分配。应用程序在申请小对象时，首先先向mcache申请，无锁分配，当mcache没有空间时，才向mcentral加锁申请一页规格。</p><p>go将内存分为三块，分别是bitmap,spans,arena三块区域。其中arena是存储数据的区域，大小为512G，spans是存储mspan结构体指针的区域，mspan用于管理规格页的分配和回收，大小为512M,bitmap用于分配和GC，给分配到span中的每个对象用1bit来表示是否占用，大小为16G</p><p><img src="Pasted%20image%2020240423142850.png"></p><p>这三块区域不属于任何一层，是共用的，其中spans可以理解为索引，arena理解为数据区，bitmap是GC索引</p><p>这些区域是向mheap区惰性申请，未分配的mspans属于mcentral,已经分配或部分分配的属于mcache</p><p><strong>总之：go的内存是按8k大小的页来分配的，每一个8k大小的页由一个mspan结构体进行管理，划分为多个规则，给指定大小范围的对象分配空间</strong></p><h2 id="golang垃圾回收">Golang垃圾回收</h2><h3 id="什么时候对象会变成垃圾">什么时候对象会变成垃圾？</h3><p>在程序运行的角度上看，堆的空间是在运行时决定的，堆的对象必须从栈上或DATA、BSS区上的指针一路索引才能被找到</p><p>因此：<strong>对象在无法被栈、DATA、BSS区上的指针索引到的时候变成垃圾</strong></p><h3 id="标记阶段---如何标记垃圾三色标记法">标记阶段---如何标记垃圾？（三色标记法）</h3><p>将所有的内存空间看成槽，每个槽内可以放一个对象或者没有对象，用三种颜色标记槽的状态</p><p>简单来说： GC启动时，初始化所有对象为白色。GC将根对象（bss段、date段、协程栈）标记为灰色加入队列进行广搜，将能遍历到的对象都标记为灰色并加入队列，被遍历过的灰色对象更新为黑色，当队列为空时所有白色对象都是需要清理的目标</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">问题：为什么需要三色标记法？<br>答案：三色抽象主要是为了能让垃圾回收流程与应用流程并发执行，这样将对象扫描过程拆分为多个阶段，而不需要一次性完成整个扫描流程，避免STW。（早期的<span class="hljs-built_in">GC</span>需要暂停用户协程的运行）<br></code></pre></td></tr></table></figure><h4 id="写屏障">写屏障</h4><p>三色标记法在静态标记堆对象上是完全足够的，但如果指针指向的对象存在变化的话，三色标记法存在漏标和错标的情况，比如黑色对象的指针指向的对象被改变。</p><p>因此要引入两个原则来防止错误： （1）强三色不变：禁止黑色对象指向白色对象（解决黑色对象指针变化的情况） （2）弱三色不变性：黑色对象可以指向白色对象，但指向的白色对象，必须有能从灰色对象可达的路径</p><p>实现这两个原则的方法被称为写屏障，写屏障不对栈上的指针变化生效，只应用在堆上： （1）插入写屏障解决黑色对象指针变化的情况，黑色对象不会指向白色对象。 （2）删除写屏障是为了防止栈上指针的变化，任何从堆上白色对象的指针中删除的对象都得到灰色保护</p><p><strong>目前Go使用的是混合屏障，对象被删除和插入都会标记为灰色</strong></p><p><strong>写屏障类似一种开关，在GC的特定时机开启，开启后指针传递时会把指针标记，即本轮不回收，下次GC时再确定</strong></p><h4 id="什么是根对象">什么是根对象？</h4><p>GC <strong>从根开始扫描的含义是从 .bss 段，.data 段以及 goroutine 的栈开始扫描</strong>，最终遍历整个堆上的对象树，对应了上文<strong>对象在无法被栈、DATA、BSS区上的指针索引到的时候变成垃圾</strong>。</p><p><img src="Pasted%20image%2020240423132144.png"></p><p>标记过程是一个广度优先的遍历过程，扫描节点，将节点的子节点推到任务队列中，然后递归扫描子节点的子节点，直到所有工作队列都被排空为止。最后没有被遍历到的对象就是需要清除的对象</p><h3 id="清扫阶段---如何回收内存">清扫阶段---如何回收内存？</h3><p>进程启动时会有两个特殊 goroutine： （1）sweep.g，主要负责清扫死对象，合并相关的空闲页 （2）scvg.g，主要负责向操作系统归还内存</p><p>当 GC 的标记流程结束之后，sweep goroutine 就会被唤醒，进行清扫工作，其实就是循环执行 sweepone -&gt; sweep。针对每个 mspan，sweep.g 的工作是将标记期间生成的 bitmap 替换掉分配时使用的 bitmap，也就是（gcmarkBits替换allocBits）</p><p>此时： （1）如果此时mspan中存活对象数 = 0，即所有 element 都变成了内存垃圾，那执行 freeSpan -&gt; 归还组成该 mspan 所使用的页，并更新全局的页分配器摘要信息 （2）如果 mspan 中没有空槽，说明所有对象都是存活的，将其放入 fullSwept 队列中 （3）如果 mspan 中有空槽，说明这个 mspan 还可以拿来做内存分配，将其放入 partialSweep 队列中</p><p>之后“清道夫”被唤醒，执行线性流程，一路运行到将页内存归还给操作系统： - bgscavenge -&gt; pageAlloc.scavenge -&gt; pageAlloc.scavengeOne -&gt; pageAlloc.scavengeRangeLocked -&gt; sysUnused -&gt; madvise</p><h3 id="什么时候会发生stw">什么时候会发生STW？</h3><p>Go GC分为Mark和Sweep两大阶段。Mark阶段又分为三个步骤，其中两个会有STW，另一个会有延迟。</p><p>Mark阶段： （1）Mark Setup阶段-STW 在gc开始时，必须执行的第一个动作是打开写屏障（Write Barrier）。写屏障的目的是允许垃圾收集器在垃圾收集期间维护堆上的数据完整性，因为垃圾收集器和应用程序将并发执行</p><p>（2）Marking阶段-并发执行 一旦写屏障打开，垃圾收集器就开始标记阶段。垃圾收集器所做的第一件事是占用25%CPU。垃圾收集器使用Goroutines进行垃圾收集工作，. 这意味着对于一个4线程的Go程序，一个P将专门用于垃圾收集工作 如果垃圾收集器确定需要减慢内存分配，原本运行应用程序Goroutines会协助标记工作。应用程序Goroutine成为Mark Assist（协助标记）中的时间长度与它申请的堆内存成正比。Mark Assist有助于更快地完成垃圾收集 （3）Mark终止-STW 关闭写屏障，执行各种清理任务</p><p>Seep阶段： 清理阶段用于回收标记阶段中标记出来的可回收的内存。当应用程序goroutine尝试在堆内存中分配新内存时，会触发该操作。<strong>清理导致的延迟被分散到每次内存分配时</strong></p><h3 id="触发时机">触发时机</h3><h4 id="阈值触发">阈值触发</h4><p>每次内存分配时都会检查当前内存分配量是否已达到阀值，如果达到阀值则立即启动GC 阀值 = 上次GC内存分配量 * 内存增长率 内存增长率由环境变量<code>GOGC</code>控制，默认为100，即每当内存扩大一倍时启动GC</p><h4 id="定时触发">定时触发</h4><p>默认情况下，最长2分钟触发一次GC</p><h4 id="手动触发">手动触发</h4><p>程序代码中也可以使用<code>runtime.GC()</code>来手动触发GC。这主要用于GC性能测试和统计</p><h2 id="如何减少gc">如何减少GC？</h2><p>所谓的减少GC，减少GC就是减少在堆上分配对象，同时避免内存逃逸（原本在栈上的对象跑到堆上，导致了GC压力变大）</p><h4 id="哪些对象在堆上">哪些对象在堆上？</h4><p>（1）堆上的指针只能指向堆上的对象 （2）interface、chan、map所持有或转化为interface的对象都会在堆上 （3）函数内返回指针类型的，指针指向的对象会逃逸到堆上 （4）string类型一定在堆上 （5）切片扩容和拷贝在堆上</p><h4 id="如何优化">如何优化？</h4><p>（1）slice和map知道大小的，预先分配足够的大小，避免扩容 （2）尽量少生成string，使用切片的方式复用string （3）少用反射，被反射的对象都会分配到堆上 （4）使用sync.Pool复用对象，避免重复生产销毁对象 （5）尽量让chan传递较小的对象，所有chan传递的对象都会分配到堆上</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">问题：函数传递指针真的比传值效率高吗？<br>答案：传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加<span class="hljs-built_in">GC</span>的负担，所以传递指针不一定是高效的<br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>（1）垃圾回收的目标就是把那些已经分配的但没有对象引用的内存找出来并回收 （2）业界常用的垃圾回收算法有引用计数、标记清扫、分代收集，而golang使用了三色标记法。 （3）简单来说，GC启动时，初始化所有能访问到的栈对象为黑色，堆对象为白色。GC将根对象（bss段、date段、协程栈）标记为灰色加入队列进行广搜，将能遍历到的对象都标记为灰色并加入队列，被遍历过的灰色对象更新为黑色，当队列为空时所有白色对象都是需要清理的目标。 （4）这样做的原因是让垃圾回收流程与应用流程可以并发执行。这样将对象扫描过程拆分为多个阶段，而不需要一次性完成整个扫描流程，避免STW</p><p>这里放几个问题，用来校验知识的掌握程度： （1）go的内存分配有几种模式？区别是什么？ （2）go的GC有哪几个阶段？其中哪个阶段有STW?STW的作用是什么？ （3）go有哪些对象是分配到堆上的，什么时候会逃逸到堆上？</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang内存分配</title>
    <link href="/2024/04/22/Golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/2024/04/22/Golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p>详情见go专家编程 https://books.studygolang.com/GoExpertProgramming/chapter04/4.1-memory_alloc.html</p><p>本文主要是进行了浓缩并加上自己的理解</p><hr><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe">问题：<span class="hljs-keyword">new</span><span class="hljs-type"></span>和malloc的区别是什么？<br>答案：<br>（<span class="hljs-number">1</span>）<span class="hljs-keyword">new</span><span class="hljs-type"></span>和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持<br>（<span class="hljs-number">2</span>）<span class="hljs-keyword">new</span><span class="hljs-type"></span>可以完成自定义对象构造和析构工作，返回对应结构体指针，malloc则仅仅是分配内存空间，返回void* 指针<br>（<span class="hljs-number">3</span>）<span class="hljs-keyword">new</span><span class="hljs-type"></span>操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的大小<br>（<span class="hljs-number">4</span>）<span class="hljs-keyword">new</span><span class="hljs-type"></span>操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。前者的实现需要依赖后者<br></code></pre></td></tr></table></figure><p>我们知道在C语言中，malloc分配的内容在堆上，其他分配在栈上。当函数声明一个局部变量，但是返回该变量的指针时，会导致悬挂指针。</p><p><strong>go避免了这个问题：go语言编译器会做逃逸分析，分析局部变量的作用域是否逃出函数的作用域，要是没有，那么就放在栈上；要是变量的作用域超出了函数的作用域，那么就自动放在堆上</strong></p><h2 id="内存结构">内存结构</h2><p>为了方便自主管理内存，Go程序预申请了一大块内存（懒分配），可以划分为spans、bitmap、arena三部分</p><p><img src="Pasted%20image%2020240422203212.png"> spans和bitmap是为了管理arena区而存在的 arena是堆区，应用中需要的内存从这里分配，由于不同程序需要的内存大小各不相同，为了避免空间浪费，堆区可以划分为不同的class，每个class由特定的空间大小。</p><p>（1）span是内存管理的基本单位，由mspan结构体维护。 跟据对象大小，mspan将一个或多个页拆分成多个块进行管理，多个mspan串在一起构成链表。 <img src="Pasted%20image%2020240422205556.png"></p><p>（2）为了降低锁竞争，Golang为每个线程分配了mache结构体，内部包含了一个mspan数组，数组中每个元素代表了一种class类型的span列表 根据对象是否包含指针，将对象分为noscan和scan两类，其中noscan代表没有指针，而scan则代表有指针，需要GC进行扫描 <img src="Pasted%20image%2020240422205724.png"> （3）central是全局资源，由mcentral结构体维护，包含了span链表的指针。当某个线程内存不足时会向central申请，当某个线程释放内存时又会回收进central。<strong>每个mcentral对象只管理特定的class规格的span</strong> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">type</span> <span class="hljs-selector-tag">mcentral</span> <span class="hljs-selector-tag">struct</span> &#123;<br>    <span class="hljs-selector-tag">lock</span>      <span class="hljs-selector-tag">mutex</span>     <span class="hljs-comment">//互斥锁</span><br>    <span class="hljs-selector-tag">spanclass</span> <span class="hljs-selector-tag">spanClass</span> <span class="hljs-comment">// span class ID</span><br>    <span class="hljs-selector-tag">nonempty</span>  <span class="hljs-selector-tag">mSpanList</span> <span class="hljs-comment">// non-empty 指还有空闲块的span列表</span><br>    <span class="hljs-selector-tag">empty</span>     <span class="hljs-selector-tag">mSpanList</span> <span class="hljs-comment">// 指没有空闲块的span列表</span><br><br>    <span class="hljs-selector-tag">nmalloc</span> <span class="hljs-selector-tag">uint64</span>      <span class="hljs-comment">// 已累计分配的对象个数</span><br>&#125;<br><br>线程从<span class="hljs-selector-tag">central</span>获取<span class="hljs-selector-tag">span</span>步骤如下：<br><span class="hljs-number">1</span>. 加锁<br><span class="hljs-number">2</span>. 从<span class="hljs-selector-tag">nonempty</span>列表获取一个可用<span class="hljs-selector-tag">span</span>，并将其从链表中删除<br><span class="hljs-number">3</span>. 将取出的<span class="hljs-selector-tag">span</span>放入<span class="hljs-selector-tag">empty</span>链表<br><span class="hljs-number">4</span>. 将<span class="hljs-selector-tag">span</span>返回给线程<br><span class="hljs-number">5</span>. 解锁<br><span class="hljs-number">6</span>. 线程将该<span class="hljs-selector-tag">span</span>缓存进<span class="hljs-selector-tag">cache</span><br></code></pre></td></tr></table></figure></p><p>（4）mheap结构体维护了整个内存结构，它包含了span、bitmap、arena的起始位置，以及一个mcentral数组作为central的集合. <img src="Pasted%20image%2020240422210922.png"></p><h2 id="内存分配过程">内存分配过程</h2><p>当需要申请内存时： （1）获取当前线程的私有缓存mcache，根据分配内存的大小计算出ClassID （2）根据ClassID从mcache的alloc数组对应位置查询可用的mspan （3）如果mcache没有可用的span则从mcentral申请一个新的span加入mcache中，如果mcentral中也没有可用的span则从mheap中申请一个新的span加入mcentral （4）从获取到的mspan中找到空闲的arena地址并返回</p><h2 id="总结">总结</h2><p>（1）Golang程序启动时申请一大块内存，并划分成spans、bitmap、arena区域，由mheap管理 （2）arena区域按页划分成一个个小块 （3）mspan管理一个或多个页 （4）mcentral管理多个mspan供线程申请使用 （5）mcache作为线程私有资源，资源来源于mcentral</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习总结</title>
    <link href="/2024/04/19/docker%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/19/docker%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是docker">什么是docker？</h2><p>Docker是一种轻量级的虚拟化技术，可以为任何应用创建一个轻量级、可移植的的容器。<strong>开发者在电脑上编译测试通过的容器可以批量地在生产环境中部署</strong>。</p><p>镜像分层技术 + 利用宿主机内核（Namespaces+CGroups） = 轻量级 + 隔离性</p><h2 id="docker的优势是什么">docker的优势是什么？</h2><p>谈到容器化部署的好处，那自然是相对于虚拟化部署而言的。 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">注意容器化虽然也属于虚拟化的一种，但是这里所指的虚拟化部署指的是通过KVM等虚拟化方式创建的虚拟机来部署应用<br></code></pre></td></tr></table></figure></p><ul><li><p>轻量级 容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，直接运行于宿主内核，Docker对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效</p></li><li><p>环境一致性 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题</p></li><li><p>更轻松的维护和扩展 <code>Docker</code> 使用的分层存储以及镜像的技术，使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得更加简单。</p></li></ul><h2 id="为什么docker比虚拟机快">为什么docker比虚拟机快？</h2><p><img src="Pasted%20image%2020240315105829.png"></p><ul><li><p><strong>Docker不需要Hypervisor实现硬件资源虚拟化</strong>。运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上Docker将会在效率上有明显优势。</p></li><li><p><strong>Docker利用的是宿主机的内核，而不需要GuestOS</strong>。因此，当新建一个容器时，Docker不需要和虚拟机一样重新加载一个操作系统内核。可避免引导寻址、加载操作系统内核返回这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载GuestOS，返回新增过程是分钟级别的。而Docker由于利用宿主机的操作系统，则省略了返回的过程，因此新建一个Docker容器只需要几秒钟</p></li></ul><h2 id="docker如何实现容器隔离">docker如何实现容器隔离？</h2><p>传统的虚拟机方案直接虚拟了几套操作系统，它们之间是隔离的。因此运行在不同虚拟机上的应用服务自然也是隔离的。但是docker直接使用了宿主机内核，如何首先容器的隔离？</p><p>答案是利用Linux内核Kernel提供的Namespace功能模块。它可以用于容器的隔离，比如在容器A中不能看到容器B的进程。</p><p>Namespaces允许一个进程以及它的子进程从共享的宿主机内核资源（网络栈、进程列表、挂载点等）里获得一个仅自己可见的隔离区域</p><h2 id="docker如何实现资源控制">docker如何实现资源控制？</h2><p>Cgroups全称Control Groups，是Linux内核提供的物理资源隔离机制，通过这种机制，可以实现对Linux进程或者进程组的资源限制、隔离和统计功能。比如使用特定数目的cpu核数和特定大小的内存，如果资源超限的情况下，会被暂停或者杀掉</p><h2 id="docker的架构">docker的架构</h2><p><img src="Pasted%20image%2020240315102314.png"></p><p>Docker 使用 client-server 架构， Docker 客户端将命令发送给 Docker 守护进程，后者负责构建，运行和分发 Docker 容器。 Docker 客户端和守护程序使用 REST API，通过 UNIX 套接字或网络接口进行通信</p><ul><li><p>镜像（image）：Docker镜像是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建很多容器。容器与镜像的关系类似于面向对象编程中的对象与类</p></li><li><p>容器（container）：Docker利用容器独立运行的一个或一组应用。容器是用镜像创建的运行实例，容器可以被启动、开始，停止、删除，每个容器都是互相隔离，保证安全的平台，<strong>可以把容器看做是一个精简版的Linux环境和运行在其中的应用程序</strong></p></li><li><p>仓库（repository）：集中存放镜像文件的场所。仓库和仓库注册服务器是有区别的，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签(tag)。仓库分为公有仓库（Public）和私有仓库（Private）两种格式，最大的公共仓库是Docker Hub，其他的仓库包括国内的阿里云、网易云等；</p></li></ul><h2 id="docker常用指令">docker常用指令</h2><p><img src="Pasted%20image%2020240315104617.png"></p><h2 id="核心知识镜像分层">核心知识：镜像分层</h2><p><strong>Union文件系统（UnionFS）：是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下</strong></p><p>Union 文件系统是 Docker 镜像分层的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像</p><p><strong>特性：</strong> 一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><p><strong>优点</strong>：分层最大的一个好处就是共享资源。有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像。同时内存中也只需加载一份base镜像，就可以为所有容器服务了，而且镜像的每一层都可以被共享。</p><h4 id="docker-如何使用-unionfs">Docker 如何使用 UnionFS</h4><p>如果我们浏览Docker hub，能发现大多数镜像都不是从头开始制作，而是从一些base镜像基础上创建，比如debian基础镜像。而新镜像就是从基础镜像上一层层叠加新的逻辑构成的。这种分层设计，一个优点就是资源共享。</p><p>想象这样一个场景，一台宿主机上运行了100个基于debian base镜像的容器，难道每个容器里都有一份重复的debian拷贝呢？这显然不合理；借助Linux的unionFS，宿主机只需要在磁盘上保存一份base镜像，内存中也只需要加载一份，就能被所有基于这个镜像的容器共享。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">问题：当某个容器修改了基础镜像的内容，比如/bin文件夹下的文件，这时其他容器是否会发生变化呢？<br>答案：Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！这一层就是我们通常说的容器层，容器之下的都叫镜像层！根据容器镜像的写时拷贝（<span class="hljs-keyword">Copy</span>-<span class="hljs-keyword">on</span>-<span class="hljs-keyword">Write</span>）技术，某个容器对基础镜像的修改会被限制在单个容器内。<br></code></pre></td></tr></table></figure><p><img src="Pasted%20image%2020240315151612.png"></p><h4 id="docker镜像的加载原理">docker镜像的加载原理</h4><p>我们已经知道了docker的镜像实际上由一层一层的文件系统组成，它们被称为UnionFS。</p><p>所有镜像的最底层有两个基础镜像： （1）bootfs（boot file system） 主要包含 bootloader 和 Kernel ， bootloader 主要是引导加 kernel, Linux刚启动时会加载 bootfs 文件系统，在 Docker 镜像的最底层是 bootfs 。这一层与 Linux/Unix系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，此时系统也会卸载 bootfs。</p><p>（2）rootfs（root file system) 在 bootfs之上。包含的就是典型 Linux系统中 的 /dev /proc /bin /etc 等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos 等等。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">问题：平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？<br>答案：为底层直接用宿主机的 kernel，自己只需要提供 rootfs 就可以了。对于精简的OS来说,rootfs 可以很小，只需要包合最基本的命令，工具和程序库就可以了。所以整个centos镜像就看起来看小（因为大头直接使用了宿主机的kernel）<br></code></pre></td></tr></table></figure><h2 id="容器数据卷">容器数据卷</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">问题：为什么我们需要容器数据卷的技术？<br>答案：当我们部署了mysql，数据在容器中，一旦容器删除，数据会丢失。所以我们有了数据持久化的需求<br></code></pre></td></tr></table></figure><p>所谓容器数据卷就是将容器的目录挂载在linux，实现数据的持久化。例如将宿主机/home/mysql映射到mysql容器中的路径/usr/mysql。这样无论哪个文件夹多了或者少了内容，都会同步到另外一个文件夹。</p><h4 id="使用方法">使用方法</h4><p>直接使用 -v 命令来挂载 <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="language-bash"> -it -v /home/sql:/usr/sql</span><br>前者是宿主机目录，后者是容器内目录<br></code></pre></td></tr></table></figure></p><h4 id="优势">优势</h4><p>（1）实现持久化，避免删除容器导致数据丢失 （2）更方便的修改配置，只要修改挂载出来的文件，就可以达到修改容器内部文件（不用进入容器的命令行）</p><h4 id="具名挂载-匿名挂载-指定路径挂载">具名挂载 匿名挂载 指定路径挂载</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">-v 容器内路径 <span class="hljs-comment">//匿名挂载</span><br>-v 卷名:容器内路径 <span class="hljs-comment">//具名挂载</span><br>-v /宿主机路径:容器内路径 <span class="hljs-comment">//指定路径挂载</span><br><br>容器内路径:ro 表示只读 <span class="hljs-comment">//该容器只能在容器外修改</span><br></code></pre></td></tr></table></figure><h2 id="dockerfile">Dockerfile</h2><p>Dockerfile是用来构建docker镜像的文件。</p><p><img src="Pasted%20image%2020240315202120.png"></p><h2 id="docker网络">Docker网络</h2><p>当<code>Docker</code>进程启动时，会在主机上创建一个名为<code>docker0</code>的虚拟网桥，此主机上启动的<code>Docker</code>容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p><p>从<code>docker0</code>子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的<strong>默认网关</strong>。在主机上创建一对虚拟网卡<code>veth pair</code>设备，Docker 将 veth pair 设备的一端放在新创建的容器中，并命名为<code>eth0</code>（容器的网卡），另一端放在主机中，以<code>vethxxx</code>这样类似的名字命名，并将这个网络设备加入到 docker0 网桥中。可以通过<code>brctl show</code>命令查看。</p><p><img src="Pasted%20image%2020240316214955.png"></p><p>Bridge 桥接模式的实现步骤主要如下：</p><ul><li>Docker Daemon 利用 veth pair 技术，在宿主机上创建一对对等虚拟网络接口设备，保证无论哪一个 veth 接收到网络报文，都会将报文传输给另一方。</li><li>Docker Daemon 将 veth0 附加到 Docker Daemon 创建的 docker0 网桥上。保证宿主机的网络报文可以发往 veth0；</li><li>Docker Daemon 将 veth1 添加到 Docker Container 所属的 namespace 下，并被改名为 eth0。如此一来，宿主机的网络报文若发往 veth0，则立即会被 Container 的 eth0 接收，实现宿主机到 Docker Container 网络的联通性；同时，也保证 Docker Container 单独使用 eth0，实现容器网络环境的隔离性。</li></ul><h2 id="docker-compose">docker compose</h2><p>Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。使用前面介绍的Dockerfile我们很容易定义一个单独的应用容器。然而在日常开发工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。</p><p>例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器；再比如在分布式应用一般包含若干个服务，每个服务一般都会部署多个实例。如果每个服务都要手动启停，那么效率之低、维护量之大可想而知。这时候就需要一个工具能够管理一组相关联的的应用容器，这就是Docker Compose</p><p>使用 Compose 基本上分为三步： 1. 使用 Dockerfile 定义您的应用程序的环境 2. 使用 docker-compose.yml 定义组成您的应用程序的服务 3. 运行docker compose up启动并运行程序</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker, 容器化技术, 云原生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx学习总结</title>
    <link href="/2024/04/19/Nginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/19/Nginx%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器。特点是占有内存少，并发能力强。有报告表明能支持高达 50,000 个并发连接数。主要优点在于： 1. 高性能：事件驱动、异步调用、Epoll 2. 轻量级：Nginx的二进制文件很小，可以快速启动并占用较少的内存。 3. 可靠性高：Nginx的代码被设计为高可靠性的，可以在长时间运行中保持稳定性。 4. 可扩展性好：Nginx可以通过添加第三方模块或编写自定义模块来扩展其功能。 5. 支持热部署：Nginx可以在不停止服务的情况下重新加载配置文件和动态模块。</p><p>Nginx的主要功能有三点： （1）反向代离 （2）负载均衡 （3）动静分离</p><h2 id="架构">架构</h2><p>下图是Nginx的进程架构图，可以看到它含有4类进程：1个Master管理进程、多个Worker工作进程、1个Cache Loader缓存载入进程和1个Cache Manager缓存淘汰进程：</p><p><img src="Pasted%20image%2020240319205726.png"></p><p>Master是管理进程，它长期处于Sleep状态，并不参与请求的处理，因此几乎不消耗服务器的IT资源。另外，只有在开启HTTP缓存后，Cache Loader和Cache Manager进程才存在，其中，当Nginx启动时加载完磁盘上的缓存文件后，Cache Loader进程也会自动退出</p><p>该架构下程序的工作模式是这样的： （1）主进程执行 bind() + listen() 后，创建多个子进程 （2）每个子进程，都通过 accept() 或 epoll_wait() ，来处理相同的套接字</p><h2 id="为什么nginx性能好">为什么Nginx性能好？</h2><p>谈到Redis缓存，我们描述其性能时会这么说：支持C10K（1万并发连接），几万QPS。而我们描述Nginx的高性能时，则会宣示：支持C10M（1千万并发连接），百万级QPS</p><p>Redis与Nginx同样使用了事件驱动、异步调用、Epoll这些机制，为什么Nginx的并发连接会高出那么多呢？</p><p>https://cloud.tencent.com/developer/article/1761931</p><p>（1）将Worker进程控制在略大于CPU核心数量，占据更多的CPU时间</p><p>（2）设置worker进程的静态优先级，占据更长的CPU时间片 在Linux中，静态优先级共包含40级，从-20到+19不等，其中-20表示最高优先级。进程的默认优先级是0，所以你可以通过调级优先级，让Worker进程获得更多的CPU资源。在nginx.conf文件中，worker_priority配置就能设置静态优先级，比如： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">worker_priority <span class="hljs-number">-10</span>;<br></code></pre></td></tr></table></figure></p><p>（3）使用CPU亲和机制（见后文） 由于每个CPU核心都拥有一级、二级缓存，为了提高这两级缓存的命中率，可以将Worker进程与CPU核心绑定在一起。频繁命中CPU缓存，可以提升Nginx指令的执行速度**</p><p>Nginx的多进程架构已经能够支持C10M级别的高并发了，那么Nginx中的多线程又是怎么回事呢？</p><p>材料、散热这些基础科技没有获得重大突破前，CPU频率很难增长，类似Redis、NodeJS这样的单进程、单线程高并发服务，只能向分布式集群方向发展，才能继续提升性能。Nginx通过Master/Worker多进程架构，可以充分使用服务器上百个CPU核心，实现C10M。</p><p>总结： 为了榨干多核CPU的价值，Nginx无所不用：通过绑定CPU提升二级缓存的命中率，通过静态优先级扩大时间片，通过多种手段均衡Worker进程之间的负载，在独立线程池中隔离阻塞的IO操作，建立本地代理缓存等等。可见，高性能既来自于架构，更来自于细节。</p><h2 id="为什么-nginx-不使用多线程">为什么 Nginx 不使用多线程？</h2><p>（1）多进程已经够用了，效率很高，所以没必要 每进来一个request，会有一个worker进程去处理。但不是全程的处理，只处理到发生阻塞的地方，比如向上游（后端）服务器转发request，并等待请求返回。那么，这个处理的worker不会傻等（阻塞），他会在发送完请求后，注册一个事件：“如果upstream返回了，告诉我一声&quot;。于是他就休息去了。此时，如果再有request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。这样即使很少的进程也可以完成很大的并发任务</p><p>（2）会引入风险降低可用性 Nginx的模块化设计允许第三方代码（结合自己的业务设计模块，例如限流模块）嵌入到核心流程中执行，这虽然大大丰富了Nginx生态，却也引入了风险。作为高性能负载均衡，稳定性非常重要。由于多线程共享同一地址空间，一旦出现内存错误，所有线程都会被内核强行终止，这会降低系统的可用性。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nim">指令： upstream <br>语法： upstream name <span class="hljs-meta">&#123;...&#125;</span> <br>环境： http含义：定义一组 <span class="hljs-type">HTTP</span>服务器，这些服务器可以监听不同的端口，以及 <span class="hljs-type">TCP</span>和 <span class="hljs-type">UNIX</span>套接字。在同一个 upstream中可以混合使用不同的端口、 <span class="hljs-type">TCP</span>和 <span class="hljs-type">UNIX</span>套接字。需要指定一系列的回调函数<br><br>注意：从本质上说，upstream 属于 handler，只是他不产生自己的内容，而是通过请求后端服务器得到内容<br></code></pre></td></tr></table></figure><h2 id="反向代离">反向代离</h2><p>正向代理：客户端的一切请求都传递到代理服务器，服务端收到的请求都来自代理服务器，具体是哪个客户端的请求，服务端不关心。<strong>正向代理相当于向服务端屏蔽了具体的客户端细节</strong></p><p><strong>反向代理相当于服务端向客户端屏蔽了具体的服务端细节</strong>，客户端在发起域名请求时，并不关心到底是访问的哪台服务器，这样Nginx就可以接收所有客户端的请求，然后决定派发到哪一个服务器。</p><p>nginx也可以用来做正向代理</p><h2 id="负载均衡">负载均衡</h2><p>客户端发出的请求<code>192.168.12.129</code>最终会转变为：<code>http://192.168.12.129:80/</code>，然后再向目标<code>IP</code>发起请求，流程如下： - 由于<code>Nginx</code>监听了<code>192.168.12.129</code>的<code>80</code>端口，所以最终该请求会找到<code>Nginx</code>进程； - <code>Nginx</code>首先会根据配置的<code>location</code>规则进行匹配，根据客户端的请求路径<code>/</code>，会定位到<code>location /&#123;&#125;</code>规则； - 然后根据该<code>location</code>中配置的<code>proxy_pass</code>会再找到名为<code>nginx_boot</code>的<code>upstream</code>； - 最后根据<code>upstream</code>中的配置信息，将请求转发到运行<code>WEB</code>服务的机器处理，由于配置了多个<code>WEB</code>服务，且配置了权重值，因此<code>Nginx</code>会依次根据权重比分发请求</p><p><strong>为了防止服务器上的其他进程占用过多的CPU，你还可以给Worker进程赋予更高的静态优先级</strong></p><p>具体的负载均衡内置策略包含：加权轮询 和 IP hash</p><h4 id="为什么要做负载均衡">为什么要做负载均衡？</h4><p>很容易理解，因为单机无法解决现在的访问量，所以引入了多机+nginx反向代理，但如果不能负载均衡，所有的请求都冲到一个服务器上，就回归了单机的情况，后端服务会崩溃</p><h2 id="动静分离">动静分离</h2><p>也就是将动态资源和静态资源分开处理</p><h4 id="为什么需要做动静分离呢它带来的好处是什么">为什么需要做动静分离呢？它带来的好处是什么？</h4><p>当我们进行web访问时，比如浏览器输入<code>www.taobao.com</code>访问淘宝首页，打开开发者调试工具可以很明显的看到，首页加载会出现<code>100+</code>的请求数，而正常初学项目开发时，静态资源一般会放入到<code>resources/static/</code>目录下。</p><p>如果这样的话，首页100+的所有请求都会来到部署WEB服务的机器处理，那则代表着一个客户端请求淘宝首页，就会对后端服务器造成100+的并发请求，一旦用户多起来，这对于后端服务器的压力是巨大的。</p><p>但如果仔细分析这100+个请求会发现，至少有<code>60+</code>是属于<code>*.js、*.css、*.html、*.jpg.....</code>这类静态资源的请求。这些资源有一个特性就是短时间不会改变（不会或者不要求实时改变）。那其实就没必要让这些请求到后端去处理，在nginx就可以处理了。</p><p><strong>做了动静分离之后，至少能够让后端服务减少一半以上的并发量。</strong></p><h2 id="nginx缓冲区">Nginx缓冲区</h2><p>接入<code>Nginx</code>的项目一般请求流程为：“客户端→<code>Nginx</code>→服务端”，在这个过程中存在两个连接：“客户端→<code>Nginx</code>、<code>Nginx</code>→服务端”，那么两个不同的连接速度不一致，就会影响用户的体验（比如浏览器的加载速度跟不上服务端的响应速度）</p><p>其实也就类似电脑的内存跟不上<code>CPU</code>速度，所以对于用户造成的体验感极差，因此在<code>CPU</code>设计时都会加入三级高速缓冲区，用于缓解<code>CPU</code>和内存速率不一致的矛盾。在<code>Nginx</code>也同样存在缓冲区的机制，主要目的就在于：<strong>「用来解决两个连接之间速度不匹配造成的问题」</strong> ，有了缓冲后，<code>Nginx</code>代理可暂存后端的响应，然后按需供给数据给客户端。先来看看一些关于缓冲区的配置项：</p><h4 id="缓存机制">缓存机制</h4><p>对于性能优化而言，缓存是一种能够大幅度提升性能的方案，因此几乎可以在各处都能看见缓存，如客户端缓存、代理缓存、服务器缓存等等，<code>Nginx</code>的缓存则属于代理缓存的一种。对于整个系统而言，加入缓存带来的优势额外明显：</p><ul><li>减少了再次向后端或文件服务器请求资源的带宽消耗。</li><li>降低了下游服务器的访问压力，提升系统整体吞吐。</li><li>缩短了响应时间，提升了加载速度，打开页面的速度更快。</li></ul><p>那么在<code>Nginx</code>中，又该如何配置代理缓存呢？通过配置项：<strong>「proxy_cache_path」</strong></p><h2 id="黑白名单">黑白名单</h2><p>有时候往往有些需求，可能某些接口只能开放给对应的合作商，或者购买/接入<code>API</code>的合作伙伴，那么此时就需要实现类似于<code>IP</code>白名单的功能。而有时候有些恶意攻击者或爬虫程序，被识别后需要禁止其再次访问网站，因此也需要实现<code>IP</code>黑名单。那么这些功能无需交由后端实现，可直接在<code>Nginx</code>中处理。<code>Nginx</code>做黑白名单机制，主要是通过<code>allow、deny</code>配置项来实现：</p><h2 id="nginx防盗链设计">Nginx防盗链设计</h2><p>盗链：<strong>「盗链即是指外部网站引入当前网站的资源对外展示」</strong></p><p>举个简单的例子理解：好比壁纸网站<code>X</code>站、<code>Y</code>站，<code>X</code>站是一点点去购买版权、签约作者的方式，从而积累了海量的壁纸素材，但<code>Y</code>站由于资金等各方面的原因，就直接通过<code>&lt;img src=&quot;X站/xxx.jpg&quot; /&gt;</code>这种方式照搬了<code>X</code>站的所有壁纸资源，继而提供给用户下载。</p><p>应该该如何屏蔽这类问题呢？答案是「防盗链」技术！<code>Nginx</code>的防盗链机制实现，跟一个头部字段：<code>Referer</code>有关，该字段主要描述了当前请求是从哪儿发出的，那么在<code>Nginx</code>中就可获取该值，然后判断是否为本站的资源引用请求，如果不是则不允许访问</p><h2 id="性能优化">性能优化</h2><h4 id="优化一打开长连接配置">优化一：打开长连接配置</h4><p>通常Nginx作为代理服务，负责分发客户端的请求，那么建议开启<code>HTTP</code>长连接，用户减少握手的次数，降低服务器损耗，具体如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">upstream xxx &#123; <br># 长连接数 <br>keepalive <span class="hljs-number">32</span>; <br># 每个长连接提供的最大请求数 <br>keepalived_requests <span class="hljs-number">100</span>; <br># 每个长连接没有新的请求时，保持的最长时间 <br>keepalive_timeout <span class="hljs-number">60</span>s; &#125;<br></code></pre></td></tr></table></figure></p><h4 id="优化二开启零拷贝技术">优化二：开启零拷贝技术</h4><p>零拷贝这个概念，在大多数性能较为不错的中间件中都有出现，例如<code>Kafka、Netty</code>等，而<code>Nginx</code>中也可以配置数据零拷贝技术</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sendfile on; # 开启零拷贝机制  <br></code></pre></td></tr></table></figure><p>零拷贝读取机制与传统资源读取机制的区别： - <strong>「传统方式：」</strong> 硬件--&gt;内核--&gt;用户空间--&gt;程序空间--&gt;程序内核空间--&gt;网络套接字</p><ul><li><strong>「零拷贝方式：」</strong> 硬件--&gt;内核--&gt;程序内核空间--&gt;网络套接字</li></ul><h4 id="优化三开启无延迟或多包共发机制">优化三：开启无延迟或多包共发机制</h4><p>在<code>Nginx</code>中有两个较为关键的性能参数，即<code>tcp_nodelay、tcp_nopush</code>，开启方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">tcp_nodelay on;   <span class="hljs-comment">//一般要建立在开启了长连接模式的情况下使用</span><br>tcp_nopush on;    <span class="hljs-comment">//必须要开启sendfile参数（零拷贝）才可使用的</span><br></code></pre></td></tr></table></figure><p><code>TCP/IP</code>协议中默认是采用了Nagle算法的，即在网络数据传输过程中，每个数据报文并不会立马发送出去，而是会等待一段时间，将后面的几个数据包一起组合成一个数据报文发送，但这个算法虽然提高了网络吞吐量，但是实时性却降低了，因此： （1）项目如果属于交互性很强的应用，那么可以手动开启<code>tcp_nodelay</code>配置，让应用程序向内核递交的每个数据包都会立即发送出去。但这样会产生大量的<code>TCP</code>报文头，增加很大的网络开销。常见的场景为<code>IM</code>、金融等类型的项目 （2）有些项目的业务对数据的实时性要求并不高，追求的则是更高的吞吐，那么则可以开启<code>tcp_nopush</code>配置项，这个配置就类似于“塞子”的意思，首先将连接塞住，使得数据先不发出去，等到拔去塞子后再发出去。设置该选项后，内核会尽量把小数据包拼接成一个大的数据包（一个<code>MTU</code>）再发送出去，当然若一定时间后（一般为<code>200ms</code>），内核仍然没有积累到一个<code>MTU</code>的量时，也必须发送现有的数据，否则会一直阻塞，常见常见为调度系统、报表系统等</p><h4 id="优化四调整worker工作进程">优化四：调整Worker工作进程</h4><p><code>Nginx</code>启动后默认只会开启一个<code>Worker</code>工作进程处理客户端请求，而我们可以根据机器的CPU核数开启对应数量的工作进程，以此来提升整体的并发量支持，如下 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"># 自动根据CPU核心数调整Worker进程数量  <br>worker_processes <span class="hljs-keyword">auto</span>;  <br></code></pre></td></tr></table></figure></p><p><strong>Worker进程的数量必须等于或者大于CPU核心的数量</strong>。由于Nginx采用了事件驱动的非阻塞架构，繁忙时Worker进程会一直处于Running状态，<strong>因此1个Worker进程就能够完全占用1个CPU核心的全部计算力</strong>，如果Worker进程数超过了CPU核心数，反而会造成一些Worker进程因为抢不到CPU而进入Sleep状态休眠</p><h4 id="优化五开启cpu亲和机制redis也有类似的优化方案">优化五：开启CPU亲和机制（redis也有类似的优化方案）</h4><p>因为进程/线程数往往都会远超出系统CPU的核心数，因此操作系统执行的原理本质上是采用时间片切换机制，也就是一个CPU核心会在多个进程之间不断频繁切换，造成很大的性能损耗。而CPU亲和机制则是指将每个<code>Nginx</code>的工作进程，绑定在固定的CPU核心上，从而减小CPU切换带来的时间开销和资源损耗，开启方式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">worker_cpu_affinity <span class="hljs-keyword">auto</span>;  <br></code></pre></td></tr></table></figure><p>taskset是linux提供的一个命令，可以让某个程序运行在某个（或）某些CPU上</p><h4 id="优化六开启epoll模型及调整并发连接数">优化六：开启epoll模型及调整并发连接数</h4><p><code>Nginx、Redis</code>都是基于多路复用模型去实现的程序，但最初版的多路复用模型<code>select</code>最大只能监听<code>1024</code>个连接，而<code>epoll</code>则属于<code>select</code>接口的增强版，因此采用该模型能够大程度上提升单个<code>Worker</code>的性能</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">问题：为什么select只能监听1024的连接？<br>答案：select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认**最大值为 1024**，只能监听 0~1023 的文件描述符<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">events &#123;  <br>    # 使用epoll网络模型  <br>    use epoll;  <br>    # 调整每个Worker能够处理的连接数上限  <br>    worker_connections  <span class="hljs-number">10240</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="nginx与网关">Nginx与网关</h2><p>网关是系统的唯一对外的入口，介于客户端和服务器端之间的中间层，处理非业务功能，提供路由请求、鉴权、监控、缓存、限流等功能。无论你查看任何一个微服务项目架构，你都会发现在客户端和服务器端之间有一个网关，移动端的任何请求都必须经过网关才能到达服务端，见下图： <img src="Pasted%20image%2020240319184553.png"></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">过滤器Filter和网关的区别<br><span class="hljs-bullet">- </span>过滤器用于拦截单个服务<br><span class="hljs-bullet">- </span>网关用于拦截整个微服务<br><span class="hljs-bullet">- </span>可以理解成网关是小区门口的保安，拦截的是所有到访者；过滤器则是每户人家的门，拦截的是单个人，而且要想到达过滤器必须先经过网关。<br></code></pre></td></tr></table></figure><h4 id="nginx和gateway区别">Nginx和Gateway区别</h4><ul><li>相同点：都是可以实现对api接口的拦截，负载均衡、反向代理、请求过滤等。</li><li>不同点：Nginx是用C语言写的，而Gateway是用Java写的，能够更好对微服务实现拓展功能，而Nginx想要实现拓展功能需要结合Lua语言等。此外Nginx实现负载均衡原理是属于服务器端负载均衡器，而Gateway则是采用本地负载均衡的形式。</li></ul><h4 id="使用场景">使用场景</h4><p>首先Nginx会抵御第一波的并发流量，是用户最前端的访问，可以把它当做第一层网关。可以看到上面的图片中项目都是通过Nginx来实现静态资源映射的，这时候输入的url是Nginx中配置的url。经过Nginx之后，Nginx通过反向代理再将请求转发到不同的网关系统，这是第二层网关，网关系统是根据不同的微服务来整合的，比如移动端网关，自媒体端网关，管理员端网关等。</p><p><strong>在项目中同时使用到这两者的情况时候，可以这么理解，用户请求进来是先过Nginx网关，这里的Nginx就相当于一个流量网关，是属于用户访问的一个入口。 然后在进入到getway网关中，这里的getway网关属于一个业务网关，通过对应的属性配置将请求传递到每一个业务微服务中去。</strong></p><p>换句话说： <strong>Nginx做四层LB（传输层负载均衡）</strong> <strong>SpringGateway做七层LB（应用层负载均衡）</strong></p><p><strong>Nginx不再承担着服务的路由分发和负载均衡，转而使用SpringCloudGateway做更专业的事，是解耦的一种表现，两种网关的出现是架构在进化中对服务进一步细分的体现。</strong></p><h4 id="为什么有nginx还需要springcloudgateway">为什么有Nginx还需要SpringCloudGateway?</h4><p>SpringCloudGateway是一个从逻辑上更贴近服务侧，一般作为API网关，与项目更是一个整体。可以根据业务更可塑地进行网关逻辑的编写和调度。同时在控制层上多加上统一的一层，有效地实现了统一鉴权，将鉴权这件事成功地从原来的代码逻辑中解耦出来。<strong>核心：解耦</strong></p><h4 id="为什么有springcloudgateway还需要nginx呢">为什么有SpringCloudGateway还需要Nginx呢？</h4><p>（1）SpringCloudGateway是一个从逻辑上更贴近服务侧，一般作为API网关，而Nginx则是流量网关，二者负责的功能不同 （2）除了网关这个能力外，Nginx在很多情况下还充当静态资源服务器 服务器本地放着静态资源，实现动静分离，当大量的访问到达，nginx可以回应一部分不常变化的请求，例如css文件。避免大量的访问冲击后端业务。</p><h2 id="upstream-使用方式">upstream 使用方式</h2><p>upstream 模块不产生自己的内容，而是通过请求后端服务器得到内容。Nginx 内部封装了请求并取得响应内容的整个过程，所以upstream 模块只需要开发若干回调函数，完成构造请求和解析响应等具体的工作。</p><p>HTTP 模块启动upstream 机制的过程： 1. 调用函数 ngx_http_upstream_create 为请求创建upstream； 2. 设置上游服务器的地址；可通过配置文件 nginx.conf 配置好上游服务器地址；也可以通过ngx_http_request_t 中的成员resolved 设置上游服务器地址； 3. 设置 upstream 的回调方法； 4. 调用函数 ngx_http_upstream_init 启动upstream；</p><h4 id="如何处理http请求">如何处理http请求？</h4><p>在 Nginx 的初始化启动过程中，worker 工作进程会调用事件模块的ngx_event_process_init 方法为每个监听套接字ngx_listening_t 分配一个 ngx_connection_t 连接，并设置该连接上读事件的回调方法handler 为ngx_event_accept，同时将读事件挂载到epoll 事件机制中等待监听套接字连接上的可读事件发生，到此，Nginx 就可以接收并处理来自客户端的请求</p><h2 id="事件驱动模型源码">事件驱动模型源码</h2><p>事件驱动处理又被称为IO多路复用，最常见的包括以下三种：select模型，poll模型和epoll模型。Nginx服务器还支持rtsig模型、kqueue模型、dev/poll模型和eventport模型等</p><h3 id="select库poll库">select库/poll库</h3><p>select 实现多路复用的方式是，将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select 函数将文件描述符集合<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</p><p>所以，对于 select 这种方式，需要进行 <strong>2 次「遍历」文件描述符集合</strong>，一次是在内核态里，一个次是在用户态里 ，而且还会发生 <strong>2 次「拷贝」文件描述符集合</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认<strong>最大值为 1024</strong>，只能监听 0~1023 的文件描述符</p><p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p><p>但是 poll 和 select 并没有太大的本质区别，<strong>都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</strong>，这种方式随着并发数上来，性能的损耗会呈指数级增长</p><h3 id="epoll库">epoll库</h3><p>epoll库是Nginx服务器支持的高性能事件驱动库之一，它是公认的非常优秀的事件驱动模型，和poll库及select库有很大的不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//用法</span><br><span class="hljs-type">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>bind(s, ...);<br>listen(s, ...)<br><br><span class="hljs-type">int</span> epfd = epoll_create(...);<br>epoll_ctl(epfd, ...); <span class="hljs-comment">//将所有需要监听的socket添加到epfd中</span><br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">int</span> n = epoll_wait(...);<br>    <span class="hljs-keyword">for</span>(接收到数据的socket)&#123;<br>        <span class="hljs-comment">//处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>epoll 通过两个方面，很好解决了 select/poll 的问题 第一点，epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 <code>O(logn)</code>。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p><p>第二点， epoll 使用<strong>事件驱动</strong>的机制，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p><p><img src="Pasted%20image%2020240318165716.png"></p><p>epoll 的方式即使监听的 Socket 数量越多的时候，<strong>效率不会线性下降</strong>，能够同时监听的 Socket 的数目上限为系统定义的进程打开的最大文件描述符个数。因而，<strong>epoll 被称为解决 C10K 问题的利器</strong>。</p><h3 id="源码解析">源码解析</h3><p>两个数据结构和四个函数 （1）epitem <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> &#123;</span><br>RB_ENTRY(epitem) rbn;<br><span class="hljs-comment">/*  RB_ENTRY(epitem) rbn等价于</span><br><span class="hljs-comment">struct &#123;</span><br><span class="hljs-comment">struct type *rbe_left;//指向左子树</span><br><span class="hljs-comment">struct type *rbe_right;//指向右子树</span><br><span class="hljs-comment">struct type *rbe_parent;//指向父节点</span><br><span class="hljs-comment">int rbe_color;    //该节点的颜色</span><br><span class="hljs-comment">&#125; rbn</span><br><span class="hljs-comment">*/</span><br> <br>LIST_ENTRY(epitem) rdlink;<br><span class="hljs-comment">/* LIST_ENTRY(epitem) rdlink等价于</span><br><span class="hljs-comment">struct &#123;</span><br><span class="hljs-comment">struct type *le_next;//指向下个元素</span><br><span class="hljs-comment">struct type **le_prev;//前一个元素的地址</span><br><span class="hljs-comment">&#125;*/</span><br> <br><span class="hljs-type">int</span> rdy; <span class="hljs-comment">//判断该节点是否同时存在与红黑树和双向链表中</span><br><br><span class="hljs-type">int</span> sockfd; <span class="hljs-comment">//socket句柄</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>;</span>  <span class="hljs-comment">//存放用户填充的事件</span><br>&#125;;<br></code></pre></td></tr></table></figure></p><p>epitem是中包含了两个主要的成员变量，分别是rbn和rdlink，前者是红黑树的节点，而后者是双链表的节点，也就是说一个epitem对象即可作为红黑树中的一个节点又可作为双链表中的一个节点。并且每个epitem中存放着一个event，对event的查询也就转换成了对epitem的查询。</p><p>也就是说在epoll中，epitem作为操作的最小单元出现，在红黑树中它就是红黑树节点，在链表中就是链表的节点</p><p>（2）eventpoll <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> &#123;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ep_rb_tree &#123;</span><br><span class="hljs-comment">struct epitem *rbh_root; </span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br>ep_rb_tree rbr;      <span class="hljs-comment">//rbr指向红黑树的根节点</span><br><br><span class="hljs-type">int</span> rbcnt; <span class="hljs-comment">//红黑树中节点的数量（也就是添加了多少个TCP连接事件）</span><br><br>LIST_HEAD( ,epitem) rdlist;    <span class="hljs-comment">//rdlist指向双向链表的头节点；</span><br><span class="hljs-comment">/*这个LIST_HEAD等价于 </span><br><span class="hljs-comment">struct &#123;</span><br><span class="hljs-comment">struct epitem *lh_first;</span><br><span class="hljs-comment">&#125;rdlist;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> rdnum; <span class="hljs-comment">//双向链表中节点的数量（也就是有多少个TCP连接来事件了）</span><br> <br><span class="hljs-comment">// ...略...</span><br><br>&#125;;<br></code></pre></td></tr></table></figure></p><p>eventpoll是epoll的核心结构体。其中包含了两个主要的成员变量，分别是rbr和rdlist，前者指向红黑树的根节点，后者指向双链表的头结点。</p><p>（3）epoll_create() <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建epoll对象，包含一颗空红黑树和一个空双向链表</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br><span class="hljs-comment">//与很多内核版本一样，size参数没有作用，只要保证大于0即可</span><br><span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>nty_tcp_manager *tcp = nty_get_tcp_manager(); <span class="hljs-comment">//获取tcp对象</span><br><span class="hljs-keyword">if</span> (!tcp) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">nty_socket</span> *<span class="hljs-title">epsocket</span> =</span> nty_socket_allocate(NTY_TCP_SOCK_EPOLL);<br><span class="hljs-keyword">if</span> (epsocket == <span class="hljs-literal">NULL</span>) &#123;<br>nty_trace_epoll(<span class="hljs-string">&quot;malloc failed\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br> <br><span class="hljs-comment">// 1° 开辟了一块内存用于填充eventpoll对象</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span> =</span> (<span class="hljs-keyword">struct</span> eventpoll*)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> eventpoll));<br><span class="hljs-keyword">if</span> (!ep) &#123;<br>nty_free_socket(epsocket-&gt;id, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br> <br>ep-&gt;rbcnt = <span class="hljs-number">0</span>;<br> <br><span class="hljs-comment">// 2° 让红黑树根指向空</span><br>RB_INIT(&amp;ep-&gt;rbr);       <span class="hljs-comment">//等价于ep-&gt;rbr.rbh_root = NULL;</span><br> <br><span class="hljs-comment">// 3° 让双向链表的头指向空</span><br>LIST_INIT(&amp;ep-&gt;rdlist);  <span class="hljs-comment">//等价于ep-&gt;rdlist.lh_first = NULL;</span><br> <br><span class="hljs-comment">// 4° 并发环境下进行互斥</span><br><span class="hljs-comment">// ...该部分代码与主线逻辑无关，可自行查看...</span><br> <br><span class="hljs-comment">//5° 保存epoll对象</span><br>tcp-&gt;ep = (<span class="hljs-type">void</span>*)ep;<br>epsocket-&gt;ep = (<span class="hljs-type">void</span>*)ep;<br> <br><span class="hljs-keyword">return</span> epsocket-&gt;id;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>对以上代码的逻辑进行梳理，可以总结为以下6步： 1. 创建eventpoll对象 2. 让eventpoll中的rbr指向空 3. 让eventpoll中的rdlist指向空 4. 在并发环境下进行互斥 5. 保存eventpoll对象 6. 返回eventpoll对象的句柄(id)</p><p>（4）epoll_ctl() <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//往红黑树中加每个tcp连接以及相关的事件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epid, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> sockid, <span class="hljs-keyword">struct</span> epoll_event *event)</span> &#123;<br> <br>nty_tcp_manager *tcp = nty_get_tcp_manager();<br><span class="hljs-keyword">if</span> (!tcp) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br> <br>nty_trace_epoll(<span class="hljs-string">&quot; epoll_ctl --&gt; 1111111:%d, sockid:%d\n&quot;</span>, epid, sockid);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">nty_socket</span> *<span class="hljs-title">epsocket</span> =</span> tcp-&gt;fdtable-&gt;sockfds[epid];<br> <br><span class="hljs-keyword">if</span> (epsocket-&gt;socktype == NTY_TCP_SOCK_UNUSED) &#123;<br>errno = -EBADF;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br> <br><span class="hljs-keyword">if</span> (epsocket-&gt;socktype != NTY_TCP_SOCK_EPOLL) &#123;<br>errno = -EINVAL;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br> <br>nty_trace_epoll(<span class="hljs-string">&quot; epoll_ctl --&gt; eventpoll\n&quot;</span>);<br><br><span class="hljs-comment">//取出之前创建的ep</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span> =</span> (<span class="hljs-keyword">struct</span> eventpoll*)epsocket-&gt;ep;<br><span class="hljs-keyword">if</span> (!ep || (!event &amp;&amp; op != EPOLL_CTL_DEL)) &#123;<br>errno = -EINVAL;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br> <br><span class="hljs-keyword">if</span> (op == EPOLL_CTL_ADD) &#123;<br><span class="hljs-comment">//添加sockfd上关联的事件</span><br>pthread_mutex_lock(&amp;ep-&gt;mtx);<br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> <span class="hljs-title">tmp</span>;</span><br>tmp.sockfd = sockid;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> RB_FIND(_epoll_rb_socket, &amp;ep-&gt;rbr, &amp;tmp); <span class="hljs-comment">//先在红黑树上找，根据key来找，也就是这个sockid，找的速度会非常快</span><br><span class="hljs-keyword">if</span> (epi) &#123;<br><span class="hljs-comment">//原来有这个节点，不能再次插入</span><br>nty_trace_epoll(<span class="hljs-string">&quot;rbtree is exist\n&quot;</span>);<br>pthread_mutex_unlock(&amp;ep-&gt;mtx);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br> <br><span class="hljs-comment">//只有红黑树上没有该节点【没有用过EPOLL_CTL_ADD的tcp连接才能走到这里】；</span><br> <br><span class="hljs-comment">//(1)生成了一个epitem对象，这个结构对象，其实就是红黑的一个节点；</span><br>epi = (<span class="hljs-keyword">struct</span> epitem*)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epitem));<br><span class="hljs-keyword">if</span> (!epi) &#123;<br>pthread_mutex_unlock(&amp;ep-&gt;mtx);<br>errno = -ENOMEM;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//(2)把socket(TCP连接)保存到节点中；</span><br>epi-&gt;sockfd = sockid;  <span class="hljs-comment">//作为红黑树节点的key，保存在红黑树中</span><br> <br><span class="hljs-comment">//(3)我们要增加的事件也保存到节点中；</span><br><span class="hljs-built_in">memcpy</span>(&amp;epi-&gt;event, event, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event));<br> <br><span class="hljs-comment">//(4)把这个节点插入到红黑树中去</span><br>epi = RB_INSERT(_epoll_rb_socket, &amp;ep-&gt;rbr, epi); <span class="hljs-comment">//实际上这个时候epi的rbn成员就会发挥作用，如果这个红黑树中有多个节点，那么RB_INSERT就会epi-&gt;rbi相应的值：可以参考图来理解</span><br>assert(epi == <span class="hljs-literal">NULL</span>);<br>ep-&gt;rbcnt ++;<br><br>pthread_mutex_unlock(&amp;ep-&gt;mtx);<br> <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == EPOLL_CTL_DEL) &#123;<br>pthread_mutex_lock(&amp;ep-&gt;mtx);<br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> <span class="hljs-title">tmp</span>;</span><br>tmp.sockfd = sockid;<br><br><span class="hljs-comment">//先在红黑树上找到要删除的sockid，根据key来找</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> RB_FIND(_epoll_rb_socket, &amp;ep-&gt;rbr, &amp;tmp);<br><span class="hljs-keyword">if</span> (!epi) &#123;<br>nty_trace_epoll(<span class="hljs-string">&quot;rbtree no exist\n&quot;</span>);<br>pthread_mutex_unlock(&amp;ep-&gt;mtx);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">//只有在红黑树上找到该节点【用过EPOLL_CTL_ADD的tcp连接才能走到这里】；</span><br> <br><span class="hljs-comment">//从红黑树上把这个节点移除</span><br>epi = RB_REMOVE(_epoll_rb_socket, &amp;ep-&gt;rbr, epi);<br><span class="hljs-keyword">if</span> (!epi) &#123;<br>nty_trace_epoll(<span class="hljs-string">&quot;rbtree is no exist\n&quot;</span>);<br>pthread_mutex_unlock(&amp;ep-&gt;mtx);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br> <br>ep-&gt;rbcnt --;<br><span class="hljs-built_in">free</span>(epi);<br><br>pthread_mutex_unlock(&amp;ep-&gt;mtx);<br> <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == EPOLL_CTL_MOD) &#123;<br><span class="hljs-keyword">struct</span> epitem tmp;<br>tmp.sockfd = sockid;<br><br><span class="hljs-comment">//同理查找</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> RB_FIND(_epoll_rb_socket, &amp;ep-&gt;rbr, &amp;tmp); <br><span class="hljs-keyword">if</span> (epi) &#123;<br><span class="hljs-comment">//红黑树上有该节点，则修改对应的事件</span><br>epi-&gt;event.events = event-&gt;events;<br>epi-&gt;event.events |= EPOLLERR | EPOLLHUP;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>errno = -ENOENT;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br> <br>&#125; <span class="hljs-keyword">else</span> &#123;<br>nty_trace_epoll(<span class="hljs-string">&quot;op is no exist\n&quot;</span>);<br>assert(<span class="hljs-number">0</span>);<br>&#125;<br> <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 该函数的逻辑其实很简单，无非就是将用户传入的参数封装为一个epitem对象，然后根据传入的op是 - EPOLL_CTL_ADD，将epitem对象插入红黑树中</p><ul><li><p>EPOLL_CTL_MOD，更新红黑树中的epitem对象</p></li><li><p>EPOLL_CTL_DEL，移除红黑树中的epitem对象</p></li></ul><ol start="5" type="1"><li>epoll_wait()</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//到双向链表中去取相关的事件通知</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epid, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span> &#123;<br> <br>nty_tcp_manager *tcp = nty_get_tcp_manager();<br><span class="hljs-keyword">if</span> (!tcp) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">nty_socket</span> *<span class="hljs-title">epsocket</span> =</span> tcp-&gt;fdtable-&gt;sockfds[epid];<br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span> =</span> (<span class="hljs-keyword">struct</span> eventpoll*)epsocket-&gt;ep;<br><br>    <span class="hljs-comment">// ...此处主要是一些负责验证性工作的代码...</span><br> <br><span class="hljs-comment">//(1)当eventpoll对象的双向链表为空时，程序会在这个while中等待一定时间，</span><br><span class="hljs-comment">//直到有事件被触发，操作系统将epitem插入到双向链表上使得rdnum&gt;0时，程序才会跳出while循环</span><br><span class="hljs-keyword">while</span> (ep-&gt;rdnum == <span class="hljs-number">0</span> &amp;&amp; timeout != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// ...此处主要是一些与等待时间相关的代码...</span><br>&#125;<br> <br> <br>pthread_spin_lock(&amp;ep-&gt;lock);<br> <br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br> <br><span class="hljs-comment">//(1)取得事件的数量</span><br><span class="hljs-comment">//ep-&gt;rdnum：代表双向链表里边的节点数量（也就是有多少个TCP连接来事件了）</span><br><span class="hljs-comment">//maxevents：此次调用最多可以收集到maxevents个已经就绪【已经准备好】的读写事件</span><br><span class="hljs-type">int</span> num = (ep-&gt;rdnum &gt; maxevents ? maxevents : ep-&gt;rdnum); <span class="hljs-comment">//哪个数量少，就取得少的数字作为要取的事件数量</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (num != <span class="hljs-number">0</span> &amp;&amp; !LIST_EMPTY(&amp;ep-&gt;rdlist)) &#123; <span class="hljs-comment">//EPOLLET</span><br> <br><span class="hljs-comment">//(2)每次都从双向链表头取得 一个一个的节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> LIST_FIRST(&amp;ep-&gt;rdlist);<br> <br><span class="hljs-comment">//(3)把这个节点从双向链表中删除【但这并不影响这个节点依旧在红黑树中】</span><br>LIST_REMOVE(epi, rdlink); <br> <br><span class="hljs-comment">//(4)这是个标记，标记这个节点【这个节点本身是已经在红黑树中】已经不在双向链表中；</span><br>epi-&gt;rdy = <span class="hljs-number">0</span>;  <span class="hljs-comment">//当这个节点被操作系统 加入到 双向链表中时，这个标记会设置为1。</span><br> <br><span class="hljs-comment">//(5)把事件标记信息拷贝出来；拷贝到提供的events参数中</span><br><span class="hljs-built_in">memcpy</span>(&amp;events[i++], &amp;epi-&gt;event, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event));<br><br>num --;<br>cnt ++;       <span class="hljs-comment">//拷贝 出来的 双向链表 中节点数目累加</span><br>ep-&gt;rdnum --; <span class="hljs-comment">//双向链表里边的节点数量减1</span><br>&#125;<br><br>pthread_spin_unlock(&amp;ep-&gt;lock);<br> <br><span class="hljs-comment">//(5)返回 实际 发生事件的 tcp连接的数目；</span><br><span class="hljs-keyword">return</span> cnt; <br>&#125;<br></code></pre></td></tr></table></figure><p>先看一下eventpoll对象的双链表中是否有节点。如果有节点的话则取出节点中的事件填充到用户传入的指针所指向的内存中。如果没有节点的话，则在while循环中等待一定时间，直到有事件被触发后操作系统会将epitem插入到双向链表上使得rdnum&gt;0时(这个过程是由操作系统调用epoll_event_callback函数完成的)，程序才会跳出while循环，去双向链表中取数据。</p><p>（6）epoll_event_callback() 通过跟踪epoll_event_callback在内核中被调用的位置。可知，当服务器在以下5种情况会调用epoll_event_callback： 1. 客户端connect()连入，服务器处于SYN_RCVD状态时 2. 三路握手完成，服务器处于ESTABLISHED状态时 3. 客户端close()断开连接，服务器处于FIN_WAIT_1和FIN_WAIT_2状态时 4. 客户端send/write()数据，服务器可读时 5. 服务器可以发送数据时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//当发生客户端三路握手连入、可读、可写、客户端断开等情况时，操作系统会调用这个函数，用以往双向链表中增加一个节点【该节点同时 也在红黑树中】</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_event_callback</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-type">int</span> sockid, <span class="hljs-type">uint32_t</span> event)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> <span class="hljs-title">tmp</span>;</span><br>tmp.sockfd = sockid;<br> <br><span class="hljs-comment">//(1)根据给定的key【这个TCP连接的socket】从红黑树中找到这个节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> RB_FIND(_epoll_rb_socket, &amp;ep-&gt;rbr, &amp;tmp);<br><span class="hljs-keyword">if</span> (!epi) &#123;<br>nty_trace_epoll(<span class="hljs-string">&quot;rbtree not exist\n&quot;</span>);<br>assert(<span class="hljs-number">0</span>);<br>&#125;<br> <br><span class="hljs-comment">//(2)从红黑树中找到这个节点后，判断这个节点是否已经被连入到双向链表里【判断的是rdy标志】</span><br><span class="hljs-keyword">if</span> (epi-&gt;rdy) &#123;<br><span class="hljs-comment">//这个节点已经在双向链表里，那无非是把新发生的事件标志增加到现有的事件标志中</span><br>epi-&gt;event.events |= event;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125; <br> <br><span class="hljs-comment">//走到这里，表示 双向链表中并没有这个节点，那要做的就是把这个节点连入到双向链表中</span><br> <br>nty_trace_epoll(<span class="hljs-string">&quot;epoll_event_callback --&gt; %d\n&quot;</span>, epi-&gt;sockfd);<br><br>pthread_spin_lock(&amp;ep-&gt;lock);<br> <br><span class="hljs-comment">//(3)标记这个节点已经被放入双向链表中，我们刚才研究epoll_wait()的时候，从双向链表中把这个节点取走的时候，这个标志被设置回了0</span><br>epi-&gt;rdy = <span class="hljs-number">1</span>;  <br> <br><span class="hljs-comment">//(4)把这个节点链入到双向链表的表头位置</span><br>LIST_INSERT_HEAD(&amp;ep-&gt;rdlist, epi, rdlink);<br> <br><span class="hljs-comment">//(5)双向链表中的节点数量加1，刚才研究epoll_wait()的时候，从双向链表中把这个节点取走的时候，这个数量减了1</span><br>ep-&gt;rdnum ++;<br> <br>pthread_spin_unlock(&amp;ep-&gt;lock);<br>pthread_mutex_lock(&amp;ep-&gt;cdmtx);<br>pthread_cond_signal(&amp;ep-&gt;cond);<br>pthread_mutex_unlock(&amp;ep-&gt;cdmtx);<br> <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将eventpoll所指向的红黑树的节点插入到双向链表中</p><p>总的来说，epoll底层实现中有两个关键的数据结构，一个是eventpoll另一个是epitem，其中eventpoll中有两个成员变量分别是rbr和rdlist,前者指向一颗红黑树的根，后者指向双向链表的头。而epitem则是红黑树节点和双向链表节点的综合体，也就是说epitem即可作为树的节点，又可以作为链表的节点，并且epitem中包含着用户注册的事件 （1）当用户调用epoll_create()时，会创建eventpoll对象（包含一个红黑树和一个双链表）； （2）而用户调用epoll_ctl(ADD)时，会在红黑树上增加节点（epitem对象）； （3）接下来，操作系统会默默地在通过epoll_event_callback()来管理eventpoll对象。当有事件被触发时，操作系统则会调用epoll_event_callback函数，将含有该事件的epitem添加到双向链表中。 （4）当用户需要管理连接时，只需通过epoll_wait()从eventpoll对象中的双链表下&quot;摘取&quot;epitem并取出其包含的事件即可。</p><p>之后对应读写操作的进程就可以苏醒，处理这个事件，调用recvfrom将准备好的数据从内核态拷贝到用户态，然后正常使用这些数据。</p><h3 id="触发模式">触发模式</h3><p>epoll 支持两种事件触发模式，分别是边缘触发（edge-triggered，ET）和水平触发（level-triggered，LT）**。</p><ul><li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；（）</li><li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</li></ul><p>举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式</p><p>二者的核心区别： <strong>保证1</strong>：在LT模式下，“就绪链表”上取出的epi上报完事件后会重新加回“就绪链表”；<strong>保证2</strong>：如果“就绪链表”不为空，且此时有进程阻塞在同一个epoll句柄的睡眠队列上，则唤醒它。</p><p>ET模式不满足上述的“保证1”，所以不会将已经上报事件的epi重新链接回“就绪链表”，也就是说，只要一个“<strong>就绪队列</strong>”上的epi上的事件被上报了，它就会被删除出“<strong>就绪队列</strong>”。（所以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//LT</span><br>set_socket_nonblocking(sd);  <br>epfd = epoll_create(<span class="hljs-number">64</span>);  <br>event.data.fd = sd;  <br>epoll_ctl(epfd, EPOLL_CTL_ADD, sd, &amp;event);  <br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;  <br>    epoll_wait(epfd, events, <span class="hljs-number">64</span>, xx);  <br>    ... <span class="hljs-comment">// 危险区域！如果有共享同一个epfd的进程/线程调用epoll_wait，它们也将会被唤醒！  </span><br><span class="hljs-comment">// 这个accept将会有多个进程/线程调用，如果并发请求数很少，那么将仅有几个进程会成功：  </span><br><span class="hljs-comment">// 1. 假设accept队列中有n个请求，则仅有n个进程能成功，其它将全部返回EAGAIN (Resource temporarily unavailable)  </span><br><span class="hljs-comment">// 2. 如果n很大(即增加请求负载)，虽然返回EAGAIN的比率会降低，但这些进程也并不一定取到了epoll_wait返回当下的那个预期的请求。  </span><br>    csd = accept(sd, &amp;in_addr, &amp;in_len);   <br>    ...  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//ET</span><br>set_socket_nonblocking(sd);  <br>epfd = epoll_create(<span class="hljs-number">64</span>);  <br>event.data.fd = sd;  <br><span class="hljs-comment">// 添加ET标记  </span><br>event.events |= EPOLLET;  <br>epoll_ctl(epfd, EPOLL_CTL_ADD, sd, &amp;event);  <br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;  <br>    epoll_wait(epfd, events, <span class="hljs-number">64</span>, xx);  <br>    <span class="hljs-keyword">while</span> ((csd = accept(sd, &amp;in_addr, &amp;in_len)) &gt; <span class="hljs-number">0</span>) &#123;  <br>        do_something(...);  <br>    &#125;   <br>    ...  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="惊群现象">惊群现象</h3><p>对于nginx的惊群问题，首先需要理解的是，在nginx启动过程中，master进程会监听配置文件中指定的各个端口，然后master进程就会调用fork()方法创建各个子进程，根据进程的工作原理，子进程是会继承父进程的全部内存数据以及监听的端口的，也就是说worker进程在启动之后也是会监听各个端口的。</p><p>关于惊群，指的就是当客户端有新建连接的请求到来时，就会触发各个worker进程的连接建立事件，但是只有一个worker进程能够正常处理该事件，而其他的worker进程会发现事件已经失效，从而重新循环进入等待状态。</p><p>这种由于一个事件而“惊”起了所有worker进程的现象就是惊群问题。很明显，如果所有的worker进程都被触发了，那么这将消耗大量的资源，本文则主要讲解nginx是如何处理惊群问题的。</p><p><strong>解决方案：</strong> 每个worker进程被创建的时候，都会调用ngx_worker_process_init()方法初始化当前worker进程，这个过程中有一个非常重要的步骤，即每个worker进程都会调用epoll_create()方法为自己创建一个独有的epoll句柄。</p><p>对于每一个需要监听的端口，都有一个文件描述符与之对应，而worker进程只有将该文件描述符通过epoll_ctl()方法添加到当前进程的epoll句柄中，并且监听accept事件，此时才会被客户端的连接建立事件触发，从而处理该事件。</p><p>从这里也可以看出，worker进程如果没有将所需要监听的端口对应的文件描述符添加到该进程的epoll句柄中，那么其是无法被触发对应的事件的。基于这个原理，nginx就使用了一个共享锁来控制当前进程是否有权限将需要监听的端口添加到当前进程的epoll句柄中，也就是说，只有获取锁的进程才会监听目标端口。通过这种方式，就保证了每次事件发生时，只有一个worker进程会被触发。如下图所示为worker进程工作循环的一个示意图：</p><p><img src="Pasted%20image%2020240319215247.png"></p><p>这里关于图中的流程，需要说明的一点是，每个worker进程在进入循环之后就会尝试获取<a href="https://www.zhihu.com/search?q=%E5%85%B1%E4%BA%AB%E9%94%81&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2347799383%7D">共享锁</a>，如果没有获取到，就会将所监听的端口的文件描述符从当前进程的epoll句柄中移除（即使并不存在也会移除），这么做的主要目的是防止丢失客户端连接事件</p><p>举个例子：如果按照理论，在当前进程释放锁的时候就将监听的端口的文件描述符从epoll句柄中移除，那么在下一个worker进程获取锁之前，这段时间各个端口对应的文件描述符是没有任何<a href="https://www.zhihu.com/search?q=epoll&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2347799383%7D">epoll</a>句柄进行监听的，此时就会造成事件的丢失。如果反过来，按照图中的在获取锁失败的时候才移除监听的文件描述符，由于获取锁失败，则说明当前一定有一个进程已经监听了这些文件描述符，因而此时移除是安全的</p><p>是这样会造成的一个问题是，按照上图，当前进程在一个循环执行完毕的时候，会释放锁，然后处理其他的事件，注意这个过程中其是没有释放所监听的文件描述符的。此时，如果另一个进程获取到了锁，并且监听了文件描述符，那么这个时候就有两个进程监听了文件描述符，因而此时如果客户端发生连接建立事件，那么就会触发两个worker进程，但这个问题是可以容忍的。</p><p>这样处理其实还有一个问题，那就是在抢夺锁的过程中，可能会出现饥饿现象。因此nginx还采用了ngx_accept_disabled参数来控制worker进程是否参与抢夺锁，如果进程繁忙，就不抢夺锁，避免其他进程饥饿以及自己的负载过高。</p><p>注意： 为什么<strong>reuseport</strong>没有惊群？ 惊群发生的原因在于同时唤醒了多个进程处理一个事件，导致了不必要的CPU空转。为什么会唤醒多个进程，因为发生事件的文件描述符在多个进程之间是共享的。而reuseport呢，侦听同一个IP地址端口对的多个socket本身在socket层就是相互隔离的，在它们之间的事件分发是TCP/IP协议栈完成的，所以不会再有惊群发生。</p><p>https://mp.weixin.qq.com/s/xxjCrFH1361iG-srfNL9_Q</p><h2 id="实际场景tcp-epoll的工作流程">实际场景：tcp + epoll的工作流程</h2><p><img src="Pasted%20image%2020240319221248.png"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx,中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab9 Symlink</title>
    <link href="/2024/04/15/Lab9-Symlink/"/>
    <url>/2024/04/15/Lab9-Symlink/</url>
    
    <content type="html"><![CDATA[<p>问题：什么是软链接？什么是硬链接？ 答案： （1）软链接(Symbolic Link),也称为符号链接,是包含了源文件位置信息的特殊文件。它的作用是间接指向一个文件或目录。如果软链接的源文件被删除或移动了，软链接就打不开了 （2）硬链接(Hard Link)指通过索引节点来进行链接。在Linux系统中,每个文件都有一个对应的索引节点,记录文件的日期,大小,所在块等信息。硬链接就是指向源文件索引节点的连接。删除源文件,不影响硬链接的访问</p><p>追问：二者的区别在于？ 答案： （1）<strong>对于硬链接来说，删除了源文件，访问依旧有效</strong>，软链接删除了源文件会失效（毕竟是快捷方式） （2）软链接可以跨分区（因为只保存源文件位置），硬链接不能跨文件系统 （3）<strong>软链接可以针对目录，硬链接不能针对目录</strong></p><p>xv6本身实现了硬链接功能（link），多个描述符公用一个inode，删除文件仅仅会导致inode引用书减一，不会导致其他链接不可用。</p><p>本次实验的目的就是实现xv6中的软链接功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//linux软链接用法：</span><br>ln -s 源文件或目录 软链接的文件或目录<br>例子：<br># 将test.txt软链接到test_link<br>ln -s test.txt test_link<br><br><span class="hljs-comment">//linux硬链接用法：</span><br>ln 源文件 硬链接名<br>即：不加 -s 则为硬链接<br></code></pre></td></tr></table></figure><h2 id="第一步-添加系统调用">第一步 添加系统调用</h2><p>回顾一下系统调用的启动流程 （1）修改usys.pl 它会批量生成对应函数名称的汇编文件。汇编文件是用户态实际的函数调用，但不包含业务逻辑，只是将函数名称通过a7寄存器传入内核，然后调用ecall进入中断 （2）usertrap处理中断时发现是系统调用，于是调用syscall()处理，该函数根据a7寄存器中的系统调用名（在内核中被宏定义为系统调用号），映射到具体的处理函数 （3）执行具体的函数逻辑 参数存在a0-a7寄存器中，需要调用argaddr函数获取</p><h2 id="第二步-symlink">第二步 symlink</h2><p>（1）添加标志位 添加T_SYMLINK文件类型</p><ul><li><p>kernel/stat.h中添加<code>T_SIMLINK</code></p></li><li><p>kernel/fcntl.h中添加<code>O_NOFOLLOW</code></p></li></ul><p>（2）新建int sys_symlink(void)函数 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_symlink</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-type">char</span> target[MAXPATH]; <span class="hljs-comment">//源对象</span><br>  <span class="hljs-type">char</span> path[MAXPATH]; <span class="hljs-comment">//软连接</span><br>  <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(argstr(<span class="hljs-number">0</span>, target, MAXPATH) &lt; <span class="hljs-number">0</span> || argstr(<span class="hljs-number">1</span>, path, MAXPATH) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span><br>  begin_op();<br>  <span class="hljs-keyword">if</span>((ip = namei(path)) != <span class="hljs-number">0</span>)&#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  ip = create(path, T_SYMLINK, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(ip == <span class="hljs-number">0</span>)&#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>    <span class="hljs-comment">//注意，调用哦个writei时是在内核，写入的数据为target已经接收到了内核</span><br>    <span class="hljs-comment">//所以此时是物理地址，ip后面的参数需要为0</span><br>    <span class="hljs-comment">//将target，偏移量为0作为起始位置，写入MAXPATH大小到ip中，不使用虚拟地址</span><br>   <span class="hljs-keyword">if</span> ((r = writei(ip, <span class="hljs-number">0</span>, (uint64)target, <span class="hljs-number">0</span>, MAXPATH)) &lt; <span class="hljs-number">0</span>)&#123;<br>      iunlockput(ip);<br>      end_op();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>   &#125;<br>  iunlockput(ip);<br>  end_op();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="第三步-修改sys_open">第三步 修改sys_open</h2><p>原本的open没有针对软链接的判断逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>...<br> <span class="hljs-comment">// 不断判断该 inode 是否为符号链接</span><br> <span class="hljs-keyword">while</span>(ip-&gt;type == T_SYMLINK &amp;&amp; !(omode &amp; O_NOFOLLOW)) &#123;<br>    <span class="hljs-comment">// 如果访问深度过大，则退出</span><br>    <span class="hljs-keyword">if</span> (depth++ &gt;= <span class="hljs-number">20</span>) &#123;<br>      iunlockput(ip);<br>      end_op();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取对应的 inode</span><br>    <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)path, <span class="hljs-number">0</span>, MAXPATH) &lt; MAXPATH) &#123;<br>      iunlockput(ip);<br>      end_op();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    iunlockput(ip);<br>    <span class="hljs-comment">// 根据文件名称找到对应的 inode</span><br>    <span class="hljs-keyword">if</span>((ip = namei(path)) == <span class="hljs-number">0</span>) &#123;<br>      end_op();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    ilock(ip);<br>  &#125;<br>  ...<br></code></pre></td></tr></table></figure><h2 id="结果">结果</h2><p><img src="Pasted%20image%2020240415223955.png"></p><p>本次实验总体来说难点有两个： （1）实现软链接 读取参数 调用create创建软连接 调用writei将目标写入软链接的date部分</p><p>（2）软连接的目标也是软连接时需要在open中实现循环查找，如果当前inode是一个软链接则： 判断深度要求（太大则报错） 调用readi读取当前inode 的内容到path变量中（open函数会接收path作为参数，这里相当于循环了） 调用namei根据path变量继续寻找链接的inode</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book-Chapter8 文件系统 part3</title>
    <link href="/2024/04/15/xv6-book-Chapter8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-part3/"/>
    <url>/2024/04/15/xv6-book-Chapter8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-part3/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter8-file-system-part3">Chapter8 File System part3</h1><h2 id="pathname-layer">Pathname Layer</h2><p>在目录层中封装了dirlookup方法，给定一个目录inode，在其中查找或添加相应条目</p><p>但是该方法只能查找当前目录，Pathname 层提供了更完整的路径名检索功能，这个过程需要调用一连串的dirlookup，每个目录名都需要一次。注意：这个过程是为了给open等文件曾的操作提供服务，而不是实现查找功能。例如在create /user/xxx这样的命令中，该层提供的服务是找到name的父目录的inode，然后创建名字为xxx的inode。</p><p>xv6是一个精简的操作系统，不存在linux中那种find指令，但可以自己实现</p><p><strong>namei</strong>和<strong>nameiparent</strong>就负责这样的路径名查找，它们都接收完整的路径名作为输入，返回相关的inode。不同之处在于，namei返回路径名中最后一个元素的inode；而nameiparent返回最后一个元素的父目录的inode，并且将最后一个元素的名称复制到调用者指定的位置name中。这两个函数都调用namex完成路径名查找的工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">namei</span><span class="hljs-params">(<span class="hljs-type">char</span> *path)</span><br>&#123;<br>  <span class="hljs-type">char</span> name[DIRSIZ];<br>  <span class="hljs-comment">//evaluates path and returns the corresponding inode</span><br>  <span class="hljs-keyword">return</span> namex(path, <span class="hljs-number">0</span>, name);<br>&#125;<br><br><span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">nameiparent</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *name)</span><br>&#123;<br>  <span class="hljs-comment">// 这里name不是临时buffer，调用者提供name[]来装载它，因为调用者还需要它</span><br>  <span class="hljs-keyword">return</span> namex(path, <span class="hljs-number">1</span>, name);<br>&#125;<br></code></pre></td></tr></table></figure><p>而namex在执行查找逻辑前需要先对路径进行解析，当我们给定一个路径时，使用skipelem进行解析。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy the next path element from path into name.</span><br><span class="hljs-comment">// Return a pointer to the element following the copied one.</span><br><span class="hljs-comment">// The returned path has no leading slashes,</span><br><span class="hljs-comment">// so the caller can check *path==&#x27;\0&#x27; to see if the name is the last one.</span><br><span class="hljs-comment">// If no name to remove, return 0.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Examples:</span><br><span class="hljs-comment">//   skipelem(&quot;a/bb/c&quot;, name) = &quot;bb/c&quot;, setting name = &quot;a&quot;</span><br><span class="hljs-comment">//   skipelem(&quot;///a//bb&quot;, name) = &quot;bb&quot;, setting name = &quot;a&quot;</span><br><span class="hljs-comment">//   skipelem(&quot;a&quot;, name) = &quot;&quot;, setting name = &quot;a&quot;</span><br><span class="hljs-comment">//   skipelem(&quot;&quot;, name) = skipelem(&quot;////&quot;, name) = 0</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// skipelem将下个path element拷贝到name中，返回跟在下个path element的后续路径</span><br><span class="hljs-comment">// 如果skipelem返回&#x27;\0&#x27;，表示提取出的path element已经是最后一个</span><br><span class="hljs-comment">// 如果path是&#x27;\0&#x27;，那么skipelem返回0</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span>*<br><span class="hljs-title function_">skipelem</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *name)</span><br>&#123;<br>  <span class="hljs-type">char</span> *s;<br>  <span class="hljs-type">int</span> len;<br><br>  <span class="hljs-keyword">while</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    path++;<br>  <span class="hljs-keyword">if</span>(*path == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  s = path;<br>  <span class="hljs-keyword">while</span>(*path != <span class="hljs-string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="hljs-number">0</span>)<br>    path++;<br>  len = path - s;<br>  <span class="hljs-keyword">if</span>(len &gt;= DIRSIZ)<br>    memmove(name, s, DIRSIZ);<br>  <span class="hljs-keyword">else</span> &#123;<br>    memmove(name, s, len);<br>    name[len] = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">while</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    path++;<br>  <span class="hljs-keyword">return</span> path;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>我们知道，linux路径名是”/user/cygnus“这种形式，skipelem通过遍历找到两个&quot;/&quot;或者&quot;/”和“0”之间的字符串，并保存在name中返回path（后续路径）。也就是说skipelem的作用是获取当前路径的目录名称，例如传入/user/cygnus会返回user，传入/cygnus会返回cygnus。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Look up and return the inode for a path name.</span><br><span class="hljs-comment">// If parent != 0, return the inode for the parent and copy the final</span><br><span class="hljs-comment">// path element into name, which must have room for DIRSIZ bytes.</span><br><span class="hljs-comment">// Must be called inside a transaction since it calls iput().</span><br><span class="hljs-comment">// if an invocation of namex by one kernel thread is blocked on a disk I/O, </span><br><span class="hljs-comment">// another kernel thread looking up a different pathname can proceed concurrently.</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">namex</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> nameiparent, <span class="hljs-type">char</span> *name)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">next</span>;</span><br><br>  <span class="hljs-comment">// 决定从哪里开始找，如果有&#x27;/&#x27;就从根目录开始，否则从当前目录开始</span><br>  <span class="hljs-keyword">if</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>  <span class="hljs-comment">//ROOTDEV device number of file system root disk</span><br>  <span class="hljs-comment">//ROOTINO root i-number</span><br>    ip = iget(ROOTDEV, ROOTINO);<br>  <span class="hljs-keyword">else</span><br>ip = idup(myproc()-&gt;cwd); <br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    提高inode的引用数量  </span><br><span class="hljs-comment">struct inode*  </span><br><span class="hljs-comment">idup(struct inode *ip)  </span><br><span class="hljs-comment">&#123;  </span><br><span class="hljs-comment">  acquire(&amp;itable.lock);  </span><br><span class="hljs-comment">  ip-&gt;ref++;  </span><br><span class="hljs-comment">  release(&amp;itable.lock);  </span><br><span class="hljs-comment">  return ip;  </span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-comment">// uses skipelem to consider each element of the path in turn</span><br>  <span class="hljs-keyword">while</span>((path = skipelem(path, name)) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// skipelem将下个path element拷贝到name中，返回跟在下个path element的后续路径</span><br>    <span class="hljs-comment">// 如果*path==&#x27;\0&#x27;就表示提取出的path element已经是最后一个</span><br>    <span class="hljs-comment">// 例: 最开始path = &#x27;/a/b&#x27;，b可以是文件也可以是目录，当前目录ip为根目录&#x27;/&#x27;</span><br>    <span class="hljs-comment">// 1、path = /b,name = a,next = name = a,ip = next = a</span><br>    <span class="hljs-comment">// 2、path = &quot;\0&quot;,name = b,(如果是nameiparent就在这一步停止并返回ip = a,name = b),</span><br>    <span class="hljs-comment">// next = name = b,ip = next = b</span><br>    <span class="hljs-comment">// 3、path = 0,name = b,ip = b,namei在跳出循环后返回ip = b</span><br>    ilock(ip);<br>    <span class="hljs-comment">// 检查当前结点ip是否为目录类型</span><br>    <span class="hljs-keyword">if</span>(ip-&gt;type != T_DIR)&#123;<br>      iunlockput(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nameiparent &amp;&amp; *path == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>      <span class="hljs-comment">// path=&#x27;\0&#x27;表示name已经是最后一个元素</span><br>      iunlock(ip);<br>      <span class="hljs-comment">// 调用者为nameiparent，当前ip就是最后一个元素的父目录</span><br>      <span class="hljs-comment">// 最后一个元素的名称在skipelem中已被复制到name</span><br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-comment">// 在当前目录结点ip下，找name，也就是找下一个path element</span><br>    <span class="hljs-keyword">if</span>((next = dirlookup(ip, name, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// 在当前目录结点下找不到</span><br>      iunlockput(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    iunlockput(ip);<br>    <span class="hljs-comment">// 释放ip，为下一次循环做准备</span><br>    <span class="hljs-comment">// 当查找&#x27;.&#x27;时，next和ip相同，若在释放ip的锁之前给next上锁就会发生死锁</span><br>    <span class="hljs-comment">// 因此namex在下一个循环中获取next的锁之前，在这里要先释放ip的锁，从而避免死锁</span><br>    ip = next;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(nameiparent)&#123;<br>    <span class="hljs-comment">// 正常情况下nameiparent应该在主循环中就返回</span><br>    <span class="hljs-comment">// 如果运行到了这里，说明nameiparent失败，因此namex返回0</span><br>    iput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// When the loop runs out of path elements, it returns</span><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure><p>namex分别对路径名中的每个目录上锁，再调用dirlookup查找该目录。因此，就算有多个内核线程调用namex，只要dirlookup查找的目录是不同的，我们就可以并发地进行路径名查找。</p><p>会不会存在这样一种并发问题呢？例如，一个内核线程正在dirlookup查找一个目录，但该目录已被另一个内核线程删除，而且原来的数据块也被分配给了新的目录或文件。</p><p>答案是xv6避免了这种情况，因为在执行namex的dirlookup时，我们拥有当前目录ip的锁，然后dirlookup返回一个inode指针给我们，这个inode指针是通过iget得到的，iget会增加inode的ref计数。因此，如果另一个内核线程对该inode调用iput，该inode是不会被删除的，因为企图删除inode的内核线程并不是最后一个指针的拥有者</p><h2 id="file-descriptor-layer">File Descriptor Layer</h2><p>终于到了文件描述符层，经过这里的封装之后，一切皆文件。无论底层是普通文件、目录、还是控制台、管道等设备，用户都可以将它们看成是文件。</p><h4 id="数据结构">数据结构</h4><p>一般每个进程都有一个<strong>打开文件表</strong>，有一系列相应的文件描述符，最多支持同时打开16个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>&#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files, NOFILE = 16</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">//全局的打开文件表，系统中所有的打开文件都会存放在这个ftable中，最多可以同时打开100个文件</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> <span class="hljs-title">file</span>[<span class="hljs-title">NFILE</span>];</span>  <span class="hljs-comment">// NFILE = 100</span><br>&#125; ftable;<br><br></code></pre></td></tr></table></figure><p>每次调用open时，都会创建一个新的打开文件，即创建一个新的struct file。因此，如果有多个进程同时打开同一个文件，它们的struct file实例是不同的，如下所示，它还封装了inode、pipe等信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Each call to open creates a new open file(a new struct file)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;<br>  <span class="hljs-type">int</span> ref; <span class="hljs-comment">// reference count</span><br>  <span class="hljs-type">char</span> readable; <span class="hljs-comment">//文件是否可读</span><br>  <span class="hljs-type">char</span> writable; <span class="hljs-comment">//文件是否可写</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">pipe</span>;</span> <span class="hljs-comment">// FD_PIPE</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <span class="hljs-comment">// FD_INODE and FD_DEVICE</span><br>  uint off;          <span class="hljs-comment">// FD_INODE</span><br>  <span class="hljs-type">short</span> major;       <span class="hljs-comment">// FD_DEVICE</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="filealloc-filealloc-和-fileclose">filealloc 、 filealloc 和 fileclose</h4><p><strong>filealloc</strong>分配一个新的打开文件struct file，它扫描ftable，找到第一个空闲的槽位，然后返回新的引用。打开文件数达到上限时，filealloc只是返回0，并不会使xv6陷入panic</p><p>注意：filealloc是从ftable中找到一个空位分配出去，fdalloc是从进程的文件表中找到一个空槽位将文flie塞进去，然后返回一个整数作为文件描述符编号。这个编号是file在进程ofile数组中的位置。所以打开一个文件其实需要falloc和fdalloc协作完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate a file structure.</span><br><span class="hljs-keyword">struct</span> file*<br><span class="hljs-title function_">filealloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br><br>  acquire(&amp;ftable.lock);<br>  <span class="hljs-comment">//找到一个引用数为0的file</span><br>  <span class="hljs-keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;<br>    <span class="hljs-keyword">if</span>(f-&gt;ref == <span class="hljs-number">0</span>)&#123;<br>      f-&gt;ref = <span class="hljs-number">1</span>;<br>      release(&amp;ftable.lock);<br>      <span class="hljs-keyword">return</span> f;<br>    &#125;<br>  &#125;<br>  release(&amp;ftable.lock);<br>  <span class="hljs-comment">// don&#x27;t panic when run out of files</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// Allocate a file descriptor for the given file.  </span><br><span class="hljs-comment">// Takes over file reference from caller on success.  </span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  <br><span class="hljs-title function_">fdalloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> fd;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  <span class="hljs-keyword">for</span>(fd = <span class="hljs-number">0</span>; fd &lt; NOFILE; fd++)&#123;  <br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[fd] == <span class="hljs-number">0</span>)&#123;  <br>      p-&gt;ofile[fd] = f;  <br>      <span class="hljs-keyword">return</span> fd;  <br>    &#125;  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>fileclose</strong>减少ref引用计数。当ref大于1时，直接将ref减1即可返回；当ref=1时，代表对该打开文件的最后一个引用也将删除，fileclose就更改该打开文件的类型为FD_NONE，然后再检查该打开文件下层资源的类型，如果是pipe或inode，还要相应地调用pipeclose或iput，以关闭和释放这些底层资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Close file f.  (Decrement ref count, close when reaches 0.)</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">fileclose</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> <span class="hljs-title">ff</span>;</span><br><br>  acquire(&amp;ftable.lock);<br>  <span class="hljs-keyword">if</span>(f-&gt;ref &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;fileclose&quot;</span>);<br>  <span class="hljs-keyword">if</span>(--f-&gt;ref &gt; <span class="hljs-number">0</span>)&#123;<br>    release(&amp;ftable.lock);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  ff = *f;<br>  f-&gt;ref = <span class="hljs-number">0</span>;<br>  f-&gt;type = FD_NONE;<br>  release(&amp;ftable.lock);<br><br>  <span class="hljs-comment">// Releases the underlying pipe or inode, according to the type.</span><br>  <span class="hljs-keyword">if</span>(ff.type == FD_PIPE)&#123;<br>    pipeclose(ff.pipe, ff.writable);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;<br>    begin_op();<br>    iput(ff.ip);<br>    end_op();<br>  &#125;<br>&#125;<br><br>uint64  <br><span class="hljs-title function_">sys_close</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> fd;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span>  <br>  <br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, &amp;fd, &amp;f) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  myproc()-&gt;ofile[fd] = <span class="hljs-number">0</span>;  <br>  fileclose(f);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="filedup">filedup</h4><p>看名字就知道filedup和dup离不开。<strong>filedup</strong>创建一个打开文件struct file的副本，逻辑很简单，只是简单地增加引用计数ref，然后返回指向相同struct file的指针 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Increment ref count for file f.</span><br><span class="hljs-keyword">struct</span> file*<br><span class="hljs-title function_">filedup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f)</span><br>&#123;<br>  acquire(&amp;ftable.lock);<br>  <span class="hljs-keyword">if</span>(f-&gt;ref &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;filedup&quot;</span>);<br>  f-&gt;ref++;<br>  release(&amp;ftable.lock);<br>  <span class="hljs-keyword">return</span> f;<br>&#125;<br><br>uint64  <br><span class="hljs-title function_">sys_dup</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span>  <br>  <span class="hljs-type">int</span> fd;  <br>  <br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  <span class="hljs-keyword">if</span>((fd=fdalloc(f)) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  filedup(f);  <br>  <span class="hljs-keyword">return</span> fd;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="fileread">fileread</h4><p><strong>fileread</strong>根据不同的底层文件类型，检查文件可读模式是否打开，然后调用不同的方法来读取这些资源，为<strong>read</strong>系统调用提供服务。struct file中的偏移量off表示此刻已经读或者写道的位置，每次读完之后就更新它，注意：管道没有偏移量，off为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Read from file f.</span><br><span class="hljs-comment">// addr is a user virtual address.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">fileread</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;readable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;type == FD_PIPE)&#123;<br>    <span class="hljs-comment">// Pipes have no concept of offset</span><br>    r = piperead(f-&gt;pipe, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;<br>    <span class="hljs-keyword">if</span>(f-&gt;major &lt; <span class="hljs-number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].read)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    r = devsw[f-&gt;major].read(<span class="hljs-number">1</span>, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_INODE)&#123;<br>    ilock(f-&gt;ip);<br>    <span class="hljs-keyword">if</span>((r = readi(f-&gt;ip, <span class="hljs-number">1</span>, addr, f-&gt;off, n)) &gt; <span class="hljs-number">0</span>)<br>      <span class="hljs-comment">// If the file represents an inode,fileread and filewrite use the I/O offset as the offset for the operation and then advance it</span><br>      <span class="hljs-comment">// offset的更新也受到inode锁的保护，因此不会发生竞争问题</span><br>      f-&gt;off += r;<br>    iunlock(f-&gt;ip);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    panic(<span class="hljs-string">&quot;fileread&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><br>uint64<br><span class="hljs-title function_">sys_read</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  <span class="hljs-type">int</span> n;<br>  uint64 p;<br><br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;n) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;p) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-comment">//表示将f文件的内容读取n个字节到地址p，一般p会是一个用户在栈上创建的数组</span><br>  <span class="hljs-keyword">return</span> fileread(f, p, n);<br>&#125;<br></code></pre></td></tr></table></figure><p>fileread将文件分为三类处理，管道piperead，设备devsw[f-&gt;major].read，inode类型使用readi。sys_read也就是调用了fileread函数，虽然一切皆文件，但是具体读取时还是要根据不同的类型有不同的读取函数，fileread只是做了一个封装。</p><h4 id="filewrite">filewrite</h4><p><strong>filewrite</strong>如下，和fileread类似，这次检查写模式是否打开，它为<strong>write</strong>系统调用提供服务。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write to file f.</span><br><span class="hljs-comment">// addr is a user virtual address.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">filewrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> r, ret = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;writable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">if</span>(f-&gt;type == FD_PIPE)&#123;<br>    ret = pipewrite(f-&gt;pipe, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_DEVICE)&#123;<br>    <span class="hljs-keyword">if</span>(f-&gt;major &lt; <span class="hljs-number">0</span> || f-&gt;major &gt;= NDEV || !devsw[f-&gt;major].write)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    ret = devsw[f-&gt;major].write(<span class="hljs-number">1</span>, addr, n);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(f-&gt;type == FD_INODE)&#123;<br>    <span class="hljs-comment">// write a few blocks at a time to avoid exceeding</span><br>    <span class="hljs-comment">// the maximum log transaction size, including</span><br>    <span class="hljs-comment">// i-node, indirect block, allocation blocks,</span><br>    <span class="hljs-comment">// and 2 blocks of slop for non-aligned writes.</span><br>    <span class="hljs-comment">// this really belongs lower down, since writei()</span><br>    <span class="hljs-comment">// might be writing a device like the console.</span><br>    <span class="hljs-type">int</span> max = ((MAXOPBLOCKS<span class="hljs-number">-1</span><span class="hljs-number">-1</span><span class="hljs-number">-2</span>) / <span class="hljs-number">2</span>) * BSIZE;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>      <span class="hljs-type">int</span> n1 = n - i;<br>      <span class="hljs-keyword">if</span>(n1 &gt; max)<br>        n1 = max;<br><br>      begin_op();<br>      ilock(f-&gt;ip);<br>      <span class="hljs-keyword">if</span> ((r = writei(f-&gt;ip, <span class="hljs-number">1</span>, addr + i, f-&gt;off, n1)) &gt; <span class="hljs-number">0</span>)<br>        f-&gt;off += r;<br>      iunlock(f-&gt;ip);<br>      end_op();<br><br>      <span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">if</span>(r != n1)<br>        panic(<span class="hljs-string">&quot;short filewrite&quot;</span>);<br>      i += r;<br>    &#125;<br>    ret = (i == n ? n : <span class="hljs-number">-1</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    panic(<span class="hljs-string">&quot;filewrite&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br>uint64<br><span class="hljs-title function_">sys_write</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  <span class="hljs-type">int</span> n;<br>  uint64 p;<br><br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;n) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;p) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//表示将地址p的n个字节写入f</span><br>  <span class="hljs-keyword">return</span> filewrite(f, p, n);<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="sys_link">sys_link</h4><p>在namepath层我们已经实现了文件和目录的查找，整个文件系统其实已经基本建立起来了，在文件层进一步将各种设备都封装称为文件，提供了一些读写的系统调用。</p><p>sys_link为一个已存在的inode创建新的硬链接，即linux支持多个文件链接到同一个inode。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create the path new as a link to the same inode as old.</span><br>uint64<br><span class="hljs-title function_">sys_link</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">//creates a new name for an existing inode</span><br>  <span class="hljs-type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">dp</span>, *<span class="hljs-title">ip</span>;</span><br><br>  <span class="hljs-comment">// a0传进旧名称，a1传进新名称</span><br>  <span class="hljs-keyword">if</span>(argstr(<span class="hljs-number">0</span>, old, MAXPATH) &lt; <span class="hljs-number">0</span> || argstr(<span class="hljs-number">1</span>, new, MAXPATH) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  begin_op();<br>  <span class="hljs-keyword">if</span>((ip = namei(old)) == <span class="hljs-number">0</span>)&#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  ilock(ip);<br>  <span class="hljs-keyword">if</span>(ip-&gt;type == T_DIR)&#123;<br>    iunlockput(ip);<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// old exists and is not a directory</span><br>  <span class="hljs-comment">// 硬链接数加1</span><br>  ip-&gt;nlink++;<br>  iupdate(ip);<br>  iunlock(ip);<br><br>  <span class="hljs-comment">// find the parent directory and final path element of new</span><br>  <span class="hljs-comment">// The new parent directory must exist and be on the same device as the existing inode</span><br>  <span class="hljs-keyword">if</span>((dp = nameiparent(new, name)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  ilock(dp);<br>  <span class="hljs-comment">// creates a new directory entry pointing at old’s inode</span><br>  <span class="hljs-keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="hljs-number">0</span>)&#123;<br>    iunlockput(dp);<br>    <span class="hljs-keyword">goto</span> bad;<br>  &#125;<br>  iunlockput(dp);<br>  iput(ip);<br><br>  end_op();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>bad:<br>  ilock(ip);<br>  ip-&gt;nlink--;<br>  iupdate(ip);<br>  iunlockput(ip);<br>  end_op();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="open重点">open（重点）</h4><p><strong>create</strong>则根据给定的路径名，创建一个全新的inode <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 以下三种情况会用到create</span><br><span class="hljs-comment">// open with the O_CREATE flag makes a new ordinary file</span><br><span class="hljs-comment">// mkdir makes a new directory  </span><br><span class="hljs-comment">// mkdev makes a new device file</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">short</span> type, <span class="hljs-type">short</span> major, <span class="hljs-type">short</span> minor)</span><br>&#123;<br>  <span class="hljs-comment">// creates a new name for a new inode</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">dp</span>;</span><br>  <span class="hljs-type">char</span> name[DIRSIZ];<br><br>  <span class="hljs-comment">// get the inode of the parent directory</span><br>  <span class="hljs-keyword">if</span>((dp = nameiparent(path, name)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  ilock(dp);<br><br>  <span class="hljs-comment">// check whether the name already exists</span><br>  <span class="hljs-keyword">if</span>((ip = dirlookup(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// name does exists</span><br>    iunlockput(dp);<br>    ilock(ip);<br>    <span class="hljs-keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))<br>      <span class="hljs-keyword">return</span> ip;<br>    iunlockput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// If the name does not already exist,create now allocates a new inode with ialloc</span><br>  <span class="hljs-keyword">if</span>((ip = ialloc(dp-&gt;dev, type)) == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;create: ialloc&quot;</span>);<br><br>  ilock(ip);<br>  <span class="hljs-comment">// 从这里开始，create同时持有ip和dp的锁</span><br>  <span class="hljs-comment">// There is no possibility of deadlock </span><br>  <span class="hljs-comment">// because the inode ip is freshly allocated</span><br>  <span class="hljs-comment">// thus no other process in the system will hold ip’s lock and then try to lock dp</span><br>  ip-&gt;major = major;<br>  ip-&gt;minor = minor;<br>  ip-&gt;nlink = <span class="hljs-number">1</span>;<br>  iupdate(ip);<br><br>  <span class="hljs-keyword">if</span>(type == T_DIR)&#123;  <br>    <span class="hljs-comment">// If the new inode is a directory,create initializes it with . and .. entries.</span><br>    <span class="hljs-comment">// Create . and .. entries.</span><br>    dp-&gt;nlink++;  <span class="hljs-comment">// for &quot;..&quot;</span><br>    iupdate(dp);<br>    <span class="hljs-comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span><br>    <span class="hljs-comment">// If the new inode is a directory,create initializes it with . and .. entries</span><br>    <span class="hljs-keyword">if</span>(dirlink(ip, <span class="hljs-string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="hljs-number">0</span> || dirlink(ip, <span class="hljs-string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;create dots&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// now that the data is initialized properly</span><br>  <span class="hljs-comment">// link it into the parent directory</span><br>  <span class="hljs-keyword">if</span>(dirlink(dp, name, ip-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;create: dirlink&quot;</span>);<br><br>  iunlockput(dp);<br><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>create先调用nameiparent根据给定的路径名的最后一个目录，然后在该目录下调用dirlookup找名称为name的文件或文件夹（名字重复了就需要报错），如果找不到则掉用ialloc分配一个新的inode。从此时开始，create同时持有父目录的锁和当前要生成文件对应的inode的锁。</p><p>将inode初始化之后分配的inode调用iupdate刷新到磁盘inode块，并且调用dirlink将父目录中新增一个dirent结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write a new directory entry (name, inum) into the directory dp.  </span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">dirlink</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dp, <span class="hljs-type">char</span> *name, uint inum)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> off;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <br>  <br>  <span class="hljs-comment">// Check that name is not present.  </span><br>  <span class="hljs-keyword">if</span>((ip = dirlookup(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;  <br>    iput(ip);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-comment">// Look for an empty dirent.  </span><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-keyword">sizeof</span>(de))&#123;  <br>    <span class="hljs-keyword">if</span>(readi(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))  <br>      panic(<span class="hljs-string">&quot;dirlink read&quot;</span>);  <br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">break</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-built_in">strncpy</span>(de.name, name, DIRSIZ);  <br>  de.inum = inum;  <br>  <span class="hljs-keyword">if</span>(writei(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))  <br>    panic(<span class="hljs-string">&quot;dirlink&quot;</span>);  <br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>实现create是为了更实现上层的sys_open、sys_mkdir和sys_mknod等系统调用接口。这里可以看看最复杂的<strong>sys_open</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_open</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">char</span> path[MAXPATH];  <br>  <span class="hljs-type">int</span> fd, omode;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <br>  <span class="hljs-type">int</span> n;  <br>  <br>  <span class="hljs-keyword">if</span>((n = argstr(<span class="hljs-number">0</span>, path, MAXPATH)) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">1</span>, &amp;omode) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  <br>  begin_op();  <br><br><span class="hljs-comment">//如果O_CREATE则创建一个新的文件</span><br>  <span class="hljs-keyword">if</span>(omode &amp; O_CREATE)&#123;  <br>    ip = create(path, T_FILE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <br>    <span class="hljs-keyword">if</span>(ip == <span class="hljs-number">0</span>)&#123;  <br>      end_op();  <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;  <br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>  <span class="hljs-comment">//打开一个已经存在的文件需要使用namei来查找</span><br>    <span class="hljs-keyword">if</span>((ip = namei(path)) == <span class="hljs-number">0</span>)&#123;  <br>      end_op();  <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;  <br>    ilock(ip);  <br>    <span class="hljs-keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;  <br>      iunlockput(ip);  <br>      end_op();  <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;  <br>  &#125;  <br>  <br>  <span class="hljs-keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="hljs-number">0</span> || ip-&gt;major &gt;= NDEV))&#123;  <br>    iunlockput(ip);  <br>    end_op();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-keyword">if</span>((f = filealloc()) == <span class="hljs-number">0</span> || (fd = fdalloc(f)) &lt; <span class="hljs-number">0</span>)&#123;  <br>    <span class="hljs-keyword">if</span>(f)  <br>      fileclose(f);  <br>    iunlockput(ip);  <br>    end_op();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-keyword">if</span>(ip-&gt;type == T_DEVICE)&#123;  <br>    f-&gt;type = FD_DEVICE;  <br>    f-&gt;major = ip-&gt;major;  <br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    f-&gt;type = FD_INODE;  <br>    f-&gt;off = <span class="hljs-number">0</span>;  <br>  &#125;  <br>  f-&gt;ip = ip;  <br>  f-&gt;readable = !(omode &amp; O_WRONLY);  <br>  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);  <br>  <br>  <span class="hljs-keyword">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;  <br>    itrunc(ip);  <br>  &#125;  <br>  <br>  iunlock(ip);  <br>  end_op();  <br>  <br>  <span class="hljs-keyword">return</span> fd;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（1）如果调用sys_open时设置了O_CREATE模式，那么将调用create；</strong> <strong>（2）否则，open默认打开一个现有的文件，因此调用namei。create返回上锁的inode，而namei返回的inode并不上锁，所以还需要显式地调用ilock。</strong> <strong>（3）无论ip是由create新分配的，还是用namei打开的原有的，前面的方法都是得到inode。我们需要的是file，所以sys_open接着调用filealloc从ftable中得到一个空file，并且调用fdalloc分配一个文件描述符，接着填充struct file结构。就得到了进程平时使用的文件。</strong></p><h4 id="管道">管道</h4><p>再看sys_pipe</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  uint64 fdarray; <span class="hljs-comment">// user pointer to array of two integers  </span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">rf</span>, *<span class="hljs-title">wf</span>;</span>  <br>  <span class="hljs-type">int</span> fd0, fd1;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br><br>  <span class="hljs-comment">// int p[2]</span><br>  <span class="hljs-comment">// pipe(p)，a0寄存器是数组p[2]，通过argaddr接收传过来的参数</span><br>  <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;fdarray) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  <span class="hljs-keyword">if</span>(pipealloc(&amp;rf, &amp;wf) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  fd0 = <span class="hljs-number">-1</span>;  <br>  <span class="hljs-keyword">if</span>((fd0 = fdalloc(rf)) &lt; <span class="hljs-number">0</span> || (fd1 = fdalloc(wf)) &lt; <span class="hljs-number">0</span>)&#123;  <br>    <span class="hljs-keyword">if</span>(fd0 &gt;= <span class="hljs-number">0</span>)  <br>      p-&gt;ofile[fd0] = <span class="hljs-number">0</span>;  <br>    fileclose(rf);  <br>    fileclose(wf);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>  <span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable, fdarray, (<span class="hljs-type">char</span>*)&amp;fd0, <span class="hljs-keyword">sizeof</span>(fd0)) &lt; <span class="hljs-number">0</span> ||  <br>     copyout(p-&gt;pagetable, fdarray+<span class="hljs-keyword">sizeof</span>(fd0), (<span class="hljs-type">char</span> *)&amp;fd1, <span class="hljs-keyword">sizeof</span>(fd1)) &lt; <span class="hljs-number">0</span>)&#123;  <br>    p-&gt;ofile[fd0] = <span class="hljs-number">0</span>;  <br>    p-&gt;ofile[fd1] = <span class="hljs-number">0</span>;  <br>    fileclose(rf);  <br>    fileclose(wf);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>创建管道的函数是<strong>pipealloc</strong>，为了创建管道，会分配两个新的打开文件f0和f1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">pipealloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file **f0, <span class="hljs-keyword">struct</span> file **f1)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">pi</span>;</span><br><br>  pi = <span class="hljs-number">0</span>;<br>  *f0 = *f1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*f0 = filealloc()) == <span class="hljs-number">0</span> || (*f1 = filealloc()) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>((pi = (<span class="hljs-keyword">struct</span> pipe*)kalloc()) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  pi-&gt;readopen = <span class="hljs-number">1</span>;<br>  pi-&gt;writeopen = <span class="hljs-number">1</span>;<br>  pi-&gt;nwrite = <span class="hljs-number">0</span>;<br>  pi-&gt;nread = <span class="hljs-number">0</span>;<br>  initlock(&amp;pi-&gt;lock, <span class="hljs-string">&quot;pipe&quot;</span>);<br>  (*f0)-&gt;type = FD_PIPE;<br>  (*f0)-&gt;readable = <span class="hljs-number">1</span>;<br>  (*f0)-&gt;writable = <span class="hljs-number">0</span>;<br>  (*f0)-&gt;pipe = pi;<br>  (*f1)-&gt;type = FD_PIPE;<br>  (*f1)-&gt;readable = <span class="hljs-number">0</span>;<br>  (*f1)-&gt;writable = <span class="hljs-number">1</span>;<br>  (*f1)-&gt;pipe = pi;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br> bad:<br>  <span class="hljs-keyword">if</span>(pi)<br>    kfree((<span class="hljs-type">char</span>*)pi);<br>  <span class="hljs-keyword">if</span>(*f0)<br>    fileclose(*f0);<br>  <span class="hljs-keyword">if</span>(*f1)<br>    fileclose(*f1);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book-Chapter8 文件系统 part2</title>
    <link href="/2024/04/15/xv6-book-Chapter8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-part2/"/>
    <url>/2024/04/15/xv6-book-Chapter8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-part2/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter8-file-system-part2">Chapter8 File System part2</h1><p>前文讲到了buffer cache层和log层都是以块的形式进行服务，但是一个大文件完全由可能包含多个块，因此我们还需对多个块进行管理，也就是将多个块抽象成新的数据结构，这就是inode层的工作。</p><p>不知道有多少人听说过文件是inode，文件夹是特殊的inode这句话。这句话一直让我很费解，我始终不理解文件到底是一个什么概念，也不知道inode到底是什么，看别人的博客直接就摆上来inode的数据结构，然后说文件夹特殊在哪里，我始终没有实感，我不明白为什么要这样做，inode的概念也就成了脑海中的空中楼阁。</p><p>如果你也和我一样，那么继续看下去吧，有了前两层的铺垫，inode不再是空中楼阁</p><h2 id="inode-layer">Inode Layer</h2><p>xv6的inode有两个含义，一个是指磁盘上的数据结构（dinode），另一个是指内存中的数据结构（inode）。inode除了包含dinode的内容，还额外添加了一些在内存中工作需要的东西，比如元数据和锁。所有的inode使用icache（有的版本称为itable）维护，这一点和buf、bcache之间的关系类似</p><h4 id="为什么需要inode层">为什么需要inode层？</h4><p>buffer cache + log已经能让我们安全的访问磁盘了，为什么还需要inode层？ 因为到此为止我们对磁盘的访问都是一块一块的，很多上层的文件（例如可执行文件）很大，绝对不止一块，那我们就需要一个结构体来管理块，将它们组合在一起，共同表示一个文件。因此我们一般认为一个inode对应一个文件。</p><p>对于已经使用的磁盘块，有很多管理方法，inode索引结构是其中一种 （1）连续分配（×）；每次写入文件时，就从磁盘中分配连续的块保存。优点在于顺序读写很快，但最大的问题在于使用久了会产生大量碎片（不能接受） （2）链表分配（×）；在分配块前，拿出块的一部分保存下一个块的位置，串成一条链表。优点在于没有碎片问题了，但是一个块损坏，整个链表就不可用了，并且块大小一般是 2 的幂次方大小，但是这种方式组织文件每个数据块的大小不再是 2 的幂次方，使用时引入额外开销。 （3）索引结构（√）；单独地将每个文件用到的磁盘块地址维护起来。<strong>也就是说为每个文件建立一个索引数据结构，里面存放的是文件使用的各个磁盘块地址</strong></p><p><img src="Pasted%20image%2020240329161052.png"></p><p>整个索引由12个直接索引，1个一级索引，1个二级索引，1个三级索引组成。大多数情况下磁盘上都是小文件，这样兼顾了大文件存储和小文件读写效率。</p><p>上图表示的 inode，有 12 个直接索引，1 个一级索引，1 个二级索引，1 个三级索引，再假设每个块 1 KB，一个地址项需要 4 字节来表示。则inode可以表示12KB + 4MB + 64MB + 16G的磁盘空间。</p><p>在xv6中，inode结构包含了总共12个直接指针，1个指针间接指针，每个数据块大小是1kB（1024字节），每个指针都是uint（4字节），因此inode可以表示的大小位12 * 1kB + (1KB / 4B) * 1KB = 12 + 256 = 268 KB</p><p>核心数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// fs.h</span><br><span class="hljs-comment">// On-disk inode structure  </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> &#123;</span>  <br>  <span class="hljs-type">short</span> type;           <span class="hljs-comment">// 指示了该inode的类型，是文件、目录、设备还是未被使用  </span><br>    <span class="hljs-comment">// Major device number用于标识设备所属的设备驱动程序。它是一个非负整数，对应于内核中注册的设备驱动程序的索引或标识符。内核使用主设备号来确定需要调用的设备驱动程序，以便处理与特定设备相关的操作。例如，硬盘驱动程序和网络接口驱动程序将具有不同的主设备号。</span><br>  <span class="hljs-type">short</span> major;          <span class="hljs-comment">// Major device number (T_DEVICE only)  </span><br>    <span class="hljs-comment">//Minor device number 用于标识同一设备驱动程序下不同的设备实例。它是一个非负整数，用于区分同一类型设备的不同实例。例如，一个主设备号对应的磁盘驱动程序可能会对应多个实际的磁盘设备，每个磁盘设备将通过不同的次设备号进行区分</span><br>  <span class="hljs-type">short</span> minor;          <span class="hljs-comment">// Minor device number (T_DEVICE only)  </span><br>  <br>  <span class="hljs-comment">// nlink表示有多少个目录条目包含这一inode。对于文件来说，nlink既是链接计数也是硬链接数，而对于目录来说，nlink只是链接计数，nlink指示这个inode及其相应的数据块什么时候被释放  </span><br>  <span class="hljs-type">short</span> nlink;          <br>  uint size;            <span class="hljs-comment">// size表示以字节为单位表示该文件有多大 </span><br>  <span class="hljs-comment">//#define NDIRECT 12，表示拥有13个数据块指针</span><br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];   <span class="hljs-comment">// Data block addresses  </span><br>&#125;;<br><br><span class="hljs-comment">// file.h</span><br><span class="hljs-comment">// in-memory copy of an inode  </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span>  <br>  uint dev;           <span class="hljs-comment">// Device number  </span><br>  uint inum;          <span class="hljs-comment">// Inode number  </span><br>  <span class="hljs-type">int</span> ref;            <span class="hljs-comment">// 指示了有多少C指针指向inode的内存副本（也就是这里的inode结构体），如果ref为0，内核就丢弃该inode结构体</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span> <span class="hljs-comment">// protects everything below here  </span><br>  <span class="hljs-type">int</span> valid;          <span class="hljs-comment">// inode has been read from disk?  </span><br>  <br>  <span class="hljs-type">short</span> type;         <span class="hljs-comment">// copy of disk inode  </span><br>  <span class="hljs-type">short</span> major;        <br>  <span class="hljs-type">short</span> minor;      <br>  <span class="hljs-type">short</span> nlink;  <br>  uint size;  <br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];  <br>&#125;;<br><br><span class="hljs-comment">//fs.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> <span class="hljs-title">inode</span>[<span class="hljs-title">NINODE</span>];</span>  <br>&#125; icache;<br></code></pre></td></tr></table></figure><p>icache.lock保护两个条件：一是每个inode在缓存中至多有一个副本（即一个dinode只能对应一个inode结构体）；二是每个inode的缓存副本中，ref代表了当前指向该inode副本的指针数。内存中的每个inode副本都有一把睡眠锁，可以同步对这些inode和它们的数据块的并发访问，这些设计思想和Buffer Cache如出一辙。</p><p><strong>注意ref和nlink作用的不同。ref是内存指针计数，只要ref大于0，内核就会将该inode的副本保留在icache中；而nlink是硬链接计数，只要nlink大于0，文件系统就不会释放该inode及其数据块在磁盘上占用的空间</strong></p><p>设计icache的主要目的是为了同步多个进程对inode的访问，而利用缓存的高速性只是次要目的。如果一个inode经常被使用，就算它不在icache中，Buffer Cache也可能会缓存它。icache是直写式（write-through）的，这意味着一旦icache中的某个inode副本被修改，就要马上调用iupdate来更新到磁盘上</p><p>获取buf是通过bget，获得inode是通过iget</p><h4 id="inode元数据操作">inode元数据操作</h4><p><strong>ialloc</strong>，在一个循环中遍历所有磁盘上的inode块，找到处于空闲的一个，读取dinode然后更新inode的type字段，并且在结尾时调用iget以将该inode块缓存在icache中，最终返回一个指向该inode的缓存副本的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// Inodes per block.</span><br><span class="hljs-comment">// 计算每个BLOCK有多少个inode</span><br><span class="hljs-comment">// IPB = 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IPB           (BSIZE / sizeof(struct dinode))</span><br><br><span class="hljs-comment">// Block containing inode i</span><br><span class="hljs-comment">// 计算给定的inode i在第几个block上</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)</span><br><br><br><span class="hljs-comment">// Allocate an inode on device dev.  </span><br><span class="hljs-comment">// Mark it as allocated by  giving it type type.  </span><br><span class="hljs-comment">// Returns an unlocked but allocated and referenced inode.  </span><br><span class="hljs-keyword">struct</span> inode*  <br><span class="hljs-title function_">ialloc</span><span class="hljs-params">(uint dev, <span class="hljs-type">short</span> type)</span>  <br>&#123;  <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  注意和iget的区别</span><br><span class="hljs-comment">  ialloc每次调用时，都会找到一个磁盘上空闲的inode块(数据结构是dinode)</span><br><span class="hljs-comment">  然后将其标记为已分配，分配完之后就会马上调用iget并将其缓存在icache中</span><br><span class="hljs-comment">  iget则是给定inode number，先看icache中对应的inode是否已经存在</span><br><span class="hljs-comment">  如果没有，就占用空位来缓存该inode</span><br><span class="hljs-comment">*/</span><br>  <span class="hljs-type">int</span> inum;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> *<span class="hljs-title">dip</span>;</span>  <br>  <br>  <span class="hljs-keyword">for</span>(inum = <span class="hljs-number">1</span>; inum &lt; sb.ninodes; inum++)&#123;  <br>    bp = bread(dev, IBLOCK(inum, sb));  <br><br><span class="hljs-comment">// 给定inode的inode number，得到该inode在哪一个block上</span><br>    <span class="hljs-comment">// 读取对应的block上的data，这个block包含了多个inode，数量为IPB</span><br>    <span class="hljs-comment">// inum%IPB是block内的偏移量，加上偏移量之后则即读取block上第inum个inode</span><br>    <span class="hljs-comment">// 注意读取的bp是磁盘上的inode，所以数据结构类型为dinode</span><br>    dip = (<span class="hljs-keyword">struct</span> dinode*)bp-&gt;data + inum%IPB;  <br><br><span class="hljs-comment">//找到一个空闲的dinode，初始化后返回</span><br>    <span class="hljs-keyword">if</span>(dip-&gt;type == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// a free inode  </span><br>      <span class="hljs-built_in">memset</span>(dip, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(*dip));  <br>      dip-&gt;type = type;  <br>      log_write(bp);  <br>      brelse(bp);  <br>      <br><span class="hljs-comment">//此时对dinode的修改值体现在dip上，但还没有反应在icache中</span><br>      <span class="hljs-keyword">return</span> iget(dev, inum);  <br>    &#125;  <br>    brelse(bp);  <br>  &#125;  <br>  panic(<span class="hljs-string">&quot;ialloc: no inodes&quot;</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><p>分配数据块的时候有位图来组织管理，所以分配数据块的时候就“从头至尾”的查询空闲<strong>位</strong>，dinode没有组织管理，因此需要从头到位查询dinode结构的情况。如果type为0就可以分配，在初始化后该dinode的分配只体现在内存中，还需要log_write刷新到磁盘上，当然，学了前面的内容我们知道，这里其实并未真正地直接写到磁盘了，只是在将该缓存数据标记为脏。</p><p>此时dinode已分配，那么需要将它调入icache中，所以调用iget函数获取icache中inode数组中的一个空位来缓存这个dinode。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Find the inode with number inum on device dev</span><br><span class="hljs-comment">// and return the in-memory copy. Does not lock</span><br><span class="hljs-comment">// the inode and does not read it from disk.</span><br><span class="hljs-comment">// iget() provides non-exclusive access to an inode, so that there can be many pointers to the same inode</span><br><span class="hljs-comment">// iget()不能对inode上锁的原因见dirlookup()</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">iget</span><span class="hljs-params">(uint dev, uint inum)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">empty</span>;</span><br><br>  acquire(&amp;icache.lock);<br><br>  <span class="hljs-comment">// Is the inode already cached?</span><br>  empty = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(ip = &amp;icache.inode[<span class="hljs-number">0</span>]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123;<br>    <span class="hljs-comment">// 先在icache缓存中查找，看是否已经被缓存</span><br>    <span class="hljs-keyword">if</span>(ip-&gt;ref &gt; <span class="hljs-number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;<br>      ip-&gt;ref++;<br>      release(&amp;icache.lock);<br>      <span class="hljs-comment">// 返回一个新的inode指针，指向icache中的inode</span><br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br><br><span class="hljs-comment">//这里是两段逻辑一起执行，一边找cache命中，一边找第一个为空的槽位，如果cache未命中，就不用专门再循环一次来寻找空槽位了</span><br>    <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span> &amp;&amp; ip-&gt;ref == <span class="hljs-number">0</span>)    <span class="hljs-comment">// Remember empty slot.</span><br>      <span class="hljs-comment">// 找到icache中第一个为空的槽位</span><br>      empty = ip;<br>  &#125;<br><br>  <span class="hljs-comment">// Recycle an inode cache entry.</span><br>  <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;iget: no inodes&quot;</span>);<br>  <span class="hljs-comment">// 遍历了当前所有icache中的inode，但是缓存没有命中</span><br>  <span class="hljs-comment">// empty是icache中第一个为空的槽位</span><br>  <span class="hljs-comment">// 初始化之后，返回指向该inode的指针</span><br>  ip = empty;<br>  ip-&gt;dev = dev;<br>  ip-&gt;inum = inum;<br>  ip-&gt;ref = <span class="hljs-number">1</span>;<br>  ip-&gt;valid = <span class="hljs-number">0</span>;<br>  release(&amp;icache.lock);<br><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>iget只是获得icache中的一个inode，如果没有就分配一个，但是该inode的addr部分仍然是空的，不要搞混淆了</p><p>在获得了inode结构体指针后，因为inode可能有多个线程都在访问，所以我们还不能直接修改。这时候就需要特殊的方式来保证并发安全，这个方式就是ilock。ilock获取相应inode的睡眠锁，从而同步所有线程对inode的并发访问。如果该inode是刚刚由ialloc分配的，那么valid字段为0，表示需要从磁盘上读出inode的内容到其缓存副本中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Lock the given inode.</span><br><span class="hljs-comment">// Reads the inode from disk if necessary.</span><br><span class="hljs-comment">// The struct inode that iget returns may not have any useful content. </span><br><span class="hljs-comment">// In order to ensure it holds a copy of the on-disk inode, code must call ilock. </span><br><span class="hljs-comment">// This locks the inode (so that no other process can ilock it) and reads the inode from the disk, if it has not already been read.</span><br><span class="hljs-comment">// Multiple processes can hold a C pointer to an inode returned by iget, but only one process can lock the inode at a time.</span><br><span class="hljs-comment">// 在读取或修改inode的元数据和数据内容之前，首先应该调用ilock对inode上锁</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ilock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> *<span class="hljs-title">dip</span>;</span><br><br>  <span class="hljs-keyword">if</span>(ip == <span class="hljs-number">0</span> || ip-&gt;ref &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;ilock&quot;</span>);<br><br>  acquiresleep(&amp;ip-&gt;lock);<br><br>  <span class="hljs-comment">// 刚从iget得到的inode指针，其valid=0</span><br>  <span class="hljs-keyword">if</span>(ip-&gt;valid == <span class="hljs-number">0</span>)&#123;<br>    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));<br>    dip = (<span class="hljs-keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;<br>    ip-&gt;type = dip-&gt;type;<br>    ip-&gt;major = dip-&gt;major;<br>    ip-&gt;minor = dip-&gt;minor;<br>    ip-&gt;nlink = dip-&gt;nlink;<br>    ip-&gt;size = dip-&gt;size;<br>    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="hljs-keyword">sizeof</span>(ip-&gt;addrs));<br>    brelse(bp);<br>    ip-&gt;valid = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(ip-&gt;type == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;ilock: no type&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 这时还没有释放ip-&gt;lock,需要调用iunlock以释放</span><br>&#125;<br><br><br><span class="hljs-comment">// Unlock the given inode.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">iunlock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(ip == <span class="hljs-number">0</span> || !holdingsleep(&amp;ip-&gt;lock) || ip-&gt;ref &lt; <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;iunlock&quot;</span>);<br><br>  releasesleep(&amp;ip-&gt;lock);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>看起来复杂，其实ilock就是上锁 + valid为0时从磁盘读取dinode，iunlock就是解锁</p><p>与iget获取一个inode相对应，iput接收一个inode指针输入，并且将其ref计数减1。如果该指针是最后一个对该inode的引用，而且该inode硬链接数nlink为0，那么就释放磁盘上的对应inode和相关数据块。iput通过调用itrunc来释放inode，将长度截断为0并且释放相关数据块，然后标记type为空闲，最后调用iupdate将新的inode元数据写回磁盘上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Drop a reference to an in-memory inode.</span><br><span class="hljs-comment">// If that was the last reference, the inode cache entry can</span><br><span class="hljs-comment">// be recycled.</span><br><span class="hljs-comment">// If that was the last reference and the inode has no links</span><br><span class="hljs-comment">// to it, free the inode (and its content) on disk.</span><br><span class="hljs-comment">// All calls to iput() must be inside a transaction in</span><br><span class="hljs-comment">// case it has to free the inode.</span><br><span class="hljs-comment">// release pointers to an inode, modifying the reference count</span><br><span class="hljs-comment">// xv6 won’t free an inode if its link count is greater than zero</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">iput</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span><br>&#123;<br>  acquire(&amp;icache.lock);<br><br>  <span class="hljs-comment">// 只有当ref=0且nlink=0，即既没有指针引用该inode，也没有目录条目引用该inode</span><br>  <span class="hljs-comment">// 释放在disk上的inode</span><br>  <span class="hljs-keyword">if</span>(ip-&gt;ref == <span class="hljs-number">1</span> &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// inode has no links and no other references: </span><br>    <span class="hljs-comment">// then the inode and its data blocks must be freed</span><br>    <span class="hljs-comment">// truncate and free.</span><br><br>    <span class="hljs-comment">// ip-&gt;ref == 1 means no other process can have ip locked,</span><br>    <span class="hljs-comment">// so this acquiresleep() won&#x27;t block (or deadlock).</span><br>    acquiresleep(&amp;ip-&gt;lock);<br><br>    release(&amp;icache.lock);<br><br>    itrunc(ip);<br>    ip-&gt;type = <span class="hljs-number">0</span>;<br>    iupdate(ip);<br>    ip-&gt;valid = <span class="hljs-number">0</span>;<br><br>    releasesleep(&amp;ip-&gt;lock);<br><br>    acquire(&amp;icache.lock);<br>  &#125;<br><br>  ip-&gt;ref--; <span class="hljs-comment">//iput的核心，其他操作都是在ref为0时善后</span><br>  <span class="hljs-comment">// 如果是最后一个指针，ref--后变为0，这时iget就能发现它，用它的位置给新的inode缓存</span><br>  <span class="hljs-comment">// 但是在硬盘上，目录的硬链接仍然存在，因为nlink!=0</span><br>  <span class="hljs-comment">// ref=0本质上只是icache不再缓存该inode，并不是释放了磁盘上的inode</span><br>  <span class="hljs-comment">// 之后还可以再次调用iget缓存该inode</span><br>  release(&amp;icache.lock);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>说白了，iput的作用就是表示该线程inode已经使用完，引用数减一，同时保证只有当ref=0且nlink=0，即没有指针引用该inode，也没有目录引用该inode时删除</p><p>接下来看iupdate（itrunc的实现涉及到inode的直接块和间接块部分，后面再说）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// Copy a modified in-memory inode to disk.</span><br><span class="hljs-comment">// Must be called after every change to an ip-&gt;xxx field</span><br><span class="hljs-comment">// that lives on disk, since i-node cache is write-through.</span><br><span class="hljs-comment">// Caller must hold ip-&gt;lock.</span><br><span class="hljs-comment">// The inode cache is write-through, which means that code that modifies a cached inode must immediately write it to disk with iupdate.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">iupdate</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span><br>&#123;<br>  <span class="hljs-comment">// 每次更改icache中的inode结构体，都需要调用iupdate写入到磁盘</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> *<span class="hljs-title">dip</span>;</span><br><br>  bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));<br>  <span class="hljs-comment">//读取ip对应inode原本所在的位置，现在ip是新的inode，dip是旧的inode，完成拷贝后刷入磁盘</span><br>  dip = (<span class="hljs-keyword">struct</span> dinode*)bp-&gt;data + ip-&gt;inum%IPB;<br><br>  <span class="hljs-comment">// ip是新的inode，dip是旧的inode</span><br>  dip-&gt;type = ip-&gt;type;<br>  dip-&gt;major = ip-&gt;major;<br>  dip-&gt;minor = ip-&gt;minor;<br>  dip-&gt;nlink = ip-&gt;nlink;<br>  dip-&gt;size = ip-&gt;size;<br>  memmove(dip-&gt;addrs, ip-&gt;addrs, <span class="hljs-keyword">sizeof</span>(ip-&gt;addrs));<br>  <span class="hljs-comment">// 此次更新写入log</span><br>  log_write(bp);<br>  brelse(bp);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>因为调用了iupdate，所以iput含有写入磁盘的操作。这意味着凡是访问和使用了文件系统的系统调用，最终都会引发写入磁盘的操作（因为几乎所有的文件系统操作与inode相关）。即使是像read这样的，看起来不会做任何写入的系统调用，也会在其结尾处调用iput，一旦read传入的inode指针是最后一个，就会引发iupdate被调用，从而导致写入磁盘的操作。因此，即使是只读的系统调用，只要使用了文件系统，就要在它们的事务中用上日志系统</p><p>还有一个比较微妙的关系是，当一个文件的硬链接数nlink为0，iput并不会马上就删除并释放该文件，因为在内存中可能还存在其它指向该文件的inode指针，甚至有进程仍然在读写这个文件。如果在最后一个进程关闭该文件的文件描述符，释放最后一个inode指针之前，崩溃或者断电发生了，下次启动时该文件仍会被标记为分配（因为没有被删除并释放），但是没有任何目录条目会包含它，也不会有任何内存中的inode指针指向它，我们失去了一些磁盘空间</p><p>文件系统有两种方式处理这种情况：一个简单的方法是，在系统启动的恢复阶段，文件系统扫描磁盘上的整个文件系统，检查是否有文件标记被分配，但是没有任何目录条目包含它，然后如果有，就删除释放这些文件。</p><p>第二个方法是不需要扫描整个文件系统，而是在磁盘的某个位置上（例如超级块中），记录硬链接数为0，而指向其的指针数不为0的文件的inode号。如果该文件最后确实被删除释放了，那么就从该记录列表中移出相应的inode号。然后在系统启动的恢复阶段，不扫描整个文件系统，而是简单地扫描该列表，删除释放该列表中的文件即可。</p><p>但是，<strong>xv6文件系统并不提供以上两种的任一一种实现，这意味着随着xv6的运行，会有越来越多的磁盘空间流失，最终，我们可能会耗尽磁盘上的空间。</strong></p><h4 id="inode-addr操作">inode addr操作</h4><p>想要通过inode获取到指示的数据块需要接口bmap：给定inode指针，bmap就为我们找到文件的第bn块对应的数据块块号，该操作的主要目的是为更高层的接口如readi和writei提供便利。如果该数据块还未被分配，bmap还会调用balloc为我们分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Bmap returns the disk block number of the bn’th data block for the inode ip.</span><br><span class="hljs-comment">//返回inode ip中addr数组中的第bn个数据块，如果指针无效则分配</span><br><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">bmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, uint bn)</span><br>&#123;<br>  <span class="hljs-comment">// 给定文件的第bn个data block </span><br>  <span class="hljs-comment">// 0 &lt;= bn &lt; NDIRECT + NINDIRECT</span><br>  <span class="hljs-comment">// 返回在磁盘上对应的data block number</span><br>  uint addr, *a;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-comment">// 先查找直接块</span><br>  <span class="hljs-keyword">if</span>(bn &lt; NDIRECT)&#123; <span class="hljs-comment">//前NDIRECT为直接映射</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>      <span class="hljs-comment">// 该直接块还没有被分配，因此分配一个新数据块</span><br>      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>    <span class="hljs-keyword">return</span> addr; <span class="hljs-comment">//按需分配，并不是一口气把整个addr填满</span><br>  &#125;<br>  bn -= NDIRECT;<br><br>  <span class="hljs-comment">// 如果bn不是直接块，就查找间接块</span><br>  <span class="hljs-keyword">if</span>(bn &lt; NINDIRECT)&#123;<br>    <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>      <span class="hljs-comment">// 一级间接映射块是空的，先分配一个一级间接块</span><br>      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    <span class="hljs-comment">// 在这里将a变为uint*形的指针，这样a的每次偏移都会增加一个sizeof(uint)</span><br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-comment">// a是一级间接块的数据，包含了256个uint，每个uint都指向一个实际的数据块</span><br>    <span class="hljs-keyword">if</span>((addr = a[bn]) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// 分配一个新数据块</span><br>      a[bn] = addr = balloc(ip-&gt;dev);<br>      <span class="hljs-comment">// balloc只会将新的位图写入日志中，而一级间接块现在被更新</span><br>      <span class="hljs-comment">// 所以要另外调用log_write将更新写入日志 中</span><br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  <br>  panic(<span class="hljs-string">&quot;bmap: out of range&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>bmap的实现逻辑比较清晰。首先检查直接块，如果bn不是对应直接块，那么检查间接块。如果读出的内容是0而不是块号，代表那一块还没有被分配。如果直接块不存在，那么就分配新的数据块；如果间接块不存在，那么先分配一块给间接块，后续再分配一块给间接块的数据块。</p><p>注意：bmap是按序分配的，不是一开始就把addr的空位填满。另外，bmap以inode为参数，所以该函数名称改为imap其实会更好。</p><p>iupdate将修改后的inode刷新到磁盘上，itrunc的作用释放一个给定inode的所有数据块，有这两个函数的帮助，才能完成完整的iput操作。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Truncate inode (discard contents).</span><br><span class="hljs-comment">// Caller must hold ip-&gt;lock.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">itrunc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, j;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  uint *a;<br><br>  <span class="hljs-comment">// truncate the file to zero bytes, freeing the data blocks</span><br>  <span class="hljs-comment">// sets the inode type to 0</span><br>  <span class="hljs-comment">// and writes the inode to disk (bfree会调用log_write)</span><br>  <span class="hljs-comment">// 整体结构和bmap相似，只是多了bfree和条目清0的操作</span><br><br>  <span class="hljs-comment">// 释放所有直接块</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NDIRECT; i++)&#123;<br>    <span class="hljs-keyword">if</span>(ip-&gt;addrs[i])&#123;<br>      bfree(ip-&gt;dev, ip-&gt;addrs[i]);<br>      ip-&gt;addrs[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 释放所有间接块</span><br>  <span class="hljs-keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;<br>    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++)&#123;<br>      <span class="hljs-keyword">if</span>(a[j])<br>        <span class="hljs-comment">// 释放所有间接数据块</span><br>        bfree(ip-&gt;dev, a[j]);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-comment">// 释放间接块</span><br>    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>    ip-&gt;addrs[NDIRECT] = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  ip-&gt;size = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 更改了inode，因此要更新到磁盘上</span><br>  iupdate(ip);<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>可以发现在inode层中，目前的核心函数只有iget和iput，这两个都是针对inode结构本身（元数据）的操作，想要真正的完成读写，实际需要操作的是inode结构中的addr。这就涉及到了readi和writei，从这里就可以看到地址的痕迹了，之前的操作都是以数据块为单位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Read data from inode.</span><br><span class="hljs-comment">// Caller must hold ip-&gt;lock.</span><br><span class="hljs-comment">// If user_dst==1, then dst is a user virtual address;</span><br><span class="hljs-comment">// otherwise, dst is a kernel address.</span><br><span class="hljs-comment">//从ip指向的文件中（inode中）的off位置开始读，读取n个字节到dst中。user_dst表示使用虚拟地址还是物理地址（因为在内核中虚拟地址和物理地址是直接映射的），毕竟内核线程和用户进程都有可能执行io</span><br><span class="hljs-comment">//注意：off不是实际的读取地址，而是inode文件内部的相对地址，off为0表示从inode文件开头读</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">readi</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, <span class="hljs-type">int</span> user_dst, uint64 dst, uint off, uint n)</span><br>&#123;<br>  uint tot, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br><br>  <span class="hljs-keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(off + n &gt; ip-&gt;size)<br>    <span class="hljs-comment">// 读取字节数不能超过文件大小</span><br>    n = ip-&gt;size - off;<br>    <br>  <span class="hljs-keyword">for</span>(tot=<span class="hljs-number">0</span>; tot&lt;n; tot+=m, off+=m, dst+=m)&#123;<br>  <span class="hljs-comment">//虽然bmap在block地址为空时会分配一个块，但是在readi中先进行过n的校验，不会大于inode 的大小size，因此不会出现越界，也就是分配块的情况</span><br>  <span class="hljs-comment">//bmap(struct inode *ip, uint bn)，bn表示读取inode addr中第几个槽位的block</span><br>    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));<br>    <span class="hljs-comment">//m表示这一次copy的字节数，它是当前剩余读取的内容和当前块剩余的内容的min值，即</span><br>    <span class="hljs-comment">//(1)想要读取n个字节，就不能超过n</span><br>    <span class="hljs-comment">//(2)如果剩余要读的内容一部分在当前块，一部分再另一个块，那么只能先读当前块剩下的内容</span><br>    m = min(n - tot, BSIZE - off%BSIZE);<br>    <span class="hljs-keyword">if</span>(either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="hljs-number">-1</span>) &#123;<br>      brelse(bp);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  <span class="hljs-comment">// 返回读出的大小</span><br>  <span class="hljs-keyword">return</span> tot;<br>&#125;<br><br><span class="hljs-comment">// Copy to either a user address, or kernel address,  </span><br><span class="hljs-comment">// depending on usr_dst.  </span><br><span class="hljs-comment">// Returns 0 on success, -1 on error.  </span><br><span class="hljs-comment">// 从磁盘copy到用户空间dst</span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">either_copyout</span><span class="hljs-params">(<span class="hljs-type">int</span> user_dst, uint64 dst, <span class="hljs-type">void</span> *src, uint64 len)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <span class="hljs-keyword">if</span>(user_dst)&#123;  <br>    <span class="hljs-keyword">return</span> copyout(p-&gt;pagetable, dst, src, len);  <br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    memmove((<span class="hljs-type">char</span> *)dst, src, len);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>readi开始时先检查读取是否合法，不能读超过文件大小的字节。然后主循环就会不断地读出文件相应的数据块，并把数据块的内容从Buffer Cache拷贝到dst中。</p><p><strong>writei</strong>和readi的架构相似，但有几个不同之处： - writei可以超出文件大小，从而增长文件； - writei是拷贝数据到Buffer Cache中； - 调用iupdate将inode写入磁盘，因为在调用bmap时可能分配了数据块导致inode addrs[ ]改变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write data to inode.</span><br><span class="hljs-comment">// Caller must hold ip-&gt;lock.</span><br><span class="hljs-comment">// If user_src==1, then src is a user virtual address;</span><br><span class="hljs-comment">// otherwise, src is a kernel address.</span><br><span class="hljs-comment">// 从src地址开始读取n个字节写入到ip指向文件从off开始的地方</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">writei</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, <span class="hljs-type">int</span> user_src, uint64 src, uint off, uint n)</span><br>&#123;<br>  uint tot, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span>(off + n &gt; MAXFILE*BSIZE)<br>    <span class="hljs-comment">// off可以等于ip-&gt;size,这样就相当于增长文件，但off+n即期望文件总大小不能超过规定的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-comment">// copies data into the buffers </span><br>  <span class="hljs-keyword">for</span>(tot=<span class="hljs-number">0</span>; tot&lt;n; tot+=m, off+=m, src+=m)&#123;<br>    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE)); <span class="hljs-comment">//BSIZE是一个块的字节数</span><br>    m = min(n - tot, BSIZE - off%BSIZE);<br>    <span class="hljs-keyword">if</span>(either_copyin(bp-&gt;data + (off % BSIZE), user_src, src, m) == <span class="hljs-number">-1</span>) &#123;<br>      brelse(bp);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 缓存块被修改，将更新写入日志</span><br>    log_write(bp);<br>    brelse(bp);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(off &gt; ip-&gt;size)<br>      ip-&gt;size = off;<br>    <span class="hljs-comment">// write the i-node back to disk even if the size didn&#x27;t change</span><br>    <span class="hljs-comment">// because the loop above might have called bmap() and added a new</span><br>    <span class="hljs-comment">// block to ip-&gt;addrs[].</span><br>    iupdate(ip);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-comment">// Copy from either a user address, or kernel address,  </span><br><span class="hljs-comment">// depending on usr_src.  </span><br><span class="hljs-comment">// Returns 0 on success, -1 on error.  </span><br><span class="hljs-comment">// 从用户空间src拷贝到磁盘dst</span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">either_copyin</span><span class="hljs-params">(<span class="hljs-type">void</span> *dst, <span class="hljs-type">int</span> user_src, uint64 src, uint64 len)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <span class="hljs-keyword">if</span>(user_src)&#123;  <br>    <span class="hljs-keyword">return</span> copyin(p-&gt;pagetable, dst, src, len);  <br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    memmove(dst, (<span class="hljs-type">char</span>*)src, len);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>最后，<strong>stat</strong>将inode的元数据拷贝到位于内存中的struct stat，为上层的用户进程提供访问该inode元数据的接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy stat information from inode.</span><br><span class="hljs-comment">// Caller must hold ip-&gt;lock.</span><br><span class="hljs-comment">// stati 将 ip的元数据拷贝到 stat结构体中</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">stati</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, <span class="hljs-keyword">struct</span> stat *st)</span><br>&#123;<br>  st-&gt;dev = ip-&gt;dev;<br>  st-&gt;ino = ip-&gt;inum;<br>  st-&gt;type = ip-&gt;type;<br>  st-&gt;nlink = ip-&gt;nlink;<br>  st-&gt;size = ip-&gt;size;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DIR     1   <span class="hljs-comment">// Directory  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_FILE    2   <span class="hljs-comment">// File  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DEVICE  3   <span class="hljs-comment">// Device  </span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span>  <br>  <span class="hljs-type">int</span> dev;     <span class="hljs-comment">// File system&#x27;s disk device  </span><br>  uint ino;    <span class="hljs-comment">// Inode number  </span><br>  <span class="hljs-type">short</span> type;  <span class="hljs-comment">// Type of file，根据0、1、2、3区分是什么文件，0表示无效</span><br>  <span class="hljs-type">short</span> nlink; <span class="hljs-comment">// Number of links to file  </span><br>  uint64 size; <span class="hljs-comment">// Size of file in bytes  </span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="小总结">小总结</h4><p>inode层已经有了文件系统的雏形，在之前的层中，我们一般只操作核心数据结构中保存数据的数组，例如bcache中的buf数组，很少直接修改元数据，这是因为在之前的层中，元数据本身一般作为辅助修改data block而存在（例如保证并发安全），而inode的元数据本身就已经是一种需要写入磁盘的数据了（inode块）（bcache和log都不用写入磁盘，只有buf和logheader需要，这两个结构基本没有元数据）。</p><p>在对更上层提供的服务中，我们可以通过readi一次操作一个inode，进而一次控制了很多个data block。<strong>这就是inode层的主要作用，向上层提供以文件访问数据块的接口，数据自此从磁盘块被抽象为文件</strong></p><p>inode层的核心数据结构：icache，inode（dinode） 元数据相关的方法：iget，iput，ialloc，iupdate，itrunc addr data block相关的方法：readi，writei</p><p>itrunc，iupdate都在iput中被调用，注意前者是释放inode中的addr部分，后者是将修改后的inode刷入磁盘inode块</p><p>以readi和writei为主线整理出三个层之间的函数调用图，为了让图看起来更简洁，省略了每次读取buf时涉及到的brelse和锁</p><p><img src="Pasted%20image%2020240401145302.png"></p><p><img src="Pasted%20image%2020240401154304.png"></p><h2 id="directory-layer">Directory Layer</h2><p>在inode层中，我们对文件有了一个大概的认识，闭上眼睛，大概可以想象到一个文件有一个addr数组，每个数组保存了一个指向数据block的指针，就这样，一个操作系统中抽象的文件与实际存在的物理磁盘块建立起了联系。</p><p>但是我们实际使用文件系统时，还需要文件目录。为什么说文件目录是特殊的文件呢？一般的inode的addr部分是指向数据块的指针，inode.type 为 T_FILE。而目录也是用inode结构体表示的，只不过inode.type为 T_DIR，addr部分依然是指向数据块的指针，但是数据块中的内容是一个个dirent结构体，因此查询文件（或者目录）时需要遍历每个数据块中的每个dirent name。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DIR     1   <span class="hljs-comment">// Directory  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_FILE    2   <span class="hljs-comment">// File  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> T_DEVICE  3   <span class="hljs-comment">// Device</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span>  <br>  ushort inum;  <br>  <span class="hljs-type">char</span> name[DIRSIZ];   <span class="hljs-comment">//DIRSIZ=14</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>addr中的每个槽位可以包含一个dirent，每个dirent包含了一个用户可读名称和inode号。用户可读名称最长为14个字符，而inode号为0的目录条目是空闲的。</p><p><strong>dirlookup</strong>给定一个目录的inode指针和目录的名称，如果在addr中找到对应的dirent结构，就返回该目录的inode指针，且将* poff 设为该dirent在目录inode的addr中的偏移量。如果没有则返回0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Look for a directory entry in a directory.  </span><br><span class="hljs-comment">// If found, set *poff to byte offset of entry.  </span><br><span class="hljs-keyword">struct</span> inode*  <br><span class="hljs-title function_">dirlookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dp, <span class="hljs-type">char</span> *name, uint *poff)</span>  <br>&#123;  <br>  uint off, inum;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span>  <br>  <br>  <span class="hljs-keyword">if</span>(dp-&gt;type != T_DIR)  <br>    panic(<span class="hljs-string">&quot;dirlookup not DIR&quot;</span>);  <br>  <br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-keyword">sizeof</span>(de))&#123;  <br>    <span class="hljs-keyword">if</span>(readi(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))  <br>      panic(<span class="hljs-string">&quot;dirlookup read&quot;</span>);  <br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">continue</span>;  <br>    <span class="hljs-keyword">if</span>(namecmp(name, de.name) == <span class="hljs-number">0</span>)&#123;  <br>      <span class="hljs-comment">// entry matches path element  </span><br>      <span class="hljs-keyword">if</span>(poff)  <br>        *poff = off;  <br>      inum = de.inum;  <br>      <span class="hljs-keyword">return</span> iget(dp-&gt;dev, inum);  <br>    &#125;  <br>  &#125;  <br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>目录层在inode层之上，自然会涉及到调用readi来实现数据的读取。dirlookup从inode的起始位置出发，每次读取一个dirent的大小。（readi提供了按照起始位置+读取字节数来选定读取范围的接口） 然后判断dirent name是否匹配，如果匹配则返回对应的文件或文件目录inode</p><p>注意：在之前的层中，我们考虑偏移量时总会去觉得是块内偏移量，因为读写的单位是块。但是在inode层封装之后，通过readi读取文件时，偏移量就是文件内容的偏移量，心中要把多个快统合在一起想象成一个文件，既然是一个不可分割的文件，那偏移量自然就是文件的偏移量。至于到底在哪个块上，怎么读出来，那就是readi的工作了，在目录层不需要我们考虑）</p><p><strong>dirlink</strong>则是在给定的inode下创建一个新的目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write a new directory entry (name, inum) into the directory dp.  </span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">dirlink</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dp, <span class="hljs-type">char</span> *name, uint inum)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> off;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <br>  <br>  <span class="hljs-comment">// 如果目录已经存在，则释放这个目录的inode，返回-1（创建失败）  </span><br>  <span class="hljs-keyword">if</span>((ip = dirlookup(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;  <br>    iput(ip);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-comment">// dirent初始情况下inum为0，找到一个inum为0的dirent，找不到则报错  </span><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-keyword">sizeof</span>(de))&#123;  <br>    <span class="hljs-keyword">if</span>(readi(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))  <br>      panic(<span class="hljs-string">&quot;dirlink read&quot;</span>);  <br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">break</span>;  <br>  &#125;  <br><br>  <span class="hljs-comment">//找到之后把目录信息写进去</span><br>  <span class="hljs-built_in">strncpy</span>(de.name, name, DIRSIZ);  <br>  de.inum = inum;  <br>  <span class="hljs-keyword">if</span>(writei(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))  <br>    panic(<span class="hljs-string">&quot;dirlink&quot;</span>);  <br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>dirlink会在指向的目录文件中添加一个dirent，通常是创建了一个新文件，需要在该目录下添加这个新文件的信息时使用</p><p>可以想象一下目录inode的工作原理，通过一个根inode，addr中包含了很多dirent结构体，每个结构体又都有一个inum值，唯一标识了一个inode。无论是文件inode还是目录inode的inum都在addr里。如果想从根目录递归查找一个文件，那么先遍历根目录所有dirent的name，如果不匹配，再根据inum递归读取inode，如果该inode是文件则跳过，如果是文件夹则继续查找。</p><h4 id="小总结-1">小总结</h4><p>目录层的核心结构是dirent，存在在inode中，一个变量inum用来指示当前inode下存放的文件或目录文件，另一个变量name用来表示该文件或文件目录的名字。</p><p>核心函数有 （1）dirlookup，查找当前inode下的有没有与给定name相匹配的文件，有则返回对应的inode （2）dirlink，在当前inode下的addr中找到一个空位新增一个dirent结构体（上层指定inum和name），常用在创建文件的时候</p><h2 id="总结">总结</h2><p>经过inode层和目录层的抽象，用户的视角从一个一个磁盘块转向到了一个又一个文件。其中inode层构建了文件抽象概念，目录层将所有文件抽象成一个树结构，方便查找。</p><p>此时开始，上层读取数据不再使用磁盘块+块内偏移量，而是更抽象的文件+文件内偏移量。在我们眼里，文件似乎作为一个整体被存放在磁盘上，我们不用再关心多个数据块如何串联在一起构成一个文件的。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book-Chapter8 文件系统 part1</title>
    <link href="/2024/04/15/xv6-book-Chapter8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-part1/"/>
    <url>/2024/04/15/xv6-book-Chapter8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-part1/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter8-file-system-part1">Chapter8 File System part1</h1><p>文件系统是操作系统持久化的一部分，是对文件的组织管理，整体可以抽象为7层，底层为上层提供服务，系统的设计思路和很多数据库都有相似的地方。</p><p><img src="Pasted%20image%2020240329165958.png"> 我将整个文件系统各层的目的总结如下：</p><ul><li><p><strong>Disk Layer</strong>，与QEMU仿真的虚拟磁盘打交道，往磁盘上读或写一些块，提供了真正读写磁盘的函数。</p></li><li><p><strong>Buffer Cache Layer</strong>，维护了一个bcache结构和多个buf结构，向上层暴露读写cache的API，将对磁盘的读写封装为对内存的读写，给上层提供一种直接读写磁盘的错觉。</p></li><li><p><strong>Logging Layer</strong>，维护了一个log结构和一系列需要写入磁盘的logheader结构，保存了日志块到磁盘块的映射关系，为磁盘读写提供崩溃一致性服务，高层对磁盘块的更新，将被打包成事务放入日志层，日志层确保这些更新是原子的，崩溃时<strong>写入操作要么都不发生，要么可恢复</strong>。</p></li><li><p><strong>Inode Layer</strong>，维护了一个icache结构体和一系列inode结构体，以inode的概念将多个数据块封装在一起，向上层提供一次访问多个数据块的能力，屏蔽具体访问某个数据块的细节，对应的函数readi，writei将以地址为单位访问数据。自此，高层对数据的访问将以inode为单位，不需要指定具体的某个数据块</p></li><li><p><strong>Directory Layer</strong>，利用inode结构中的addr，存储多个dirent结构，每个该结构都指向一个inode和对应的name。将众多的inode抽象为一个树状结构，方便寻找和定位。为上层提供了查找当前目录下inode的服务。</p></li><li><p><strong>Pathname Layer</strong>，为每个文件和文件目录提供符合文件系统层次结构的路径名，向上层提供根据根目录循环查找具体某个inode的服务</p></li><li><p><strong>File Descriptor Layer</strong>，文件描述符将所有底层资源（管道、设备、普通文件等）进行抽象，自此，上层对所有底层资源的访问都将以文件为单位，不再有inode的概念。诸多的系统调用例如mkdir，dup，read，open，pipe都是基于该层提供的服务实现。</p></li></ul><p>如果第一次见到这些东西难免有点晕，怎么这么复杂？但等看完所有内容，再回头看这些描述，会发现每一层的功能服务是如此的清晰明了。文件系统从底层到高层，逐层提供服务的思想是如此的精妙</p><p>磁盘布局如下图所示，每个部分究竟是干什么的，后文会慢慢展开</p><p><img src="Pasted%20image%2020240329170526.png"></p><p>本章内容将包含buffer cache层和log层的内容，<strong>这两层包含在一起为更上层提供了安全访问磁盘的API接口</strong></p><h2 id="buffer-cache">Buffer cache</h2><p>磁盘读写操作是很慢的，我们不可能真的对每个读写操作都直接调用驱动程序访问磁盘扇区，所以一般都会将一部分内存作为磁盘的缓存，在cache miss的时候再进行调换。</p><p><strong>Buffer cache将磁盘访问进行抽象，每次进程对磁盘的操作都变成了对cache的操作，屏蔽了读写磁盘的细节。</strong> 磁盘读写的单位是扇区，cache读写的单位是块，一个块等于了一个或多个扇区的大小。</p><h4 id="数据结构">数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">buf</span>[<span class="hljs-title">NBUF</span>];</span>  <br>  <br>  <span class="hljs-comment">// Linked list of all buffers, through prev/next.  </span><br>  <span class="hljs-comment">// Sorted by how recently the buffer was used.  </span><br>  <span class="hljs-comment">// head.next is most recent, head.prev is least.  </span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">head</span>;</span>  <br>&#125; bcache;<br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> &#123;</span>  <br>  <span class="hljs-type">int</span> valid;   <span class="hljs-comment">// has data been read from disk?  </span><br>  <span class="hljs-type">int</span> disk;    <span class="hljs-comment">// does disk &quot;own&quot; buf?  </span><br>  uint dev;    <span class="hljs-comment">//该缓存块表示的设备</span><br>  uint blockno;   <span class="hljs-comment">//块号</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span>  <span class="hljs-comment">//这是公共资源，需要配锁</span><br>  uint refcnt;  <span class="hljs-comment">//每个缓存块可能被多个任务引用，需要计数。缓存块可以被多个任务引用，但同时只能由一个任务读写。</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">prev</span>;</span> <span class="hljs-comment">// LRU cache list  </span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">next</span>;</span>  <br>  uchar data[BSIZE];  <span class="hljs-comment">// BSIZE = 1024，xv6的块大小是1KB</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>bcache 表示整个cache，是一个共有结构，因此拥有一把自旋锁（保护整个LRU结构，修改LRU不能需要在没有读写操作时执行）。该cache拥有NBUF个槽位，每个槽位都是buf结构。buf是缓存块的数据结构，每个buf都是一个或磁盘块的抽象，拥有睡眠锁（保护buf内部数据的安全）。</p><p>buf中除了包含真实的缓存数据以外，还需要： （1）valid：表示该槽位是否已被使用，是否有效 （2）disk：表示磁盘正在处理该缓存块的读或写请求，如果磁盘还未处理完成，disk=1，如果磁盘处理完成，disk=0 （3）refcnt：表示当前有多少个内核线程保存了指向该buf的指针，缓存块可以被多个线程引用，但同时只能由一个线程执行读写 （4）blockno：表示缓存的磁盘块在磁盘上的位置</p><h4 id="函数">函数</h4><p>（1）binit初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">binit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span>  <br>  <br>  initlock(&amp;bcache.lock, <span class="hljs-string">&quot;bcache&quot;</span>);  <br>  <br>  <span class="hljs-comment">// 先让head的前后都指向自己，然后开始串联这个LRU链表</span><br>  bcache.head.prev = &amp;bcache.head;  <br>  bcache.head.next = &amp;bcache.head;  <br><br><span class="hljs-comment">//头插法</span><br>  <span class="hljs-keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;  <br>    b-&gt;next = bcache.head.next;  <br>    b-&gt;prev = &amp;bcache.head;  <br>    initsleeplock(&amp;b-&gt;lock, <span class="hljs-string">&quot;buffer&quot;</span>);  <br>    bcache.head.next-&gt;prev = b;  <br>    bcache.head.next = b;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>初始化之后，整个数组串起来就变成了LRU，next表示最近使用的，prev表示很久未使用的。</p><p>（2）bread读取 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return a locked buf with the contents of the indicated block.  </span><br><span class="hljs-keyword">struct</span> buf*  <br><span class="hljs-title function_">bread</span><span class="hljs-params">(uint dev, uint blockno)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span>  <br>  <br>  b = bget(dev, blockno);  <br>  <span class="hljs-keyword">if</span>(!b-&gt;valid) &#123;  <br>    virtio_disk_rw(b, <span class="hljs-number">0</span>);  <span class="hljs-comment">//0代表读取磁盘块</span><br>    b-&gt;valid = <span class="hljs-number">1</span>;  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> b;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>bread通过调用bget来获取指定磁盘块的缓存块，如果b-&gt;valid=0，说明这个槽位是空的，没有缓存任何磁盘块，所以调用virtio_disk_rw从上层指定磁盘（dev）读取上层指定的磁盘块（blockno）的内容，读取完成后更新b-&gt;valid。bread最后返回的是上锁的且可用的缓存块</p><p>所以bread的核心在于bget。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Look through buffer cache for block on device dev.  </span><br><span class="hljs-comment">// If not found, allocate a buffer.  </span><br><span class="hljs-comment">// In either case, return locked buffer.  </span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> buf*  <br><span class="hljs-title function_">bget</span><span class="hljs-params">(uint dev, uint blockno)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span>  <br><br><br><span class="hljs-comment">// 多个线程访问Buffer Cache时，总是在外面等待</span><br>  acquire(&amp;bcache.lock);  <br>  <br>  <span class="hljs-comment">// Is the block already cached?  </span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;  <br>    <span class="hljs-keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;  <br>      b-&gt;refcnt++;  <br>      release(&amp;bcache.lock);  <br>      acquiresleep(&amp;b-&gt;lock);  <br>      <span class="hljs-keyword">return</span> b;  <br>    &#125;  <br>  &#125;  <br>  <br>  <span class="hljs-comment">// Not cached.  </span><br>  <span class="hljs-comment">// Recycle the least recently used (LRU) unused buffer.  </span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;  <br>    <span class="hljs-keyword">if</span>(b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;  <br>      b-&gt;dev = dev;  <br>      b-&gt;blockno = blockno;  <br>      b-&gt;valid = <span class="hljs-number">0</span>;  <br>      b-&gt;refcnt = <span class="hljs-number">1</span>;   <br>      release(&amp;bcache.lock);  <br>      <span class="hljs-comment">//此处会出现同步问题嘛？比如第二个线程在第一个循环抢先获得了睡眠锁，误认为缓存命中。</span><br>      <span class="hljs-comment">//答案是不会，因为refcnt为1，所以不用担心被释放；valid为0，即使从第一个循环返回，依然会被bread认为缓存未命中，进而去磁盘读取数据（完成了第一个线程原本想完成的任务）</span><br>      acquiresleep(&amp;b-&gt;lock);  <br>    <span class="hljs-comment">// 返回上锁的缓存块</span><br>      <span class="hljs-keyword">return</span> b;  <br>    &#125;  <br>  &#125;  <br>  panic(<span class="hljs-string">&quot;bget: no buffers&quot;</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>bget首先对bcache上锁（只要访问缓存就必须先上大锁），遍历整个bcache，结果分为两种情况：如果命中则引用数refcnt++然后释放大锁，返回带睡眠锁的buf；否则从LRU中找出第一个没有线程使用的块标记valid=0后，释放大锁（valid=0就不会被使用，refcnt!=0就不会释放），返回带睡眠锁的buf。</p><p>如果所有的槽位都满了则panic。一种优化方案是让相应的线程先挂起睡眠，直到Buffer Cache中有了空的槽位再将其唤醒</p><p>（3）bwrite刷新</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write b&#x27;s contents to disk.  Must be locked.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">bwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span>  <br>&#123;  <br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))  <br>    panic(<span class="hljs-string">&quot;bwrite&quot;</span>);  <br>  virtio_disk_rw(b, <span class="hljs-number">1</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><p>bwrite它首先保证持有该缓存块的睡眠锁，然后调用virtio_dist_rw将更新后的缓存块冲刷到磁盘的相应位置上</p><p>（4）brelse释放 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Release a locked buffer.  </span><br><span class="hljs-comment">// Move to the head of the most-recently-used list.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">brelse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span>  <br>&#123;  <br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))  <br>    panic(<span class="hljs-string">&quot;brelse&quot;</span>);  <br><br><span class="hljs-comment">//因为每次bread返回的buf都是带锁的，在上层进行使用时保证了buf不被修改，所以在使用完成后需要释放锁</span><br>  releasesleep(&amp;b-&gt;lock);  <br>  <br>  acquire(&amp;bcache.lock);  <br>  b-&gt;refcnt--;  <br>  <span class="hljs-keyword">if</span> (b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;  <br>    <span class="hljs-comment">// 如果refcnt不为0，说明该buf还会被使用，那就没必要在现在移动它的位置，算是一个小优化（或许可以叫懒移动？）</span><br>    b-&gt;next-&gt;prev = b-&gt;prev;  <br>    b-&gt;prev-&gt;next = b-&gt;next;  <br>    b-&gt;next = bcache.head.next;  <br>    b-&gt;prev = &amp;bcache.head;  <br>    bcache.head.next-&gt;prev = b;  <br>    bcache.head.next = b;  <br>  &#125;  <br>    <br>  release(&amp;bcache.lock);  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>每次引用（bget）时都会提高缓存块refcnt的值，所谓的brelse释放也就是在完成了读写操作后，让refcnt下降并维护LRU结构。</p><p>（5）其他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">bpin</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;  <br>  acquire(&amp;bcache.lock);  <br>  b-&gt;refcnt++;  <br>  release(&amp;bcache.lock);  <br>&#125;  <br>  <br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">bunpin</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span> &#123;  <br>  acquire(&amp;bcache.lock);  <br>  b-&gt;refcnt--;  <br>  release(&amp;bcache.lock);  <br>&#125;<br></code></pre></td></tr></table></figure><p>refcnt是很关键的变量，这两个函数用来保证要写入日志的缓存块不会被回收（在log层使用）</p><h4 id="小总结">小总结</h4><p>Buffer cache层主要做两件事： （1）同步所有对磁盘块的并发访问，尤其是保证，一个磁盘块要么没有被缓存，要么在内存中<strong>只有一份缓存副本</strong>，而且<strong>一次只有一个内核线程可以使用该副本</strong></p><p>（2）核心数据结构是bcache和buf，前者使用自旋锁保护，后者使用睡眠锁，bget和bread中加锁的顺序是重点</p><h2 id="logging">Logging</h2><p>buffer cache为线程提供了读写磁盘的功能，但这只是最基础的功能，如果崩溃或断电在这些写操作的中间发生，那么就会导致磁盘上的数据结构处于不一致的状态。例如在删除文件时，需要将文件长度设为0，并且释放它的数据块。此时，如果这些写磁盘操作被重新排序组织的话，那么在这期间发生的崩溃可能会导致inode指向一个已经标记为空闲的数据块</p><p>解决崩溃一致性的常见方案就是使用日志记录。在xv6的文件系统中，<strong>文件操作方面的系统调用并不会直接对磁盘进行写操作，而是把对磁盘写操作描述包装成一个日志写在磁盘中，当该系统调用执行完成之后，再提交一个记录到磁盘上</strong></p><p>数据日志协议的四部曲如下： - <strong>日志写入</strong>：将事务的内容（TxB，元数据块和数据块）写入日志，等待这些写入完成。 - <strong>日志提交</strong>：将事务提交块（包括TxE）写入日志，一旦完成，我们认为事务已经成功提交。 - <strong>加检查点</strong>：将日志中的事务（元数据和数据更新）写入磁盘的最终位置上。 - <strong>释放</strong>：一段时间后，更新日志超级块，将已完成加检查点的事务标记为空闲。</p><p>xv6的数据日志也遵循上述协议，按照上述逻辑工作。如果系统崩溃或断电，重启之后，在启动阶段，文件系统的恢复程序就会检查日志上是否有已被提交的完整事务。如果有，那么就重放它们，也就是将日志内容重新写到磁盘上的相应位置；如果没有，那么直接无视这部分日志，就好像什么也没发生过。最后，恢复程序总会清除日志</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">问题：为什么日志可以解决崩溃一致性问题？<br>答案：如果崩溃发生在提交之前，那么磁盘上的日志文件就不会被标记为已完成，恢复系统的代码就会忽视它，磁盘的状态就好像写操作从未进行一样。如果是在提交之后崩溃的，恢复程序会重演所有的写操作。在任何一种情况下，日志文件都使得磁盘操作对于系统崩溃来说是原子操作，在恢复之后，要么所有的写操作都完成，要么都失败<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Disk layout:  </span><br><span class="hljs-comment">// [ boot block | super block | log | inode blocks |  </span><br><span class="hljs-comment">//                                          free bit map | data blocks]  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">// mkfs computes the super block and builds an initial file system. The  </span><br><span class="hljs-comment">// super block describes the disk layout:  </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">superblock</span> &#123;</span>  <br>  uint magic;        <span class="hljs-comment">// Must be FSMAGIC  </span><br>  uint size;         <span class="hljs-comment">// Size of file system image (blocks)  </span><br>  uint nblocks;      <span class="hljs-comment">// Number of data blocks  数据块数量</span><br>  uint ninodes;      <span class="hljs-comment">// Number of inodes.  inode数量</span><br>  uint nlog;         <span class="hljs-comment">// Number of log blocks   日志块数量</span><br>  uint logstart;     <span class="hljs-comment">// Block number of first log block 第一个日志块的块号  </span><br>  uint inodestart;   <span class="hljs-comment">// Block number of first inode block  第一个inode节点所在块号</span><br>  uint bmapstart;    <span class="hljs-comment">// Block number of first free map block  第一个位图块块号</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>xv6的日志区域驻留在磁盘的一个固定位置上，并且在超级块中也有其位置记录。日志区在超级快后面，分为日志头（位于第一个日志块）和日志数据块</p><h4 id="数据结构-1">数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXOPBLOCKS  10  <span class="hljs-comment">// max # of blocks any FS op writes</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOGSIZE (MAXOPBLOCKS*3)  <span class="hljs-comment">// max data blocks in on-disk log</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">logheader</span> &#123;</span>     <span class="hljs-comment">//日志头部</span><br>  <span class="hljs-type">int</span> n;               <br>  <span class="hljs-type">int</span> block[LOGSIZE]; <br>&#125;;<br></code></pre></td></tr></table></figure><p>日志头用来记录每次日志的大小和位置关系信息，n用来记录每次日志使用的空间大小，日志空间的总大小记录在超级块中（单位是块），block建立了日志数据块和磁盘块的映射关系。例如<code>block[1] = 1024</code>表示日志块1记录的数据应该放到1024磁盘块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">log</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-type">int</span> start;    <span class="hljs-comment">//日志区第一块块号，初始化时从超级块中读取</span><br>  <span class="hljs-type">int</span> size;     <span class="hljs-comment">//日志区大小，初始化时从超级快读取</span><br>  <span class="hljs-type">int</span> outstanding; <span class="hljs-comment">// 有多少文件系统调用正在执行</span><br>  <span class="hljs-type">int</span> committing;  <span class="hljs-comment">// 正在提交</span><br>  <span class="hljs-type">int</span> dev;     <span class="hljs-comment">//设备，即主盘还是从盘，文件系统在从盘，初始化时从超级快读取</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">logheader</span> <span class="hljs-title">lh</span>;</span>   <span class="hljs-comment">//日志头</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">log</span> <span class="hljs-title">log</span>;</span><br></code></pre></td></tr></table></figure><p>log结构体只存在于内存，用来管理当前的日志，这是一个公共资源要避免竞争条件所以配了一把锁。从这里可以发现，xv6使用了一个log结构体来管理日志系统，和真实系统的日志系统相比，并发性不足。xv6一次只能处理一个事务，即在完成这次事务的提交之前，不能产生新的事务。</p><p>如果想要提高并发性能，可以将log中的logheader从一个变成数组，用类似bcache的方式来管理，这个过程涉及到很多并发访问的问题，要复杂很多。</p><h4 id="函数-1">函数</h4><p>（1）初始化initlog 与根据事务崩溃恢复 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// Init fs，在操作系统启动时调用</span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">fsinit</span><span class="hljs-params">(<span class="hljs-type">int</span> dev)</span> &#123;  <br>  readsb(dev, &amp;sb);  <br>  <span class="hljs-keyword">if</span>(sb.magic != FSMAGIC)  <br>    panic(<span class="hljs-string">&quot;invalid file system&quot;</span>);  <br>  initlog(dev, &amp;sb);  <br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">readsb</span><span class="hljs-params">(<span class="hljs-type">int</span> dev, <span class="hljs-keyword">struct</span> superblock *sb)</span>  <span class="hljs-comment">//读超级块</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  bp = bread(dev, <span class="hljs-number">1</span>);  <span class="hljs-comment">//读取超级块数据到缓存块</span><br>  memmove(sb, bp-&gt;data, <span class="hljs-keyword">sizeof</span>(*sb));  <span class="hljs-comment">//移动数据</span><br>  brelse(bp);   <span class="hljs-comment">//释放缓存块</span><br>&#125;<br><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">initlog</span><span class="hljs-params">(<span class="hljs-type">int</span> dev, <span class="hljs-keyword">struct</span> superblock *sb)</span>  <br>&#123;  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> logheader) &gt;= BSIZE)  <br>    panic(<span class="hljs-string">&quot;initlog: too big logheader&quot;</span>);  <br>  <br>  initlock(&amp;<span class="hljs-built_in">log</span>.lock, <span class="hljs-string">&quot;log&quot;</span>);  <br>  <span class="hljs-built_in">log</span>.start = sb-&gt;logstart;  <br>  <span class="hljs-built_in">log</span>.size = sb-&gt;nlog;  <br>  <span class="hljs-built_in">log</span>.dev = dev;  <br>  recover_from_log();  <br>&#125;<br><br><br></code></pre></td></tr></table></figure></p><p>初始化时从超级块中读出log块的信息，然后触发恢复操作</p><p>故障恢复recover_from_log <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <br><span class="hljs-title function_">recover_from_log</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  read_head();  <span class="hljs-comment">//读出logheader，如果没有需要恢复的块则n == 0</span><br>  install_trans(<span class="hljs-number">1</span>); <span class="hljs-comment">// n==0会直接跳出循环，否则将logged blocks写入到磁盘的相应位置</span><br>  <span class="hljs-built_in">log</span>.lh.n = <span class="hljs-number">0</span>;  <span class="hljs-comment">//恢复完成，设置值为0，如果此时断电再重启，由于log的值还没刷新到磁盘上去，所以仍然会执行install_trans，重复拷贝，这其实是一个可以优化的点</span><br>  write_head(); <span class="hljs-comment">// 清除旧日志</span><br>&#125;<br><br><span class="hljs-comment">// Read the log header from disk into the in-memory log header  </span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <br><span class="hljs-title function_">read_head</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">buf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.start);  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">logheader</span> *<span class="hljs-title">lh</span> =</span> (<span class="hljs-keyword">struct</span> logheader *) (buf-&gt;data);  <br>  <span class="hljs-type">int</span> i;  <br>  <span class="hljs-built_in">log</span>.lh.n = lh-&gt;n;  <br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">log</span>.lh.n; i++) &#123;  <br>    <span class="hljs-built_in">log</span>.lh.block[i] = lh-&gt;block[i];  <br>  &#125;  <br>  brelse(buf);  <br>&#125;<br><br><span class="hljs-comment">// Copy committed blocks from log to their home location  </span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <br><span class="hljs-title function_">install_trans</span><span class="hljs-params">(<span class="hljs-type">int</span> recovering)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> tail;  <br><br><span class="hljs-comment">//需要写入的n块都紧挨着logheader块（也就是最前面的块），所以按顺序一个个遍历并执行拷贝操作即可</span><br>  <span class="hljs-keyword">for</span> (tail = <span class="hljs-number">0</span>; tail &lt; <span class="hljs-built_in">log</span>.lh.n; tail++) &#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">lbuf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.start+tail+<span class="hljs-number">1</span>); <span class="hljs-comment">// read log block  </span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">dbuf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.lh.block[tail]); <span class="hljs-comment">// read dst  </span><br>    <span class="hljs-comment">//memmove(dst, src, n)，copy block to dst</span><br>    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);   <br>    bwrite(dbuf);  <span class="hljs-comment">// write dst to disk  </span><br>    <span class="hljs-keyword">if</span>(recovering == <span class="hljs-number">0</span>)  <br>      bunpin(dbuf);  <br>    brelse(lbuf);  <br>    brelse(dbuf);  <br>  &#125;  <br>&#125;<br><br><span class="hljs-comment">// Write in-memory log header to disk.  </span><br><span class="hljs-comment">// This is the true point at which the  </span><br><span class="hljs-comment">// current transaction commits.  </span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <br><span class="hljs-title function_">write_head</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">buf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.start);  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">logheader</span> *<span class="hljs-title">hb</span> =</span> (<span class="hljs-keyword">struct</span> logheader *) (buf-&gt;data);  <br>  <span class="hljs-type">int</span> i;  <br>  hb-&gt;n = <span class="hljs-built_in">log</span>.lh.n;  <br><span class="hljs-comment">// 更新每个log block对应的data block的块号，这一部分在系统恢复这一逻辑中是没啥用的，主要是在提交事务时有用，所以这里也有一个小的优化点</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">log</span>.lh.n; i++) &#123;  <br>    hb-&gt;block[i] = <span class="hljs-built_in">log</span>.lh.block[i];  <br>  &#125;  <br>  bwrite(buf);  <br>  <span class="hljs-comment">//到这里，整个恢复过程完成</span><br>  brelse(buf);  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>读出磁盘上的logheader，如果计数n=0，代表日志系统不需要进行恢复，因此跳过recovery继续启动；如果计数n不等于0，代表有需要重放的日志，因此我们回到数据日志四部曲中的加检查点，再次调用install_trans重新执行加检查点过程。最后在函数退出点，清除旧日志</p><p>我们接下来分别来看，这三个操作是怎么执行的： - read_head：使用下层提供的bread读取日志区第一个块的内容到缓存buf（这里放着head），然后将值绑定到log结构体重，并调用brelse释放buf。</p><ul><li><p>install_trans：需要写入的n块都紧挨着logheader块（也就是最前面的块），所以按顺序一个个遍历并执行拷贝操作即可，因为是拷贝过程，所以涉及到从日志块中读，往磁盘data块中写</p></li><li><p>write_head：日志写入完成，将更新后的logheader写回磁盘上</p></li></ul><p>（2）提交事务</p><p>提交事务就需要涉及到具体的应用场景了 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>begin_op(); <br><span class="hljs-comment">//... </span><br>bp = bread(...); <br>bp-&gt;data[...] = ...; <span class="hljs-comment">// modify bp-&gt;data[] </span><br>log_write(bp); <span class="hljs-comment">// bp has been modified, so put it in log </span><br>brelse(bp); <span class="hljs-comment">// release bp </span><br><span class="hljs-comment">// ... </span><br>end_op();<br><br></code></pre></td></tr></table></figure></p><p>begin_op、log_write和end_op是日志层提供给上层使用的接口，</p><p> 和 begin_op和 end_op 配套使用，表明文件系统调用的开始和结束（每次文件调用都需要使用） <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// called at the start of each FS system call.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">begin_op</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  acquire(&amp;<span class="hljs-built_in">log</span>.lock);  <br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;  <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>.committing)&#123;   <span class="hljs-comment">//如果有其他线程正在提交日志，则休眠</span><br>      sleep(&amp;<span class="hljs-built_in">log</span>, &amp;<span class="hljs-built_in">log</span>.lock);  <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>.lh.n + (<span class="hljs-built_in">log</span>.outstanding+<span class="hljs-number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;  <br>   <span class="hljs-comment">//如果此次文件系统调用涉及的块数超过日志块数上限，休眠</span><br>      sleep(&amp;<span class="hljs-built_in">log</span>, &amp;<span class="hljs-built_in">log</span>.lock);  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>      <span class="hljs-built_in">log</span>.outstanding += <span class="hljs-number">1</span>;  <br>      release(&amp;<span class="hljs-built_in">log</span>.lock);  <br>      <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>  &#125;  <br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>begin_op的目的就是保证事务提交的原子性，在一个线程提交事务时（committing会在commit操作前由end_op标记），其他线程是不允许干涉的，outstanding对于log结构体就像refcnt对于buf结构体，线程可以并发的发起对文件的修改，这些修改都会原子性的反应在log.lh上，只有当outstanding</p><p>在通过outstanding确保事务操作不会被打扰后，可以调用log_write执行写操作了。到了日志层，我们需要转换思想，不再使用buffer cache层中的bwrite，而是要使用log_write，它再log层对bwrite进行了封装，会检查写日志操作是否合法。 <figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">一个很好的想象方法时，<span class="hljs-built_in">buffer</span> cache层里只有buf，也就是一个缓存块，读取都是针对它的，但是在<span class="hljs-built_in">log</span>层，每次写操作都涉及到了<span class="hljs-built_in">log</span>块和buf，包含了两个步骤了，因此视角会高一些，多了一些检测合法性的操作，不能再单纯的调用bwrite了<br></code></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">log_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> i;  <br>  <br>  acquire(&amp;<span class="hljs-built_in">log</span>.lock);  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="hljs-built_in">log</span>.lh.n &gt;= <span class="hljs-built_in">log</span>.size - <span class="hljs-number">1</span>)  <br>    panic(<span class="hljs-string">&quot;too big a transaction&quot;</span>);  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>.outstanding &lt; <span class="hljs-number">1</span>)  <br>    panic(<span class="hljs-string">&quot;log_write outside of trans&quot;</span>);  <br>  <br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">log</span>.lh.n; i++) &#123;  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="hljs-comment">// log absorption  </span><br>      <span class="hljs-keyword">break</span>;  <br>  &#125;  <br>  <span class="hljs-built_in">log</span>.lh.block[i] = b-&gt;blockno;  <br>  <span class="hljs-keyword">if</span> (i == <span class="hljs-built_in">log</span>.lh.n) &#123;  <span class="hljs-comment">// Add new block to log?  </span><br>bpin(b);  <span class="hljs-comment">//将b的refcnt保证原子性的情况下加1，因为在log_write结束后会释放b，但此时只是讲b的修改记录在了logheader中，refcnt不为0可以保证b不会从LRU中移除。</span><br><span class="hljs-built_in">log</span>.lh.n++;  <br>  &#125;  <br>  release(&amp;<span class="hljs-built_in">log</span>.lock);  <br>&#125;<br></code></pre></td></tr></table></figure><p>log_write抛开大量的检查之外，其实主要内容就是维护了log.lh.block数组，建立了日志块和data块之间的映射关系。注意：此时log.lh还没有刷到日志块中，因此此时断电会认为写操作失败，什么事情都没有发生，保证了一致性。</p><p>在建立好了映射关系之后，就可以准备将它刷新到日志块上去 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// called at the end of each FS system call.  </span><br><span class="hljs-comment">// commits if this was the last outstanding operation.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">end_op</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> do_commit = <span class="hljs-number">0</span>;  <br>  <br>  acquire(&amp;<span class="hljs-built_in">log</span>.lock);  <br>  <span class="hljs-built_in">log</span>.outstanding -= <span class="hljs-number">1</span>;  <br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>.committing)  <br>    panic(<span class="hljs-string">&quot;log.committing&quot;</span>);  <br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">log</span>.outstanding == <span class="hljs-number">0</span>)&#123;  <br>    do_commit = <span class="hljs-number">1</span>;  <br>    <span class="hljs-built_in">log</span>.committing = <span class="hljs-number">1</span>;   <span class="hljs-comment">//开始提交事务，此时的log是不能被操作的</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-comment">// begin_op() may be waiting for log space,  </span><br>    <span class="hljs-comment">// and decrementing log.outstanding has decreased    // the amount of reserved space.    </span><br>    <span class="hljs-comment">// 如果当前还有其它FS调用正在执行，那么我们先不急着提交 </span><br>    <span class="hljs-comment">// 而是留给最后一个FS调用负责提交所有事务，这是group commit </span><br>    <span class="hljs-comment">// 此外，可能有其它FS调用在begin_op时因空间不足而被挂起 </span><br>    <span class="hljs-comment">// 现在可能有空间可用，唤醒一个被挂起的FS调用</span><br>    wakeup(&amp;<span class="hljs-built_in">log</span>);  <br>  &#125;  <br>  release(&amp;<span class="hljs-built_in">log</span>.lock);  <br>  <br>  <span class="hljs-keyword">if</span>(do_commit)&#123;  <br>    <span class="hljs-comment">// call commit w/o holding locks, since not allowed  </span><br>    <span class="hljs-comment">// to sleep with locks.    </span><br>    commit();  <br>    acquire(&amp;<span class="hljs-built_in">log</span>.lock);  <br>    <span class="hljs-built_in">log</span>.committing = <span class="hljs-number">0</span>;   <span class="hljs-comment">//提交完成</span><br>    wakeup(&amp;<span class="hljs-built_in">log</span>);  <br>    release(&amp;<span class="hljs-built_in">log</span>.lock);   <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>end_op的逻辑也很简单，除开提交事务（也就是刷新日志到日志块上这个过程）前的检测，就是调用了commit函数。<strong>注意：从代码可以看出，提交事务其实是group commit，因为当多个线程并发访问log，outstanding&gt;1，但并不是每个线程都要发起一次事务，如果察觉到还有其他线程在操作log（即outstanding != 0），则直接return，该线程进行的读写操作会由最后一个线程帮忙一起完成。</strong></p><p><strong>但是这样其实是有问题的，如果一直有线程访问log，那么会导致outstanding过很久也不为0，logheader也就迟迟不能刷新到磁盘中去，这样崩溃时虽然不会导致一致性问题，但会导致大量的既往操作被丢失，也是不合适，一个优化的方式是添加计时器，当达到一定计时条件时，不再允许outstanding的增加（即不再允许新的操作），然后等现有的操作执行完后commit。 </strong></p><p>（3）commit 还记得前面提到的日志四部曲嘛：日志写入，日志提交，加检查点，释放 让我们来看commit代码是怎么做的： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <br><span class="hljs-title function_">commit</span><span class="hljs-params">()</span>  <br>&#123;  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>.lh.n &gt; <span class="hljs-number">0</span>) &#123;  <br>    write_log();     <span class="hljs-comment">// 日志写入，负责将logheader里面的data数据搬运到log块中 </span><br>    write_head();    <span class="hljs-comment">// 日志提交，前面只提交data数据，这里提交log header,即第一个日志块   </span><br>    <br>    <span class="hljs-comment">// 更新的logheader成功写进磁盘后，代表事务提交成功 </span><br>    <span class="hljs-comment">// 因此从这里开始，到更新完成日志被清除之前， </span><br>    <span class="hljs-comment">// 如果发生了crash，那么恢复时就会重复log中的操作</span><br><br>    install_trans(<span class="hljs-number">0</span>); <span class="hljs-comment">// 加检查点，也就是执行从日志块到data块的搬运，在这里终于完成了真正的数据写入磁盘的操作，前面的部分都是在保证崩溃一致性</span><br>    <br>    <span class="hljs-built_in">log</span>.lh.n = <span class="hljs-number">0</span>;  <br>    write_head();    <span class="hljs-comment">// 释放，因为n已经被标记为0，所以日志区域中的块现在可以被重用。注意，我们应该等待这一步完成之后，才能回到end_op中，将commiting置0，表示日志系统提交完成并处于空闲。这个顺序很重要，先释放旧日志块再开始处理新事务，否则后续发生crash时，可能会使用前一个事务的日志块来恢复</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>首先是write_log日志写入： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy modified blocks from cache to log.  </span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <br><span class="hljs-title function_">write_log</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> tail;  <br>  <br>  <span class="hljs-keyword">for</span> (tail = <span class="hljs-number">0</span>; tail &lt; <span class="hljs-built_in">log</span>.lh.n; tail++) &#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">to</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.start+tail+<span class="hljs-number">1</span>); <span class="hljs-comment">// log block  </span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">from</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.lh.block[tail]); <span class="hljs-comment">// cache block  </span><br>    memmove(to-&gt;data, from-&gt;data, BSIZE); <br>    <span class="hljs-comment">// 从from复制到to，使用memmove后，现在两个缓存块副本都是更新后的状态</span><br><br>    bwrite(to);  <span class="hljs-comment">// write the log  </span><br>    brelse(from);  <br>    brelse(to);  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后是write_head日志提交，这个在崩溃恢复那里已经出现过了： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Write in-memory log header to disk.  </span><br><span class="hljs-comment">// This is the true point at which the  </span><br><span class="hljs-comment">// current transaction commits.  </span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <br><span class="hljs-title function_">write_head</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">buf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.start);  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">logheader</span> *<span class="hljs-title">hb</span> =</span> (<span class="hljs-keyword">struct</span> logheader *) (buf-&gt;data);  <br>  <span class="hljs-type">int</span> i;  <br>  hb-&gt;n = <span class="hljs-built_in">log</span>.lh.n;  <br><span class="hljs-comment">// 更新每个log block对应的data block的块号</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">log</span>.lh.n; i++) &#123;  <br>    hb-&gt;block[i] = <span class="hljs-built_in">log</span>.lh.block[i];  <br>  &#125;  <br><span class="hljs-comment">// 将更新后的logheader写回磁盘上</span><br><br>  bwrite(buf);  <span class="hljs-comment">//到一步完成，整个日志提交完成，不再害怕硬盘崩溃</span><br>  brelse(buf);  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>第三步是install_trans加检查点，也就是完成从日志块到数据块的搬运（想象一下磁盘的分布图）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy committed blocks from log to their home location  </span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <br><span class="hljs-title function_">install_trans</span><span class="hljs-params">(<span class="hljs-type">int</span> recovering)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> tail;  <br>  <br>  <span class="hljs-keyword">for</span> (tail = <span class="hljs-number">0</span>; tail &lt; <span class="hljs-built_in">log</span>.lh.n; tail++) &#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">lbuf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.start+tail+<span class="hljs-number">1</span>); <span class="hljs-comment">// read log block  </span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">dbuf</span> =</span> bread(<span class="hljs-built_in">log</span>.dev, <span class="hljs-built_in">log</span>.lh.block[tail]); <span class="hljs-comment">// read dst  </span><br>    <span class="hljs-comment">// 和write_log不同之处在于，写入磁盘时的目的地不同 </span><br>    <span class="hljs-comment">// write_log写入的是磁盘上的日志区域logged blocks， </span><br>    <span class="hljs-comment">// install_trans是读取logged blocks，写入data blocks</span><br>    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class="hljs-comment">// copy block to dst  </span><br>    bwrite(dbuf);  <span class="hljs-comment">// write dst to disk  </span><br><br>    <span class="hljs-comment">// 在log_write中bpin了相应的缓存块，这里bunpin它</span><br>    <span class="hljs-comment">// 因此在这之后，这一缓存块可以被Buffer Cache回收</span><br>    <span class="hljs-keyword">if</span>(recovering == <span class="hljs-number">0</span>)  <br>      bunpin(dbuf);  <br>    brelse(lbuf);  <br>    brelse(dbuf);  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>最后一步是释放日志快，同样是调用write_head，因为n已经被标记为0，所以日志区域中的块现在可以被重用。注意，我们应该等待这一步完成之后，才能回到end_op中，将commiting置0，表示日志系统提交完成并处于空闲。这个顺序很重要，先释放旧日志块再开始处理新事务，否则后续发生crash时，可能会使用前一个事务的日志块来恢复</p><h4 id="小总结-1">小总结</h4><p>log层的代码很多很复杂，而且有大量的合法性检测，但抛开表象往深处看： （1）这一层其实主要就是提供了崩溃一致性的服务，这个服务说大白话就是写入data数据块前，先写入到日志快，这样即使磁盘崩溃，要么可以恢复，要么可以当作没发生，保证了一致性。 （2）崩溃一致性服务涉及到的核心结构是log，它在操作系统中唯一存在，记录日志块的元数据（锁、所在设备、起始位置、块数量、并发访问数量、是否正在提交），包含了唯一的logheader，记录了日志块到data块的映射关系 （3）崩溃一致性服务可以按照步骤拆分为1+4，即准备过程 + 日志四部曲。 - 准备过程核心为三个函数：begin_op，log_write，end_op，负责建立logheader中的block映射关系并保证事务提交的原子性 - 日志四部曲为四个步骤：write_log（日志写入），write_head（日志提交），install_trans（加检查点），标记n=0（释放）。 （4）优化：group commit的机制可以降低事务提交的次数，防止过多的IO操作，但是仅使用outstanding的值作为判断提交的条件过于单一，可能导致长时间无法提交事务，可以引入时间来优化这一点。</p><h4 id="管理空闲的块">管理空闲的块</h4><p>前面只讲到了如何写入和读出一个块，但是没有讲当上层服务需要一个新磁盘块时应该怎么做。具体有两种方案： （1）空闲链表（×）；内存是使用空闲链表的方式管理的，每次需要空间就分配一个出去，但这种方法不适合磁盘，会导致空闲表过大或者链式结构过长（不适合处理大量的空闲数据） （2）位图法（√）；专门使用一个块来表示其他块的使用情况。一个 bit位表示一个磁盘块的使用情况，1 代表使用，0 代表空闲。</p><p>balloc从对应磁盘设备上分配一个块，涉及到了对位图的读写 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BSIZE 1024  <span class="hljs-comment">// block size</span></span><br><br><span class="hljs-comment">// 计算每个BLOCK可以包含多少个bitmap位</span><br><span class="hljs-comment">// BLOCK SIZE = 1024，所以一个BLOCK可以包含8192个bit</span><br><span class="hljs-comment">// 即BPB = 8192</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPB           (BSIZE*8)</span><br><br><span class="hljs-comment">// 给定block number b，b/BPB表示该块的bitmap位应该在哪个bitmap block上</span><br><span class="hljs-comment">// 再加上bitmap区域的起始位置，得到最终的bitmap block number</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BBLOCK(b, sb) ((b)/BPB + sb.bmapstart)</span><br><br><span class="hljs-comment">// Allocate a zeroed disk block.</span><br><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">balloc</span><span class="hljs-params">(uint dev)</span><br>&#123;<br>  <span class="hljs-type">int</span> b, bi, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  bp = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">//BPB表示一个bitmap块可以表示块的数量，这里的遍历范围很大，但其实真正的上限是bitmap块的数量</span><br>  <span class="hljs-keyword">for</span>(b = <span class="hljs-number">0</span>; b &lt; sb.size; b += BPB)&#123;<br>    <span class="hljs-comment">// 外层循环选中一个bitmap block</span><br>    <span class="hljs-comment">// 计算bitmap块号并读取到缓冲区，该块号表示块号b的状态（是否可用）</span><br>    bp = bread(dev, BBLOCK(b, sb));  <span class="hljs-comment">//bp表示的当前bitmap块的buf</span><br>    <span class="hljs-keyword">for</span>(bi = <span class="hljs-number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123;<br>      <span class="hljs-comment">// 内层循环一个个检查bitmap block里面的位</span><br>      m = <span class="hljs-number">1</span> &lt;&lt; (bi % <span class="hljs-number">8</span>);<br>      <span class="hljs-keyword">if</span>((bp-&gt;data[bi/<span class="hljs-number">8</span>] &amp; m) == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// Is block free?</span><br>        <span class="hljs-comment">// bi/8表示在1024个位置里面的第几个位置</span><br>        <span class="hljs-comment">// 如果空闲，将对应的磁盘块设为已分配</span><br>        bp-&gt;data[bi/<span class="hljs-number">8</span>] |= m;  <span class="hljs-comment">// Mark block in use.</span><br>        log_write(bp);  <span class="hljs-comment">//将修改后的位图刷回到磁盘</span><br>        brelse(bp);     <br>        bzero(dev, b + bi);  <span class="hljs-comment">// 清0新分配的磁盘块，防止旧内容或垃圾数据被使用</span><br><span class="hljs-comment">// balloc修改的是bitmap block的内容，返回的是新分配磁盘块的块号，前文别混淆了</span><br>        <span class="hljs-keyword">return</span> b + bi;<br>      &#125;<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  panic(<span class="hljs-string">&quot;balloc: out of blocks&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>总的来说，balloc做了两件事： - 双层遍历每个bitmap块的每个bit位，找到空闲的block设置为已分配 - 刷新磁盘上的bitmap块 - 返回新分配的磁盘块的块号</p><p>bfree的动作正好与balloc相反，这两个操作balloc和bfree应该在同一个事务中被调用 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Free a disk block.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">bfree</span><span class="hljs-params">(<span class="hljs-type">int</span> dev, uint b)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-type">int</span> bi, m;<br><br>  <span class="hljs-comment">// 同样地，这里也隐含了同步机制</span><br>  <span class="hljs-comment">// 给定block number b，返回所在的bitmap block number</span><br>  bp = bread(dev, BBLOCK(b, sb));<br>  <span class="hljs-comment">// 确定是bitmap里面的第几位</span><br>  <span class="hljs-comment">// 以下类似balloc</span><br>  <span class="hljs-comment">// 在bitmap中找到该块的对应位置，置0</span><br>  bi = b % BPB;<br>  m = <span class="hljs-number">1</span> &lt;&lt; (bi % <span class="hljs-number">8</span>);<br>  <span class="hljs-keyword">if</span>((bp-&gt;data[bi/<span class="hljs-number">8</span>] &amp; m) == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;freeing free block&quot;</span>);<br>  bp-&gt;data[bi/<span class="hljs-number">8</span>] &amp;= ~m;<br>  log_write(bp);<br>  brelse(bp);<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="总结">总结</h2><p>本章包含了文件系统中的buffer cache层和log层</p><p>buffer cache层主要提供磁盘并发访问的接口，利用磁盘块号，使得上层像直接操作磁盘一样操作在内存中的缓存，核心数据结构为一个bcache结构体和多个buf穿成链表构成的LRU，核心操作为bread，bget，bwrite</p><p>log层主要提供了崩溃一致性的服务，核心数据结构为一个log和它包含在内的logheader。核心操作为保证事务提交原子性的begin_op和end_op，建立日志块和数据块映射关系的log_write，负责完成数据刷盘操作的日志四部曲write_log，write_head，install_trans，标记n=0。</p><p><strong>这两层包含在一起为更上层提供了安全访问磁盘的API接口</strong></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book-Chapter7 进程调度</title>
    <link href="/2024/04/15/xv6-book-Chapter7-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <url>/2024/04/15/xv6-book-Chapter7-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter7-进程调度">Chapter7 进程调度</h1><p>操作系统的三大核心：虚拟化、并发、持久化。<strong>调度</strong>归属于CPU虚拟化。</p><p>整个调度的过程可以通过一张图来表示，当看不懂下文的内容时，不妨回来看看图</p><p><img src="Pasted%20image%2020240325152459.png"></p><h2 id="调度是什么在什么时候发生">调度是什么？在什么时候发生？</h2><p>调度的本质是CPU虚拟化，正如通过使用页表，每个进程有了自己拥有大量物理内存的假象，通过调度，每个进程也有了自己独占CPU的假象。</p><p>针对现代操作系统，在两种情况下会发生调度 （1）进程主动进入休眠，放弃CPU （2）CPU时间片</p><p>xv6中，每个进程都有内核态和用户态两种状态，进程结构体中维护了用户态页表和内核态页表，用户态页表的访问范围为0-3G的虚拟空间，而内核态页表具有所有虚拟空间的访问权。权限的控制是通过CPU特权等级实现的。</p><p>xv6的进程调度并非直接将进程的上下文替换，而是首先通过trap进入内核，从用户态切换到内核态，再从内核级线程跳转到CPU的<strong>调度线程scheduler</strong>，<strong>每个CPU都有一个调度线程，该线程的上下文保存再CPU的结构体中，在没有任何用户进程可运行时，这些CPU就运行各自的调度线程</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">问题：内核级线程和内核线程的区别？<br>答案：内核级线程表示用户进程<span class="hljs-built_in">trap</span>到内核态，有自己的页表，执行对应操作。内核线程只能由内核线程创建而来，它们的工作只会访问3-4g范围的虚拟空间，这些虚拟空间和物理地址是直接映射的，所以所有的内核线程公用一个页表（因此我们称之为内核线程而不是内核进程，因为没有自己独属的页表）<br></code></pre></td></tr></table></figure><p>所以调度的流程其实是 用户级线程A-&gt;内核级线程A -&gt;调度线程-&gt;内核级线程B -&gt; 用户级线程B。可以发现调度这个概念只存在于内核级线程之间，不存在直接将一个用户级线程切换为另一个用户级线程。</p><h4 id="线程主动休眠">线程主动休眠</h4><p>很多情况下我们要求线程主动休眠，例如睡眠锁。</p><p>这一点在xv6中是通过Sleep 和 Wakeup 两个系统调用实现的。它们的主要思想是 （1）一个进程可以调用sleep，将进程的工作状态从RUNNING 变为 SLEEPING自动放弃CPU的使用权，等待被唤醒 （2）当事件确实发生之后，另一个进程调用wakeup唤醒处于SLEEPING状态的进程。</p><p>sleep的代码位于kernel/proc.c，它将线程的运行状态标记为SLEEPING，然后调用sched让出CPU。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Atomically release lock and sleep on chan.  </span><br><span class="hljs-comment">// Reacquires lock when awakened.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan, <span class="hljs-keyword">struct</span> spinlock *lk)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>    <br>  <span class="hljs-comment">// Must acquire p-&gt;lock in order to  </span><br>  <span class="hljs-comment">// change p-&gt;state and then call sched.  // Once we hold p-&gt;lock, we can be  // guaranteed that we won&#x27;t miss any wakeup  // (wakeup locks p-&gt;lock),  // so it&#x27;s okay to release lk.  </span><br>  acquire(&amp;p-&gt;lock);  <span class="hljs-comment">//DOC: sleeplock1  </span><br>  release(lk);  <br>  <br>  <span class="hljs-comment">// Go to sleep.  </span><br>  p-&gt;chan = chan;  <br>  p-&gt;state = SLEEPING;  <br>  <br>  <span class="hljs-comment">//后文有更详细的描述</span><br>  sched();  <br>  <br>  <span class="hljs-comment">// Tidy up.  </span><br>  p-&gt;chan = <span class="hljs-number">0</span>;  <br>  <br>  <span class="hljs-comment">// Reacquire original lock.  </span><br>  release(&amp;p-&gt;lock);  <br>  acquire(lk);  <br>&#125;<br><br><span class="hljs-comment">//注意，平时在用户态让线程等待几秒用的sleep其实是下面的sys_sleep</span><br>uint64  <br><span class="hljs-title function_">sys_sleep</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> n;  <br>  uint ticks0;  <br>  <br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  acquire(&amp;tickslock);  <br>  ticks0 = ticks;  <br>  <span class="hljs-keyword">while</span>(ticks - ticks0 &lt; n)&#123;  <br>    <span class="hljs-keyword">if</span>(myproc()-&gt;killed)&#123;  <br>      release(&amp;tickslock);  <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;  <br>    sleep(&amp;ticks, &amp;tickslock);  <br>  &#125;  <br>  release(&amp;tickslock);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>wakeup则查找一个睡眠/等待在给定频道channel上的进程。然后将其状态设为RUNNABLE。这个channel可以很随意地设置，xv6则经常使用一些内核数据结构的地址来作为channel，以将所有与该数据结构相关的进程，都关联到同一个channel上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Wake up all processes sleeping on chan.  </span><br><span class="hljs-comment">// Must be called without any p-&gt;lock.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">wakeup</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>  <br>  <br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;  <br>    <span class="hljs-keyword">if</span>(p != myproc())&#123;  <br>      acquire(&amp;p-&gt;lock);  <br>      <span class="hljs-keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;  <br>        p-&gt;state = RUNNABLE;  <br>      &#125;  <br>      release(&amp;p-&gt;lock);  <br>    &#125;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="时间片调度">时间片调度</h4><p>计时器会定时给中断控制器传递时间中断信号，再由时间控制器告诉CPU发生了时间中断。 进程调度大多数情况下都发生在时钟中断，核心是yield()函数（kernel/proc.c）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// ...</span><br><br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    yield();<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Give up the CPU for one scheduling round.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  acquire(&amp;p-&gt;lock);<br>  p-&gt;state = RUNNABLE;<br>  sched();<br>  release(&amp;p-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>时间片调度比线程sleep要简单的多，单纯的获得锁然后修改进程状态为RUNNABLE状态，再释放锁并调用sche即可</p><h2 id="调度是如何执行的">调度是如何执行的？</h2><p>无论是哪种发生调度的情况，最后都是使用sched来完成具体的调度的操作。</p><p>在之前的步骤中，用户级线程已经切换为了内核级线程。</p><p>所以这一步是将内核级线程切换为调度线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// proc.c</span><br><span class="hljs-comment">// Switch to scheduler.  Must hold only p-&gt;lock</span><br><span class="hljs-comment">// and have changed proc-&gt;state. Saves and restores</span><br><span class="hljs-comment">// intena because intena is a property of this</span><br><span class="hljs-comment">// kernel thread, not this CPU. It should</span><br><span class="hljs-comment">// be proc-&gt;intena and proc-&gt;noff, but that would</span><br><span class="hljs-comment">// break in the few places where a lock is held but</span><br><span class="hljs-comment">// there&#x27;s no process.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">sched</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> intena;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span>(!holding(&amp;p-&gt;lock))<br>    panic(<span class="hljs-string">&quot;sched p-&gt;lock&quot;</span>);<br>  <span class="hljs-keyword">if</span>(mycpu()-&gt;noff != <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;sched locks&quot;</span>);<br>  <span class="hljs-keyword">if</span>(p-&gt;state == RUNNING)<br>    panic(<span class="hljs-string">&quot;sched running&quot;</span>);<br>  <span class="hljs-keyword">if</span>(intr_get())<br>    panic(<span class="hljs-string">&quot;sched interruptible&quot;</span>);<br><br>  intena = mycpu()-&gt;intena;<br>  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);<br>  mycpu()-&gt;intena = intena;<br>&#125;<br><br><span class="hljs-comment">// swtch.S</span><br>.globl swtch  <br>swtch:  <br>        sd ra, <span class="hljs-number">0</span>(a0)  <br>        sd sp, <span class="hljs-number">8</span>(a0)  <br>        sd s0, <span class="hljs-number">16</span>(a0)  <br>        sd s1, <span class="hljs-number">24</span>(a0)  <br>        sd s2, <span class="hljs-number">32</span>(a0)  <br>        sd s3, <span class="hljs-number">40</span>(a0)  <br>        sd s4, <span class="hljs-number">48</span>(a0)  <br>        sd s5, <span class="hljs-number">56</span>(a0)  <br>        sd s6, <span class="hljs-number">64</span>(a0)  <br>        sd s7, <span class="hljs-number">72</span>(a0)  <br>        sd s8, <span class="hljs-number">80</span>(a0)  <br>        sd s9, <span class="hljs-number">88</span>(a0)  <br>        sd s10, <span class="hljs-number">96</span>(a0)  <br>        sd s11, <span class="hljs-number">104</span>(a0)  <br>  <br>        ld ra, <span class="hljs-number">0</span>(a1)  <br>        ld sp, <span class="hljs-number">8</span>(a1)  <br>        ld s0, <span class="hljs-number">16</span>(a1)  <br>        ld s1, <span class="hljs-number">24</span>(a1)  <br>        ld s2, <span class="hljs-number">32</span>(a1)  <br>        ld s3, <span class="hljs-number">40</span>(a1)  <br>        ld s4, <span class="hljs-number">48</span>(a1)  <br>        ld s5, <span class="hljs-number">56</span>(a1)  <br>        ld s6, <span class="hljs-number">64</span>(a1)  <br>        ld s7, <span class="hljs-number">72</span>(a1)  <br>        ld s8, <span class="hljs-number">80</span>(a1)  <br>        ld s9, <span class="hljs-number">88</span>(a1)  <br>        ld s10, <span class="hljs-number">96</span>(a1)  <br>        ld s11, <span class="hljs-number">104</span>(a1)  <br>          <br>        ret<br></code></pre></td></tr></table></figure><p><strong>sched</strong>会坚持此时的线程是否持有其他锁，<strong>持有其它的锁然后放弃CPU是不允许的</strong>，即我们不能在调用swtch之前，持有除了p-&gt;lock以外的其它锁，通过swtch，切换到调度线程的调度器。</p><p>swtch接收两个参数，&amp;p-&gt;context, &amp;mycpu()-&gt;context，前者表示线程的上下文，后者表示cpu调度线程的上下文，在这段汇编代码中，寄存器（上下文）完成了前者的保存（从寄存器到context）和后者的加载（从context到寄存器）。</p><p>那么这个调度线程到底是在执行什么任务呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-CPU process scheduler.</span><br><span class="hljs-comment">// Each CPU calls scheduler() after setting itself up.</span><br><span class="hljs-comment">// Scheduler never returns.  It loops, doing:</span><br><span class="hljs-comment">//  - choose a process to run.</span><br><span class="hljs-comment">//  - swtch to start running that process.</span><br><span class="hljs-comment">//  - eventually that process transfers control</span><br><span class="hljs-comment">//    via swtch back to the scheduler.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">scheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();<br>  <br>  c-&gt;proc = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">// Avoid deadlock by ensuring that devices can interrupt.</span><br>    intr_on();<br>    <br>    <span class="hljs-type">int</span> found = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>      acquire(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE) &#123;<br>        <span class="hljs-comment">// Switch to chosen process.  It is the process&#x27;s job</span><br>        <span class="hljs-comment">// to release its lock and then reacquire it</span><br>        <span class="hljs-comment">// before jumping back to us.</span><br>        p-&gt;state = RUNNING;<br>        c-&gt;proc = p;<br>        swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br><br>        <span class="hljs-comment">// Process is done running for now.</span><br>        <span class="hljs-comment">// It should have changed its p-&gt;state before coming back.</span><br>        c-&gt;proc = <span class="hljs-number">0</span>;<br><br>        found = <span class="hljs-number">1</span>;<br>      &#125;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(found == <span class="hljs-number">0</span>) &#123;<br>      intr_on();<br>      <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;wfi&quot;</span>)</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在scheduler代码中，CPU从runnable状态的进程中找出一个执行。同样使用swtch进行上下文替换。其实可以发现，sched和scheduler表现为一对协同程序，一个内核线程的sched通过swtch切换到scheduler中，而scheduler又通过swtch切换回到另一个内核线程的sched中。</p><p>但是，这种协同并不是绝对的，有一个例外，就是<strong>进程刚被创建</strong>的时候，它的ra在<strong>allocproc</strong>中被设置为forkret，因此scheduler在调度执行一个新创建的进程时，会返回到forkret中，然后就从usertrapret直接返回到用户空间中。allocproc和forkret的相关部分代码如下所示。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">问题：在进程调度中，p-&gt;<span class="hljs-keyword">lock</span>的使用有什么讲究？<br>答案：p-&gt;<span class="hljs-keyword">lock</span>的一个作用就是，在整个调度过程完成之前，不能让其它的调度器调度执行旧的进程，因为它处于一种不稳定的中间态：我们在yield中标记了该进程为RUNNABLE，但是实际上我们还在执行该进程的内核线程，若此时其它<span class="hljs-meta">CPU</span>发现了它，并且调度执行它，那么就会有两个<span class="hljs-meta">CPU</span>在执行该进程，这是一个严重的错误。因此，通过一直持有p-&gt;<span class="hljs-keyword">lock</span>直到返回scheduler中，我们可以避免以上情况发生，因为就算其它<span class="hljs-meta">CPU</span>上的调度器发现该进程，即将调度执行它时，也会阻塞在acquire(p-&gt;<span class="hljs-keyword">lock</span>)上<br><br>注意：在<span class="hljs-meta">CPU</span>上下文切换时必须关闭中断，否则无法保证了调度的原子性。例如状态虽然为RUNNING，但是相关的寄存器还没有加载完全，然后时钟中断导致swtch时，将没有完成初始化的寄存器存进了context中，从而覆盖了该进程真正的寄存器值，这也是一个严重的错误<br></code></pre></td></tr></table></figure><h4 id="cpu结构体长啥样">CPU结构体长啥样？</h4><p>xv6为每个CPU维护一个<strong>struct cpu</strong>（kernel/proc.h）结构，如下所示。该结构包含了，CPU正在运行的进程的进程结构，CPU调度线程的上下文，以及用于管理中断的相关信息 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-CPU state.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">proc</span>;</span>          <span class="hljs-comment">// The process running on this cpu, or null.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>     <span class="hljs-comment">// swtch() here to enter scheduler().</span><br>  <span class="hljs-type">int</span> noff;                   <span class="hljs-comment">// Depth of push_off() nesting.</span><br>  <span class="hljs-type">int</span> intena;                 <span class="hljs-comment">// Were interrupts enabled before push_off()?</span><br>&#125;;<br></code></pre></td></tr></table></figure></p><p><strong>mycpu</strong>返回一个指向当前CPU的struct cpu的指针，索引的方法是通过每个CPU独有的<strong>hartid</strong>来查找。xv6将每个CPU的hartid存储在相应CPU的thread pointer，即<strong>tp</strong>寄存器中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return this CPU&#x27;s cpu struct.</span><br><span class="hljs-comment">// Interrupts must be disabled.</span><br><span class="hljs-keyword">struct</span> cpu*<br><span class="hljs-title function_">mycpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-type">int</span> id = cpuid();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> &amp;cpus[id];<br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-comment">// Must be called with interrupts disabled,</span><br><span class="hljs-comment">// to prevent race with process being moved</span><br><span class="hljs-comment">// to a different CPU.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">cpuid</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> id = r_tp();<br>  <span class="hljs-keyword">return</span> id;<br>&#125;<br></code></pre></td></tr></table></figure><p>tp寄存器的值是在系统启动的早期阶段，即在机器模式下设置好的。usertrapret将tp保存在trapframe中，因为在用户空间下tp可能会被修改；然后从用户空间再次陷入到内核时，uservec将之前保存的tp值恢复。如果能直接读取tp寄存器的值会更方便，但该操作只能在机器模式下发生。所以，在系统启动阶段，在机器模式下为我们设置好tp的值之后，我们就要小心地维护该值，确保有一个正确的副本</p><p>因为时钟中断随时可能发生，为了保证mycpu或者说cpuid返回的值是正确的，在调用mycpu并且使用该cpu值的时候，应该保持中断的关闭</p><p><strong>myproc</strong>则在mycpu的基础上，返回当前CPU正在运行进程的进程结构，可以看到，在获取进程结构时保持中断关闭。当取出进程结构之后就可以关闭中断，即使该进程运行在一个新的CPU上，c-&gt;proc也能正确地指向那一个进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return the current struct proc *, or zero if none.</span><br><span class="hljs-keyword">struct</span> proc*<br><span class="hljs-title function_">myproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  push_off();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> c-&gt;proc;<br>  pop_off();<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：在获取CPU id和当前进程时都需要关闭中断</p><h2 id="实际案例管道">实际案例：管道</h2><p>管道是一种linux常见的进程通信机制</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel">Linux 内核提供的常见的进程通信机制：<br>（<span class="hljs-number">1</span>）管道（也称作共享文件）<br>（<span class="hljs-number">2</span>）消息队列（也称作消息传递）<br>（<span class="hljs-number">3</span>）共享内存（也称作共享存储）<br>（<span class="hljs-number">4</span>）信号量和 <span class="hljs-built_in">PV</span> 操作<br>（<span class="hljs-number">5</span>）信号<br>（<span class="hljs-number">6</span>）套接字（Socket）<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//pipe.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PIPESIZE 512</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-type">char</span> data[PIPESIZE];<br>  uint nread;     <span class="hljs-comment">// number of bytes read</span><br>  uint nwrite;    <span class="hljs-comment">// number of bytes written</span><br>  <span class="hljs-type">int</span> readopen;   <span class="hljs-comment">// read fd is still open</span><br>  <span class="hljs-type">int</span> writeopen;  <span class="hljs-comment">// write fd is still open</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p>每个管道都由一个<strong>struct pipe</strong>（kernel/pipe.c）代表，包含了一把自旋锁，一个缓冲区data，对管道读写的字节数计数值，以及表示读写端打开的标志位。缓冲区是循环的，即data 索引PIPESIZE-1的下一个是data索引0，但是计数值不循环。从而当nwrite == nread+PIPESIZE时，缓冲区满；nwrite == nread时，缓冲区空。但因此，在索引缓冲区时，我们也需要用取模操作，如实际的索引为nread % PIPESIZE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">pipewrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe *pi, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">char</span> ch;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pr</span> =</span> myproc();<br><br>  acquire(&amp;pi-&gt;lock);<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-keyword">while</span>(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123;  <span class="hljs-comment">//DOC: pipewrite-full</span><br>      <span class="hljs-keyword">if</span>(pi-&gt;readopen == <span class="hljs-number">0</span> || pr-&gt;killed)&#123;<br>        release(&amp;pi-&gt;lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>      wakeup(&amp;pi-&gt;nread);<br>      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(copyin(pr-&gt;pagetable, &amp;ch, addr + i, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>    pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;<br>  &#125;<br><br>  wakeup(&amp;pi-&gt;nread);<br>  release(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>pipewrite</strong>开始时先获取管道的锁。在一个for循环中，往管道中写入数据，写够n个字节后，就唤醒nread频道上的piperead进程，然后跳出for循环，释放锁，并且顺利返回；如果在写入字节的过程中，缓冲区满了，那么就会陷入while循环，唤醒nread频道上的piperead进程，并且将自己挂起在nwrite频道上睡眠</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">piperead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe *pi, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pr</span> =</span> myproc();<br>  <span class="hljs-type">char</span> ch;<br><br>  acquire(&amp;pi-&gt;lock);<br><br>  <span class="hljs-keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="hljs-comment">//DOC: pipe-empty</span><br>    <span class="hljs-keyword">if</span>(pr-&gt;killed)&#123;<br>      release(&amp;pi-&gt;lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="hljs-comment">//DOC: piperead-sleep</span><br>  &#125;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;  <span class="hljs-comment">//DOC: piperead-copy</span><br>    <span class="hljs-keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)<br>      <span class="hljs-keyword">break</span>;<br>    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];<br>    <span class="hljs-keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  wakeup(&amp;pi-&gt;nwrite);  <span class="hljs-comment">//DOC: piperead-wakeup</span><br>  release(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>piperead</strong>，开始时同样先获取管道的锁，首先检查缓冲区是否为空，如果是，直接将自己挂起在nread频道上睡眠；否则，我们可以从缓冲区读出所有的字节（&lt;=n），最后唤醒nwrite频道上的pipewrite进程，释放锁，然后返回</p><p>考虑一种实际情况，假设不同的CPU并发地调用这两个函数。首先，pipewrite获取管道的锁pi-&gt;lock；piperead紧随其后，但是阻塞在入口处，等待锁被释放。pipewrite在循环中写入字节，直到缓冲区满了，然后调用wakeup，告知所有睡眠的piperead进程，现在缓冲区里有数据可读，然后自己调用sleep，释放pi-&gt;lock，等待piperead进程读出一些数据。</p><p>因为pi-&gt;lock现在可用，所以piperead现在获得pi-&gt;lock并进入临界区，检查缓冲区有数据可读，于是在循环中读出缓冲区里的数据，全部读出之后，调用wakeup，告知所有睡眠的pipewrite进程，现在缓冲区有空闲空间可以写入数据，然后自己释放pi-&gt;lock并退出。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab5 Copy-on-Write Fork</title>
    <link href="/2024/04/14/Lab5-Copy-on-Write-Fork/"/>
    <url>/2024/04/14/Lab5-Copy-on-Write-Fork/</url>
    
    <content type="html"><![CDATA[<p>写时复制的思想可以说遍布整个计算机世界，在xv6系统中，fork用来创建一个新进程，其中有一步是把父进程页表的内容都拷贝给子进程页表。</p><p>在不使用写时复制的思想时，每一次fork都需要给子进程分配物理内存。但是我们知道，在大多数情况下，fork只是用来创建一个子进程然后用exec去代替，在exec中也会创建页表用来加载目标程序的内容，然后替换掉原本子进程的页表。<strong>在这种情况下，fork时就给子进程分配物理内存没有任何意义。</strong></p><p>写时复制fork带来的好处在于： （1）创建进程更快 （2）避免无意义的物理内存分配</p><p>因此我们只需要在fork时，让子进程的虚拟地址映射到父进程的物理地址即可，不必真的给子进程分配物理内存然后从父进程对应位置进行拷贝。等到涉及到写操作时（无论是父进程还是子进程）再进行物理内存分配。</p><p><strong>写时复制（copy-on-write） 的目标是推迟为子进程分配和复制物理内存页，直到实际需要时再分配（因此大多数情况下，fork出来的子进程页表都被exec替换了，所以不需要分配）。</strong></p><p>那么这个实验应该如何进行呢？ （1）fork系统调用为子进程分配物理页是在uvmcopy函数中完成，所以要修改 uvmcopy（）以将父页面的物理页面映射到子页面，而不是分配新页面，并且修改PTE_W位，拒绝执行写操作 （2）由于存在多个进程映射到了同一个物理页，为了避免kfree释放内存时导致错误，需要记录每一个物理页的引用次数，初始化为0，kalloc时为1，每一次uvmcopy则+1，kfree则-1 （3）如果后续涉及到写操作会引发load page fault，中断号是15，在中断处理函数usertrap中完成内存分配 （4）由于在内核中进行内存访问时，虚拟内存和物理内存是直接映射，不经过mmu，因此对copyout函数需要特殊处理，如果copy的是一个拒绝写操作的页，则完成内存分配后再进行原有逻辑。</p><p><strong>整个实验过程涉及到的地方很多，我在完成实验时出现了两个比较大的错误，后文会讲出错原因，查错过程和经验总结。</strong></p><h2 id="第一步-修改uvmcopy">第一步 修改uvmcopy</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vm.c</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">uvmcopy</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> old, <span class="hljs-type">pagetable_t</span> new, uint64 sz)</span><br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  uint64 pa, i;<br>  uint flags;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: pte should exist&quot;</span>);<br>   <br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: page not present&quot;</span>);<br>    pa = PTE2PA(*pte);<br>    <br><span class="hljs-comment">//--------------------------------------------</span><br>    *pte &amp;= ~PTE_W;   <span class="hljs-comment">//取消PTE_W位，页不可写</span><br>    flags = PTE_FLAGS(*pte);<br><span class="hljs-comment">//     if((mem = kalloc()) == 0) //原本会对物理页进行分配，这里取消掉</span><br><span class="hljs-comment">//       goto err;</span><br><span class="hljs-comment">//     memmove(mem, (char*)pa, PGSIZE); </span><br>    <span class="hljs-comment">//------------------------------------------</span><br>    <span class="hljs-comment">//原本pa的位置为mem，现在直接使用父进程的物理地址pa</span><br>    <span class="hljs-keyword">if</span>(mappages(new, i, PGSIZE, pa, flags) != <span class="hljs-number">0</span>)&#123; <br>      <span class="hljs-keyword">goto</span> err;<br>    &#125;<br>    incrRC((<span class="hljs-type">void</span>*)pa);  <span class="hljs-comment">//这里是第二步的操作，在完成映射后，对应物理地址引用数+1</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> err:<br>  uvmunmap(new, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二步-添加引用数相关逻辑">第二步 添加引用数相关逻辑</h2><p>（1）创建引用计数数组，并初始化 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//kalloc.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA2INDEX(pa) (((uint64)pa)/PGSIZE)  <span class="hljs-comment">//根据物理地址，找到对应的下标</span></span><br><span class="hljs-type">int</span> mem_ref[PHYSTOP/PGSIZE]; <span class="hljs-comment">//用来对所有的页做引用计数，是共有变量所以需要上锁</span><br><br><span class="hljs-comment">//该函数会在kinit中调用，kinit会在操作系统初始化时调用</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa_start, <span class="hljs-type">void</span> *pa_end)</span>&#123;<br>  <span class="hljs-type">char</span> *p;<br>  p = (<span class="hljs-type">char</span>*)PGROUNDUP((uint64)pa_start);<br>  <span class="hljs-keyword">for</span>(; p + PGSIZE &lt;= (<span class="hljs-type">char</span>*)pa_end; p += PGSIZE) &#123;<br>    mem_ref[PA2INDEX(p)] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化的时候把每个物理页都初始化为1，因为free时会释放1，这样最终的引用数都为0</span><br>    kfree(p);<br>  &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure></p><p>（2）在分配时将计数器+1 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br><span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  acquire(&amp;kmem.lock);<br>  r = kmem.freelist;<br>  <span class="hljs-keyword">if</span>(r)<br>    kmem.freelist = r-&gt;next;<br>  release(&amp;kmem.lock);<br><br>  <span class="hljs-keyword">if</span>(r)&#123;<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br><br>    <span class="hljs-comment">//lab cow ---------------------</span><br>    <span class="hljs-keyword">if</span> (getRC((<span class="hljs-type">void</span>*)r) != <span class="hljs-number">0</span>) &#123;<br>      panic(<span class="hljs-string">&quot;kalloc: cowcount[idx] != 0&quot;</span>);<br>    &#125;<br>    incrRC((<span class="hljs-type">void</span>*)r); <span class="hljs-comment">// 新allocate的物理页的计数器为1</span><br>    <span class="hljs-comment">//lab cow ---------------------</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)r;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>（3）释放时将引用计数-1，如果归0则释放 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  <span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br>    <br>   <span class="hljs-comment">//lab cow -----------------------------------------</span><br>  acquire(&amp;kmem.lock);<br>  <span class="hljs-type">int</span> remain = --mem_ref[(uint64)pa/PGSIZE];<br>  release(&amp;kmem.lock);<br><br>  <span class="hljs-keyword">if</span> (remain &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">//lab cow-------------------------------------------</span><br>  <br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br>  r = (<span class="hljs-keyword">struct</span> run*)pa;<br>  acquire(&amp;kmem.lock);<br>  r-&gt;next = kmem.freelist;<br>  kmem.freelist = r;<br>  release(&amp;kmem.lock);<br>&#125;<br></code></pre></td></tr></table></figure></p><p>（4）获取引用数和增加引用数 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">getRC</span><span class="hljs-params">(<span class="hljs-type">void</span>* pa)</span>&#123;<br>  acquire(&amp;kmem.lock);<br>  <span class="hljs-type">int</span> num = mem_ref[(uint64)pa/PGSIZE];<br>  release(&amp;kmem.lock);<br>  <span class="hljs-keyword">return</span> num;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">incrRC</span><span class="hljs-params">(<span class="hljs-type">void</span>* pa)</span>&#123;<br>    acquire(&amp;kmem.lock);<br>    <span class="hljs-type">int</span> idx = ++mem_ref[(uint64)pa/PGSIZE]; <span class="hljs-comment">//增加引用数</span><br>    release(&amp;kmem.lock);<br>    <span class="hljs-keyword">return</span> idx;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="第三步-在usertrap中完成内存分配">第三步 在usertrap中完成内存分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//trap.c</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-comment">//.......</span><br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;<br>    <span class="hljs-comment">// system call</span><br>    <span class="hljs-keyword">if</span>(p-&gt;killed)<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// sepc points to the ecall instruction,</span><br>    <span class="hljs-comment">// but we want to return to the next instruction.</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,</span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.</span><br>    intr_on();<br>    syscall();<br>   <span class="hljs-comment">//lab cow ------------------------------------</span><br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">15</span>)&#123; <span class="hljs-comment">//15表示load page fault</span><br>  <span class="hljs-comment">//r_stval会保存发生缺页中断时的虚拟地址</span><br>      <span class="hljs-keyword">if</span>(cowalloc(p-&gt;pagetable, r_stval()) &lt; <span class="hljs-number">0</span>)&#123;<br>        p-&gt;killed = <span class="hljs-number">1</span>;<br>      &#125;<br>  &#125;<br>  <span class="hljs-comment">//lab cow ------------------------------------</span><br> <br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>    p-&gt;killed = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">//.......</span><br>  <span class="hljs-keyword">if</span>(p-&gt;killed)<br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要自己实现cowalloc <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">  <br><span class="hljs-comment">//vm.c</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">cowalloc</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va)</span> &#123;<br>  <span class="hljs-keyword">if</span> (va &gt;= MAXVA) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cowalloc: exceeds MAXVA\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-type">pte_t</span>* pte = walk(pagetable, va, <span class="hljs-number">0</span>); <span class="hljs-comment">// should refer to a shared PA</span><br>  <span class="hljs-keyword">if</span> ((*pte &amp; PTE_V) == <span class="hljs-number">0</span> || (*pte &amp; PTE_U) == <span class="hljs-number">0</span>) &#123;<br>    panic(<span class="hljs-string">&quot;cowalloc: pte permission err&quot;</span>);<br>  &#125;<br>  uint64 pa = PTE2PA(*pte);<br>  <span class="hljs-keyword">if</span> (getRC((<span class="hljs-type">void</span>*)pa) == <span class="hljs-number">1</span>)&#123;<br>    *pte |= PTE_W;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  uint64 new = (uint64)kalloc();<br>  <span class="hljs-keyword">if</span> (new == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cowalloc: kalloc fails\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  memmove((<span class="hljs-type">void</span> *)new, (<span class="hljs-type">const</span> <span class="hljs-type">void</span> *)pa, PGSIZE);<br>  kfree((<span class="hljs-type">void</span> *)pa);<br>  *pte = PA2PTE(new) | PTE_FLAGS(*pte) | PTE_W;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>大概的逻辑就是：差错检测，walk寻找物理页pa和对应的pte，查找该pa的引用数，如果为1，说明不需要额外分配内存，直接重置PTE_W，即可返回。</p><p>如果不为1，则说明需要分配物理内存，然后将pa的值copy到new中，用新分配的内存new来代替原本的pa，由于pa对应的一份引用已经copy走了，所以引用数减一，通过kfree实现（可以理解为原本的进程有了新物理地址，原来的这一块地盘可以释放了）</p><p>新的物理页对应的pte也需要重置PTE_W位</p><h2 id="第四步-copyout特殊处理">第四步 copyout特殊处理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vm.c</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">copyout</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 dstva, <span class="hljs-type">char</span> *src, uint64 len)</span><br>&#123;<br>   uint64 n, va0, pa0;<br>  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>)&#123;<br>    va0 = PGROUNDDOWN(dstva);<br>    <br> <span class="hljs-comment">//lab cow-------------------------------------------，和</span><br>    <span class="hljs-type">pte_t</span> *pte = walk(pagetable, va0, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> ((*pte &amp; PTE_W) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 写的目的地是COW共享页, 需要复制一份</span><br>      <span class="hljs-keyword">if</span> (cowalloc(pagetable, va0) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//lab cow-------------------------------------------</span><br>    <br>    pa0 = walkaddr(pagetable, va0);<br>    <span class="hljs-keyword">if</span>(pa0 == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    n = PGSIZE - (dstva - va0);<br>    <span class="hljs-keyword">if</span>(n &gt; len)<br>      n = len;<br>    memmove((<span class="hljs-type">void</span> *)(pa0 + (dstva - va0)), src, n);<br>    len -= n;<br>    src += n;<br>    dstva = va0 + PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理过程和usertrap差不多，找到pte，检查是否为不可写，如果是则调用cowalloc分配物理内存。</p><h2 id="结果">结果</h2><p>cowtest结果</p><p><img src="Pasted%20image%2020240414193839.png"></p><h2 id="错误和总结">错误和总结</h2><h3 id="第一个错误">第一个错误</h3><p>本次实验出了两次比较大的错误，第一次是在kalloc的逻辑中： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//kalloc错误代码</span><br><span class="hljs-keyword">if</span>(r)&#123;<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br><br>    <span class="hljs-comment">//lab cow ---------------------</span><br>    <span class="hljs-keyword">if</span> (mem_ref[PA2INDEX(r)] != <span class="hljs-number">0</span>) &#123;<br>      panic(<span class="hljs-string">&quot;kalloc: cowcount[idx] != 0&quot;</span>);<br>    &#125;<br>    mem_ref[PA2INDEX(pa)] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 新allocate的物理页的计数器为1</span><br>    <span class="hljs-comment">//lab cow ---------------------</span><br> &#125;<br></code></pre></td></tr></table></figure></p><p>原本getRC的逻辑是写的<code>mem_ref[PA2INDEX(pa)]</code>，通过数组直接获取引用值，对读操作没有上锁，incrRC 则是<code>mem_ref[PA2INDEX(pa)] = 1</code></p><p>结果在初始化为每个进程分配内核栈的时候调用kalloc报错<code>kalloc: cowcount[idx] != 0</code></p><p>百思不得其解，因为操作系统初始化时其他CPU都需要等待，只有一个CPU完成主要功能，在各个地方调用printf函数查错，最后发现错误的地方就是上面的代码。</p><p><strong>单CPU + 代码顺序正确 ≠ 不会发生并发问题</strong></p><p>CPU存在乱序执行 + 编译器可能进行代码优化导致我在if语句判断的时候出错了，<strong>赋值为1 的语句实际上运行在了 if 语句的前面，导致panic报错。</strong></p><h3 id="第二个错误">第二个错误</h3><p>第二个错误是在kfree中 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//错误的代码</span><br>  <span class="hljs-keyword">if</span> (remain &gt; <span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></p><p>心里想的和敲得代码不一样，这里应该是引用数为0则释放的逻辑，结果另一个地方是引用数为1的逻辑，结果敲代码的时候写串了。</p><p>这个错误导致了在shell指令（或其他命令）时可以正常执行，但是之后会报多个错误，</p><p><img src="Pasted%20image%2020240414193230.png"></p><p>init进程是操作系统执行的第一个进程，除了用来启动0、1、2三个文件描述符，还会fork出 shell 控制台，处理僵尸进程。它应该会一直运行才对。</p><p>而且因为操作系统可以正常开启到 sh 界面，因此让我误以为kalloc.c文件夹下的文件没有问题，在其他地方找了好久，最后才发现是因为kfree时的逻辑错了，如果引用数大于1才跳过，则 shell 在fork出第一个子进程例如cowtest处理之后，会调用kfree，将引用数从2变成1，结果达到了kfree的要求，被迫释放，引发连锁反应，最初的的进程init释放导致panic</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四大NoSQL数据库</title>
    <link href="/2024/04/12/%E5%9B%9B%E5%A4%A7NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2024/04/12/%E5%9B%9B%E5%A4%A7NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>通常，NoSQL数据库具有以下几个特点：</p><ol type="1"><li>灵活的可扩展性。</li><li>灵活的数据模型</li><li>与云计算紧密融合。</li></ol><h1 id="nosql兴起的原因">NoSQL兴起的原因</h1><p>https://cshihong.github.io/2018/05/19/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/</p><h4 id="原因一关系型数据库已经无法满足web2.0的需求">原因一：关系型数据库已经无法满足Web2.0的需求</h4><p>关系型数据库无法满足Web2.0的需求，主要表现在以下几个方面：</p><ol type="1"><li>无法满足海量数据的管理需求。</li><li>无法满足数据高并发的需求。</li><li>无法满足高可扩展性和高可用性的需求。</li></ol><p>在现在<strong>1分钟</strong>的时间内： - 新浪可以发送2万条微博。 - 苹果可以下载4.7万次应用。 - 淘宝可以卖出6万件商品。 - 人人网可以发送30万次访问。 - 百度可以产生90万次搜索查询。</p><h4 id="原因二关系型数据库的关键特性">原因二：关系型数据库的关键特性：</h4><p>关系数据库的关键特性包括完善的<strong>事务机制</strong>和<strong>高效的查询机制</strong>。但是，关系数据库引以为傲的两个关键特性，到了Web2.0时代却成了鸡肋，主要表现在以下几个方面：</p><ol type="1"><li>Web2.0网站系统通常不要求严格的数据库事务。</li><li>Web2.0并不要求严格的读写实时性。</li><li>Web2.0通常不包含大量复杂的SQL查询（去结构化，存储空间换取更好的查询性能）。</li></ol><h2 id="kv键值对">KV键值对</h2><p>redis</p><h2 id="文档数据库">文档数据库</h2><p>mongoDB</p><h2 id="列存储数据库">列存储数据库</h2><p>Hbase</p><h2 id="图关系数据库">图关系数据库</h2><p>存储的是关系，例如广告推荐，社交网络</p><p>Neo4j，infoGrid</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发基础（锁的根源）</title>
    <link href="/2024/04/12/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%88%E9%94%81%E7%9A%84%E6%A0%B9%E6%BA%90%EF%BC%89/"/>
    <url>/2024/04/12/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%88%E9%94%81%E7%9A%84%E6%A0%B9%E6%BA%90%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>并发的三要素是：原子性、可见性、有序性。在Linux内核当中产生访问的并发源主要有：中断和异常、内核抢占、多处理器并发执行、软中断和tasklet</p><p>虽然单个CPU也存在并发的概念，但是往往我们提到锁等专用语时涉及到的问题，根源都来自多CPU系统，<strong>多CPU的缓存一致性问题是绝大多数并发问题的根源</strong></p><p>本文的主要目的是以CPU缓存的一致性问题为例子，引出并发问题的常见解决方案。</p><p>我们都知道CPU为了提高利用率使用了缓存，然而多CPU的情况下，这些缓存的一致性如何保证呢？</p><p>导致缓存一致性问题的核心主要是两个问题：</p><p>（1）<strong>可见性问题</strong>：在一个CPU修改了内存数据的时候，其它CPU是不知道的，所以导致一个CPU改了，另外一个CPU看不见</p><p>（2） <strong>有序性问题</strong>：在多个CPU同时读取和修改CPU的时候，如何保证这几个CPU操作的顺序性，一旦不能保证整个修改操作的顺序，那么就可能导致先写后读的两个请求，结果反映到内存就成了先读后写的结果，从而没有读取到最新的数据，又或者两个写数据的请求顺序被调换了，那么就可能会造成脏写</p><h2 id="基于总线的一致性解决方案">基于总线的一致性解决方案</h2><p>CPU要和存储设备进行交互，必须要通过总线设备，在获取到总线控制权后才能启动数据信息的传输，而CPU要想从主存读写数据，那么就必须向总线发起一个总线事务（读事务或写事务）来从主存读取或者写入数据</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">总线事务：从请求总线到完成总线使用的操作序列称为总线事务，它是在一个总线周期中发生的一系列活动<br></code></pre></td></tr></table></figure><p>既然所有CPU对内存的操作都需要依赖总线，那在修改共享变量时让总线通知其他CPU不能使用该变量不就可以了嘛？这样的操作叫总线嗅探</p><h4 id="总线嗅探">总线嗅探</h4><p>缓存一致性的<strong>可见性问题</strong>在于：多CPU缓存的情况下，一个CPU修改了主存的共享变量，其它CPU是不知道的，所以解决这个问题最直接的办法就是在每次修改时都通知其他CPU。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">写传播：一个处理器对一个位置的所写入的值，最终对其它处理器是可见的<br></code></pre></td></tr></table></figure><p>当一个CPU修改了主存的数据时，其它CPU都会收到相应的数据变更通知，收到通知的CPU如果发现自己也缓存了对应的数据，那么就会将自己缓存的数据所在缓存行标记为失效，当下次读取该数据时发现自己的缓存行已过期，那么就会选择从主存加载最新的数据。 而实现这个功能的机制就叫“总线嗅探”</p><p>总线嗅探是通过CPU侦听总线上发生的数据交换操作，当总线上发生了数据操作，那么总线就会广播对应的通知，其他CPU收到通知就将对应的缓存标记为失效</p><h4 id="总线仲裁">总线仲裁</h4><p>总线嗅探只能保证被一个CPU修改的数据会通知到其他CPU。但如果其他CPU在收到该通知之前就使用了这个数据怎么办？这就是缓存一致性的第二个问题：<strong>有序性问题</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">写串行化：对同一内存单元的所有写操作（无论是来自一个处理器还是多个处理器）都能串行化。换句话说，所有的处理器能以相同的次序看到这些写操作<br></code></pre></td></tr></table></figure><p>解决有序性最简单粗暴的方式就是加锁，当一个CPU对操作的资源加了锁，那么其它CPU就只能等待，只有等前一个释放了锁（资源占用权），后面的才能获得执行权，从而保证整体操作的顺序性</p><p>在CPU缓存中实现这一操作的功能叫<strong>总线仲裁</strong>。在多个申请者同时提出总线请求时，以一定的优先算法仲裁哪个应获得对总线的使用权。</p><p>在总线嗅探机制下，其他CPU知道了缓存脏了，要去内存读取，然而原CPU的写操作还没完成，此时总线仲裁保证了<strong>事务串行化</strong>，所以总线被&quot;锁住&quot;，其他CPU没办法去内存读取，除非写操作完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">问题：总线仲裁的方式有哪些？<br>（<span class="hljs-number">1</span>）链式查询方式：优先级固定，部件离总线控制器越近，其优先级越高（可能导致饥饿）<br>链式查询方式是指总线上所有的部件共用一根总线请求线，当有部件请求使用总线时，需经此线发总线请求信号到总线控制器。由总线控制器检查总线是否忙，若总线不忙，则立即发总线响应信号，经总线响应线串行地从一个部件传送到下一个部件，依次查询。若响应信号到达的部件有总线请求，刚信号被截住，不再传下去。<br>（<span class="hljs-number">2</span>）独立请求方式<br>独立请求方式是指每个设备均有一对总线请求线和总线允许线。当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在总线控制器中排队，当总线控制器按一定的优先次序决定批准某个部件的请求时，给该部件发送总线响应信号，该部件接到此信号后就获得了总线使用权，开始传送数据<br></code></pre></td></tr></table></figure><h4 id="现有方案缺点">现有方案缺点</h4><p>（1）总线负载：总线嗅探机制要求CPU 修改数据时不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，而其他的CPU也必须接收这个事件。这无疑会加重总线的负载 （2）性能瓶颈：总线仲裁本质是粗粒度的锁。为了保证数据的正确性，发生在总线上的事务操作必须是排它顺序执行的，这也就造成了只要一个CPU占用了总线，那么其它的CPU就无法与主存进行通讯而只能等待前一个执行完成，总线资源的这种独占性我们也常称为总线锁，而基于总线加锁的波及范围太大，所以存在很大的性能问题</p><p>顺带一提：缺点（2）中的情况在很多地方都能见到。例如xv6中CPU使用kalloc()分配内存时，多个CPU需要抢夺一把锁导致性能瓶颈。一种常见的解决方案是将粗粒度的锁变为细粒度的问题，例如kalloc维护了一个大的空闲链表，修改链表需要上锁，这就是一个粗粒度问题。如果为每个CPU都维护一个空闲链表，链表元素不够时再去其他CPU那里抢夺，这样一个粗粒度的大锁就变成了细粒度的小锁。</p><h2 id="第一次优化mesi协议">第一次优化：MESI协议</h2><p>总线性能瓶颈在于基于在总线与主存打交道会造成阻塞，那么反过来想如果不通过总线与内存发生数据交互就可以避免总线加锁。<strong>所以优化的核心在于如何减少与主存的交互</strong></p><p>至于如何减少CPU通过主线和主存打交道的次数，这里可以分为两个方向， （1）减少读频率：<strong>减少从主存读取数据的频率</strong> （2）减少写频率：<strong>减少修改数据后而把数据同步到主存的频率</strong>。</p><h4 id="减少从主存读取数据频率减少读频率">减少从主存读取数据频率（减少读频率）</h4><p>如果CPU读取一个自己缓存没有的数据时，不是直接通过总线向主存读取，而是优先从其它已经缓存了对应数据的CPU缓存获取。</p><p>当一个CPU读取数据时，首先从自己的缓存里面读取对应的缓存行，如果此时自己的缓存里面没有，那么它会向总线发起一个读取事务， 此时其它CPU会收到一个来自总线读取的消息，如果其它CPU的缓存有持有对应缓存行的数据时，它会把缓存行的地址放到总线上， 那么读取数据的CPU只需要通过地址拷贝对应的缓存行到自己的CPU缓存即可</p><h4 id="减少同步数据到主存的频率减少写频率">减少同步数据到主存的频率（减少写频率）</h4><p>如果当前数据只有自己一个人缓存了，那么就不存在多个CPU缓存的一致性问题， 所以无论当前CPU修改多少次当前缓存行的值，也不会影响到其他人，所以这种情况下的数据变更可以不必马上同步到主存去（例如循环中不断重复的i++操作，就没必要立刻同步到内存），只有在其他CPU也需要读取对应的数据时候，那么此时数据就会由一个人独占变成共享了，可以这个时候再把数据同步到主存去</p><h4 id="mesi-协议">MESI 协议</h4><p>减少和内存的交互是优化的核心理念。MESI协议是具体的实现方案。</p><p>由于CPU之间没办法直接通信，所以它们之间就必须商定一套机制来确保<strong>通过自己的数据状态就能知道其他CPU的缓存情况</strong>，<strong>从而做出对应的策略，而这套机制就是缓存一致性协议</strong>。</p><p>MESI是一套比较出名的缓存一致性协议，它用4个状态来标记 Cache Line： - Modified，已修改</p><ul><li><p>Exclusive，独占</p></li><li><p>Shared，共享</p></li><li><p>Invalidated，已失效</p></li></ul><p>「已修改」状态就是脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。而「已失效」状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。</p><p>「独占」和「共享」状态都代表 Cache Block 里的数据是干净的，也就是说，这个时候 Cache Block 里的数据和内存里面的数据是一致性的。区别在于「独占」时做修改不需要通知其他CPU。</p><p>在「独占」状态下的数据，如果有其他核心从内存读取了相同的数据到各自的 Cache ，就会变成「共享」状态。</p><p>「共享」状态代表着相同的数据在多个 CPU 核心的 Cache 里都有，所以更新时要先向其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。</p><p><img src="Pasted%20image%2020240312161800.png"></p><p><img src="Pasted%20image%2020240324154030.png"></p><h4 id="mesi协议的缺点">MESI协议的缺点</h4><p>在共享状态下，因为一个缓存行的数据在多个 CPU 核心的 Cache 里都有。所以，当我们想要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 广播一个请求，要求先把其他 CPU 里面的 缓存行都变成无效的状态，等其他CPU都响应对于invalid 操作的ACK 后，修改数据的CPU才能更新当前 Cache 里面的数据，这个广播操作就是缓存锁，一般叫作 RFO（Request For Ownership），也就是获取当前对应 Cache Block 数据的所有权。</p><p>简单来说：处于共享状态下的数据不能直接修改，得先通知其他CPU使缓存失效并受到ack确认。</p><p>这一看就是同步操作，在收到ack之前，CPU只能空等浪费时间。所以仍然需要优化。</p><h2 id="第二次优化mesi性能优化">第二次优化：MESI性能优化</h2><p>MESI的性能瓶颈在于修改共享状态的数据时需要发送invalid命令，并且等待ack，这个过程会导致CPU阻塞。</p><p>在这个问题上也有两种优化角度： （1）在CPU等待其他CPU 回复的过程中可以去干一些其它的事情 （2）缩短ack响应的时间。让其他CPU回复ack的时间快一点</p><h4 id="store-buffer">Store Buffer</h4><p>Store Buffer相当于给CPU的一个额外缓存区，CPU广播了修改共享状态数据的通知之后，不再傻等着其它CPU回复了，而是把广播invalid指令发出去以后，然后直接把要修改的数据放到 Store Bufferes里，然后就去干其它事情了，当等到其他CPU都响应了ACK之后，然后再回头从Store Bufferes读取出来执行最后的数据修改操作。</p><p>这样在当前CPU的角度，数据已经被修改了，只是还没有更新到L1 Cache中</p><p>但这样就涉及到一个问题，当CPU去执行其他操作时可能会遇到读取L1 Cache中的已修改但仍然标记为 share 的数据（此时还没等到其他CPU的ack）时会出现错误。</p><p>所以这就需要<strong>Store Forward(存储转发)</strong> 操作：要求CPU读取数据时得先看Store Buferes里面有没有，如果有则直接读取Store Buferes里的值，如果没有才能读取自己缓存里面的数据，这也就是所谓的“Store Forward”</p><h4 id="invalidate-queue失效队列">Invalidate Queue（失效队列）</h4><p>从CPU广播，到其他CPU收到广播消息、到其他CPU标记自己的缓存行为invalid，到响应消息，这个过程最慢的一环在于CPU标记自己的缓存行为invalid。尤其是CPU在执行其它指令的期间并不能马上来处理invalid的广播消息，所以就有了失效队列的优化</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">注意：这里再次验证了并发问题的老话，没有什么是加一层不能解决的，失效队列就是新增的一层<br></code></pre></td></tr></table></figure><p>当前CPU收到其他CPU广播的invalid 消息后，不一定要马上处理，而是把放这个失效队列里面，然后就马上返回 invalid ack 。然后当自己有时间的时候再去处理失效队列里的消息，最后通过这种异步的方式，加快了CPU整个修改数据的过程。</p><h4 id="当前方案的问题">当前方案的问题</h4><p>经过了 store buffer 和invalid queue 优化后的MESI性能的确是有了提升，不过随之而来的也伴随着两个问题，没有优化的MESI虽然整个过程是同步进行的，但是这样可以确保每个操作都真正意义上的执行了，从而保证了数据的强一致性。</p><p>然而优化之后将这种强一致性变成了弱一致性：使得其它CPU在修改了共享变量之后，并不能即时的把数据标记失效，这就可能造成在某一段时间内，各个处理器之间还是会存在数据的不一致</p><p>例如：当CPU收到invalid指令时，失效队列直接回复ack，但CPU其实还没有处理这个事件，Cache仍然为share，假如此时涉及到读操作，就会读到错误的数据。</p><p>Store Buffer也是同样的道理</p><p><strong>这个问题是导致我们程序并发问题（CPU乱序执行）的根源！！！</strong></p><p>但是既然优化过后的缓存一致性协议无法达到数据的强一致，那么我们为什么还要去优化呢？因为大多数情况都不存在并发问题，只有少数场景才会导致这种问题，我们不能因为极少数场景的问题而放弃了大多数场景的性能提升。</p><p>虽然是极少数场景出现的问题，但是也不能不管，针对这种少数场景就必须要有一套处理机制来保证我们程序不出问题，这就是内存屏障。</p><h2 id="第三次优化内存屏障">第三次优化：内存屏障</h2><p>我们已经知道了出现并发错误的核心在于，我们对MESI进行了优化，放弃了强一致性</p><p>所以一个显而易见的优化方案出现了，只要我们禁用这种优化，不就可以保证一致性了嘛？（当然只是在少数场景下）</p><p>内存屏障就可以简单的认为它就是用来禁用CPU缓存优化的</p><p><strong>内存屏障Memory Barriers</strong>（或Memory Fences）是计算机体系结构提供了一种指令，它可以强制内存的更新对所有CPU可见。当执行内存屏障指令时，系统确保，在内存屏障<strong>之前</strong>所有的load和store，都会在内存屏障<strong>之后</strong>的load或store执行前完成。因此，即使指令被重新排序，内存屏障确保了，位于它之前的存储操作已经在内存中完成，因此在内存屏障之后，这些存储操作对所有处理器是可见的</p><p>使用了内存屏障后，写入数据时会<strong>保证所有的指令都执行完毕</strong>，这样就能保证修改过的数据能即时的暴露给其他的CPU。<strong>在读取数据的时候保证所有的“无效队列”消息都已经被读取完毕</strong>，这样就保证了其他CPU修改的数据消息都能被当前CPU知道，<strong>然后根据Invalid消息判断自己的缓存是否处于无效状态</strong>，这样就读取数据的时候就能正确的读取到最新的数据</p><h4 id="store-barrier写屏障">Store Barrier(写屏障)</h4><p>强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到CPU缓存</p><p>结合上面的场景，这个指令其实就是告诉CPU，执行这个指令的时候需要把store buffer的数据都同步到内存中去</p><h3 id="load-barrier读屏障">Load Barrier(读屏障)</h3><p>强制所有在load屏障指令之后的load指令，都在该load屏障指令执行之后被执行，并且一直等到load缓冲区被该CPU读完才能执行之后的load指令</p><p>这个指令的意思是，在读取共享变量的指令前，先处理所有在失效队列中的消息，这样就保证了在读取数据之前所有失效的消息都得到了执行，从而保证自己读取到的数据是最新的</p><h3 id="full-barrier全能屏障">Full Barrier（全能屏障）</h3><p>包含了Store Barrier 和Load Barrier的功能</p><h2 id="锁的本质">锁的本质</h2><p>其实在理解了第二次优化和第三次优化的过程之后，我们就能理解锁到底是怎么回事了。在正常情况下，如果连CPU缓存的一致性的都不能保证，那么在软件层面，无论如何设计算法都没办法实现锁。</p><p>举个例子，多个CPU通过上锁来保证一个变量i不断递增，想要实现这个操作的前提就是： （1）每个CPU拿到的i都必须是最新的，不然计算肯定错误 （2）当前CPU计算的时候，其它CPU不允许同时计算，不然计算肯定也错误 （3）当前CPU计算完成后必须立马让其他CPU可见，不然他们计算时拿到的值就不是最新的</p><p><strong>volatile</strong>变量是java为用户提供的内存屏障，编译后可以发现它其实是执行了lock这一条CPU指令，那么这条指令到底做了什么呢？按照intel文档的说法，lock指令可以保证该操作排他性的独占该内存，意思就是不能存在i的任何拷贝，并且完成后需要更新到所有CPU都可见的缓冲区。</p><p>这个操作其实就是从Share变成Modified，然后其他CPU的Share变成invalid然后修改变量的过程。为了保证操作的正确性，自然不能有store buffer和invalid queue的存在，也就是说lock之前的所有操作都需要完成，私有区域被同步。lock和mfence最大的区别在于，前者只要求所有CPU可见，也就是更新操作写回L3缓存即可，后者要求写回到内存。</p><p>所以，CPU提供的原子性操作本质就是内存屏障，将上文提到的第二部优化暂时关闭，这样CPU缓存就能保证强一致性。而锁的概念也就在此之上诞生了，平时提到的锁其实是一个操作系统的概念，它通过关闭中断和CPU提供的保证缓存一致性的指令，来为临界区的代码提供了原子性</p><h2 id="总结">总结</h2><p>总线嗅探和总线仲裁保证了CPU缓存的一致性，但引入性能问题 第一次优化使用MESI协议让性能更好，但仍然存在优化空间</p><p>第二次优化引入store buffer和invalid queue让性能更好，但使得缓存从强一致性变成弱一致性</p><p>第三次优化引入内存屏障，使得缓存在少数情况下的弱一致性也变为了强一致性</p><p>CPU缓存的涉及思想可以迁移到很多现在的分布式缓存设计上，例如使用mq来实现写传播，队列来实现事务串行化</p>]]></content>
    
    
    <categories>
      
      <category>高并发问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发, 锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习总结</title>
    <link href="/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/12/MySQL%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>市面上的mysql教程要么动则几十个小时，要么就是过于八股文，纯粹为面试而生，各个问题之间不成体系，纯靠记忆，难以理解，于是我通过阅读各种学习笔记，面经，以成体系的方式，结合自己的理解形成了一份mysqk学习总结。</p><p>希望通过系统化学习的方式，结合自己以前学过的知识，可以让知识在脑海中的记忆更加牢固。基本上每一个大块都按照是什么，为什么做，怎么做来展开。</p><h2 id="基础">基础</h2><p>什么是数据库三大范式？ https://zhuanlan.zhihu.com/p/554101160 （1）列不可分 （2）主键依赖（消除部分依赖） <strong>2NF优化发生在联合主键情况下</strong>，即一张表的主键为KEY（A,B），而表中属性C只依赖于A，则成为C对主键的部分依赖。<strong>对于单主键的表，如果优化为1NF后，自然就已经满足2NF了。</strong> （3）表不可分（消除传递依赖） 非主键列必须直接依赖于主键，不能存在传递依赖，比如（A,B,C）三个列，其中A是主键，C依赖于B，B依赖于A，存在传递依赖。将表拆分为（A,B）和（B,C）之后满足第三范式</p><h3 id="数据类型">数据类型</h3><p>（1）数值类型：tinyint只占一个字节，适合用来存储年龄 （2）时间和日期：date，time，year，datetime，timestamp类型 （3）字符串类型：char和varchar用的多，后者作为边长字符串更节省空间 - <strong>最大长度</strong>：char是255，varchar是65535，单位是字符（而不是字节） - <strong>尾随空格</strong>：char会将尾随空格去掉，而varchar不会 因为存储时，char会用空格填充至指定长度，所以取出时需要去除空格。如果char字段有唯一索引，<code>a</code>和<code>a</code>会提示唯一索引冲突 - <strong>存储空间占用</strong>：varchar会占用额外的1~2字节来存储字符串长度。如果最大长度超过255，就需要2字节，否则1字节 char  适应于固定长度的码值、定值；更新次数多的小长度字段； varchar 适应于不定的字段，如审核意见、理由；更新次数少的字段；系统性能需要； 在绝大多数情况下最好使用varchar</p><h3 id="crud操作">CRUD操作</h3><p><a href="https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=199">牛客网在线编程_SQL篇_非技术快速入门 (nowcoder.com)</a></p><p>（1）DISTINCT去重 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">&lt;</span>字段名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure> （2）LIMIT 查询结果限制返回行数 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name LIMIT <span class="hljs-number">10</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>MYSQL<br><br><span class="hljs-keyword">SELECT</span> TOP <span class="hljs-number">10</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name; <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">SQL</span> Server<br></code></pre></td></tr></table></figure> （3） as 将查询后的列重新命名 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">&lt;</span>字段名<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">as</span> <span class="hljs-operator">&lt;</span>字段名<span class="hljs-operator">&gt;</span>, <span class="hljs-operator">&lt;</span>字段名<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">as</span> <span class="hljs-operator">&lt;</span>新名字<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span>... <span class="hljs-keyword">from</span> 表名;<br></code></pre></td></tr></table></figure> （4）where 条件查询 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> device_id,university <span class="hljs-keyword">from</span> user_profile <span class="hljs-keyword">where</span> university<span class="hljs-operator">=</span><span class="hljs-string">&#x27;北京大学&#x27;</span>;<br></code></pre></td></tr></table></figure> （5）between and 和 not between and 范围查询 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> device_id,gender,age <span class="hljs-keyword">from</span> user_profile <span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">23</span><br></code></pre></td></tr></table></figure> （6） where in 选出包含条件的字段 和 not in 除条件字段以外的字段 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> device_id,gender,age,university,gpa <span class="hljs-keyword">from</span> user_profile <span class="hljs-keyword">where</span> university <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;北京大学&#x27;</span>,<span class="hljs-string">&#x27;复旦大学&#x27;</span>,<span class="hljs-string">&#x27;山东大学&#x27;</span>);<br></code></pre></td></tr></table></figure> （7）like和通配符实现模糊查询 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">列名 [<span class="hljs-keyword">NOT</span>] <span class="hljs-keyword">LIKE</span><br>匹配串中可包含如下四种通配符：  <br>_：匹配任意一个字符；  <br><span class="hljs-operator">%</span>：匹配<span class="hljs-number">0</span>个或多个字符；  <br>[ ]：匹配[ ]中的任意一个字符(若要比较的字符是连续的，则可以用连字符“<span class="hljs-operator">-</span>”表 达 )；  <br>[<span class="hljs-operator">^</span> ]：不匹配[ ]中的任意一个字符。<br><br>从学生表表中查询学号的最后一位不是<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">5</span>的学生信息。<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 学生表 <span class="hljs-keyword">WHERE</span> 学号 <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%[^235]&#x27;</span><br></code></pre></td></tr></table></figure> （8）聚合函数：max、min、avg、count <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(device_id) <span class="hljs-keyword">as</span> male_num, <span class="hljs-built_in">avg</span>(gpa) <span class="hljs-keyword">as</span> avg_gpa <span class="hljs-keyword">from</span> user_profile <span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;male&#x27;</span><br></code></pre></td></tr></table></figure> （9）group by分组 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    gender,<br>    university,<br>    <span class="hljs-built_in">count</span>(device_id) <span class="hljs-keyword">as</span> user_num,<br>    <span class="hljs-built_in">avg</span>(active_days_within_30) <span class="hljs-keyword">as</span> avg_active_day,<br>    <span class="hljs-built_in">avg</span>(question_cnt) <span class="hljs-keyword">as</span> avg_question_cnt<br><span class="hljs-keyword">from</span> user_profile<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender, university<br></code></pre></td></tr></table></figure> （10）having分组过滤：聚合函数结果作为筛选条件时，不用where用having <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    university,<br>    <span class="hljs-built_in">avg</span>(question_cnt) <span class="hljs-keyword">as</span> avg_question_cnt,<br>    <span class="hljs-built_in">avg</span>(answer_cnt) <span class="hljs-keyword">as</span> avg_answer_cnt<br><span class="hljs-keyword">from</span> user_profile<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> university<br><span class="hljs-keyword">having</span> avg_question_cnt <span class="hljs-operator">&lt;</span> <span class="hljs-number">5</span> <span class="hljs-keyword">or</span> avg_answer_cnt <span class="hljs-operator">&lt;</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure> （11）order by 对某个列升序排列（asc表示升序，desc表示降序） <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <br>university,<br>    <span class="hljs-built_in">avg</span>(question_cnt) <span class="hljs-keyword">as</span> avg_question_cnt<br><span class="hljs-keyword">from</span> user_profile<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> university<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> avg_question_cnt<br><br>语法：<br><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column1, column2, ... <span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>;（<span class="hljs-keyword">asc</span>表示升序，<span class="hljs-keyword">desc</span>表示降序）<br></code></pre></td></tr></table></figure> （12）等值连接inner join，左连接left join，右连接right join（通过where实现外连接），完全连接full join <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> qpd.device_id, qpd.question_id, qpd.result<br><span class="hljs-keyword">from</span> question_practice_detail <span class="hljs-keyword">as</span> qpd<br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> user_profile <span class="hljs-keyword">as</span> up<br><span class="hljs-keyword">on</span> up.device_id<span class="hljs-operator">=</span>qpd.device_id <span class="hljs-keyword">and</span> up.university<span class="hljs-operator">=</span><span class="hljs-string">&#x27;浙江大学&#x27;</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> question_id<br></code></pre></td></tr></table></figure> （13）round(x,4)，保留四位小数 （14）UNION 与 UNION ALL 合并两张表，前者去重后者不去重效率高 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    device_id,<br>    gender,<br>    age,<br>    gpa<br><span class="hljs-keyword">from</span> user_profile<br><span class="hljs-keyword">where</span> university <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;山东大学&#x27;</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span><br>    device_id,<br>    gender,<br>    age,<br>    gpa<br><span class="hljs-keyword">from</span> user_profile<br><span class="hljs-keyword">where</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;male&#x27;</span><br></code></pre></td></tr></table></figure> （14）case..when..then..end函数，放在select后面。end后的为分类后的列名 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">注意<span class="hljs-keyword">when</span>之间没有逗号<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">25</span> <span class="hljs-keyword">OR</span> age <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;25岁以下&#x27;</span> <br>            <span class="hljs-keyword">WHEN</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">25</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;25岁及以上&#x27;</span><br>            <span class="hljs-keyword">END</span> age_cut,<span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>)number<br><span class="hljs-keyword">FROM</span> user_profile<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> age_cut<br></code></pre></td></tr></table></figure> （15）限定日期，year(date)=2021 and month(date)=8,day(date)=20 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    <span class="hljs-keyword">day</span>(<span class="hljs-type">date</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">day</span>,<br>    <span class="hljs-built_in">count</span>(question_id) <span class="hljs-keyword">as</span> question_cnt<br><span class="hljs-keyword">from</span> question_practice_detail<br><span class="hljs-keyword">where</span> <span class="hljs-keyword">month</span>(<span class="hljs-type">date</span>)<span class="hljs-operator">=</span><span class="hljs-number">8</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">year</span>(<span class="hljs-type">date</span>)<span class="hljs-operator">=</span><span class="hljs-number">2021</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-type">date</span><br></code></pre></td></tr></table></figure> （16）date_add计算用户的平均次日留存率 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(q2.device_id) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(q1.device_id) <span class="hljs-keyword">as</span> avg_ret<br><span class="hljs-keyword">from</span><br>    (<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> device_id, <span class="hljs-type">date</span><br>    <span class="hljs-keyword">from</span> question_practice_detail) <span class="hljs-keyword">as</span> q1<br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span><br>    (<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> device_id, <span class="hljs-type">date</span><br>    <span class="hljs-keyword">from</span> question_practice_detail) <span class="hljs-keyword">as</span> q2<br><span class="hljs-keyword">on</span> q1.device_id <span class="hljs-operator">=</span> q2.device_id <span class="hljs-keyword">and</span> q2.date <span class="hljs-operator">=</span> date_add(q1.date, <span class="hljs-type">interval</span> <span class="hljs-number">1</span> <span class="hljs-keyword">day</span>)<br><br></code></pre></td></tr></table></figure> （17）字符串截取substring_index(FIELD, sep, n)可以将字段FIELD按照sep分隔： 当n大于0时取第n个分隔符(n从1开始)<strong>左边的全部内容</strong>； 当n小于0时取倒数第n个分隔符(n从-1开始)<strong>右边的全部内容</strong>； <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    substring_index(profile, <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-number">-1</span>) <span class="hljs-keyword">as</span> gender,<br>    <span class="hljs-built_in">count</span>(device_id) <span class="hljs-keyword">as</span> number<br><span class="hljs-keyword">from</span> user_submit<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> gender<br></code></pre></td></tr></table></figure> （18）截取字符串中间的内容使用嵌套substring_index （19）IF(expr1,expr2,expr3) ，如果如果expr1为TRUE，则IF()返回值为expr2，否则返回值为expr3 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    up.device_id,<br>    university,<br>    <span class="hljs-built_in">count</span>(question_id) <span class="hljs-keyword">as</span> question_cnt,<br>    <span class="hljs-built_in">sum</span>(if(qpd.result<span class="hljs-operator">=</span><span class="hljs-string">&#x27;right&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)) <span class="hljs-keyword">as</span> right_question_cnt<br><span class="hljs-keyword">from</span><br>    user_profile <span class="hljs-keyword">as</span> up<br>        <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span>  question_practice_detail <span class="hljs-keyword">as</span> qpd  <span class="hljs-keyword">on</span> qpd.device_id <span class="hljs-operator">=</span> up.device_id <span class="hljs-keyword">and</span> <span class="hljs-keyword">month</span>(qpd.date) <span class="hljs-operator">=</span> <span class="hljs-number">8</span><br><span class="hljs-keyword">where</span> university <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;复旦大学&#x27;</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> up.device_id<br></code></pre></td></tr></table></figure></p><h3 id="理解字符集的重要性utf8和utf8mb4">理解字符集的重要性（utf8和utf8mb4）</h3><p>在创建数据库时需要指定字符集，MySQL的“utf8mb4”才是是真正的“UTF-8”，“utf8”只支持每个字符最多三个字节，而真正的UTF-8是每个字符最多四个字节。 utf8mb4 在utf8的基础上扩展了一个字节，<strong>多了emoji编码支持</strong>和和一些不常用的汉字的支持</p><h2 id="架构">架构</h2><p>图片来自小林coding <img src="Pasted%20image%2020240408170454.png"></p><p>MySQL 的架构共分为两层：<strong>Server 层和存储引擎层</strong> （1）<strong>Server 层负责建立连接、分析和执行 SQL</strong>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现 （2）<strong>存储引擎层负责数据的存储和提取</strong>，索引数据结构是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，默认InnoDB</p><p>使用MYSQL的第一件事是连接，涉及到了连接器</p><h3 id="连接器">连接器</h3><p>连接器主要有三个工作： （1）与客户端进行 TCP 三次握手建立连接； MySQL 是基于 TCP 协议进行传输的，所以计算机网络中学习到的TCP特性，mysql都有。 mysql默认151个连接，也存在长连接和短连结的概念（和http一样）。 <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">问题：怎么解决长连接占用内存的问题？<br>答案：<span class="hljs-number">1</span>. 定期断开长连接 <span class="hljs-number">2</span>. 客户端主动重置连接（客户端可以在代码中调用<span class="hljs-built_in">mysql_reset_connection</span>()）来重置连接<br></code></pre></td></tr></table></figure></p><p>（2） 校验客户端的用户名和密码，如果用户名或密码不对，则会报错； 涉及到密码的传输问题，因此mysql可以提供tsl加密传输，</p><p>（3）确认用户权限。如果登录成功会读取该用户的权限，<strong>后面的权限逻辑判断都基于此时读取到的权限</strong>；</p><h3 id="解析器">解析器</h3><p>连上mysql传入sql语句，需要解析器来进行解析： （1）词法分析，MySQL 会根据输入的字符串识别出关键字 （2）语法分析，基于词法分析的结果，语法解析器会根据语法规则，判断这个 SQL 语句是否满足 MySQL 语法。如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等</p><p>注意：表不存在或者字段不存在，并不是在解析器里做的</p><h3 id="预处理器">预处理器</h3><p>从这里开始就进入了SQL执行的流程，第一个阶段是通过预处理器</p><p>（1）检查 SQL 查询语句中的表或者字段是否存在； （2）将 select <em> 中的 </em> 符号，扩展为表上的所有列</p><h3 id="优化器">优化器</h3><p>经过预处理阶段后，还需要为 SQL 查询语句先制定一个<strong>执行计划</strong>，这个工作交由优化器来完成。</p><p><strong>优化器主要负责确认 SQL 查询语句的执行方案</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><p>要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 <code>explain</code> 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引</p><h3 id="执行器">执行器</h3><p>经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。执行的过程，主要是执行器和存储引擎交互的过程</p><h4 id="主键索引查询">主键索引查询</h4><p>以下面的语句为例，这是一个主键索引 + 等值查询 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure> （1）执行器第一次查询，调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong> （2）存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束 （3）执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录 （4）执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数</p><h4 id="全表查询">全表查询</h4><p>上面是一个使用了索引的例子，如果是全表扫描（没有用的索引）的话： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;iphone&#x27;</span>;<br></code></pre></td></tr></table></figure></p><p>（1）执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong> （2）执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录） （3）执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端 （4）一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息； （5）执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询</p><h2 id="存储引擎">存储引擎</h2><p>存储引擎负责MySQL的存储行为，InnoDB 是 MySQL 默认的存储引擎</p><p>我们每创建一个 database（数据库） 都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里，每创建一个数据库，就会在该目录下多一个以数据库名称为名的文件夹。</p><p>该文件夹下有三个文件： （1）db.opt，用来存储当前数据库的默认字符集和字符校验规则 （2）xxx.frm，<strong>表结构</strong>会保存在这个文件。每新建一张表都会生成一个.frm 文件，用来保存每个表的元数据信息 （3）xxx.ibd，<strong>表数据</strong>会保存在这个文件， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。这个文件也被称为<strong>表空间文件</strong></p><p>InnoDB存储引擎的逻辑存储结构如下： <img src="Pasted%20image%2020240408220454.png"></p><p>（1）段（segment），表空间是由各个段（segment）组成的。段一般分为数据段、索引段和回滚段等。 - 索引段：存放 B + 树的非叶子节点的区的集合； - 数据段：存放 B + 树的叶子节点的区的集合； - 回滚段：存放的是回滚数据的区的集合，MVCC 利用了回滚段实现了多版本查询数据（关于这部分的总结在后面）。</p><p>（2）区（extent），InnoDB 存储引擎是用 B+ 树来组织数据的，B+ 树中每一层都是通过双向链表连接起来的，以页为单位来分配存储空间可能导致不连续引发随机IO，降低读写效率。因此在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了</p><p>（3）页（page），页是 InnoDB 存储引擎磁盘管理的最小单元，默认16KB。意味着数据库一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中</p><p>（4）行（row），数据库表中的记录都是按行进行存放的，不同的存储引擎有不同的行格式。</p><h3 id="innodb-行格式">InnoDB 行格式</h3><p>Compact格式如下：一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分 <img src="Pasted%20image%2020240408221901.png"> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_user` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `phone` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB <span class="hljs-keyword">DEFAULT</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> ascii ROW_FORMAT <span class="hljs-operator">=</span> COMPACT;<br></code></pre></td></tr></table></figure></p><p>以下面的表为例： <img src="Pasted%20image%2020240409104708.png"></p><h4 id="记录的额外信息">记录的额外信息</h4><p>（1）变长字段长度列表 该部分只在表格存在varchar时才有，<strong>逆序</strong>记录变长字段的大小 <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">逆序使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU <span class="hljs-keyword">Cache</span> Line 中，这样就可以提高 CPU <span class="hljs-keyword">Cache</span> 的命中率<br></code></pre></td></tr></table></figure></p><p>表格中的第一行： - name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01； - phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03； - age 列和 id 列不是变长字段，所以这里不用管。 <img src="Pasted%20image%2020240409104744.png"> <figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">每个变长字段的「变长字段长度」需要用多少字节表示？<br>（1）如果变长字段允许存储的最大字节数小于等于<span class="hljs-number"> 255 </span>字节，就会用<span class="hljs-number"> 1 </span>字节表示「变长字段长度」<br>（2）如果变长字段允许存储的最大字节数大于<span class="hljs-number"> 255 </span>字节，就会用<span class="hljs-number"> 2 </span>字节表示「变长字段长度」<br></code></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">问题：为什么 <span class="hljs-type">VarChar</span> 建议不要超过<span class="hljs-number">255</span>？<br>答案：变长字段在行格式中会有单独的空间表示变长字段长度，如果长度在<span class="hljs-number">255</span>以内，则只需要<span class="hljs-number">1</span>个字节就可以表示，可以在提供较大的扩展性的同时避免空间浪费。<br></code></pre></td></tr></table></figure><p>（2）NULL值列表 该部分只有在<strong>数据表的字段没有全部定义为成NOT NULL 的时候</strong>存在</p><p>如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中，该列表中每个字节包含的8位，每一位用来表示一个允许null值的列当前是否位null。记录过程和变长字段长度列表一样是<strong>逆序</strong>的。</p><p>以表格中的第一行为例，没有null值，因此每一位都是0： <img src="Pasted%20image%2020240409104919.png"> NULL 值列表是默认是 1 字节空间，可以表示8个null字段，如果超过8个字段则会继续扩展占用更大的空间。 <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">问题：每个数据库表的行格式都有「<span class="hljs-literal">NULL</span> 值列表」吗？<br>答案：当数据表的字段都定义成 NOT <span class="hljs-literal">NULL</span> 的时候，这时候表里的行格式就不会有 <span class="hljs-literal">NULL</span> 值列表了，所以如果将表的每个字段都设置位not <span class="hljs-literal">null</span>就可以节省<span class="hljs-number">1</span>字节的空间。<br></code></pre></td></tr></table></figure></p><p>（3）记录头信息</p><p>记录头信息中包含的内容很多，下面列举几个非常重要的字段： - delete_mask ：标识此条数据是否被删除。在执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</p><ul><li><p>next_record：指向下一条记录的「记录头信息」和「真实数据」之间的位置（记录与记录之间是通过链表组织的），这样设计的好处在于向左读是记录头信息，向右读是真实数据，很方便。</p></li><li><p>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</p></li></ul><h4 id="记录的真实数据">记录的真实数据</h4><p>记录真实数据部分除了包含我们创建表时定义的每个列的数值字段，还有三个别的字段，分别为： （1）row_id。该字段不是必需的，如果我们建表的时候指定了主键或者唯一约束列，就没有 row_id 隐藏字段。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段，占用 6 个字节 （2）trx_id。该字段是必须的，作为事务id表示这个数据是由哪个事务生成的，占用 6 个字节 （3）roll_pointer。该字段是必须的，记录上一个版本的指针，占用7个字节（MVCC 机制使用）</p><h4 id="行溢出">行溢出</h4><p>MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外（Innodb会使用外部页外存储），其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节（MySQL内部使用了2个字节来存储字符串的长度信息）。</p><p>也就是除了 TEXT、BLOBs 类型的列，<strong>一行的总长度不能超过65535字节</strong>，因此究竟能保存多少数据还和使用的字符集有关（utf8只占3字节，utf8mb4占4字节） （因此要时刻注意业务根据大表拆分）</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">问题：varchar(<span class="hljs-built_in">n</span>) 中 <span class="hljs-built_in">n</span> 最大取值为多少？<br>答案：根据字符集来确定，varchar(<span class="hljs-built_in">n</span>) 字段类型的 <span class="hljs-built_in">n</span> 代表的是最多存储的字符数量，并不是字节大小。<br><br>单字段情况下：varchar(<span class="hljs-built_in">n</span>) 中 <span class="hljs-built_in">n</span> 最大值 * 一个字符占用字节数 + 「变长字段长度列表」 和 「NULL 值列表」 占用的字节数 &lt;= <span class="hljs-number">65535</span> 即可<br>多字段情况下同理：所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &lt;= <span class="hljs-number">65535</span><br></code></pre></td></tr></table></figure><p>一行的最大长度为65535个字节，但是MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 16KB，也就是 16384 字节。因此如果数据量太大，会导致行溢出，<strong>多的数据就会存到另外的「溢出页」中</strong>。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中</p><p>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页 <img src="Pasted%20image%2020240409164748.png"></p><p>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样： <img src="Pasted%20image%2020240409164830.png"></p><h3 id="innodb-页格式">InnoDB 页格式</h3><p><strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，默认大小16KB。数据页的结构如下：</p><p><img src="Pasted%20image%2020240412100745.png"></p><p>具体内容如下：</p><p><img src="Pasted%20image%2020240412101641.png"></p><p>文件头包含上下页的指针，让数据页变成双向链表。在前文我们已经知道行记录通过链表连在一起，所以还需要一个<strong>页目录</strong>，充当记录的索引</p><p><img src="Pasted%20image%2020240412102320.png"></p><p>页目录的创建流程： 1. 将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录； 2. 每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段） 3. 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</p><p>因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">问题：为什么数据页是以<span class="hljs-selector-tag">B</span>+树的结构存储，而行记录是链表？<br>答案：因为mysql以页为单位读取，<span class="hljs-selector-tag">B</span>+树主要用来减小磁盘IO，读取行记录时页已经加载到了内存中，不再需要担心磁盘IO问题，因此使用快表即可。（每个分组内部最多只能保存八个记录，因此组内遍历也不会十分耗时）<br></code></pre></td></tr></table></figure><h2 id="索引">索引</h2><p>索引是一种帮助存储引擎快速获取数据的数据结构</p><p>索引和数据都是位于存储引擎中的，在之前的xv6学习中，我们知道文件系统中每个文件结构体都包含了一个inode指针，这个inode本身存储在磁盘的inode块，结构内部包含了指向数据块的指针，它就是一种索引。</p><h3 id="索引的分类">索引的分类</h3><p>我们可以按照四个角度来分类索引。 （1）按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。 （2）按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。 （3）按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。 （4）按「字段个数」分类：<strong>单列索引、联合索引</strong>。</p><p>从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、Hash 索引、Full-Text 索引，不同的存储引擎支持的索引类型不同。innodb支持B+Tree 索引和Full-text索引，MyISAM支持B+索引和Hash索引。</p><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引： （1）如果有主键，默认会使用主键作为聚簇索引的索引键（key）； （2）如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键； （3）在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（这个在之前的行结构中提到了，row_id在没有指定索引时会自动创建），</p><p>因此聚簇索引也叫主键索引，其它索引都属于非聚簇索引，也被称为辅助索引（Secondary Index）、二级索引。<strong>innodb创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">问题：普通索引和唯一索引的区别？<br>答案：<br>（<span class="hljs-number">1</span>）普通索引为条件时查询到数据会一直扫描,直到扫完整张表；唯一索引为查询条件时,查到该数据会直接返回,不会继续扫表<br>（<span class="hljs-number">2</span>）普通索引会直接将操作更新到 <span class="hljs-keyword">change</span> <span class="hljs-keyword">buffer</span> 中,然后结束；唯一索引需要判断数据是否冲突<br><br>注意：因此唯一索引更加适合查询，普通索引更适合插入<br></code></pre></td></tr></table></figure><h3 id="为什么使用b树作为索引">为什么使用B+树作为索引</h3><p>在理解为什么使用B+树之前，我们需要知道<strong>数据结构都是为业务场景服务的</strong>。MySQL的业务场景是什么样的呢？数据库为了避免全表查询一条数据，需要利用索引，而MySQL 的数据是持久化的，意味着数据（索引+记录）是保存到磁盘上</p><p>这导致了每次查找索引都需要涉及磁盘IO，所以我们需要一个满足下面条件的数据结构 （1）减少磁盘IO。能在尽可能少的磁盘的 I/O 操作中完成查询工作； （2）高效。要能高效地查询某一个记录，也要能高效地执行范围查找； （3）范围查询。mysql支持范围查询</p><p>AVL树，红黑树等结构允许高效，但是会涉及到的磁盘IO次数太高 哈希表难以进行范围查询 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">问题：为什么不使用快表？<br>答案：在写入时<span class="hljs-selector-tag">B</span>+树涉及更新索引层，效率不如快表，但查询时，三层的<span class="hljs-selector-tag">B</span>+Tree就可以存储<span class="hljs-number">2000</span>W的数据，查找数据最多只需要三次磁盘IO即可，快表需要<span class="hljs-number">24</span>层索引，涉及<span class="hljs-number">24</span>次IO。而数据库的应用场景读多写少。<br></code></pre></td></tr></table></figure></p><p>B树可以满足前两项但有以下问题： （1）B 树的每个节点都包含索引+记录，读取索引时不可避免的读取到无用的记录数据，这些无用数据占用内存资源的同时还使得磁盘 I/O 操作次数变多 （2）使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题</p><p>B+树叶子节点才会存放实际数据，非叶子节点只会存放索引，叶子节点之间构成一个有序链表。这样的结构带来了以下好处： （1）<strong>单点查询比B树更稳定</strong>。虽然B 树最快可以在 O(1) 的时间代价内就查到，但波动大 （2）<strong>范围查询比B树快</strong>。B+树可以在查到第一个节点后向右遍历链表，节省从头开始查找的时间 （3）<strong>插入和删除效率比B树高</strong>。B+树拥有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，删除非常快</p><p>Innodb 根据索引类型不同，分为聚集和二级索引。聚集索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚集索引的叶子节点，而二级索引的叶子节点存放的是主键值。根据二级索引查到主键值之后需要进行<strong>回表</strong>（即再根据主键查找）</p><p>因为表的数据都是存放在聚集索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚集索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个</p><h3 id="索引的适用场景">索引的适用场景</h3><p>索引最大的好处是提高查询速度，但也会带来占用物理空间，并且带来维护的开销。因此需要看情况使用。</p><h4 id="什么时候需要索引">什么时候需要索引？</h4><p>（1）字段有唯一性限制的，比如商品编码、学生ID （2）经常用于 WHERE`查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引 （3）经常用于 GROUP BY和 ORDER BY的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。 <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">当查询语句中包含 <span class="hljs-keyword">group</span> <span class="hljs-title">by</span> 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要尽量避免这种情况出现<br></code></pre></td></tr></table></figure></p><p>总结来看就是具有唯一性，具有区分度的字段很适合用来构建索引。</p><h4 id="什么时候不需要索引">什么时候不需要索引？</h4><p>（1）WHERE、GROUP BY和 ORDER BY用不到的字段 （2）没有区分度的字段，例如性别（优化器发现某个值出现在表的数据行中的百分比很高，即区分度低的时候，它一般会忽略索引，进行全表扫描） （3）表数据太少的时候，不需要创建索引 （4）经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，频繁的重建索引会影响数据库性能</p><p>总结来看就是没有区分度的字段没必要构建索引</p><h4 id="什么时候会出现索引失效">什么时候会出现索引失效？</h4><p>创建了索引并不意味着查询的时候会使用到索引，所以我们心里要清楚有哪些情况会导致索引失效，从而避免写出索引失效的查询语句，否则这样的查询效率是很低的 <strong>（1）当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</strong> <strong>（2）当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效</strong> <strong>（3）联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效</strong> <strong>（4）在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">问题：什么是最左匹配原则？<br>答案：最左匹配原则就是最左优先，在创建多列索引（联合索引）时，要根据业务需求，where子句中使用最频繁的一列放在最左边。<br><br>当你创建了一个联合索引，该索引的任何最左前缀都可以用于查询。比如当你有一个联合索引 <span class="hljs-comment">(col1, col2, col3)</span>，该索引的所有前缀为 <span class="hljs-comment">(col1)</span>、<span class="hljs-comment">(col1, col2)</span>、<span class="hljs-comment">(col1, col2, col3)</span>，包含这些列的所有查询都会使用该索引进行查询<br><br>原因在于索引查询需要有序，而联合索引是先根据最左侧的字段进行排序，剩下的字段在前一个字段相等时再进行排序，因此只能保证局部有序，所以建立联合索引时要把最常用的放在最左侧，避免索引失效<br></code></pre></td></tr></table></figure><p>在之前mysql架构中提到了执行器会根据优化器给出的方案进行查询，其中type指的就是索引的使用情况，常见的类型列出如下，效率从低到高 - All（全表扫描）； - index（全索引扫描）； - range（索引范围扫描）； - ref（非唯一索引扫描）； - eq_ref（唯一索引扫描）； - const（结果只有一条的主键或唯一索引扫描）。</p><p>All 和 index 开销都很大</p><p>range 表示采用了索引范围扫描，一般在 where 子句中使用 &lt; 、&gt;、in、between 等关键词，只检索给定范围的行，属于范围查找。<strong>从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式</strong></p><p>ref 类型表示采用了非唯一索引，虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，<strong>要进行目标值附近的小范围扫描</strong></p><p>eq_ref 类型是使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref</p><p>const 类型表示使用了主键或者唯一索引与常量值进行比较，比如： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> product <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></p><p>注意：onst 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong>const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中</strong></p><h3 id="索引优化问题">索引优化问题</h3><p>理解索引的原理和mysql使用索引的方式，我们就能知道如何让索引更好的工作，使得mysql查询的 性能更好</p><h4 id="前缀索引">前缀索引</h4><p>前缀索引优化即使用某个字段中字符串的前几个字符建立索引，这样可以减小索引字段的大小，节约空间同时增加查询速度。一般应用在内容很长，但区分度主要聚集在开头的字符串，例如外国人名、电子邮件。</p><p>这种优化方式的缺点在于 order by 无法使用，也无法进行覆盖索引</p><h4 id="覆盖索引重要">覆盖索引（重要）</h4><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以<strong>避免回表操作</strong></p><p>问题：假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？ 答案：我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表</p><p>使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作</p><h4 id="主键索引保持自增">主键索引保持自增</h4><p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中</p><p><strong>如果我们使用自增主键</strong>，可以将插入操作变为追加操作，不需要从中间插入B+树，避免导致现有数据的移动，甚至是<strong>页分裂</strong></p><p>问题：什么是页分裂？ 答案：如下图所示，插入新数据时不得不移动其它数据来腾出位置，甚至需要从一个页面复制数据到另外一个页面。页分裂会导致<strong>大量的内存碎片，使索引结构不再紧凑，从而影响查询效率</strong> <img src="Pasted%20image%2020240409213434.png"></p><p>如果是顺序插入，就会如下图所示，不会引发分裂，只会重新申请一个页 <img src="Pasted%20image%2020240409213625.png"></p><h4 id="控制主键索引长度">控制主键索引长度</h4><p>主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong></p><h4 id="索引最好设置为-not-null">索引最好设置为 NOT NULL</h4><p>这样做的好处在于： （1）索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，进而影响查询效率。比如进行索引统计时，count 会省略值为NULL 的行 （2） NULL 会占用物理空间，带来存储空间问题，如果表中存在允许为 NULL 的字段，那么行格式中<strong>至少会用 1 字节空间存储 NULL 值列表</strong>（在之前innodb行格式中提到了）</p><h2 id="事务">事务</h2><p><strong>事务是一系列不可分割的数据库的操作。这些操作要么同时成功，要么同时失败，不允许出现中间状态的数据。</strong></p><p>事务是由 MySQL 的引擎来实现的， InnoDB 支持事务，MyISAM不支持。该部分的所有内容都是基于InnoDB引擎</p><h3 id="事务的特性">事务的特性</h3><p>实现事务需要遵守四个方面的特性： （1）<strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态 （2）<strong>一致性（Consistency）</strong>：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如转帐前A和B共100元，转账后两者的余额依然为100元。（一致性与原子性是密切相关的） （3）<strong>隔离性（Isolation）</strong>：并发运行时，一个事务的执行不能被其他事务干扰 （4）<strong>持久性（Durability）</strong>：事务一旦提交，它对数据库中数据的改变就应该是永久性的</p><p>这些事务在Innodb中有对应的机制来保证： （1）原子性是通过 undo log（回滚日志） 来保证 （2）隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证 （3）持久性是通过 redo log （重做日志）来保证 （4）一致性则是通过持久性+原子性+隔离性共同来保证</p><p>理解mysql事务，其实就是理解这三种机制，每一个机制都不简单，涉及到的内容很多，因此只有<strong>隔离性</strong>的保证会在当前二级标题下进行总结，剩余的部分会放到后面的二级标题中</p><h3 id="事务的隔离级别有哪些">事务的隔离级别有哪些？</h3><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现并发事务：在同时处理多个事务的时候，就可能出现问题： （1）脏读（dirty read）：一个事务读到了另一个未提交事务修改过的数据 （2）不可重复读（non-repeatable read）：在一个事务内多次读取同一个数据，其他事务修改了数据，出现前后两次读到的数据内容不一样的情况 （3）幻读（phantom read）：在一个事务内多次读取范围内数据的时候，其他事务插入或删除了数据，出现前后两次查询到的记录数量不一样的情况</p><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下： - <strong>读未提交（<em>read uncommitted</em>）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到 - <strong>读提交（<em>read committed</em>）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到，通过在事务的每次select时创建read view来实现 - <strong>可重复读（<em>repeatable read</em>）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，通过在事务开启时时创建read view实现（注意与<strong>读提交</strong>时机不同）。 - <strong>串行化（<em>serializable</em> ）</strong>；通过加读写锁避免并行访问，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</p><p><img src="Pasted%20image%2020240410100827.png"></p><p>要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别，要解决幻读现象不建议将隔离级别升级到「串行化」</p><p>串行化非常影响数据库性能，因此 <strong>如何在可重复读模式下控制幻读的发生</strong> 就尤为重要了，mysql给出的答案是，根据不同的读场景分别处理，MySQL读取数据实际上有两种模式，分别是当前读和快照读： （1）<strong>快照读</strong>：普通的select语句(不包括 select ... lock in share mode; select ... for update)。也就是说，不加锁的select操作都是采用快照读的模式。<strong>用基于MVCC多版本并发控制方式解决幻读</strong> <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">读已提交：事务每次<span class="hljs-keyword">select</span>时创建快照读<br>可重复读：事务第一次<span class="hljs-keyword">select</span>时创建快照读，后续一直使用<br></code></pre></td></tr></table></figure> （2）<strong>当前读</strong>：数据修改的操作(update、insert、delete) 都是采用当前读的模式，<strong>用next-key lock（记录锁+间隙锁）方式解决幻读</strong></p><p>后文主要对这两种情况展开</p><h3 id="mvcc">MVCC</h3><h4 id="mvcc是什么">MVCC是什么？</h4><p>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制机制，提高了数据库并发读写的性能，同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cos">（<span class="hljs-number">1</span>）MVCC 多版本并发控制是只是一个模型概念，并非具体实现<br>（<span class="hljs-number">2</span>）MySQL实现MVCC概念中，快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。而相对而言，当前读就是悲观锁的具体功能实现<br>（<span class="hljs-number">3</span>）MVCC模型在MySQL中的具体实现则是由三个隐式字段，undo日志 ，<span class="hljs-keyword">Read</span> <span class="hljs-keyword">View</span>等去实现的<br></code></pre></td></tr></table></figure><p>注意：MVCC主要用来实现普通select的可重复读隔离等级，同时解决这种情况下的幻读问题。</p><h4 id="mvcc是如何是实现的快照读是如何避免幻读的">MVCC是如何是实现的？（快照读是如何避免幻读的？）</h4><p>上面的问题其实可以更进一步，即</p><p>MVCC开始事务后（执行 begin 语句后），根据隔离级别会在不同的时机产生一个read view。后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的，即使中途其他事务插入了新纪录，也是查询不出来的，避免了幻读问题</p><p>read view的结构如下：</p><p><img src="Pasted%20image%2020240410160614.png"></p><p>在上文讲解innodb引擎的行结构时提到了每个行包含了额外信息和真实信息，其中，真实信息里除了列数据，还包括了三个隐式字段，有作用的主要是trx_id和roll_ptr： （1）trx_id：记录创建这条记录以及最后一次修改该记录的事务的ID，是一个指针 （2）roll_ptr：回滚指针，指向这条记录的上一个版本（存储于rollback segment回滚段）。每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，于是就可以通过它找到修改前的记录 <img src="Pasted%20image%2020240408221901.png"> 根据read view的四个字段，可以将记录中的 trx_id 划分这三种情况： （1）如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong> （2）如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong> （3）如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中 - 如果记录的 trx_id <strong>在</strong> m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong> - 如果记录的 trx_id <strong>不在</strong> m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</p><p>**这样通过「版本链」就实现了 MVCC（多版本并发控制）</p><h4 id="可重复读是如何实现的">可重复读是如何实现的？</h4><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong></p><p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：</p><p><img src="Pasted%20image%2020240410161912.png"></p><ul><li><p>在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。</p></li><li><p>在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，<strong>活跃的事务 id 中最小的事务 id 是事务 A</strong>，下一个事务 id 应该是 53。</p></li></ul><p>接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作 （1）事务 B 读取账户余额记录，读到余额是 100 万 事务 B 第一次读取账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时<strong>发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的</strong>，也就是事务 B 可以获取到这条记录。</p><p>（2） 事务 A 将账户余额记录修改成 200 万，并没有提交事务 事务 A 通过 update 语句将这条记录修改了（还未提交事务），将余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong> <img src="Pasted%20image%2020240410162900.png"></p><p>（3）事务 B 读取账户余额记录，读到余额还是 100 万 事务 B 第二次去读取该记录，发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间， 且trx_id 值是在 m_ids 范围内，，那么说明这条记录是被还未提交的事务修改的，这时事务 B 会沿着 undo log 链条找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是余额是 100 万的这条记录</p><p>（4）事务 A 提交事务</p><p>（5）事务 B 读取账户余额记录，读到余额依然还是 100 万； 由于隔离级别时<strong>可重复读</strong>，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是余额是 100 万的这条记录</p><p>我们可以发现，其实mvcc已经很好的控制了幻读的发生，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的。</p><h4 id="读提交是如何工作的">读提交是如何工作的？</h4><p>如果隔离模式是读已提交，那会发生什么？</p><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p><p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务： （1）事务 B 读取数据（创建 Read View），账户余额为 100 万； （2）事务 A 修改数据（还没提交事务），将账户余额从 100 万修改成了 200 万； （3）事务 B 读取数据（创建 Read View），账户余额为 100 万； （4）事务 A 提交事务； （5）事务 B 读取数据（创建 Read View），账户余额为 200 万（同一个事物，多次读取前后不一致）；</p><h3 id="当前读是如何避免幻读的">当前读是如何避免幻读的？</h3><h4 id="当前读的业务场景">当前读的业务场景</h4><p>问题：有了快照读难道还不够吗？为什么还需要当前读？ 答案：因为快照读读取的不是最新数据，但很多业务场景必须读最新数据，例如涉及到金钱、转账等情况，此时就需要引入锁来解决问题了。</p><p>MySQL 里除了普通查询是快照读，其他都是<strong>当前读</strong>，比如 update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作，否则就会产生冲突。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">问题：什么时候会使用<span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span> （这种语句是当前读）<br>答案：在高并发场景下还对数据的准确性有很高要求的时候使用。比如涉及到金钱、库存等。一般这些操作都是很长一串并且是开启事务的。如果库存刚开始读的时候是<span class="hljs-number">1</span>，而立马另一个进程进行了<span class="hljs-keyword">update</span>将库存更新为<span class="hljs-number">0</span>了，而事务还没有结束，会将错的数据一直执行下去，就会有问题。所以需要<span class="hljs-keyword">for</span> upate 进行数据加锁防止高并发时候数据出错<br><br>注意：这时使用的锁发分为表锁和行锁。如果查询时没用索引/主键的话就是表锁，否则就是是行锁。<br></code></pre></td></tr></table></figure><h4 id="间隙锁记录锁">间隙锁+记录锁</h4><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。</p><p><img src="Pasted%20image%2020240410202002.png"></p><p><img src="Pasted%20image%2020240410202114.png"></p><p>（1）事务 A 执行了这面这条锁定读语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合） （2）事务 B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-key lock，于是事物 B 会生成一个插入意向锁，同时进入等待状态，直到事务 A 提交了事务。这就避免了由于事务 B 插入新记录而导致事务 A 发生幻读的现象（其实也就是串行化了）</p><h3 id="幻读被解决了吗">幻读被解决了吗？</h3><p>虽然上面的内容都在说如何解决幻读问题，但其实都只是尽可能的让幻读少发生，**MySQL Innodb 中的 MVCC 并不能完全避免幻读现象，只是很大程度上避免了幻读现象的发生</p><p>情况（1）： <img src="Pasted%20image%2020240410203445.png"></p><p>情况（2）： - T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id &gt; 100 得到了 3 条记录。</p><ul><li><p>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</p></li><li><p>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id &gt; 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</p></li></ul><p>这些情况其实都是由于在执行update这样的「当前读语句」之前，也就是插入next-key lock之前发生了其他事务对查询区间的插入和删除操作。</p><p>所以要避免这类特殊场景下发生幻读的现象的方法在于： <strong>尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录</strong></p><h3 id="事务-总结">事务-总结</h3><p>这一部分按照顺序： （1）什么是事务？ACID四性 （2）并发事务带来了什么问题？脏读、不可重复读、幻读 （3）如何解决这些问题？不同的事务隔离等级 （4）这些事务隔离等级是如何实现的？默认「可重复读」，引出了MVCC （5）MVCC是什么？如何实现的？ （6）「当前读」如何实现？</p><p>这一部分由于出现了很多名词，比如隐式字段，undo日志（回滚日志），read view。可能会看的云里雾里，所以我整合出了一张图片。</p><p><img src="Pasted%20image%2020240410194737.png"></p><p>MVCC实现主要是依赖 <strong>隐式字段</strong>，<strong>undo日志</strong> 和 <strong>Read View</strong> ，但这三者并不是并行的关系，隐式字段将unode日志和read view连接在了一起。隐式字段的roll_ptr指向了undo日志，trx_id和read view建立关联</p><p>当前读的只要实现是根据next-key lock，关于锁的应用会在后面再进行总结</p><h2 id="锁">锁</h2><p>锁往往是与并发问题同时出现，并发问题的根源我已经在之前的<a href>并发基础</a>文章中进行了详细的阐述，并在<a href>xv6 lock</a>中对操作系统不同类型的锁进行了递进式的讲解（自旋锁、睡眠锁、ticket锁、MCS锁）。</p><p>本章节只要的内容主要是介绍mysql为了保证并发安全提供的锁</p><h3 id="全局锁">全局锁</h3><h4 id="如何使用全局锁">如何使用全局锁？</h4><p>使用全局锁需要执行这条命令： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">加锁：flush tables <span class="hljs-keyword">with</span> read lock<br>解锁：unlock tables<br></code></pre></td></tr></table></figure></p><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程无论是修改数据还是修改表结构，都会被阻塞： （1）对数据的增删改操作，比如 insert、delete、update等语句； （2）对表结构的更改操作，比如 alter table、drop table 等语句。 <strong>当会话断开了，全局锁会被自动释放</strong>（否则会导致死锁）</p><h4 id="全局锁的应用场景">全局锁的应用场景？</h4><p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">问题：加全局锁又会带来什么缺点呢？<br>答案：如果数据库里有很多数据，全库备份就会花费很多的时间，这期间，业务只能读数据，而不能更新数据，会造成业务停滞！<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">问题：如何避免全局锁造成的业务停滞？<br>答案：如果数据引擎支持支持[可重复读]，那么在备份数据库之前先开启事务，会先创建 <span class="hljs-keyword">Read</span> <span class="hljs-keyword">View</span>，然后整个事务执行期间都在用这个<span class="hljs-keyword">Read</span> <span class="hljs-keyword">View</span>来完成，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作，即使其他事务更新了表的数据，也不会影响备份数据库时的 <span class="hljs-keyword">Read</span> <span class="hljs-keyword">View</span><br><br>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 –single-<span class="hljs-keyword">transaction</span> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎<br><br>对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法<br></code></pre></td></tr></table></figure><h3 id="表级锁">表级锁</h3><h4 id="表锁">表锁</h4><p>如果想对学生表（t_student）加表锁，可以使用下面的命令： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的共享锁，也就是读锁；<br>lock tables t_student read;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的独占锁，也就是写锁；<br>lock tables t_stuent write;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>解锁<br>unlock tables<br></code></pre></td></tr></table></figure> 当会话退出后，也会释放所有表锁</p><p>尽量避免在使用 InnoDB 引擎的表使用表锁，因为一种常见的提高锁性能的方案就是锁分段，将粗粒度的锁换为细粒度的锁，mysql默认引擎更换为<strong>InnoDB 的重要原因在于细粒度的行级锁</strong>，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">问题：表锁有什么缺点？<br>答案：粒度太大，并发效率低<br></code></pre></td></tr></table></figure><h4 id="元数据锁">元数据锁</h4><p>我们不需要显示的使用 元数据锁（MDL），因为当我们对数据库表进行操作时，会自动加锁 （1）对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>； （2）对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</p><p>MDL 的作用是保证用户对表执行 CRUD 操作时，防止其他线程对表结构做变更，只有在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">问题：元数据锁有什么缺点？<br>答案：如果某个事务占用锁的时间太长，对表结构的更新操作（写锁）会导致其他线程对表的读操作阻塞（因为申请 MDL 锁的操作会形成一个队列，队列写锁获取优先级高于读锁），这时数据库的线程很快就会爆满<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">问题：如何应对元数据锁的缺陷？<br>答案：在对表结构进行变更时，先看看数据库中是否有长事务已经对表加上了MDL读锁，可以考虑<span class="hljs-built_in">kill</span>掉这个长事务再进行表结构变更<br></code></pre></td></tr></table></figure><h4 id="意向锁">意向锁</h4><p><strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong></p><p>用法： （1）在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」； （2）在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</p><p>我们已经知道innodb会对记录加行锁来替代表锁，但是在进行一些表级别的修改时还是需要表锁的，此时： （1）如果没有意向锁，那么加独占表锁时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢 （2）有了意向锁，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加独占表锁时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录</p><h4 id="auto-inc-锁">AUTO-INC 锁</h4><p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的，之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的</p><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉</p><p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的</p><p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞</p><h3 id="行级锁">行级锁</h3><p>InnoDB 引擎支持行级锁的， MyISAM引擎并不支持行级锁</p><p>普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为<strong>锁定读</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//对读取的记录加共享锁</span><br><span class="hljs-function"><span class="hljs-title">select</span></span> ... lock in share mode;<br><br><span class="hljs-comment">//对读取的记录加独占锁</span><br><span class="hljs-function"><span class="hljs-title">select</span></span> ... <span class="hljs-keyword">for</span> update;<br></code></pre></td></tr></table></figure><p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong></p><p>行级锁的类型主要有三类：记录锁（Record Lock）、间隙锁（Gap Lock）、记录锁 + 间隙锁（Next-Key Lock）</p><p>（1）记录锁是一种读写锁，锁住的是一条记录。在持有读锁时可以接收其他读锁，但不能加写锁。持有写锁时既不能加读锁也不能加写锁 （2）间隙锁锁住一个id范围。只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象（前面已经讲到了）。 假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生 （3）Next-Key Lock锁定一个范围，并且锁定记录本身。 假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。 （4）插入意向锁，这是一种特殊的间隙锁，锁住的是一个点。 一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态</p><p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p><h3 id="加锁规则与死锁">加锁规则与死锁</h3><h4 id="加锁规则">加锁规则</h4><p>MySQL中普通的select不需要加锁，只有增删改和特殊的select会加独占行锁。</p><p><a href="https://xiaolincoding.com/mysql/lock/how_to_lock.html#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2">MySQL 是怎么加锁的？ | 小林coding (xiaolincoding.com)</a></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">问题：为什么<span class="hljs-keyword">update</span>时没加索引会锁全表？<br>答案：在 <span class="hljs-keyword">update</span> 语句的 <span class="hljs-keyword">where</span> 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-<span class="hljs-keyword">key</span> 锁（记录锁 + 间隙锁），相当于把整个表锁住了，可能导致业务崩溃。<br><br>注意：在线上在执行 <span class="hljs-keyword">update</span>、<span class="hljs-keyword">delete</span>、<span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span> 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-<span class="hljs-keyword">key</span> 锁，相当于把整个表锁住了<br><br>连问：如何避免这种情况的发生？<br>答案：将 MySQL 里的 sql_safe_updates 参数设置为 <span class="hljs-number">1</span>。<br>此时<span class="hljs-keyword">update</span> 语句必须满足如下条件之一才能执行成功：<br>（<span class="hljs-number">1</span>）使用 <span class="hljs-keyword">where</span>，并且 <span class="hljs-keyword">where</span> 条件中必须有索引列；<br>（<span class="hljs-number">2</span>）使用 <span class="hljs-keyword">limit</span>；<br><span class="hljs-keyword">delete</span> 语句必须满足以下条件能执行成功：<br>（<span class="hljs-number">1</span>）同时使用 <span class="hljs-keyword">where</span> 和 <span class="hljs-keyword">limit</span>，此时 <span class="hljs-keyword">where</span> 条件中可以没有索引列；<br></code></pre></td></tr></table></figure><h4 id="死锁">死锁</h4><p>https://xiaolincoding.com/mysql/lock/show_lock.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81</p><p><img src="Pasted%20image%2020240411105024.png"></p><p>Time1：事务A获取(20,30)的间隙锁（会在事务结束后释放） Time2：事务B获取(20,30)的间隙锁（会在事务结束后释放）（间隙锁是兼容的，所以不会阻塞） Time3：事务A插入行为被事务B的间隙锁阻塞，获取插入意向锁 Time4：事务B插入行为被事务A的间隙锁阻塞，获取插入意向锁</p><p>两个事务都在等待对方释放间隙锁，导致死锁</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran">问题：如何避免死锁？<br>答案：<br>（<span class="hljs-number">1</span>）设置事务等待锁的超时时间<br>（<span class="hljs-number">2</span>）开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务（默认开启）<br><br>追问：主动死锁检测是如何实现的？<br>答案：对事务等待图(<span class="hljs-keyword">wait</span>-for graph)进行深度优先搜索，该图存储了锁和事务等待关系。事务与事务之间的连线，代表事务在等待另一个事务释放资源，发现环则出现了死锁<br></code></pre></td></tr></table></figure><h2 id="日志">日志</h2><p>在xv6文件系统的学习中，我们知道文件系统中有提供崩溃一致性服务的日志层。现在我们来看看mysql中有哪些日志，分别有什么作用</p><h3 id="buffer-pool">Buffer Pool</h3><h4 id="什么是buffer-pool">什么是Buffer Pool ？</h4><p>在xv6中，为了提供给CPU直接访问磁盘的错觉，每次对磁盘的访问都会转化为对内存缓存的访问，buffer cache层有一个bcache数据结构，维护了磁盘块和缓存块的映射关系。</p><p>buffer pool可以理解为是mysql的buffer cahce，在进程的角度来看，每次访问都是访问磁盘，这样效率比较低，所以最好将使用过的数据缓存起来，下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了。</p><p>buffer pool由 innnodb 维护，默认大小为128MB</p><p><img src="Pasted%20image%2020240411152746.png"></p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），<strong>为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</strong></li></ul><p>每一个页都存在一个控制块（这也是文件系统的常规操作了），控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等 <img src="Pasted%20image%2020240411215332.png"></p><h4 id="buffer-pool缓存了什么">buffer pool缓存了什么？</h4><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p><p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">注意：根据linux懒分配的原理，申请的连续内存空间只是连续的虚拟地址，并且暂时不会真的分配物理地址，而是等待虚拟内存被访问后，操作系统才会触发缺页中断，申请物理内存，接着将虚拟地址和物理地址建立映射关系，所以MySQL 刚启动的时候，虚拟内存空间很大，而物理内存空间却很小<br></code></pre></td></tr></table></figure><p>在前面的内容中，我们知道一个表空间包含了数据段，索引段，回滚段。所以buffer pool，除了缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等</p><h4 id="buffer-pool的结构">Buffer Pool的结构？</h4><p>Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页可以分为： （1）空闲的 空闲空间的控制块以<strong>空闲链表</strong>的形式连接在一起，每个节点都包含了对空闲控制块的指针，然后每个控制块又包含了对应缓存页的指针 每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除 （2）干净的页（已经被使用，但是未修改） 使用LRU进行管理。当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部，当访问的页不在 Buffer Pool 里，除了要把从磁盘新读取的页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。<strong>注意脏数据页也在LRU当中，</strong> （3）脏的 脏空间的控制块以<strong>Flush 链表</strong>的形式连接在一起，结构和空闲链表一致，只不过节点中指向的控制块都是脏页的控制块。 有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘</p><p><img src="Pasted%20image%2020240411223355.png"></p><h4 id="lru的结构有什么问题如何解决">LRU的结构有什么问题？如何解决？</h4><p>简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题 （1）预读失效 MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO，但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。如果使用简单的 LRU 算法，就会把预读页放到 LRU 链表头部，而当 Buffer Pool空间不够的时候，还需要把末尾的页淘汰掉（明明不是最经常使用的页，却放在了LRU最前面，使得缓存命中率下降） （2）Buffer Pool 污染 当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong></p><p>（1）针对预读失效的问题，解决方案在于让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长，具体的做法在于改进LRU算法： 将LRU分为两个部分，前半部分为young区域，后半部分为old 区域，<strong>预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong></p><p>（2）针对Buffer pool污染问题，解决方案在于给进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间 如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>； 如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>； 也就说，只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</p><p>另外，MySQL 还针对 young 区域做了一个优化，young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">问题：如何提高buffer pool缓存命中率？（其他的缓存也是一样的道理）<br>答案：（<span class="hljs-number">1</span>）避免预读导致的缓存失效，将LRU分为young和<span class="hljs-keyword">old</span>，前者缓存热点数据，后者做预读<br>（<span class="hljs-number">2</span>）避免缓存污染，只有同时满足「被访问」与「在 <span class="hljs-keyword">old</span> 区域停留时间超过 <span class="hljs-number">1</span> 秒」两个条件，才会被插入到 young 区域头部，避免因为大范围搜索导致的LRU热点缓存失效<br></code></pre></td></tr></table></figure><h3 id="undo-log">undo log</h3><p>一个事务在还没有提交事前，如果 MySQL 发生了崩溃，怎么保证崩溃一致性呢？（要怎么回滚到事务之前的数据呢？），使用的就是回滚日志undo log，<strong>保证了事务的 ACID 特性中的原子性（Atomicity，要么都成功，要么都失败）</strong>。 每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如： （1） 在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了； （2）在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了； （3）在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</p><p>在发生回滚时，就读取 undo log 里的数据，然后做原先相反操作。比如当 delete 一条记录时，undo log 会把记录中的内容都保存下来，然后写入 Buffer Pool 中的 Undo 页面。当执行回滚操作的时候，就可以读取 undo log 里的数据，然后进行 insert 操作</p><p>一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id（老朋友了，这两个值都是保存在row中隐式字段）： （1）通过 trx_id 可以知道该记录是被哪个事务修改的； （2）通过 roll_pointer 指针可以将这些 undo log 串成一个链表形成版本链</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel">问题：<span class="hljs-keyword">undo</span> <span class="hljs-keyword">log</span>有什么作用？<br>答案：<br>（<span class="hljs-number">1</span>）实现事务回滚，保障事务的原子性<br>（<span class="hljs-number">2</span>）参与实现 MVCC（多版本并发控制）<br></code></pre></td></tr></table></figure><h3 id="redo-log">redo log</h3><p>通过对undo log记录的讲解，我们知道该日志是在内存更新的，每次对事物的记录会写入到buffer pool中的undo页。</p><p>然而这些记录都是在内存中的，内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失，所以如果想要它们真的持久化，还需要刷盘到磁盘上</p><h4 id="什么是redo-log">什么是redo log？</h4><p>redo log 是物理日志，记录了某个数据页做了什么修改，比如“ 对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新 ”，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><p>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要急着将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</p><h4 id="为什么需要redo-log">为什么需要redo log？</h4><p>redo log用来实现<strong>WAL （Write-Ahead Logging）技术</strong>：MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</p><p>这样做的好处在于： （1）写入 redo log 的方式使用了追加操作，所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写，顺序写比随机写高效的多，因此 redo log 写入磁盘的开销更小 （2）<strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失</p><p>整个更新的流程如下：</p><p><img src="Pasted%20image%2020240411154002.png"></p><p>其实如果熟悉文件系统的话，会明白这就是文件系统日志层提供的功能，xv6中的log_write()函数会将对磁盘的写入先记录在日志中，然后将日志刷入磁盘，之后再把数据刷入磁盘。</p><h4 id="redo-log写入磁盘的时机">redo log写入磁盘的时机</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim">问题：<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> 要写到磁盘，数据也要写磁盘，为什么要多此一举？<br>答案：<br>（<span class="hljs-number">1</span>）将磁盘的随机写行为转换为<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span>的顺序写（追加写是一种顺序写），效率更高<br>（<span class="hljs-number">2</span>）实现事务的持久性，提供崩溃恢复的能力（已提交的事务不会崩溃，未提交的事务当作没发生，不会出现数据写磁盘写一办后崩溃导致错误的情况）<br><br>追问：产生的 <span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> 是直接写入磁盘的吗？<br>答案：不是，因为这样会产生大量IO，<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> 也有自己的缓存<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">buffer</span>，每当产生一条 <span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> 时，会先写入到 <span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">buffer</span><br><br>追问：那<span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span>会在什么时候写入磁盘呢？<br>答案：<br>（<span class="hljs-number">1</span>）MySQL 正常关闭时；<br>（<span class="hljs-number">2</span>）当 <span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">buffer</span> 中记录的写入量大于 <span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">buffer</span> 内存空间的一半时，会触发落盘<br>（<span class="hljs-number">3</span>）InnoDB 的后台线程每隔 <span class="hljs-number">1</span> 秒，将 <span class="hljs-keyword">redo</span> <span class="hljs-built_in">log</span> <span class="hljs-keyword">buffer</span> 持久化到磁盘<br>（<span class="hljs-number">4</span>）每次事务提交时根据innodb_flush_log_at_trx_commit 参数决定刷盘策略<br></code></pre></td></tr></table></figure><p>innodb_flush_log_at_trx_commit有0、1、2三种取值，分别代表了不同的策略： （0）表示每次事务提交时 ，<strong>将 redo log 留在 redo log buffer 中</strong> ，该模式下在事务提交时不会主动触发写入磁盘的操作。直接在内存操作，开销最小 （1）表示每次事务提交时，<strong>将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</strong>，涉及到系统调用和磁盘IO，开销最大 （2）表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log <strong>写到 redo log 文件</strong>。注意：写入到文件并不等于写入到磁盘（这里又是文件系统的知识），只涉及到系统调用，没有涉及到磁盘IO，开销适中</p><p><img src="Pasted%20image%2020240411162914.png"></p><p>所以参数0和2都没有直接写入磁盘，因此需要等待其他刷盘条件触发，例如InnoDB 的后台线程每隔 1 秒： - 针对参数 0 ：会把缓存在 redo log buffer 中的 redo log ，通过调用 <code>write()</code> 写到操作系统的 Page Cache，然后调用 <code>fsync()</code> 持久化到磁盘。<strong>所以参数为 0 的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失</strong>;</p><ul><li>针对参数 2 ：调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log 持久化到磁盘。<strong>所以参数为 2 的策略，较取值为 0 情况下更安全，因为 MySQL 进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失</strong>。</li></ul><p>我们可以发现：数据安全性和写入性能是不可得兼的，<strong>要不追求数据安全性，牺牲性能；要不追求性能，牺牲数据安全性</strong>。</p><h4 id="redo-log-文件写满了怎么办">redo log 文件写满了怎么办？</h4><p>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ：<code>ib_logfile0</code> 和 <code>ib_logfile1</code> 。</p><p>重做日志文件组是以<strong>循环写</strong>的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形</p><p>所以 InnoDB 存储引擎会先写 ib_logfile0 文件，当 ib_logfile0 文件被写满的时候，会切换至 ib_logfile1 文件，当 ib_logfile1 文件也被写满时，会切换回 ib_logfile0 文件</p><p><img src="Pasted%20image%2020240411221019.png"></p><p>redo log 是为了防止 Buffer Pool 中的脏页丢失而设计的，随着系统运行，Buffer Pool 的脏页刷新到了磁盘中，那么 redo log 对应的记录也就没用了，可以擦除</p><p>redo log 是循环写的方式，相当于一个环形，InnoDB 用 write pos 表示 redo log 当前记录写到的位置，用 checkpoint 表示当前要擦除的位置</p><p><img src="Pasted%20image%2020240411180259.png"></p><ul><li>write pos 和 checkpoint 的移动都是顺时针方向；</li><li>write pos ～ checkpoint 之间的部分（图中的红色部分），用来记录新的更新操作；</li><li>check point ～ write pos 之间的部分（图中蓝色部分）：待落盘的脏数据页记录；</li></ul><p>如果 write pos 追上了 checkpoint，就意味着 redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞，此时会停下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针），然后 MySQL 恢复正常运行，继续执行新的更新操作</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel">问题：为什么要注重<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>的大小设置？<br>答案：针对并发量大的系统，如果<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>太小，很容易导致<span class="hljs-keyword">log</span>写满，进而阻塞MySQL的更新操作，使得业务停滞，因此要非常注意<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>的大小<br></code></pre></td></tr></table></figure><h3 id="binlog">binlog</h3><p>前面介绍的 undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。</p><p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件</p><p>binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mel">问题：为什么有了 binlog， 还要有<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>？<br>答案：这个问题跟 MySQL 的时间线有关系，最开始 MySQL 里并没有 InnoDB 引擎，没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，使用 <span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 来实现 crash-safe 能力<br><br>追问：binlog和<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>有什么区别？<br>答案：<br>（<span class="hljs-number">1</span>）适用对象不同。binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用。<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 是 Innodb 存储引擎实现的日志<br>（<span class="hljs-number">2</span>）写入方式不同。binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志。<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 是循环写，日志空间大小是固定，全部写满就从头开始<br>（<span class="hljs-number">3</span>）用途不同。binlog 用于备份恢复、主从复制，<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 用于掉电等故障恢复<br><br>追问：如果不小心整个数据库的数据被删除了，能使用 <span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 文件恢复数据吗？<br>答案：不可以使用 <span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span> 文件恢复，只能使用 binlog 文件恢复，因为<span class="hljs-keyword">redo</span> <span class="hljs-keyword">log</span>的任务是让数据安全的刷入磁盘不因为崩溃丢失，但是不能恢复主动删除的数据。binlog因为记录了所有的更新操作，所以可以复原。<br></code></pre></td></tr></table></figure><h4 id="binlog什么时候刷盘">binlog什么时候刷盘？</h4><p>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，<strong>执行器</strong>把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache</p><p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率，具体和redo log的innodb_flush_log_at_trx_commit是类似的。 ​（1）当sync_binlog=0的时候，表示每次提交事务都只write，不fsync ​（2）当sync_binlog=1的时候，表示每次提交事务都执行fsync （3）当sync_binlog=N的时候，表示每次提交事务都write，但积累N个事务后才fsync。</p><h4 id="如何实现主从复制">如何实现主从复制？</h4><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上</p><p>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成</p><p>MySQL 集群的主从复制过程梳理成 3 个阶段： （1）<strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据 MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应 （2）<strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中 从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。 （3）<strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据 从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua">问题：从库是不是越多越好？<br>答案：不是，从库数量增加，从库连接上来的 I/O 线程也比较多，主库也要创建同样多的 <span class="hljs-built_in">log</span> <span class="hljs-built_in">dump</span> 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽，导致较长的主从延迟<br><br>追问：一般主从复制的模型是什么样的？<br>答案：一个主库一般跟 <span class="hljs-number">2</span>～<span class="hljs-number">3</span> 个从库（<span class="hljs-number">1</span> 套数据库，<span class="hljs-number">1</span> 主 <span class="hljs-number">2</span> 从 <span class="hljs-number">1</span> 备主）<br><br>追问：如何解决主从延迟问题？<br>答案：<br>（<span class="hljs-number">1</span>）架构层面采用分库架构，让不同的业务请求分散到不同的数据库服务上，分散单台机器的压力<br>（<span class="hljs-number">2</span>）配置方面修改sync_binlog参数的值，从<span class="hljs-number">1</span>变成<span class="hljs-number">100</span>~<span class="hljs-number">1000</span><br>（<span class="hljs-number">3</span>）采用并行复制策略，将SQL线程转化成多个线程来进行重放，加快对DML数据的处理速度，从而减缓主从延迟<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">问题：什么情况下会出现主从延迟？<br>答案：<br>（<span class="hljs-number">1</span>）从库机器性能比主库差<br>（<span class="hljs-number">2</span>）从库处理的读请求过多，占据了大量CPU资源<br>（<span class="hljs-number">3</span>）从库太多，主库需要将 <span class="hljs-keyword">binlog </span>同步到所有的从库，如果从库数量太多，会增加同步的时间和开销<br>（<span class="hljs-number">4</span>）出现大事务，大事务执行时间长因此非常容易造成主从延迟，因此要尽量分批进行<br>（<span class="hljs-number">5</span>）采用半同步复制替代异步复制<br></code></pre></td></tr></table></figure><h3 id="一条update语句的执行流程">一条update语句的执行流程</h3><p>前面的步骤都和select语句一样，从连接器、解析器、预处理器、优化器到执行器。不同之处就在于执行器的执行。</p><p>具体更新一条记录 <code>UPDATE t_user SET name = 'cygnus' WHERE id = 1;</code> 的流程如下： （1）执行器调用存储引擎的接口，通过主键索引树搜索获取 id = 1 这一行记录 如果 id=1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新 如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器 （2）执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样 如果一样的话就不进行后续更新流程 如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作 （3）开启事务， InnoDB 层更新记录前，首先生成一条 undo log写入Buffer Pool 中的 Undo 页面维护版本链 （4）InnoDB 层开始更新记录，将记录写入内存（同时标记为脏页），然后创建一条 redo log，写入到redo log buffer（此时更新完成，剩下的写入磁盘操作会由后台线程选择合适的时机来完成，这就是WAL技术） （5）在一条更新语句执行完成后，然后生成该语句对应的 binlog，保存到binlog cache （6）事务完成，开始「两阶段提交」</p><h3 id="两阶段提交">两阶段提交</h3><h4 id="为什么需要两阶段提交">为什么需要两阶段提交？</h4><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成主从库数据不一致。前者成功后者失败，则主库的数据更多，后者成功前者失败，则从库的数据更多。</p><p><strong>MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决</strong></p><h4 id="如何实现两阶段提交">如何实现两阶段提交？</h4><p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 开启一个内部 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong>，如下图： <img src="Pasted%20image%2020240411213234.png"></p><p>（1）<strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用） （2）<strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit</p><p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 prepare 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID： （1）<strong>如果 binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则回滚事务</strong>。对应时刻 A 崩溃恢复的情况 （2）<strong>如果 binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则提交事务</strong>。对应时刻 B 崩溃恢复的情况。</p><p>可以发现，<strong>两阶段提交是以 binlog 写成功为事务提交成功的标识</strong></p><p>注意：两阶段提交看起来似乎是redo log和binlog按顺序刷盘，但实际上redo log还有1s间隔这种刷盘条件，因此<strong>事务没提交的时候，redo log 也是可能被持久化到磁盘的</strong>。但是仍然不会引发主从不一致的问题，因为如果发生崩溃，在重启时，会拿着已经写入磁盘的redo log的XID去 binlog 查看是否存在此 XID，如果没有会发生回滚</p><p><strong>所以， redo log 可以在事务没提交之前持久化到磁盘，但是 binlog 必须在事务提交之后，才可以持久化到磁盘</strong></p><h4 id="两阶段提交有什么问题">两阶段提交有什么问题？</h4><p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差： （1）<strong>磁盘 I/O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘 （2）<strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致</p><h4 id="磁盘io太高怎么办">磁盘IO太高怎么办？</h4><p>事务在提交的时候，需要将 binlog 和 redo log 持久化到磁盘，如果出现 MySQL 磁盘 I/O 很高的现象，可以通过控制以下参数，来 “延迟” binlog 和 redo log 刷盘的时机，从而降低磁盘 I/O 的频率。 （1）设置组提交的两个参数： binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，延迟 binlog 刷盘的时机，从而减少 binlog 的刷盘次数 （2）将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000），表示每次提交事务都 write，但累积 N 个事务后才 fsync，相当于延迟了 binlog 刷盘的时机 （3）将 innodb_flush_log_at_trx_commit 设置为 2。表示每次事务提交时，都只是将 redo log 写到 redo log 文件而不是直接写入磁盘</p><h2 id="读写分离分库分表冷热分离">读写分离、分库分表、冷热分离</h2><p>读写分离主要应对的是数据库读并发问题，分库分表主要应对数据库存储问题</p><h3 id="读写分离">读写分离</h3><p><strong>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上</strong>，一般我们会选择一主多从的形式。</p><h4 id="如何实现读写分离">如何实现读写分离</h4><p>不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步： （1）部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。 （2）保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的<strong>主从复制</strong>。 （3）系统将写请求交给主数据库处理，读请求交给从数据库处理。</p><p>落实到项目本身的话，常用的方式有两种： （1）代理方式 在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。 在 MySQL 8.2 的版本中，MySQL Router 能自动分辨对数据库读写/操作并把这些操作路由到正确的实例上。这是一项有价值的功能，可以优化数据库性能和可扩展性，而无需在应用程序中进行任何更改 （2）组件方式 引入第三方组件来帮助完成读写请求，这种方式目前在各种互联网公司中用的最多的</p><h3 id="分库分表">分库分表</h3><h4 id="什么是分库">什么是分库？</h4><p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库 （1）<strong>垂直分库</strong> 就是把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库 举个例子：说你将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。 （2）<strong>水平分库</strong> 是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展 举个例子：订单表数据量太大，对订单表进行了水平切分（水平分表），然后将切分后的 2 张订单表分别放在两个不同的数据库</p><h4 id="什么是分表">什么是分表？</h4><p><strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分 （1）<strong>垂直分表</strong> 是对数据表列的拆分，把一张列比较多的表拆分为多张表。 举个例子：可以将用户信息表中的一些列单独抽出来作为一个表 （2）<strong>水平分表</strong> 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题 举个例子：可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响 水平拆分只能解决单表数据量大的问题，为了提升性能，我们通常会选择将拆分后的多张表放在不同的数据库中。也就是说，水平分表通常和水平分库同时出现</p><h4 id="什么情况下需要分库分表">什么情况下需要分库分表？</h4><p>（1）单表的数据达到千万级别以上，数据库读写速度比较缓慢。 （2）数据库中的数据占用的空间越来越大，备份时间越来越长。 （3）应用的并发量太大（应该优先考虑其他性能优化方法，而非分库分表）</p><h4 id="常见的分片算法有哪些">常见的分片算法有哪些？</h4><p>分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。 （1）<strong>哈希分片</strong>：求指定分片键的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。哈希分片可以使每个表的数据分布相对均匀，但对动态伸缩（例如新增一个表或者库）不友好。 （2）<strong>范围分片</strong>：按照特定的范围区间（比如时间区间、ID 区间）来分配数据，比如 将 <code>id</code> 为 <code>1~299999</code> 的记录分到第一个表， <code>300000~599999</code> 的分到第二个表。范围分片适合需要经常进行范围查找且数据分布均匀的场景，不太适合随机读写的场景 （3）<strong>映射表分片</strong>：使用一个单独的表（称为映射表）来存储分片键和分片位置的对应关系。映射表分片策略可以支持任何类型的分片算法，如哈希分片、范围分片等。映射表分片策略是可以灵活地调整分片规则，不需要修改应用程序代码或重新分布数据。不过，这种方式需要维护额外的表，还增加了查询的开销和复杂度。 （4）<strong>一致性哈希分片</strong>：将哈希空间组织成一个环形结构，将分片键和节点（数据库或表）都映射到这个环上，然后根据顺时针的规则确定数据或请求应该分配到哪个节点上，解决了传统哈希对动态伸缩不友好的问题。 （5）<strong>地理位置分片</strong>：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置（如城市、地域）来分配数据。</p><h4 id="分库分表会带来什么问题">分库分表会带来什么问题？</h4><p>在做技术决策之前，不光是要考虑这个技术能不能满足我们的要求，是否适合当前业务场景，还要重点考虑其带来的成本 （1）<strong>join 操作</strong>：同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作 很多大厂的资深 DBA 都是建议尽量不要使用 join 操作。因为 join 的效率低，并且会对分库分表造成影响。对于需要用到 join 操作的地方，可以采用多次查询业务层进行数据组装的方法 （2）<strong>事务问题</strong>：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。答案是分布式事务 （3）<strong>分布式 ID</strong>：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。如何为不同的数据节点生成全局唯一主键呢？答案是分布式 ID （4）<strong>跨库聚合查询问题</strong>：分库分表会导致常规聚合查询操作，如 group by，order by 等变得异常复杂。这是因为这些操作需要在多个分片上进行数据汇总和排序，而不是在单个数据库上进行。为了实现这些操作，需要编写复杂的业务代码，或者使用中间件来协调分片间的通信和数据传输</p><p><strong>现在很多公司都是用的类似于 TiDB 这种分布式关系型数据库，不需要我们手动进行分库分表（数据库层面已经帮我们做了），也不需要解决手动分库分表引入的各种问题，直接一步到位，内置很多实用的功能</strong></p><h3 id="冷热分离">冷热分离</h3><p>数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中</p><p>这样做的好处在于节省成本，有一些数据不能丢，但是属于冷数据，可以分配一些性能欠佳的服务器节省成本</p><p>冷热分离的思想非常简单，就是对数据进行分类，然后分开存储。冷热分离的思想可以应用到很多领域和场景中，而不仅仅是数据存储，这在生活中也很常见，例如将常用的物品放在显眼的位置，不常用的物品放入储藏室</p><h4 id="如何区分冷热数据">如何区分冷热数据</h4><p>（1）<strong>时间维度区分</strong>：按照数据的创建时间、更新时间、过期时间等，将一定时间段内的数据视为热数据，超过该时间段的数据视为冷数据。例如，订单系统可以将 1 年前的订单数据作为冷数据，1 年内的订单数据作为热数据。这种方法适用于数据的访问频率和时间有较强的相关性的场景。</p><p>（2）<strong>访问频率区分</strong>：将高频访问的数据视为热数据，低频访问的数据视为冷数据。例如，内容系统可以将浏览量非常低的文章作为冷数据，浏览量较高的文章作为热数据。这种方法需要记录数据的访问频率，成本较高，适合访问频率和数据本身有较强的相关性的场景。</p><p>具体要根据实际业务场景决定，例如几年前的数据并不一定都是冷数据，例如一些优质文章发表几年后依然有很多人访问</p><h4 id="实际应用情况">实际应用情况</h4><p>冷数据的存储要求主要是容量大，成本低，可靠性高，访问速度可以适当牺牲</p><p>冷数据存储方案： （1）中小厂：直接使用 MySQL/PostgreSQL 即可（不改变数据库选型和项目当前使用的数据库保持一致），比如新增一张表来存储某个业务的冷数据或者使用单独的冷库来存放冷数据（涉及跨库查询，增加了系统复杂性和维护难度） （2）大厂：Hbase（常用）、RocksDB、Doris、Cassandra</p><p>如果公司成本预算足的话，也可以直接上 TiDB 这种分布式关系型数据库，直接一步到位。TiDB 6.0 正式支持数据冷热存储分离，可以降低 SSD 使用成本。使用 TiDB 6.0 的数据放置功能，可以在同一个集群实现海量数据的冷热存储，将新的热数据存入 SSD，历史冷数据存入 HDD</p><h2 id="总结">总结</h2><p>回答下面的问题可以很好的校验对知识的掌握程度 #### 基础部分 （1）<strong>为什么会有utf8mb4？和utf8有什么不同？</strong> （2）char和varchar有什么区别？ （3）<strong>说一下数据库的三大范式</strong> （4）删除表数据后表的大小却没有变动,这是为什么?</p><h4 id="架构部分">架构部分</h4><p>（1）<strong>执行一条select语句的过程中发生了什么？</strong></p><h4 id="存储引擎-1">存储引擎</h4><p>（1） <strong>MySQL 一行记录是怎么存储的？</strong> （2）<strong>为什么 MySQL 采用 B+ 树作为索引？</strong> （3）MyISAM 与 InnoDB 的区别是什么？ （5）使用 Innodb 的情况下，一条更新语句是怎么执行的? （6）为什么 VarChar 建议不要超过255？ （7）<strong>buffer pool 是做什么的？</strong> （8）如何避免缓存失效？</p><h4 id="索引-1">索引</h4><p>（1）什么是索引? （2）<strong>索引失效有哪些情况？</strong> （3）什么是回表? （4）什么是索引下推? （5）什么是覆盖索引? （6）什么是最左前缀原则? （7）普通索引和唯一索引该怎么选择?</p><h4 id="事务-1">事务</h4><p>（1）什么是事务?其特性是什么? （2）<strong>事务的隔离级别是什么？如何实现？</strong> （3）说一说 mvcc 吧，有什么作用? （4）为什么不要使用长事务? 更大的主从延迟；锁定太多的数据，造成阻塞和锁超时；回滚耗时长；undo log膨胀 （5）<strong>mysql如何实现可重复读？能解决幻读吗？什么情况下仍然会发生？如何尽可能避免？</strong></p><h4 id="锁-1">锁</h4><p>（1）<strong>mysql中有哪些锁？分别有什么应用场景？有什么缺点？</strong> （2）<strong>什么情况下会发生死锁？如何解决死锁？</strong> （3） <strong>select......for update会锁表还是锁行？</strong></p><h4 id="日志-1">日志</h4><p>（1）如果数据库的数据被误删了，如何恢复？ （2）什么是预读？什么时候会发生预读失效？ （3）buffer pool是一种什么样的结构？ （4）WAl 是什么?有什么好处? （5）<strong>binlog 是做什么的?</strong> （6）<strong>undo log 是做什么的?</strong> （7）relaylog 是做什么的? （8）<strong>redo log 是做什么的?</strong> （9）redo log 是怎么记录日志的? （10）redolog 和 binlog 的区别是什么? （11）Mysql 主从之间是怎么同步数据的？主从延迟要怎么解决？ （12）Innodb 事务为什么要两阶段提交? （13）<strong>如何进行主从复制？</strong></p><h4 id="综合">综合</h4><p>（1）使用 Innodb 的情况下，一条更新语句是怎么执行的? （2）一条 Sql 语句查询偶尔慢会是什么原因? - 数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘<br>- 执行的时候遇到锁，如表锁、行锁 （3）一条 Sql 语句查询一值慢会是什么原因？ - 没有用索引或索引失效 （4）怎样使用explain的？对于执行计划你是怎样分析的？ 通过<strong>type</strong>判断索引的使用情况 （5）说说你的 Sql 调优思路 - 打开慢查询日志，这样可以定位到执行慢的SQL语句 - 利用explain查看执行计划，大多数情况下慢的原因在于索引，根据type判断索引使用情况 （6）为什么不要使用长事务？ - 并发情况下，连接池容易被撑爆 - 锁定太多的数据，造成大量的阻塞和锁超时 - 执行时间长，容易造成主从延迟 （7）如何避免长事务？ - 在一个事务里面， 避免一次处理太多数据 - 在一个事务里面， 避免耗时太多的操作，造成事务超时。一些非DB的操作，比如rpc调用，消息队列的操作尽量放到事务之外操作</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库, mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book-Chapter6-Lock</title>
    <link href="/2024/03/16/xv6-book-Chapter6/"/>
    <url>/2024/03/16/xv6-book-Chapter6/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter6-lock">Chapter6 Lock</h1><p>设计操作系统时最需要关注的三个重点：虚拟化、并发、持久化。 <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">（<span class="hljs-number">1</span>）虚拟化就是为每个程序都提供自己独占<span class="hljs-meta">CPU</span>或内存的假象<br>（<span class="hljs-number">2</span>）并发需要关注多个线程或应用程序间可能出现的竞争现象<br>（<span class="hljs-number">3</span>）持久性则关注让用户数据等保存在机器上而不受机器崩溃的影响<br></code></pre></td></tr></table></figure></p><p>内核之中总是遍布着各种共享数据结构。例如，多个CPU可以同时地调用kalloc，并发地从free-list上取出第一页。并发可以带来更好的性能。但也需要花费较多的精力提供<strong>正确性</strong>。</p><p>本篇的内容主要围绕 <strong>锁</strong> 展开，这是解决并发问题的核心工具之一。</p><p><strong>临界区Critical Section</strong>：当多个CPU访问共享资源的代码段</p><p><strong>竞态条件Race Condition</strong>：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件，导致竞态条件发生的代码区称作临界区</p><p>所谓的锁解决的就是用来保证临界区中工作<strong>原子性atomic</strong>的同步工具，本质是让并发操作串行化</p><p>以XV6为例子，内核之中总是遍布着各种共享数据结构。例如，多个CPU可以同时地调用kalloc，并发地从free-list上取出第一页。这就涉及到了并发问题。</p><h2 id="锁的基本原理">锁的基本原理</h2><p>那么锁到底是怎么实现的呢？在<a href>并发基础</a>中我讲到了锁的核心是清空MESI中的invalid queue和store buffer。而这种硬件指令需要CPU提供（CPU保证在执行这一指令时，其他CPU核不能读或写对应的内存地址）</p><p>具体来说，以xv6为例，acquire操作需要__sync_lock_test_and_set()，而它其实是C语言对汇编指令amoswap的封装，amoswap实现了在一条指令完成一次 load 和 store，也就是将将一个寄存器的值和某一内存地址的值做交换</p><p>所以xv6锁的一种基础实现是下面的过程：</p><p>acquire -&gt; __sync_lock_test_and_set() -&gt; amoswap -&gt; load and store</p><p>看来锁的实现需要依赖硬件提供的原子操作，但其实这样的原子操作不止一种</p><h4 id="用来实现锁的硬件指令">用来实现锁的硬件指令</h4><p>注意：这些原子指令的逻辑会使用c语言来展示，但请注意它们是由硬件提供并非真的由C语言来实现。</p><p>（1）<strong>test_and_set</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//__sync_lock_test_and_set()</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">TestAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> *old_ptr, <span class="hljs-type">int</span> new)</span>&#123;<br>  <span class="hljs-type">int</span> old = *old_ptr;  <span class="hljs-comment">// 获取旧的值</span><br>  *old_ptr = new;      <span class="hljs-comment">// 存储新的值</span><br>  <span class="hljs-keyword">return</span> old;          <span class="hljs-comment">// 返回旧的值</span><br>&#125;<br><br><span class="hljs-comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span><br><span class="hljs-comment">//   a5 = 1</span><br><span class="hljs-comment">//   s1 = &amp;lk-&gt;locked</span><br><span class="hljs-comment">//   amoswap.w.aq a5, a5, (s1)</span><br></code></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_t</span>&#123;</span><br>  <span class="hljs-type">int</span> flag;<br>&#125; <span class="hljs-type">lock_t</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span>&#123;<br>  lock-&gt;flag = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 0表示锁可用，1表示锁已被占用</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span>&#123;<br>  <span class="hljs-keyword">while</span>(TestAndSet(&amp;lock-&gt;flag, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)  <span class="hljs-comment">// 第一个执行TestAndSet的线程会得到旧值0而跳出循环</span><br>    ;  <span class="hljs-comment">// 不做任何事情，只是自旋地等待</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span>&#123;<br>  lock-&gt;flag = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  init(&amp;<span class="hljs-type">lock_t</span>);<br><br>  <span class="hljs-keyword">do</span>&#123;<br>    lock(&amp;<span class="hljs-type">lock_t</span>);<br><br>    <span class="hljs-comment">// 临界区</span><br><br>    unlock(&amp;<span class="hljs-type">lock_t</span>);<br>  &#125;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br><br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>test-and-set指令是一种用来将1 (set)写入一个内存位置，并以单个原子的形式返回其旧值的不可中断操作，一开始锁的值是0，当一个进程访问时被设置为新值1，返回旧值0，跳出循环。其他进程进入时该锁已经被设置为1，因此返回旧值也为1，不能跳出循环，一直自旋，直到第一个进程释放锁，也就是讲锁的值变为0。</p><p>（2）<strong>Compare and Swap</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">CompareAndSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr, <span class="hljs-type">int</span> expected, <span class="hljs-type">int</span> new)</span>&#123;<br>  <span class="hljs-type">int</span> actual = *ptr;<br>  <span class="hljs-keyword">if</span>(actual == expected)<br>    *ptr = new;<br>  <span class="hljs-keyword">return</span> actual;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span>&#123;<br>  <span class="hljs-keyword">while</span>(CompareAndSwap(&amp;lock-&gt;flag, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>    ;<br>&#125;<br></code></pre></td></tr></table></figure><p>检测ptr指向的值是否和expected相等。如果是，就更新ptr的值为new，否则什么也不更新。无论如何，最后都返回该内存地址的实际值actual</p><p>（3）<strong>Fetch and Add</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">FetchAndAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> *ptr)</span>&#123;<br>  <span class="hljs-type">int</span> old = *ptr;<br>  *ptr = old + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> old;<br>&#125;<br></code></pre></td></tr></table></figure><p>指令让特定地址的值自增1，并且返回旧值，整个过程是原子的。这一点和test-and-set很相似，但是我们现在可以用fetch-and-add指令实现<strong>ticket</strong>锁，这是对传统自旋锁的优化，后文再详细描述。</p><h2 id="自旋锁">自旋锁</h2><p>这是一种用原地等待的方式解决资源冲突的锁 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_t</span>&#123;</span><br>  <span class="hljs-type">int</span> flag;<br>&#125; <span class="hljs-type">lock_t</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span>&#123;<br>  lock-&gt;flag = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 0表示锁可用，1表示锁已被占用</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span>&#123;<br>  <span class="hljs-keyword">while</span>(TestAndSet(&amp;lock-&gt;flag, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)  <span class="hljs-comment">// 第一个执行TestAndSet的线程会得到旧值0而跳出循环</span><br>    ;  <span class="hljs-comment">// 不做任何事情，只是自旋地等待</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *lock)</span>&#123;<br>  lock-&gt;flag = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>xv6在kernel/spinlock.c实现了自旋锁。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Mutual exclusion lock.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> &#123;</span><br>  uint locked;       <span class="hljs-comment">// Is the lock held?</span><br><br>  <span class="hljs-comment">// For debugging:</span><br>  <span class="hljs-type">char</span> *name;        <span class="hljs-comment">// Name of lock.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">cpu</span>;</span>   <span class="hljs-comment">// The cpu holding the lock.</span><br>&#125;;<br><br><span class="hljs-comment">// Acquire the lock.</span><br><span class="hljs-comment">// Loops (spins) until the lock is acquired.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>  push_off(); <span class="hljs-comment">// disable interrupts to avoid deadlock.</span><br>  <span class="hljs-keyword">if</span>(holding(lk))<br>    panic(<span class="hljs-string">&quot;acquire&quot;</span>);<br><br>  <span class="hljs-comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span><br>  <span class="hljs-comment">//   a5 = 1</span><br>  <span class="hljs-comment">//   s1 = &amp;lk-&gt;locked</span><br>  <span class="hljs-comment">//   amoswap.w.aq a5, a5, (s1)</span><br>  <span class="hljs-keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)<br>    ;<br><br>  <span class="hljs-comment">// 即 memory barrior</span><br>  <span class="hljs-comment">// it tells the compiler and CPU to not reorder loads or stores across the barrier</span><br>  __sync_synchronize();<br><br>  <span class="hljs-comment">// Record info about lock acquisition for holding() and debugging.</span><br>  lk-&gt;cpu = mycpu();<br>&#125;<br><br><span class="hljs-comment">// Release the lock.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(!holding(lk))<br>    panic(<span class="hljs-string">&quot;release&quot;</span>);<br><br>  lk-&gt;cpu = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// On RISC-V, this emits a fence instruction.</span><br>  __sync_synchronize();<br><br>  <span class="hljs-comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span><br>  <span class="hljs-comment">// This code doesn&#x27;t use a C assignment, since the C standard</span><br>  <span class="hljs-comment">// implies that an assignment might be implemented with</span><br>  <span class="hljs-comment">// multiple store instructions.</span><br>  <span class="hljs-comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span><br>  <span class="hljs-comment">//   s1 = &amp;lk-&gt;locked</span><br>  <span class="hljs-comment">//   amoswap.w zero, zero, (s1)</span><br>  __sync_lock_release(&amp;lk-&gt;locked);<br><br>  pop_off();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>自旋锁使用Test and set或者 campare and swap实现，具有忙等的缺点和不用上下文切换的优点。因此在临界区比较短的情况下是个很好的选择。</p><p>基于CAS的实现速度很快，尤其是在没有真正竞态的情况下（事实上大部分时候就是这种情况）， 但这种方法存在一个缺点：它是「不公平」的，容易导致饥饿。 一旦spinlock被释放，第一个能够成功执行CAS操作的CPU将成为锁的拥有者，但这个CPU大概率不是等待时间最长的那个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">问题：为什么说大概率不是等待时间最长的那个CPU获得锁？<br>答案：由于MESI协议，如果spinlock的值没有更改，那么在busy wait时，试图获取spinlock的CPU，只需要不断地读取自己包含这个spinlock变量的cache line上的值就可以了。但是当锁被释放，该cache line的值被修改，其他CPU上的cache line变为invalid，读取时需要从内存读取新的spinlock的值到自己的cache line中。释放锁的那个CPU会有最大概率再次获得锁<br></code></pre></td></tr></table></figure><h4 id="自旋锁的第一次优化ticket-spinlock">自旋锁的第一次优化：Ticket Spinlock</h4><p>Ticket Spinlock为了解决公平问题而出现，主要的思路是用两个变量来实现<strong>排队取号，按号取锁</strong>。 （1）排队取号。用变量next表示现在已经排到的号码，每个CPU持有锁前需要取号，假设号码为n（这个过程是原子的，利用<strong>Fetch and Add</strong>实现） （2）按号取锁。使用owner变量表示现在正在工作的号码，如果n == owner则获得锁</p><p>具体可以看下面的伪代码实现： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-type">atomic_t</span>  val;<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">raw_tickets</span> &#123;</span><br>                        u16 next;<br>                        u16 owner;<br>                &#125; tickets;<br>        &#125;;<br>&#125; <span class="hljs-type">arch_spinlock_t</span>;<br><br><span class="hljs-comment">//加锁</span><br>spin_lock(lock *l)<br>&#123;<br><span class="hljs-comment">//该函数对原子类型的变量进行原子读操作，它返回原子类型的变量v的值</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-type">atomic_add</span>(<span class="hljs-number">1</span>, l.next);  <span class="hljs-comment">//先拿票</span><br>    <span class="hljs-keyword">while</span>(n != <span class="hljs-type">atomic_read</span>(l.owner) + <span class="hljs-number">1</span>)  <span class="hljs-comment">//查看是否轮到自己</span><br>        cpu_relax();<br>&#125;<br> <br><span class="hljs-comment">//放锁</span><br>spin_unlock(lock *l)<br>&#123;<br>    <span class="hljs-type">atomic_add</span>(<span class="hljs-number">1</span>, l.owner); <span class="hljs-comment">//服务完成，叫下一号</span><br>&#125;<br><br>从lock和unlock可以看出，在ticket spinlock中，<span class="hljs-string">&quot;compare&quot;</span>和<span class="hljs-string">&quot;swap&quot;</span>的操作就分离了。把spinlock当前的值和旧的值进行比较（compare），还是由每个试图获得spinlock的CPU来执行的，但设置新的值（swap），则是由上一个持有spinlock的CPU来完成的。<br><br></code></pre></td></tr></table></figure></p><p>使用ticket spinlock可以让CPU按照到达的先后顺序，去获取spinlock的所有权，形成了「有序竞争」。所有都CPU都像在银行办理业务一样，先取号，等叫号匹配上就能持有办理业务（持有锁）</p><p>然而在这样优化之后会发现一个新问题，由于给CPU排了先后顺序，所以其实只有一个CPU（排序最靠前的CPU）可以获得spinlock，也只有它的cache line被invalidate才是有意义的，对于其他的CPU来说，这就是做无用功。内存比cache慢那么多，开销不小。因此还存在进一步优化的空间</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">举例子：<br>用银行叫号来类比，假设现在2号客户的业务办理完了，接下来就该在大厅里叫3号，然后3号客户去办理，但是所有排号的，4号、5号……哪怕是20号，也得听一下叫的号，这何苦呢？<br></code></pre></td></tr></table></figure><h4 id="自旋锁的第二次优化mcs-lock">自旋锁的第二次优化：MCS Lock</h4><p>无论是简单的非公平自旋锁（Spinlock）还是公平的基于排队的自旋锁（Ticket Spinlock），由于执行线程均在同一个共享变量上自旋，申请和释放锁的时候必须对该共享变量进行修改，这将导致所有参与排队自旋锁操作的处理器的缓存变得无效（<strong>缓存穿透</strong>）。如果排队自旋锁竞争比较激烈的话，频繁的缓存同步操作会导致繁重的系统总线和内存的流量，从而大大降低了系统整体的性能</p><p>MCS Lock作为一种高性能的公平自旋锁，在ticket spinlock基础上引入了单向链表。申请加锁的线程只需要在本地变量上自旋，直接前驱负责通知其结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">int</span> locked; <br>&#125;;<br></code></pre></td></tr></table></figure><p>每当一个CPU试图获取一个spinlock，它就会将自己的MCS lock加到这个spinlock的等待队列，成为该队列的一个节点(node)，加入的方式是由该队列末尾的MCS lock的&quot;next&quot;指向这个新的MCS lock</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//加锁</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mcs_spin_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mcs_spinlock **lock, <span class="hljs-keyword">struct</span> mcs_spinlock *node)</span><br>&#123;<br><span class="hljs-comment">// 初始化node</span><br>node-&gt;locked = <span class="hljs-number">0</span>;<br>node-&gt;next   = <span class="hljs-literal">NULL</span>;<br><br>    <br>    <span class="hljs-comment">//xchg是x86的原子指令之一，可以用来实现Compare and Swap或者Test and Set，自带lock语义</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">xchg(*ptr, x)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">ret = *ptr;</span><br><span class="hljs-comment">*ptr = x;</span><br><span class="hljs-comment">return ret;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 找队列末尾的那个mcs lock</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">prev</span> =</span> xchg(lock, node);<br><span class="hljs-comment">// likely()是一种指定CPU分支预测方向的语句，表示大多数情况下下队列都是空的，为空则获得锁</span><br><span class="hljs-keyword">if</span> (likely(prev == <span class="hljs-literal">NULL</span>)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//READ_ONCE()和WRITE_ONCE()这两个宏中起到关键作用的是 volatile ，它主要告诉编译器：</span><br><span class="hljs-comment">1、声明这个变量很重要，不要把它当成一个普通的变量，做出错误的优化。</span><br><span class="hljs-comment">2、保证 CPU 每次都从内存重新读取变量的值，而不是用寄存器中暂存的值。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 队列不为空，把自己加到队列的末尾</span><br>WRITE_ONCE(prev-&gt;next, node);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#define arch_mcs_spin_lock_contended(l)</span><br><span class="hljs-comment">do &#123;</span><br><span class="hljs-comment">smp_cond_load_acquire(l, VAL);</span><br><span class="hljs-comment">&#125; while (0)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 等待lock的持有者把lock传给自己，arch_mcs_spin_lock_contended是陷入自旋锁</span><br>arch_mcs_spin_lock_contended(&amp;node-&gt;locked);<br>&#125;<br></code></pre></td></tr></table></figure><p>加入队列的方式是添加到末尾（tail），所以函数的第一个参数是指向末尾的指针。之所以是二级指针，是因为它指向的是末尾节点里的next，next本身是一个指向str uct mcs_spinlock的一级指针。</p><p>整个加锁流程是这样的： （1）当第一个需要锁的CPU来获得锁，经过xchg，把自己的node放到lock的位置，由于之前lock的位置是null，因此prev为null，表示拿到了锁，可以去执行临界区了。 （2）如果其他CPU此时过来争夺锁，由于链表lock的位置所指向的东西被替换为了上一个CPU的node，因此只能拿到已经放在这个位置的node，然后将自己的node排在后面并陷入自旋</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//解锁</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mcs_spin_unlock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mcs_spinlock **lock, <span class="hljs-keyword">struct</span> mcs_spinlock *node)</span><br>&#123;<br><span class="hljs-comment">// 找到等待队列中的下一个节点</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">next</span> =</span> READ_ONCE(node-&gt;next);<br><br>        <span class="hljs-comment">// 当前没有其他CPU试图获得锁</span><br><span class="hljs-keyword">if</span> (likely(!next)) &#123;<br><span class="hljs-comment">// 直接释放锁 </span><br><span class="hljs-keyword">if</span> (likely(cmpxchg_release(lock, node, <span class="hljs-literal">NULL</span>) == node))<br><span class="hljs-keyword">return</span>;<br>                <span class="hljs-comment">// 等待新的node添加成功</span><br><span class="hljs-keyword">while</span> (!(next = READ_ONCE(node-&gt;next)))<br>cpu_relax();<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">#define arch_mcs_spin_unlock_contended(l)</span><br><span class="hljs-comment">smp_store_release((l), 1)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 将锁传给等待队列中的下一个node</span><br>arch_mcs_spin_unlock_contended(&amp;next-&gt;locked);<br>&#125;<br></code></pre></td></tr></table></figure><p>整个解锁的过程是这样的： （1）先去获得自己的next节点，如果有CPU正在自旋等待，next会指向下一个CPU node，否则为null （2）如果为null则直接释放锁，也就是把自己占用的lock的位置腾出来变成null，cmpxchg_release是一个CAS指令。如果成功就直接返回，但是这个过程是有可能失败的，因为可能此时有了CPU来获得锁。此时要等待该CPU添加node 的过程完成，然后把锁传递给他。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">问题：分身之后的spinlock是什么？<br>答案：每个MCS lock的locked变量<br></code></pre></td></tr></table></figure><hr><p>到这里可以小总结一下，<strong>上述的方法是如何回避传统自旋锁导致的缓存无效的？</strong></p><p>传统的自旋锁由于CPU都去读取spinlock变量的值，该值在多个CPU cache中存在，一旦修改就导致多个CPU缓存无效，被迫读内存。但现在每个CPU cache都只有自己的lock变量，并且自旋的过程就是不断查询该lock变量的过程。在某个CPU释放锁的过程中，涉及到修改下一个CPU cache line中lock，这是一个独占的变量，于是下一个CPU分享自己的lock给当前CPU，该lock在两个CPU中呈现share状态。然后当前CPU修改自己cache中的这个分享过来的lock，变为modified状态，然后通知下一个CPU的该lock变为invalid状态。这样在下一个CPU的下一次自旋中涉及到读操作，发现cache失效，于是去其他CPU询问有没有lock值，当前CPU收到消息，将lock值写入内存，并修改状态为share。下一个CPU再去内存读取。</p><p>可以发现整个过程只涉及到了两个CPU的操作，并没有像传统的自旋锁牵连到其他CPU。</p><hr><p>然而MCS lock仍然存在问题，你会发现它的实现保留在了Linux的代码中，但是你却找不到任何一个地方调用了它的lock和unlock的函数，原因在于相比ticket spinlock，MCS lock多了一个指针，要多占4（或者8）个字节，消耗的存储空间是原来的2-3倍。spinlock可是操作系统中使用非常广泛的数据结构，经常嵌入到结构体中，这多占的存储空间不可小视。</p><p>所以MCS lock还存在优化空间</p><h4 id="自旋锁的第三次优化queued-spinlock">自旋锁的第三次优化：queued spinlock</h4><p>MCS lock可以解决在锁的争用比较激烈的场景下，cache line无谓刷新的问题，但它内含一个指针，所以更消耗存储空间，但这个指针又是不可或缺的，因此这次优化的目标其实是把原生的MCS lock进行改进，「塞」进4字节的空间里。</p><p><strong>此次优化后queued spinlock，是目前linux系统真正使用的自旋锁</strong></p><p>整个优化过程的代码很复杂，就不详细展开了，只需要知道该锁是在MCS lock的基础上，通过假设绝大多数情况下只有2-3个CPU企图获得锁，如果出现更激烈的争夺，再启用MCS lock的方式，将变量缩短，降低了对内存的消耗。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//include/asm-generic/qspinlock_types.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qspinlock</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">atomic_t</span> val;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __LITTLE_ENDIAN</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            u8locked;<br>            u8pending;<br>        &#125;;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            u16locked_pending;<br>            u16tail;<br>        &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>...<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qnode</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> <span class="hljs-title">mcs</span>;</span><br>&#125;;<br>DEFINE_PER_CPU_ALIGNED(<span class="hljs-keyword">struct</span> qnode, qnodes[MAX_NODES]);<br><br></code></pre></td></tr></table></figure><p>MCS lock中表示是否持有锁的&quot;locked&quot;占据了32个bits，但它其实只需要表示0和1两个值，在qspinlock中被压缩成了8个bits，即&quot;<strong>locked byte</strong>&quot;（其实只需要1个bit）</p><p>此外，MCS lock的结构体中没有专门的标识等待队列末尾的元素，它使用的是一个全局的二级指针（struct mcs_spinlock lock）来指向队列末尾。而qspinlock使用的是一个per-CPU的数组来表示每个MCS node（用qnode结构体表示），通过CPU编号作为数组的index，就可以获得对应 MCS node的内存位置，因而qspinlock使用的是末尾 MCS node的CPU编号加1，即&quot;<strong>tail cpu</strong>&quot;，来记录等待队列tail的位置</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">问题：什么是per-<span class="hljs-meta">cpu</span>？<br>答案：percpu变量，就是对于同一个变量，每个<span class="hljs-meta">cpu</span>都有自己的一份，它可以被用来存放一些<span class="hljs-meta">cpu</span>独有的数据，比如<span class="hljs-meta">cpu</span>的id，<span class="hljs-meta">cpu</span>上正在运行的线程等等，因该机制可以非常方便的解决一些特定问题，所以在内核编程中被广泛使用<br></code></pre></td></tr></table></figure><h2 id="睡眠锁">睡眠锁</h2><p>xv6在kernel/sleeplock.c实现了睡眠锁：这种类型的锁，会在acquire需要自旋等待时让出CPU，缺点在于上下文切换带来的开销，优点在于允许中断且避免忙等。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">例如100个线程反复竞争一把睡眠锁，<span class="hljs-strong">**若一个线程持有锁，在释放锁之前被抢占，其它99个线程分别尝试获取睡眠锁，发现被抢占后，让出CPU，引起上下文切换。如果使用某种轮转调度程序，这99个线程会一直处于运行—让出的模式，直到持有锁的线程再次运行**</span>。虽然这比原来使用自旋锁，浪费99个完整的时间片要好，但是99次上下文切换的成本也是惊人的<br></code></pre></td></tr></table></figure><p>xv6提供了yield原语，进程可以调用它主动放弃CPU（让出CPU的本质就是进程<strong>取消调度deschedule</strong>了自己）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>  flag = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-keyword">while</span>(TestAndSet(&amp;flag, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>    yield();  <span class="hljs-comment">// 主动放弃CPU</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>&#123;<br>  flag = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>xv6也给出了自己的实现方式： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//sleeplock.c</span><br><br><span class="hljs-comment">// Long-term locks for processes  </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> &#123;</span>  <br>  uint locked;       <span class="hljs-comment">// Is the lock held?  </span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lk</span>;</span> <span class="hljs-comment">// spinlock protecting this sleep lock  </span><br>    <span class="hljs-comment">// For debugging:  </span><br>  <span class="hljs-type">char</span> *name;        <span class="hljs-comment">// Name of lock.  </span><br>  <span class="hljs-type">int</span> pid;           <span class="hljs-comment">// Process holding lock  </span><br>&#125;;<br><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">initsleeplock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sleeplock *lk, <span class="hljs-type">char</span> *name)</span>  <br>&#123;  <br>  initlock(&amp;lk-&gt;lk, <span class="hljs-string">&quot;sleep lock&quot;</span>);  <br>  lk-&gt;name = name;  <br>  lk-&gt;locked = <span class="hljs-number">0</span>;  <br>  lk-&gt;pid = <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">acquiresleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sleeplock *lk)</span>  <br>&#123;  <br>  acquire(&amp;lk-&gt;lk);  <br>  <span class="hljs-keyword">while</span> (lk-&gt;locked) &#123;  <br>    sleep(lk, &amp;lk-&gt;lk);  <br>  &#125;  <br>  lk-&gt;locked = <span class="hljs-number">1</span>;  <br>  lk-&gt;pid = myproc()-&gt;pid;  <br>  release(&amp;lk-&gt;lk);  <br>&#125;  <br>  <br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">releasesleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sleeplock *lk)</span>  <br>&#123;  <br>  acquire(&amp;lk-&gt;lk);  <br>  lk-&gt;locked = <span class="hljs-number">0</span>;  <br>  lk-&gt;pid = <span class="hljs-number">0</span>;  <br>  wakeup(lk);  <br>  release(&amp;lk-&gt;lk);  <br>&#125;  <br>  <br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">holdingsleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sleeplock *lk)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> r;  <br>    <br>  acquire(&amp;lk-&gt;lk);  <br>  r = lk-&gt;locked &amp;&amp; (lk-&gt;pid == myproc()-&gt;pid);  <br>  release(&amp;lk-&gt;lk);  <br>  <span class="hljs-keyword">return</span> r;  <br>&#125;<br><br><span class="hljs-comment">//spinlock.c</span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">initlock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk, <span class="hljs-type">char</span> *name)</span>  <br>&#123;  <br>  lk-&gt;name = name;  <br>  lk-&gt;locked = <span class="hljs-number">0</span>;  <br>  lk-&gt;cpu = <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>这种方法是最基础的睡眠锁，也是用Test and set或者compare and swap实现。但该方案存在着很多偶然性，不能防止饥饿。所以还需要某种机制来决定锁释放时，谁能抢到锁。队列是一种很常见的选择。</p><h4 id="睡眠锁的优化引入休眠队列">睡眠锁的优化：引入休眠队列</h4><p>当引入了休眠队列，必然涉及到多个CPU对队列的共同操作，因此想要优化睡眠锁还需要引入一把自旋锁保护队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在这里，有两个lock，flag和guard</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lock_t</span>&#123;</span><br>  <span class="hljs-type">int</span> flag;<br>  <span class="hljs-type">int</span> guard;<br>  <span class="hljs-type">queue_t</span> *q;<br>&#125; <span class="hljs-type">lock_t</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock_init</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *m)</span>&#123;<br>  m-&gt;flag = <span class="hljs-number">0</span>;<br>  m-&gt;guard = <span class="hljs-number">0</span>;<br>  queue_init(m-&gt;q);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *m)</span>&#123;<br>  <span class="hljs-keyword">while</span>(TestAndSet(&amp;m-&gt;guard, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>    ;  <span class="hljs-comment">// 自旋地等待直到获取guard lock</span><br>  <span class="hljs-keyword">if</span>(m-&gt;flag == <span class="hljs-number">0</span>)&#123;<br>    m-&gt;flag = <span class="hljs-number">1</span>;   <span class="hljs-comment">// flag lock还没有被获取，因此成功获取</span><br>    m-&gt;guard = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 释放guard lock</span><br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    queue_add(m-&gt;q, gettid());  <span class="hljs-comment">// flag lock已经被获取，该线程将进入队列中睡眠</span><br>    m-&gt;guard = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 睡眠之前释放guard lock</span><br>    park();        <span class="hljs-comment">// 睡眠</span><br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(<span class="hljs-type">lock_t</span> *m)</span>&#123;<br>  <span class="hljs-keyword">while</span>(TestAndSet(&amp;m-&gt;guard, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>)<br>    ;  <span class="hljs-comment">// 自旋地等待直到获取guard lock</span><br>  <span class="hljs-keyword">if</span>(queue_empty(m-&gt;q))<br>    m-&gt;flag = <span class="hljs-number">0</span>;  <span class="hljs-comment">//没有人要获取flag lock，直接释放它</span><br>  <span class="hljs-keyword">else</span><br>    unpark(queue_remove(m-&gt;q));  <span class="hljs-comment">// 从队列里唤醒一个线程，把flag lock交给它</span><br>  m-&gt;guard = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 结束之前释放guard lock</span><br>&#125;<br></code></pre></td></tr></table></figure><p>整个上锁过程的实现分为两个部分： （1）先争夺自旋锁，获得队列的修改资格 （2）如果此时睡眠锁还没有被获取，则获取睡眠锁。因为此时不需要再进入队列，所以释放自旋锁，执行自己的操作，然后解锁。如果此时睡眠锁已经被获取，则把自己加入休眠队列，然后释放锁，最后进入休眠（顺序不能错）</p><h2 id="其他常见的锁">其他常见的锁</h2><p>以睡眠锁和自旋锁为核心，根据不同的应用场景针对特定问题进行优化，诞生了很大被广泛使用的锁。这里做一个简单的汇总和介绍。</p><p>如果掌握了睡眠锁和自旋锁的知识，那么其他锁也万变不离其宗</p><h4 id="读写锁">读写锁</h4><p>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。</p><p><strong>读写锁适用于能明确区分读操作和写操作的场景</strong>，<strong>在读多写少的场景，能发挥出优势</strong>： - 当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</p><ul><li>但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。</li></ul><p>根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。前者可能导致写锁饥饿，后者可能导致读锁饥饿。</p><p><strong>公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。</strong></p><p>这里用队列获取锁的方式避免不公平分配，和Ticket Spinlock其实是一个道理。</p><h4 id="分布式锁">分布式锁</h4><h4 id="乐观锁和悲观锁">乐观锁和悲观锁</h4><p>悲观锁认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。自旋锁就是一种悲观锁</p><p>乐观锁认为冲突的概率很低，它的工作方式是：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作</strong>。</p><p>前者经常见到，后者一个最典型的例子就是在线文档，<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></p><h2 id="产生死锁的条件与解决方案">产生死锁的条件与解决方案</h2><p>两个线程都在等待对方释放锁的情况就是死锁</p><h4 id="死锁产生的条件">死锁产生的条件</h4><p>死锁只有<strong>同时满足</strong>以下四个条件才会发生： - 互斥条件；<strong>多个线程不能同时使用同一个资源</strong> - 持有并等待条件；<strong>线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1</strong> - 不可剥夺条件；<strong>在自己使用完之前不能被其他线程获取</strong> - 环路等待条件；<strong>两个线程获取资源的顺序构成了环形链</strong></p><h4 id="常见的死锁情况">常见的死锁情况</h4><ul><li><p>中断处理程序尝试获取线程已经持有的自旋锁。 xv6中的一种死锁情况： 背景：时钟中断处理程序clockintr需要增加ticks值，而一个内核线程也可能通过系统调用sys_sleep来访问ticks值，因此，我们为ticks维护了一把锁tickslock，clockintr和sys_sleep都需要获取该自旋锁来访问或修改ticks值 问题：假设一个内核线程调用sys_sleep，因此它持有tickslock。此时运行该内核线程的CPU收到时钟中断，因此被导向到中断处理程序clockintr中，clockintr第一件事就是acquire(&amp;tickslock)，但是因为这把锁已经被内核线程持有，所以clockintr会一直在原地自旋等待tickslock被释放。导致死锁。即使是其他CPU也没办法通过调度解决这个问题，因为此时进程还处于running状态，调度只能调度runnable状态</p><p>解决方案：如果中断处理程序需要持有某一把<strong>自旋锁</strong>，那么每个CPU在持有这把自旋锁时，一定要<strong>保持中断关闭</strong>。在xv6的实现中，一旦某个线程获取了自旋锁，那么在该CPU上将不会产生中断（因此不会发生线程调度），因为在acquire中已经关闭了该CPU的中断。</p></li><li><p>持有自旋锁的进程主动放弃CPU</p></li><li><p><strong>上锁的顺序</strong>错误。 例如进程1获取锁的顺序是先A后B，进程2则是先B后A。如果进程1获得A的同时，进程2也获得了B，那么死锁就发生了</p><p>这在内核中很常见，因为修改某些数据结构可能会要求你同时持有多个锁，因此上锁的顺序很重要，稍有不慎就会导致死锁。避免这种死锁的解决方案看上去也很简单，只需要规定一个<strong>全局的上锁顺序</strong>即可。规定全局的上锁顺序，意味着锁实际上是每个函数规范的一部分：调用者必须以一种规定的顺序调用函数，以遵循获取锁的顺序</p><p>例子：xv6里面有很多这种上锁顺序的实例，尤其是同时持有两个锁的上锁顺序，几乎处处可见。其中，xv6的文件系统代码包含最长的上锁序列。例如，在创建一个文件时，我们需要同时获取以下的锁才能继续执行：文件所在目录的锁，新文件的inode的锁，磁盘缓冲块的锁，磁盘驱动器的锁，以及调用进程的锁。按以上的顺序获取这些锁，死锁才不会发生。</p></li></ul><h2 id="避免死锁的方法">避免死锁的方法</h2><p><strong>避免死锁的唯一判断条件就是当前线程申请了这个资源，是否会导致死锁。只允许不会造成死锁的线程申请资源</strong>，这就涉及到银行家算法</p><h4 id="银行家算法">银行家算法</h4><h4 id="如何计算不死锁要求的最低资源">如何计算不死锁要求的最低资源？</h4><p>某系统有n个进程，每个进程需要x个同类资源，系统不会产生死锁的最少资源数是多少？ 设最少资源数为y个<br>满足如下表达式即可：<br>n(x-1)+1&lt;=y 注：每个进程需要x个资源，初始时给每个进程 x-1 个资源，最后再给一个额外的资源，没当一个进程运行完后马上释放其占有的资源，其它进程可以申请资源继续运行。</p><h2 id="如何避免激烈的锁争夺">如何避免激烈的锁争夺</h2><p>如果多个线程在某个锁上发生竞争会导致事务串行化，过度竞争还会导致线程频繁的发生上下文切换，形成系统性能的瓶颈。</p><p>有两个因素会影响在锁上发生竞争的可能性：<strong>请求锁的频率、持有锁的时间</strong>，准确的说两者的乘积越大发生竞争的可能性越大，我们大体可以通过三点来降低线程在锁上发生竞争的可能性</p><h4 id="缩小锁范围">缩小锁范围</h4><p>缩小锁的范围可以减少持有锁的时间，这个很好理解，比如一个synchronized修饰的方法有十行代码，假设执行每行代码花费的时间相同，如果使用synchronized块，并且块中只包含一行代码，那么持有锁的时间将大大降低</p><p>尽管缩小同步代码块可以降低持有锁的时间，但是同步代码块不能过小。也就是说实际项目中不能随便的把十行代码只留一行放到synchronized块里，但是我们可以把不需要锁同步的代码放到锁的外部，这样就可以尽可能缩小锁的范围。此外，使用同步代码块也是有开销的，如果把一个同步代码块分解为多个代码块，反而会对系统的性能产生负面影响</p><h4 id="锁分解">锁分解</h4><p>锁分解是将多个对象共用的一个锁分解成各自的锁</p><h4 id="锁分段">锁分段</h4><p>而锁分段是将一个对象分成多个部分，每个部分使用一个锁。比如一个数组是一个对象，数组长度是100。我们把这个数组分成10段，获取第0-9个元素使用一个锁，获取第10-19个元素使用另一个锁，以此类推。原本每次获取对象的操作都是互斥的，通过这样改动，获取第0个元素和获取第10个元素之间就没有了互斥</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">问题：具体有哪些手段可以降低锁竞争？<br>答案：<br>（1）根据应用场景选择合适的锁，例如web应用多读环境选择读写锁<br>（2）实现无锁数据机构，例如mysql基于快照读解决幻读问题<br>（3）锁分段，缩小锁的粒度<br></code></pre></td></tr></table></figure><h4 id="实践">实践</h4><p>减少锁竞争主要有三种方式：缩小锁的范围、锁分解和锁分段，在某种意义上讲，前两种更像是修改原有代码设计不妥当的地方，而第三种是完全意义上的优化。</p><p><strong>下面是一个xv6中避免剧烈锁竞争的优化案例：</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">内核设计中，一个重要的部分就是如何避免锁的争夺。xv6对此只做了很简单的工作，复杂的内核会更细致地组织它们的数据结构和相应算法，从而尽最大可能避免锁的争夺。<br><br>看源码可以知道内核在分配内存时会调用kalloc()，从free-list中分配出一页空间。这个过程需要加锁。因此多个<span class="hljs-meta">CPU</span>想要分配和释放物理页时，都需要在争夺同一把锁。<br><br>一个可能的解决锁争夺的方案就是为每个<span class="hljs-meta">CPU</span>都维护一个free-list，因此锁的数量从原来的一把，增加到和<span class="hljs-meta">CPU</span>的数量相等，这样<span class="hljs-meta">CPU</span>大部分时间下都不用和其它<span class="hljs-meta">CPU</span>去争夺锁，而只需要持有自己的锁，并访问自己的free-list。<br><br>只有在自己的free-list用完了之后，才去和其它<span class="hljs-meta">CPU</span>争夺别人的锁，然后“偷”一些物理页到自己的free-list上。可以验证，这种方式大量减少了锁的争夺。<br><br>同样地，对于只有一把锁的缓冲区buffer cache，我们也可以用类似的思路，将缓冲区的空间分配到多个哈希桶中，因此每个哈希桶一把锁，并根据块号来索引哈希桶，从而减少了在缓冲区上的锁的争夺。<br><br>因此这指示我们在实际设计并发代码时，我们可以先采用**粗粒度Coarse-grained**的上锁方式，对要保护的临界区上一把大锁。例如前面提到的内核分配器就是一个很好的例子。然后我们在保证并发正确性的情况下，逐步地拆解这些数据结构，并且使用**细粒度Fine-grained**的上锁方式。例如xv6对于每个文件都单独维护一把锁，因此修改不同文件的不同进程，不需要在锁的争夺上烦恼。甚至，如果你想再细致一点，你还可以让多个进程同时修改文件，因此使用更细粒度的锁。总之，采用何种粒度的上锁方式，取决于你对性能和代码的复杂性的要求。<br><br>简单来说：从一个粗粒度的锁逐渐拆分数据结构成为多个细粒度的锁，有效降低锁竞争<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab4-Trap</title>
    <link href="/2024/03/13/Lab4-Trap/"/>
    <url>/2024/03/13/Lab4-Trap/</url>
    
    <content type="html"><![CDATA[<p><a href="%5B%5BLab:%20System%20calls%20(mit.edu)%5D(https://pdos.csail.mit.edu/6.S081/2021/labs/syscall.html)%5D">课程地址</a></p><p>本次实验是需要完成trap相关的实验内容，主要是加深对trap的理解，理论知识包含在 [<a href="https://cygnus-queen.github.io/2024/03/07/xv6-book-Chapter4/">xv6-book-Chapter4 - Cygnus的博客 (cygnus-queen.github.io)</a></p><h2 id="alarm">Alarm</h2><p>其实这是一个相当有趣的实验。在完成一些项目时，我们总是需要对计算资源的使用情况进行分析，其中CPU资源的利用率是非常重要的分析指标。经常可能会有进程占据了过多的CPU资源长时间运行（占用多个CPU时钟）。</p><p>本次实验主要是实现两个系统调用`siga[[Pasted image 20240313123317.png]]</p><p>[[Lab4 trap]]lram(int,void(*)())<code>、</code>sigreturn()`。通过这两个系统实现alarm功能，<strong>监测用户程序使用CPU的时长</strong>（以时钟中断为单位），从而对用户程序发出提醒。</p><ul><li><p><strong>sigalarm</strong>：第一个参数是设置时钟中断个数当达到个数时调用指定函数，第二个参数时设置alarm的处理函数。</p></li><li><p><strong>sigreturn</strong>：在alarm处理函数中执行完所以代码后调用，主要功能是<strong>恢复中断前的状态</strong>。</p></li></ul><p>监测时间主要是以<strong>时钟中断为单位</strong>（时间片是进程调度的基础），如果时钟中断为50ms，那么每50ms进行一次中断。通过统计用户进程进行了几次中断，就可以获知用户进程占据CPU的累计时长，一旦时长到达了警报线就会触发处理函数给出提醒。</p><h4 id="第一步添加makefile">第一步：添加makefile</h4><p>课程提供了用来检查系统调用是否正确的函数alarmtest。但是原有的makefile文件里没有，所以需要添加进去。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">UPROGS</span>=\<br><span class="hljs-built_in">..</span>.<br><span class="hljs-variable">$U</span>/_alarmtest\<br></code></pre></td></tr></table></figure><h4 id="第二步在内核注册系统调用">第二步：在内核注册系统调用</h4><p>每一个新的系统调用，都需要注册：</p><p>（1）在syscall.h中添加系统调用号的宏定义</p><p>（2）在syscall.c中添加调用号和系统调用函数的映射关系，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//----syscall.c</span><br><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title function_">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title function_">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;<br><span class="hljs-comment">//...</span><br>[SYS_sigalarm] sys_sigalarm,<br>[SYS_sigreturn] sys_sigreturn,<br>&#125;<br><br><span class="hljs-comment">//----syscall.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_sigalarm 22</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_sigreturn 23</span><br></code></pre></td></tr></table></figure><h4 id="第三步在用户态添加系统调用的定义和声明">第三步：在用户态添加系统调用的定义和声明</h4><p>想要在用户态使用一个函数，自然要对该函数进行声明和定义。</p><p>注意：这里的系统调用定义并非是业务逻辑的真实实现，而是一个外壳，实际是通过发出ecall指令进入内核态找到真正的业务实现。这对进程来讲是透明的，它会以为自己是进行了正常的函数调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//----user.h</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sigalarm</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> (*)())</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">//----usys.pl</span><br>entry(<span class="hljs-string">&quot;sigalarm&quot;</span>);<br>entry(<span class="hljs-string">&quot;sigreturn&quot;</span>);<br></code></pre></td></tr></table></figure><p>这样在编译之后，就会生成usys.S文件，里面包含了这两个系统调用的实现。</p><p>这个实现只是单纯的调用ecall指令进入内核态，并且传递函数名称，例如sys_sigalarm。该名称正好在内核态有对应的系统调用号，通过该系统调用号映射到一个函数的地址即可完成真实的调用。</p><h4 id="第四步实现系统调用">第四步：实现系统调用</h4><p>原本的题目是按照test0到test2逐步引导完成整个过程的，但其实如果对中断的流程比较熟悉的话。可以直接完成test2的内容。</p><p>系统调用的代码都位于sysproc.h，最初的形式如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <br><span class="hljs-type">int</span> interval;  <br>uint64 f_addr;  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>argint(<span class="hljs-number">0</span>,&amp;interval);  <br>argaddr(<span class="hljs-number">1</span>,&amp;f_addr);  <br><br><span class="hljs-comment">//需要在proc结构中添加这些变量</span><br>p-&gt;interval = interval;  <br>p-&gt;handler = f_addr;  <br>p-&gt;ticks = <span class="hljs-number">0</span>;  <br>  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br>uint64  <br><span class="hljs-title function_">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>sys_sigalarm的逻辑其实很简单，就是单纯的接收函数值然后完成赋值，有一种注册alarm功能的感觉。</p><p>根据题目给出的提示，除了上面的准备内容，还需要把alarm interval 和 handler pointer放在proc结构体中 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//----proc.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>&#123;</span><br>  ...<br>  <span class="hljs-type">int</span> interval;<br>  <span class="hljs-type">int</span> ticks;<br>  uint64 handler;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在每个时钟中断发生时需要将ticks（计数器）加一，并且当计数器达到设置的条件时，触发handler函数。具体的做法是将handler函数的地址赋值给epc <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//kernel/trap.c</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)&#123;<br>    p-&gt;ticks++;<br>    <span class="hljs-keyword">if</span>(p-&gt;ticks == p-&gt;interval &amp;&amp; <span class="hljs-number">0</span> &lt; p-&gt;interval)&#123;<br><br><span class="hljs-comment">//注意，这一步有一点&quot;插队&quot;的感觉</span><br>      p-&gt;trapframe-&gt;epc = p-&gt;handler; <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      yield();<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>然而epc原本的值是通过r_sepc()得到的，保存着中断前pc寄存器的值，按照原本的中断逻辑，需要在中断的末尾调用w_sepc()将epc赋值回sepc寄存器，进而传递给pc，让程序可以在中断前的位置正常运行。</p><p>然后此时我们却将epc的值进行了修改，因此中断结束返回的位置会是sigalarm。而不是原本程序的pc。如果我们想将sigalarm做成一个插件形式的，可以穿插在任意程序当中的函数，则我们还需要解决返回值的问题，具体的方式是在sigreturn中将epc的值“复原”。</p><p>而这就要求我们在赋值handler给epc前，需要将trapframe给保存下来，因此正确的修改方式如下：</p><p>（1）新增一个pre_trapframe，用来保存原本的trapframe，避免因为handler赋值给epc导致找不到原本程序的下一步执行位置。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//----proc.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">pre_trapframe</span>;</span><br>&#125;<br><br><span class="hljs-comment">//----proc.c</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc*<br><span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>....<br>  <span class="hljs-keyword">if</span>((p-&gt;pre_trapframe = (<span class="hljs-keyword">struct</span> trapframe *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>....<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">freeproc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>&#123;<br>....<br>  <span class="hljs-keyword">if</span>(p-&gt;pre_trapframe)<br>    kfree((<span class="hljs-type">void</span>*)p-&gt;pre_trapframe);<br>  p-&gt;pre_trapframe = <span class="hljs-number">0</span>;<br>....<br>&#125;<br></code></pre></td></tr></table></figure></p><p>（2）实现sys_sigreturn</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//--trap.c</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)&#123;<br>    p-&gt;ticks++;<br>    <span class="hljs-keyword">if</span>(p-&gt;ticks == p-&gt;interval &amp;&amp; p-&gt;interval &gt; <span class="hljs-number">0</span>)&#123;<br>      *p-&gt;pre_trapframe = *p-&gt;trapframe;<br>      p-&gt;trapframe-&gt;epc = p-&gt;handler; <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      yield();<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//--sysproc.c</span><br>uint64<br><span class="hljs-title function_">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br>  *p-&gt;trapframe = *p-&gt;pre_trapframe;<br>  p-&gt;ticks = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> p-&gt;pre_trapframe-&gt;a0;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实验结果">实验结果</h4><p><img src="Pasted%20image%2020240313123317.png"></p><h2 id="总结">总结</h2><p>其实alarm函数是大多数CPU性能指标监测函数的雏形，想要完成该任务需要熟练理解trap的流程以及添加系统调用的方法</p><p>那我们应该怎么实现呢？</p><p>（1）首先是初始化，我既然要监测CPU使用的次数是否超过阈值并报警。那肯定需要一个阈值interval、一个计数的变量ticks和一个处理报警逻辑的函数handler，分别由用户提供，并在调用时初始化。</p><p>（2）其次是业务的执行。既然是检测时钟中断的次数，那么自然在trap.c代码中完成ticks++和阈值判断的业务。如果想要执行报警逻辑，需要返回给pc一个函数的地址。而赋值pc是通过赋值trapframe-&gt;epc进而赋值sepc实现的。</p><p>（3）最后就是恢复原本的进程，如果直接赋值了epc会导致原本进程的上下文丢失，因此在赋值前自然想到使用其他变量来保存上下文，于是我们新建了一个pre_trapframe。在调用sysreturn时将进程上下文赋值回去。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book-Chapter4-Trap</title>
    <link href="/2024/03/07/xv6-book-Chapter4/"/>
    <url>/2024/03/07/xv6-book-Chapter4/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter4-traps-and-system-calls">Chapter4 Traps and System Calls</h1><p>Trap是一类特殊事件，他们可以打断当前指令流的执行： - 系统调用。执行RISC-V的<strong>ecall</strong>指令时 - 异常。用户或内核指令可能进行了一些非法操作，例如除以0或者使用无效的虚拟地址时 - 设备中断。当一个设备因某些原因（如磁盘的读/写工作完成）需要CPU及时处理时</p><p>无论是哪一种，都涉及到了操作系统从用户态到内核态的转换。通常的流程是：</p><p>（1）保留进程现场（现有的寄存器和其他状态），以便恢复</p><p>（2）中断处理函数（判断trap的类型，并决定如何处理）</p><p>（3）执行特定代码（对应问题的执行代码）</p><p>（4）保存内核状态（第三步涉及到了对内核的操作，恢复进程状态前要保存内核现在的状态）</p><p>（4）进程现场恢复。内核就恢复之前保存的寄存器和其它进程状态</p><p>trap最好是对用户进程<strong>透明</strong>的，即保存和恢复相关寄存器应该由内核负责而不让用户来操心，从trap返回时也应该回到进程指令流被中止的位置，用户进程应该感受不到trap的发生</p><p>它的整个处理流程，以xv6为例，应该经过以下几个函数：</p><ul><li><p><strong>uservec</strong>：位于trampoline.S的前半部分汇编代码，用于做一些陷入内核之前的准备工作，例如保存用户空间下的一系列寄存器，加载内核栈、内核页表等设置，然后跳转到usertrap。这一部分，我们称为<strong>trap vector</strong>。</p></li><li><p><strong>usertrap</strong>：位于内核中的一段C代码，判断引起trap的事件类型，并决定如何处理该trap，如跳转到系统调用函数、设备驱动程序等。我们一般也称其为<strong>trap handler</strong>。</p></li><li><p><strong>usertrapret</strong>：位于内核中的另一段C代码，trap被处理完之后，就会跳转到usertrapret，保存内核栈、内核页表等内核相关信息，进行一些设置，然后跳转到userret。</p></li><li><p><strong>userret</strong>：位于trampoline.S的后半部分汇编代码，用于做一些返回用户空间的恢复工作，恢复之前保存的用户空间寄存器，最后返回用户空间，恢复用户进程指令流的执行。</p></li></ul><p>问题：为什么我们没有将uservec和usertrap两个代码路径合并在一起？ 答案：因为用两段代码分别负责<strong>保存</strong>和<strong>处理</strong>的工作，可以区分以下三种不同的情况：来自<strong>用户空间的trap</strong>，来自<strong>内核空间的trap</strong>和<strong>计时器中断</strong>。进而采取不同的处理方法</p><h2 id="trap-寄存器">Trap 寄存器</h2><p>之前介绍操作系统的时候提到过，内核态到用户态的转换其实是通过CPU特权等级实现的。其实每个CPU都有一些<strong>控制寄存器</strong>的集合，内核通过写入这些寄存器（只有Super模式才能写入这些寄存器）告诉CPU如何处理这次trap</p><p>以下寄存器都以S开头，是Super模式下的寄存器，一些m开头的寄存器只有机器模式才能访问：</p><ul><li><p><strong>stvec</strong>：内核将trap handler写到stvec中。当trap发生时，RISC-V就会跳转到stvec中的地址，准备处理trap。换句话说，这个寄存器就是保存发生trap后CPU执行的第一个函数的地址。在xv6中因为uservec和usertrap被分开了，因此写入stvec的是先执行的uservec或者kernelvec，而不是usertrap。可以认为uservec其实是usertrap的一部分</p></li><li><p><strong>sepc</strong>：当trap发生时，会执行stvec中保存的内容，其实也就是将PC寄存器重置为stvec的内容，为了保存之前进程的运行状态，RISC-V会<strong>将当前pc的值保存在sepc中</strong>。稍后在userret中，sret指令将sepc的值复制到pc中，内核可以设置sepc来控制sret返回到哪里</p></li><li><p><strong>scause</strong>：RISC-V在这里存放一个数字，代表引发trap的原因</p></li><li><p><strong>sscratch</strong>：一个特别的寄存器。在用户空间发生trap，并进入到uservec之后，sscratch就装载着指向进程<strong>trapframe</strong>结构体的指针（进程的trapframe结构体，在进程被创建，并在userret指令返回时，就已经被内核设置好并且放置到sscratch中）。RISC-V还提供了一条<strong>交换指令</strong>（csrrw），可以将任意寄存器与sscratch进行值的交换。sscratch的这些特性，便于在uservec中进行一些寄存器的保存、恢复工作。</p></li><li><p><strong>sstatus</strong>：状态寄存器。位于该寄存器中的<strong>SIE</strong>位可以控制设备中断是否开启，如果SIE被清0，RISC-V会推迟期间的设备中断，直到SIE被再次置位；<strong>SPP</strong>位可以指示一个trap是来自用户模式下还是监管者模式下的，因此也决定了sret要返回到哪个模式下。<strong>因为操作系统不能在保存trap现场时再发生一次trap，这样会导致错误。因此需要利用sstatus在trap发生开始时关闭中断，再现场保存完成后再开启。</strong></p></li></ul><p>我们知道，因为CPU并不知道自己正在做什么，只是按照流水线的形式一条条的执行指令而已。所以操作系统的内核态用户态转换，最核心的部分就是这些寄存器的变换，他们引导着整个trap流程。如果不理解它们，对trap的理解将会停留在记忆层面，没有实感</p><p>整个中断处理过程中，使用寄存器的流程： （1）如果造成trap的是设备中断，将sstatus中的SIE位清0，然后跳过以下步骤。</p><p>（2）（如果trap的原因不是设备中断）将sstatus中的SIE位清0，关闭设备中断。</p><p>（3）将pc的值复制到sepc中。</p><p>（4）将发生trap的当前模式（用户模式或Super模式）写入sstatus中的SPP位。</p><p>（5）设置scause的内容，反映trap的起因。</p><p>（6）设置CPU模式为Super模式。</p><p>（7）将stvec的值复制到pc中。</p><p>（8）从新的pc值开始执行。（回到用户态）</p><h2 id="在用户态发生的trap">在用户态发生的Trap</h2><p>在用户空间下发生trap时，satp仍然保存着用户态进程的页目录，而进入内核时需要内核的页目录。这个过程由uservec函数完成。而stvec中保存着指向uservec的指针。</p><h4 id="第一步uservec"><strong>第一步：uservec</strong></h4><p>执行系统调用时，会保存系统调用号到寄存器a7，并执行ecall指令，该指令会保存PC的值到sepc，再将stvec的值加载到PC中。于是CPU开始执行uservec函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c">uservec:      <br><br>        csrrw a0, sscratch, a0  <br>    <br><span class="hljs-meta"># sd:左边保存到右边</span><br>        sd ra, <span class="hljs-number">40</span>(a0)  <br>        sd sp, <span class="hljs-number">48</span>(a0)  <br>        sd gp, <span class="hljs-number">56</span>(a0)  <br>        sd tp, <span class="hljs-number">64</span>(a0)  <br>        sd t0, <span class="hljs-number">72</span>(a0)  <br>        sd t1, <span class="hljs-number">80</span>(a0)  <br>        sd t2, <span class="hljs-number">88</span>(a0)  <br>        sd s0, <span class="hljs-number">96</span>(a0)  <br>        sd s1, <span class="hljs-number">104</span>(a0)  <br>        sd a1, <span class="hljs-number">120</span>(a0)  <br>        sd a2, <span class="hljs-number">128</span>(a0)  <br>        sd a3, <span class="hljs-number">136</span>(a0)  <br>        sd a4, <span class="hljs-number">144</span>(a0)  <br>        sd a5, <span class="hljs-number">152</span>(a0)  <br>        sd a6, <span class="hljs-number">160</span>(a0)  <br>        sd a7, <span class="hljs-number">168</span>(a0)  <br>        sd s2, <span class="hljs-number">176</span>(a0)  <br>        sd s3, <span class="hljs-number">184</span>(a0)  <br>        sd s4, <span class="hljs-number">192</span>(a0)  <br>        sd s5, <span class="hljs-number">200</span>(a0)  <br>        sd s6, <span class="hljs-number">208</span>(a0)  <br>        sd s7, <span class="hljs-number">216</span>(a0)  <br>        sd s8, <span class="hljs-number">224</span>(a0)  <br>        sd s9, <span class="hljs-number">232</span>(a0)  <br>        sd s10, <span class="hljs-number">240</span>(a0)  <br>        sd s11, <span class="hljs-number">248</span>(a0)  <br>        sd t3, <span class="hljs-number">256</span>(a0)  <br>        sd t4, <span class="hljs-number">264</span>(a0)  <br>        sd t5, <span class="hljs-number">272</span>(a0)  <br>        sd t6, <span class="hljs-number">280</span>(a0)  <br>  <br>   <span class="hljs-meta"># save the user a0 in p-&gt;trapframe-&gt;a0  </span><br>        csrr t0, sscratch  <br>        sd t0, <span class="hljs-number">112</span>(a0)  <br>  <br>        <span class="hljs-meta"># restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp  </span><br>        ld sp, <span class="hljs-number">8</span>(a0)  <br>  <br>        <span class="hljs-meta"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid  </span><br>        ld tp, <span class="hljs-number">32</span>(a0)  <br>  <br>        <span class="hljs-meta"># load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap  </span><br>        ld t0, <span class="hljs-number">16</span>(a0)  <br>  <br>        <span class="hljs-meta"># restore kernel page table from p-&gt;trapframe-&gt;kernel_satp  </span><br>        ld t1, <span class="hljs-number">0</span>(a0)  <br>        csrw satp, t1  <br>        sfence.vma zero, zero  <br>  <br>        # a0 is no longer valid, since the kernel page  <br>        <span class="hljs-meta"># table does not specially map p-&gt;tf.  </span><br>  <br>        <span class="hljs-meta"># jump to usertrap(), which does not return  </span><br>        jr t0<br></code></pre></td></tr></table></figure><p>（1）首先用csrrw指令交换a0和sscratch中的内容。前面我们提到过，内核在返回用户空间之前，就将该进程的trapframe放置进sscratch中。因此交换后在sscratch中保存了原来用户进程的a0，而a0变成了之前由内核设置的该进程trapframe结构的地址</p><p>（2）当我们有了trapframe（这是一个在trap发生时专门用来保存状态的结构体），就可以保存用户进程的其他寄存器了。注意这里的顺序不能乱，必须和进程trapframe的结构体设置保持一致</p><p>（3）trapframe还保存了一些内核信息相关的指针，现在将它们恢复出来，包括内核栈指针，CPU_id，内核页表，以及usertrap的位置。这样就可以跳转到usertrap函数了</p><h4 id="第二步usertrap">第二步：usertrap</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;  <br>  <br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)  <br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);  <br>  <br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),  </span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.  </span><br>  w_stvec((uint64)kernelvec);  <br>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>    <br>  <span class="hljs-comment">// save user program counter.  </span><br>  p-&gt;trapframe-&gt;epc = r_sepc();  <br>    <br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;  <br>    <span class="hljs-comment">// system call  </span><br>  <br>    <span class="hljs-keyword">if</span>(p-&gt;killed)  <br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);  <br>  <br>    <span class="hljs-comment">// sepc points to the ecall instruction,  </span><br>    <span class="hljs-comment">// but we want to return to the next instruction.    </span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;  <br>  <br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,  </span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.    </span><br>    intr_on();   <span class="hljs-comment">//打开中断</span><br>  <br>    syscall();  <br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;  <br>    <span class="hljs-comment">// ok  </span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());  <br>    p-&gt;killed = <span class="hljs-number">1</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-keyword">if</span>(p-&gt;killed)  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);  <br>  <br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.  </span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)  <br>    yield();  <br>  <br>  usertrapret();  <br>&#125;<br></code></pre></td></tr></table></figure><p>（1）usertrap首先改变stvec寄存器的值。之前stvec的值是uservec，代表在用户空间下发生trap时，就跳转到uservec；而现在我们是在内核空间下，所以修改为kernelvec，专门处理内核空间下的trap。</p><p>（2）保存pc的值，之前在trap时，pc被替换为了stvec，原本的值存放在sepc里，现在copy到trapframe结构体中</p><p>（3）r_scause读取scause寄存器的内容（在trap时，会将trap原因写入scause寄存器）。分类讨论 - 系统调用：则syscall执行，该函数会从a7寄存器读取到系统调用号然后执行 - 设备中断：暂时不做处理 - 异常：直接kill程序 - 时间片：CPU放弃当前进程</p><h4 id="第三步usertrapret">第三步：usertrapret</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//用来回到用户空间</span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  <span class="hljs-comment">// we&#x27;re about to switch the destination of traps from  </span><br>  <span class="hljs-comment">// kerneltrap() to usertrap(), so turn off interrupts until  // we&#x27;re back in user space, where usertrap() is correct.  </span><br>  intr_off();  <br>  <br>  <span class="hljs-comment">// send syscalls, interrupts, and exceptions to trampoline.S  </span><br>  w_stvec(TRAMPOLINE + (uservec - trampoline));  <br>  <br>  <span class="hljs-comment">// set up trapframe values that uservec will need when  </span><br>  <span class="hljs-comment">// the process next re-enters the kernel.  </span><br>  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="hljs-comment">// kernel page table  </span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack  </span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;  <br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid()  </span><br>  <br>  <span class="hljs-comment">// set up the registers that trampoline.S&#x27;s sret will use  // to get to user space.    // set S Previous Privilege mode to User.  </span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_sstatus();  <br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// clear SPP to 0 for user mode  </span><br>  x |= SSTATUS_SPIE; <span class="hljs-comment">// enable interrupts in user mode  </span><br>  w_sstatus(x);  <br>  <br>  <span class="hljs-comment">// set S Exception Program Counter to the saved user pc.  </span><br>  w_sepc(p-&gt;trapframe-&gt;epc);  <br>  <br>  <span class="hljs-comment">// tell trampoline.S the user page table to switch to.  </span><br>  uint64 satp = MAKE_SATP(p-&gt;pagetable);  <br>  <br>  <span class="hljs-comment">// jump to trampoline.S at the top of memory, which   </span><br>  <span class="hljs-comment">// switches to the user page table, restores user registers,  </span><br>  <span class="hljs-comment">// and switches to user mode with sret.  </span><br>  uint64 fn = TRAMPOLINE + (userret - trampoline);  <br>  ((<span class="hljs-type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);  <br>&#125;<br></code></pre></td></tr></table></figure><p>（1）修改stvec的值为uservec（用户中断处理函数）。在usertrap中，该值被修改为了kernelvec（内核中断处理），现在要修改回来</p><p>（2）保存内核运行的参数（类似保护现场），包括内核页表，内核栈，usertrap的位置，CPU_id</p><p>（3）设置CPU特权等级，只有sstatus寄存器里的指令被执行，才标志着内核到用户态的转换。此时虽然已经写入了寄存器，但是具体执行还需要</p><p>（4）进行剩余的准备工作，例如设置sepc的值，之前该值被保存在了trapframe的epc中。</p><p>（5）调用userret。注意：虽然之前设置了很多寄存器的值，但是都是准备工作，想要产生的效果都还没有兑现，需要执行sret指令后，才会将sepc里的值覆盖到PC中。有一种按钮的感觉</p><h4 id="第四步userret">第四步：userret</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c">userret:  <br>        <span class="hljs-meta"># userret(TRAPFRAME, pagetable)  </span><br>        <span class="hljs-meta"># switch from kernel to user.  </span><br>        <span class="hljs-meta"># usertrapret() calls here.  </span><br>        # a0: TRAPFRAME, in user page table.  <br>        # a1: user page table, <span class="hljs-keyword">for</span> satp.  <br>  <br>        <span class="hljs-meta"># switch to the user page table.  </span><br>        csrw satp, a1  <br>        sfence.vma zero, zero  <br>  <br>        <span class="hljs-meta"># put the saved user a0 in sscratch, so we  </span><br>        <span class="hljs-meta"># can swap it with our a0 (TRAPFRAME) in the last step.  </span><br>        ld t0, <span class="hljs-number">112</span>(a0)  <br>        csrw sscratch, t0  <br>  <br>        <span class="hljs-meta"># restore all but a0 from TRAPFRAME  </span><br>        ld ra, <span class="hljs-number">40</span>(a0)  <br>        ld sp, <span class="hljs-number">48</span>(a0)  <br>        ld gp, <span class="hljs-number">56</span>(a0)  <br>        ld tp, <span class="hljs-number">64</span>(a0)  <br>        ld t0, <span class="hljs-number">72</span>(a0)  <br>        ld t1, <span class="hljs-number">80</span>(a0)  <br>        ld t2, <span class="hljs-number">88</span>(a0)  <br>        ld s0, <span class="hljs-number">96</span>(a0)  <br>        ld s1, <span class="hljs-number">104</span>(a0)  <br>        ld a1, <span class="hljs-number">120</span>(a0)  <br>        ld a2, <span class="hljs-number">128</span>(a0)  <br>        ld a3, <span class="hljs-number">136</span>(a0)  <br>        ld a4, <span class="hljs-number">144</span>(a0)  <br>        ld a5, <span class="hljs-number">152</span>(a0)  <br>        ld a6, <span class="hljs-number">160</span>(a0)  <br>        ld a7, <span class="hljs-number">168</span>(a0)  <br>        ld s2, <span class="hljs-number">176</span>(a0)  <br>        ld s3, <span class="hljs-number">184</span>(a0)  <br>        ld s4, <span class="hljs-number">192</span>(a0)  <br>        ld s5, <span class="hljs-number">200</span>(a0)  <br>        ld s6, <span class="hljs-number">208</span>(a0)  <br>        ld s7, <span class="hljs-number">216</span>(a0)  <br>        ld s8, <span class="hljs-number">224</span>(a0)  <br>        ld s9, <span class="hljs-number">232</span>(a0)  <br>        ld s10, <span class="hljs-number">240</span>(a0)  <br>        ld s11, <span class="hljs-number">248</span>(a0)  <br>        ld t3, <span class="hljs-number">256</span>(a0)  <br>        ld t4, <span class="hljs-number">264</span>(a0)  <br>        ld t5, <span class="hljs-number">272</span>(a0)  <br>        ld t6, <span class="hljs-number">280</span>(a0)  <br>  <br>   <span class="hljs-meta"># restore user a0, and save TRAPFRAME in sscratch  </span><br>        csrrw a0, sscratch, a0  <br>          <br>        <span class="hljs-meta"># return to user mode and user pc.  </span><br>        <span class="hljs-meta"># usertrapret() set up sstatus and sepc.  </span><br>        sret<br><br></code></pre></td></tr></table></figure><p>和第一步反过来复原进程的状态即可。最后调用sret，结束漫长的trap过程。</p><p>sret完成的任务：</p><p>（1）复制sepc的值到pc中</p><p>（2）根据sstatus寄存器的设置，切回CPU模式，并重新开放中断 和ecall十分类似。</p><h2 id="如何传递参数用户态--内核态">如何传递参数？（用户态--&gt;内核态）</h2><p>发生系统调用时，难免涉及到参数传递。如果是值传递，那么参数会在中断时保存在寄存器中，内核态取出来可以直接用，但如果传递的是一个指针，真正的值需要到对应地址去取的话，就出现问题了。 （1）用户进程可能是有漏洞或者有恶意的，因此它会传递一个无效的指针，甚至是一个企图访问，属于其它用户进程内容，或者属于内核内容的指针 （2）内核页表和用户页表的不同所造成的，因为各自的映射不同，在使用内核页表时，不能用简单的指令访问这些用户地址</p><p>因此涉及到指针的问题时，需要使用内核提供的函数。在xv6中如下所示： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Fetch the nul-terminated string at addr from the current process.</span><br><span class="hljs-comment">// Returns length of string, not including nul, or -1 for error.</span><br><span class="hljs-comment">// The kernel implements functions that safely transfer data to and from user-supplied addresses.</span><br><span class="hljs-comment">//kernel/syscall.c</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">fetchstr</span><span class="hljs-params">(uint64 addr, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> max)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-type">int</span> err = copyinstr(p-&gt;pagetable, buf, addr, max);<br>  <span class="hljs-keyword">if</span>(err &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> err;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(buf);<br>&#125;<br><br><br><span class="hljs-comment">// Copy a null-terminated string from user to kernel.</span><br><span class="hljs-comment">// Copy bytes to dst from virtual address srcva in a given page table,(user pagetable)</span><br><span class="hljs-comment">// until a &#x27;\0&#x27;, or max.</span><br><span class="hljs-comment">// Return 0 on success, -1 on error.</span><br><span class="hljs-comment">//kernel/vm.c</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">copyinstr</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, <span class="hljs-type">char</span> *dst, uint64 srcva, uint64 max)</span><br>&#123;<br>  uint64 n, va0, pa0;<br>  <span class="hljs-type">int</span> got_null = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span>(got_null == <span class="hljs-number">0</span> &amp;&amp; max &gt; <span class="hljs-number">0</span>)&#123;<br>    va0 = PGROUNDDOWN(srcva);<br>    <span class="hljs-comment">// walkaddr checks that the user-supplied virtual address is partof the process’s user address space,</span><br>    <span class="hljs-comment">// so programs cannot trick the kernel into reading other memory</span><br>    <span class="hljs-comment">// pa0只是页表的位置，还需要与偏移量拼接才能到最终的物理地址</span><br>    pa0 = walkaddr(pagetable, va0);<br>    <span class="hljs-keyword">if</span>(pa0 == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    n = PGSIZE - (srcva - va0);<br>    <span class="hljs-keyword">if</span>(n &gt; max)<br>      n = max;<br><br>    <span class="hljs-comment">// Since the kernel maps all physical RAM addresses to the same kernel virtual address,</span><br>    <span class="hljs-comment">// copyinstr can directly copy string bytes fromp a0 to dst</span><br>    <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span> *) (pa0 + (srcva - va0));  <span class="hljs-comment">//得到真实的物理地址</span><br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">if</span>(*p == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        *dst = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        got_null = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        *dst = *p;<br>      &#125;<br>      --n;<br>      --max;<br>      p++;<br>      dst++;<br>    &#125;<br><br>    srcva = va0 + PGSIZE; <span class="hljs-comment">//一个页一个页的拷贝，直到遇到\0。</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(got_null)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// Look up a virtual address, return the physical address,</span><br><span class="hljs-comment">// or 0 if not mapped.</span><br><span class="hljs-comment">// Can only be used to look up user pages.</span><br>uint64<br><span class="hljs-title function_">walkaddr</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va)</span><br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  uint64 pa;<br><br><span class="hljs-comment">//检查虚拟地址访问的位置是否合法</span><br>  <span class="hljs-keyword">if</span>(va &gt;= MAXVA)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  pte = walk(pagetable, va, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(pte == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_U) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  pa = PTE2PA(*pte);<br>  <span class="hljs-keyword">return</span> pa;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p><strong>copyinstr</strong>（kernel/vm.c）的作用是，给定一个用户页表，从用户虚拟地址srcva（例如用户缓冲区），安全地拷贝最多max个字节到内核的dst位置中。首先copyinstr调用walkaddr来为srcva找到对应的物理地址pa0，利用内核采用<strong>直接映射</strong>的特性，我们将pa0作为虚拟地址，便可以直接地从pa0中拷贝字节流到dst中。</p><p>现在，用户将无法传递一个尝试访问内核的物理内存的指针，因为<strong>walkaddr</strong>会检查该地址是否在用户虚拟地址空间中。因此，一个尝试访问内核物理内存的非法访问，显然不会出现在用户页表的映射项里，walkaddr会返回失败，从而不让恶意的用户进程得逞。同理，尝试访问其它用户进程的物理内存的指针也不会通过walkaddr的严格检查。</p><h2 id="在内核态发生的trap">在内核态发生的Trap</h2><p>和用户态非常相似，只不过不需要修改satp和sp，内核页表和内核栈都可以继续使用的。因此kernelvec的工作很简单，当前正在运行的内核线程因trap而被暂停，直接在该内核线程的内核栈上，保存相关的寄存器即可。保存在线程自己的栈上这一点很重要，因为内核下的trap可能会导致线程的切换，然后内核会在另一个线程的内核栈上执行，而原线程的相关寄存器则被安全地放置在自己的内核栈上。</p><h2 id="计时器中断">计时器中断</h2><p>实际上计时器中断在<strong>机器模式</strong>下处理。在xv6的启动阶段中，仍处于机器模式下，在机器模式下我们通过timerinit（kernel/start.c）<strong>初始化了计时器</strong>，<strong>CLINT</strong>将负责产生计时器中断，更重要的是，我们通过<strong>改写mtvec寄存器的值</strong>（和stvec类似）将机器模式下的trap handler设置为timervec。因此，当CLINT产生一个计时器中断时，硬件会自动陷入机器模式，并跳转到timervec开始处理。</p><p>简单来说：其他中断通过ecall触发，然后由保存在stvec寄存器的uservec函数进行处理。计时器中断由CLINT自行触发，由保存在mtvec寄存器的timervec函数处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">timervec:<br>        <span class="hljs-meta"># start.c has set up the memory that mscratch points to:</span><br>        <span class="hljs-meta"># scratch[0,8,16] : register save area.</span><br>        <span class="hljs-meta"># scratch[32] : address of CLINT<span class="hljs-string">&#x27;s MTIMECMP register.</span></span><br><span class="hljs-string"><span class="hljs-meta">        # scratch[40] : desired interval between interrupts.</span></span><br><span class="hljs-string"><span class="hljs-meta">        </span></span><br><span class="hljs-string"><span class="hljs-meta">        csrrw a0, mscratch, a0</span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a1, 0(a0)</span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a2, 8(a0)</span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a3, 16(a0)</span></span><br><span class="hljs-string"><span class="hljs-meta"></span></span><br><span class="hljs-string"><span class="hljs-meta">        # schedule the next timer interrupt</span></span><br><span class="hljs-string"><span class="hljs-meta">        # by adding interval to mtimecmp.</span></span><br><span class="hljs-string"><span class="hljs-meta">        ld a1, 32(a0) # CLINT_MTIMECMP(hart)</span></span><br><span class="hljs-string"><span class="hljs-meta">        ld a2, 40(a0) # interval</span></span><br><span class="hljs-string"><span class="hljs-meta">        ld a3, 0(a1)</span></span><br><span class="hljs-string"><span class="hljs-meta">        add a3, a3, a2</span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a3, 0(a1)</span></span><br><span class="hljs-string"><span class="hljs-meta"></span></span><br><span class="hljs-string"><span class="hljs-meta">        # raise a supervisor software interrupt.</span></span><br><span class="hljs-string"><span class="hljs-meta">li a1, 2</span></span><br><span class="hljs-string"><span class="hljs-meta">        csrw sip, a1</span></span><br><span class="hljs-string"><span class="hljs-meta"></span></span><br><span class="hljs-string"><span class="hljs-meta">        ld a3, 16(a0)</span></span><br><span class="hljs-string"><span class="hljs-meta">        ld a2, 8(a0)</span></span><br><span class="hljs-string"><span class="hljs-meta">        ld a1, 0(a0)</span></span><br><span class="hljs-string"><span class="hljs-meta">        csrrw a0, mscratch, a0</span></span><br><span class="hljs-string"><span class="hljs-meta"></span></span><br><span class="hljs-string"><span class="hljs-meta">        mret</span></span><br></code></pre></td></tr></table></figure><p><strong>timervec</strong>如下所示（kernel/kernelvec.S），主要做的事情就是对计时器芯片重新编程，使其开始新的一轮计时，并且产生向监管者模式发出一个<strong>软件中断</strong>。最后，timervec通过mret返回监管者模式下，如果在监管者模式下，我们的中断是开放的，那么内核就能够捕捉到这个软件中断，内核会跳转到kernelvec，保存相关寄存器，然后在kerneltrap中，发现这是一个设备中断而且是计时器中断，从而执行相应的处理。</p><h2 id="异常处理">异常处理</h2><p>xv6的处理方式非常粗暴，内核直接终止进程。如果是发生在内核空间下的异常，内核会停止执行。实际上，现在的操作系统通常有很多不同的方法来响应这些异常。</p><p>例如，<strong>缺页错误Page-fault</strong>这种异常，可以被很多操作系统内核利用，从而实现<strong>写时复制Copy-On-Write</strong>方法，例如copy-on-write fork。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab3-Page Table</title>
    <link href="/2024/03/07/Lab3-Page-Table/"/>
    <url>/2024/03/07/Lab3-Page-Table/</url>
    
    <content type="html"><![CDATA[<p><a href="%5B%5BLab:%20System%20calls%20(mit.edu)%5D(https://pdos.csail.mit.edu/6.S081/2021/labs/syscall.html)%5D">课程地址</a>_</p><p>本次实验是需要完成页表相关的内容，主要是加深对虚拟内存的理解，理论知识包含在 <a href="https://cygnus-queen.github.io/2023/09/20/xv6-book-Chapter3/">xv6-book Chapter3 - Cygnus的博客 (cygnus-queen.github.io)</a></p><h2 id="实验一加快系统调用">实验一：加快系统调用</h2><p>在第二章我们可以知道，系统调用是操作系统提供给应用程序的接口。当使用系统调用时会发生中断，这涉及到内核态和用户态的切换，因此带来比较大的开销。</p><p>本次实验想要加速这个过程，那么怎么加速呢？ 答：在内核和用户程序之间创建一个共享的只读页。这样内核往这个页里写数据时，用户就不需要经过复杂的系统调用直接读取。具体来说，是加速getpid()。</p><p>4g内存被分为1g的内核虚拟空间和3g的进程虚拟空间：</p><ol type="1"><li><p>其中内核虚拟空间在操作系统初始化时就已经完成，保存在文件当中，被所有进程共享。进程的4g空间中的那1g内核空间是文件copy的部分。</p></li><li><p>其中进程虚拟空间的部分从高地址到低地址分别为：栈、映射区（文件映射、匿名映射）、堆、BSS段、data段、text段。 详细可参见下面博客 <a href="https://zhuanlan.zhihu.com/p/645063459">一步一图带你构建 Linux 页表体系 —— 详解虚拟内存如何与物理内存进行映射 - 知乎 (zhihu.com)</a></p></li></ol><p>xv6的虚拟空间结构，最顶部是TRAMPOLINE和TRAPFRAME，本次的任务目标是在紧挨着这两个页下面的位置实现一个加速getpid()的共享页</p><p>因此第一步，我们需要定义页面的位置。在memlayout.h文件中，已经宏定义了位置USYSCALL，位于TRAPFRAME下方，并给出了需要放在这个位置的数据结构struct usyscall <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LAB_PGTBL  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)   <span class="hljs-comment">//宏定义共享页所在位置（虚拟内存中）</span></span><br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span> &#123;</span>   <span class="hljs-comment">//要放在共享页的结构体</span><br><span class="hljs-type">int</span> pid; <span class="hljs-comment">// Process ID  </span><br>&#125;;  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></p><p>读取USYSCALL位置的ugetpid函数也已经给出 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> LAB_PGTBL  </span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">ugetpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span> *<span class="hljs-title">u</span> =</span> (<span class="hljs-keyword">struct</span> usyscall *)USYSCALL;  <br><span class="hljs-keyword">return</span> u-&gt;pid;  <br>&#125;  <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></p><p>现状就是，如果共享区域被写入了结构体的值，用户程序可以直接调用ugetpid读取。</p><p>因此还需要解决的问题就是：</p><ol type="1"><li><p>给usyscall结构体一个实例，并完善空间分配和回收的代码</p></li><li><p>建立实例到USYSCALL位置的映射关系</p></li></ol><p>要共享的内容是进程的PID，因此可以在进程结构体中新增一个usyscall实例： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state  </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span>  <br>...<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span> *<span class="hljs-title">usyscall</span>;</span> <span class="hljs-comment">//lab3 page table 添加  </span><br>&#125;;<br></code></pre></td></tr></table></figure></p><p>接着在进程创建的过程中为这个实例赋值。进程创建涉及到allocproc() <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc*  <br><span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>  <br>  <br>...... <span class="hljs-comment">//省略无关代码</span><br>  <br><span class="hljs-comment">// Allocate a trapframe page.  </span><br><span class="hljs-keyword">if</span>((p-&gt;trapframe = (<span class="hljs-keyword">struct</span> trapframe *)kalloc()) == <span class="hljs-number">0</span>)&#123;  <br>freeproc(p);  <br>release(&amp;p-&gt;lock);  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-comment">//lab3 page table 添加的内容  </span><br><span class="hljs-keyword">if</span>((p-&gt;usyscall = (<span class="hljs-keyword">struct</span> usyscall *)kalloc()) == <span class="hljs-number">0</span>)&#123;  <br>freeproc(p);  <br>release(&amp;p-&gt;lock);  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>p-&gt;usyscall-&gt;pid = p-&gt;pid;  <br>  <br><span class="hljs-comment">// An empty user page table.  </span><br>p-&gt;pagetable = proc_pagetable(p);  <br><span class="hljs-keyword">if</span>(p-&gt;pagetable == <span class="hljs-number">0</span>)&#123;  <br>freeproc(p);  <br>release(&amp;p-&gt;lock);  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>......<br><br><span class="hljs-keyword">return</span> p;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>在allocproc中，会调用kalloc给trapframe结构体分配物理空间，返回物理空间地址。我们可以照葫芦画瓢在这里也给usyscall分配物理空间，赋值给p-&gt;usyscall，并给结构体内的变量赋值。</p><p><strong>既然创建进程时分配了内存的地方，那么销毁进程时也要释放内存</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// free a proc structure and the data hanging from it,  </span><br><span class="hljs-comment">// including user pages.  </span><br><span class="hljs-comment">// p-&gt;lock must be held.  </span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span>  <br><span class="hljs-title function_">freeproc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span>  <br>&#123;  <br><br><span class="hljs-keyword">if</span>(p-&gt;trapframe)  <br>kfree((<span class="hljs-type">void</span>*)p-&gt;trapframe);  <br>p-&gt;trapframe = <span class="hljs-number">0</span>;  <br><br><span class="hljs-keyword">if</span>(p-&gt;pagetable)  <br>proc_freepagetable(p-&gt;pagetable, p-&gt;sz);  <br>  <br><span class="hljs-comment">//lab3 page table 添加  </span><br><span class="hljs-keyword">if</span>(p-&gt;usyscall)  <br>kfree((<span class="hljs-type">void</span>*)p-&gt;usyscall);  <br>p-&gt;usyscall = <span class="hljs-number">0</span>;  <br><br><span class="hljs-comment">//...... 省略其他代码</span><br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>由于虚拟内存机制，即使拿到了物理地址，我们也没办法直接访问（访问该地址时,会把他当虚拟地址使用），还需要建立虚拟地址到物理地址的映射关系。</p><p>进程创建时，allocproc调用proc_pagetable， <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create a user page table for a given process,  </span><br><span class="hljs-comment">// with no user memory, but with trampoline pages.  </span><br><span class="hljs-type">pagetable_t</span>  <br><span class="hljs-title function_">proc_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span>  <br>&#123;  <br><span class="hljs-type">pagetable_t</span> pagetable;  <br>  <br><span class="hljs-comment">// An empty page table.  </span><br>pagetable = uvmcreate();  <br><span class="hljs-keyword">if</span>(pagetable == <span class="hljs-number">0</span>)  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  <br><span class="hljs-comment">// map the trampoline code (for system call return)  </span><br><span class="hljs-comment">// at the highest user virtual address.  </span><br><span class="hljs-comment">// only the supervisor uses it, on the way  </span><br><span class="hljs-comment">// to/from user space, so not PTE_U.  </span><br><span class="hljs-keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,  <br>(uint64)trampoline, PTE_R | PTE_X) &lt; <span class="hljs-number">0</span>)&#123;  <br>uvmfree(pagetable, <span class="hljs-number">0</span>);  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.  </span><br><span class="hljs-keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,  <br>(uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="hljs-number">0</span>)&#123;  <br>uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <br>uvmfree(pagetable, <span class="hljs-number">0</span>);  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><br><span class="hljs-comment">//Lab3 page table 添加  </span><br><span class="hljs-keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,  <br>(uint64)p-&gt;usyscall, PTE_R | PTE_U) &lt; <span class="hljs-number">0</span>)&#123;  <br>uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <br>uvmunmap(pagetable, TRAPFRAME, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <br>uvmfree(pagetable, <span class="hljs-number">0</span>);  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-keyword">return</span> pagetable;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>物理地址保存在p-&gt;usyscall中，虚拟地址已经宏定义为USYSCALL，直接调用mappages函数建立映射关系。设置访问权限为PTE_R（只读）和 PTE_U（用户态可访问），<strong>如果映射失败，说明proc_pagetable函数运行失败，需要使用uvmunmap函数撤销前面建立的映射</strong>（重视这种细节是预防bug的最好方法）。</p><p>proc_pagetable函数增加了USYSCALL相关操作，所以proc_freepagetable也需要增加对应的操作： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Free a process&#x27;s page table, and free the  </span><br><span class="hljs-comment">// physical memory it refers to.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">proc_freepagetable</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 sz)</span>  <br>&#123;  <br>uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <br>uvmunmap(pagetable, TRAPFRAME, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <br>  <br><span class="hljs-comment">//lab3 page table 添加  </span><br>uvmunmap(pagetable, USYSCALL, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <br><br>uvmfree(pagetable, sz);  <br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>至此，第一个实验就完成了，可以随便在一个用户态程序中调用ugetpid()，和getpid()系统调用对比。例如我对原本ls.c的main代码做出修改： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>  <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>  <br>&#123;  <br><span class="hljs-type">int</span> i; <br><br><span class="hljs-comment">//lab3 page table 添加</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ugetpid: %d getpid: %d \n&quot;</span>,ugetpid(),getpid());  <br><br><span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;  <br>ls(<span class="hljs-string">&quot;.&quot;</span>);  <br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <br>&#125;  <br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;argc; i++)  <br>ls(argv[i]);  <br>  <br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>在命令行输入语句make qemu，进入xv6系统，运行ls指令，得到的结果如下： <img src="Pasted%20image%2020231116003105.png"></p><p>官方也给出了测试用例，直接在xv6中运行pgtbltest： <img src="Pasted%20image%2020231116223909.png"></p><p>可以看到ugetpid_test成功通过，下面没有通过的pgaccess_test，不用管他，这是之后的内容。</p><h4 id="实验一总结">实验一总结</h4><p>实验任务：添加一个共享页，加速系统调用 解决方法（只有后面四步是需要自己完成的）： 1. 写好需要放在共享页的结构体</p><ol start="2" type="1"><li><p>确定共享页的位置（进程只能看见虚拟空间，所以是确认虚拟内存中的位置）</p></li><li><p>编写从共享页获取内容的函数</p></li><li><p>在进程结构体中新增第一步中提到的结构体实例</p></li><li><p>在给进程分配空间时，添加给共享页分配内存的代码；销毁时添加收回内存代码</p></li><li><p>建立共享页位置和物理空间的映射关系</p></li><li><p>在用户态函数中调用第三步提到的函数，完成实验验证</p></li></ol><h2 id="实验二打印页表">实验二：打印页表</h2><p>实验二的目的是编写一个可以打印页表的函数，加深从用户虚拟地址到实际物理地址这个映射过程的理解。任务要求：</p><ol type="1"><li><p>定义一个名为vmprint()的函数。接受pagetable_t作为参数，并按照格式打印</p></li><li><p>在exe .c中，在返回argc之前插入<code>if(p-&gt;pid=1=1)</code> <code>vmprint(p-&gt;pagetable)</code>，打印进程的页表</p></li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">page table 0x0000000087f6b000<br> ..0: pte 0x0000000021fd9c01 pa 0x0000000087f67000<br> .. ..0: pte 0x0000000021fd9801 pa 0x0000000087f66000<br> .. .. ..0: pte 0x0000000021fda01b pa 0x0000000087f68000<br> .. .. ..1: pte 0x0000000021fd9417 pa 0x0000000087f65000<br> .. .. ..2: pte 0x0000000021fd9007 pa 0x0000000087f64000<br> .. .. ..3: pte 0x0000000021fd8c17 pa 0x0000000087f63000<br> ..255: pte 0x0000000021fda801 pa 0x0000000087f6a000<br> .. ..511: pte 0x0000000021fda401 pa 0x0000000087f69000<br> .. .. ..509: pte 0x0000000021fdcc13 pa 0x0000000087f73000<br> .. .. ..510: pte 0x0000000021fdd007 pa 0x0000000087f74000<br> .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000<br>init: starting sh<br></code></pre></td></tr></table></figure><p>注意： 1. 可以将vmprint()放在vm.c文件中</p><ol start="2" type="1"><li><p>使用kernel/riscv.h文件末尾的宏来进行pte和pa的转换</p></li><li><p>在kernel/def .h中声明vmprint的原型，以便exec可以调用它</p></li><li><p>在printf调用中使用%p来打印完整的64位十六进制pte和地址，如示例所示</p></li></ol><p>整体实现没什么特别的，就是从一个pagetable出发去寻址，pagetable相当于根地址。</p><p>从根地址出发，遍历根地址指向的所有pte（共512个），将每个允许访问的qte转换为pa并打印，再进一步通过该qte当作根地址，去找下一级的qte，一直到三级页表访问完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable)</span>&#123; <br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>    <span class="hljs-comment">//pagetable实际上就是一个存放pte的数组，类型为uint64</span><br>    <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span>(pte &amp; PTE_V)&#123;<br>      uint64 pa2 = PTE2PA(pte);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..%d: pte %p pa %p\n&quot;</span>,i,pte,pa2);<br><br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">512</span>; j++)&#123;<br>        <span class="hljs-type">pagetable_t</span> pagetable1 = (<span class="hljs-type">pagetable_t</span>)pa2; <br>        <span class="hljs-type">pte_t</span> pte = pagetable1[j];<br><br>        <span class="hljs-keyword">if</span>(pte &amp; PTE_V)&#123;<br>          uint64 pa1 = PTE2PA(pte);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. ..%d: pte %p pa %p\n&quot;</span>,j,pte,pa1);<br><br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">512</span>; k++)&#123;<br><br>            <span class="hljs-type">pagetable_t</span> pagetable0 = (<span class="hljs-type">pagetable_t</span>)pa1;<br>            <span class="hljs-type">pte_t</span> pte = pagetable0[k];<br><br>            <span class="hljs-keyword">if</span>(pte &amp; PTE_V)&#123;<br>              uint64 pa0 = PTE2PA(pte);<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>,k,pte,pa0);<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>将写好的程序添加到exec中，这样xv6启动时就会自动调用vmprint了 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">exec</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>  ...<br>  <span class="hljs-keyword">if</span>(p-&gt;pid==<span class="hljs-number">1</span>)&#123;<br>    vmprint(p-&gt;pagetable);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> argc; <span class="hljs-comment">// this ends up in a0, the first argument to main(argc, argv)</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="实验三检测被使用过的页表">实验三：检测被使用过的页表</h2><p>实验三的要求是实现pgaccess系统调用。用于检查哪些页面已被访问。系统调用有三个参数： 第一个参数：使用第一个用户页的起始虚拟地址进行检查 第二个参数：需要检查的页数 第三个参数：以位掩码形式存储的结果 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">pgaccess_test</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> *buf;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> abits;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pgaccess_test starting\n&quot;</span>);<br>  testname = <span class="hljs-string">&quot;pgaccess_test&quot;</span>;<br>  buf = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">32</span> * PGSIZE);<br>  <span class="hljs-keyword">if</span> (pgaccess(buf, <span class="hljs-number">32</span>, &amp;abits) &lt; <span class="hljs-number">0</span>)<br>    err(<span class="hljs-string">&quot;pgaccess failed&quot;</span>);<br>  buf[PGSIZE * <span class="hljs-number">1</span>] += <span class="hljs-number">1</span>;<br>  buf[PGSIZE * <span class="hljs-number">2</span>] += <span class="hljs-number">1</span>;<br>  buf[PGSIZE * <span class="hljs-number">30</span>] += <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">if</span> (pgaccess(buf, <span class="hljs-number">32</span>, &amp;abits) &lt; <span class="hljs-number">0</span>)<br>    err(<span class="hljs-string">&quot;pgaccess failed&quot;</span>);<br>  <span class="hljs-keyword">if</span> (abits != ((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>)))<br>    err(<span class="hljs-string">&quot;incorrect access bits set&quot;</span>);<br>  <span class="hljs-built_in">free</span>(buf);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pgaccess_test: OK\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure> 看上面的测试用例，在pgaccess_test这个函数中，申请了buf，总共包含了32个页的大小。再没有访问的时候，并不会实际分配物理页。 第一次调用pgaccess，此时buf虽然被创建，但还没有被使用过。因此abits为0 接着修改buf，这就涉及到访问具体的页，这个过程页PTE的标志位中的PTE_A（需要自己再riscv.h中定义）会被置为1。pgaccess的作用就是检测出buf中被使用的页，然后以位图的形式保存结果</p><p>提示： - 阅读user/pgtlbtest.c中的pgaccess_test()以查看如何使用pgaccess。<br>- 在kernel/sysproc.c中实现sys_pgaccess()。<br>- 使用argaddr()和argt()来解析参数，lab2对这两种方法有所使用。<br>- 对于输出位掩码，在内核中存储一个临时缓冲区，并在填充正确的位后将其复制给用户(通过copyout())更容易。<br>- kernel/vm.c中的walk()对于查找正确的pte非常有用。<br>- 在kernel/riscv.h中定义PTE_A，即访问位。请参考<a href="https://link.zhihu.com/?target=https%3A//github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMFDQC-and-Priv-v1.11/riscv-privileged-20190608.pdf">RISC-V特权架构手册</a>来确定其值。<br>- 检查PTE_A是否设置后，请<strong>务必清除</strong>PTE_A。否则，将无法确定自pgaccess()最后一次调用以来是否访问了该页(即，将永远设置该位)。 - vmprint()在调试页表时可能会派上用场。</p><p>具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>  <br><span class="hljs-title function_">sys_pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br><span class="hljs-comment">// lab pgtbl: your code here.  </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc(); <span class="hljs-comment">//任何系统调用的第一步是获取当前执行的进程  </span><br>  <br>uint64 base; <span class="hljs-comment">//参数1，接收传递的页表起始地址  </span><br><span class="hljs-type">int</span> len; <span class="hljs-comment">//参数2，接收需要检查的页表个数  </span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> abits = <span class="hljs-number">0</span>;<span class="hljs-comment">//参数3，用来将最终得到bit图传回  </span><br>uint64 mask; <span class="hljs-comment">//最终的bitmap  </span><br>  <br><span class="hljs-comment">//用户态的参数会保存在寄存器中，使用arg系列函数指定参数编号可以取得参数  </span><br>argaddr(<span class="hljs-number">0</span>,&amp;base);  <br>argint(<span class="hljs-number">1</span>,&amp;len);  <br>  <br>uint64 va = base;  <br><span class="hljs-comment">//从va位置开始，遍历len个页表，  </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i &lt; len;i++)&#123;  <br><span class="hljs-comment">//0表示遇到没有分配物理内存的虚拟页时不分配空间  </span><br><span class="hljs-type">pte_t</span>* pte = walk(p-&gt;pagetable,va,<span class="hljs-number">0</span>);  <br>  <br><span class="hljs-comment">//回顾之前的内容，没个PTE有10个标志位，代码只设定了5个，PTE_A需要自己在risc.h中设置  </span><br><span class="hljs-keyword">if</span>(*pte &amp; PTE_A)&#123;  <br><span class="hljs-comment">//说明第i个页表已经访问过了，所以设置bitmap  </span><br>abits = abits | (<span class="hljs-number">1</span> &lt;&lt; i);  <br><span class="hljs-comment">//标记之后，情况PTE_A  </span><br>*pte = *pte &amp; (~PTE_A);  <br>&#125;  <br>va += PGSIZE;  <br>&#125;  <br>  <br><span class="hljs-comment">//得到了想要的bitmap，现在要传回到用户态,先接收参数  </span><br>argaddr(<span class="hljs-number">2</span>,&amp;mask);  <br>  <br><span class="hljs-comment">//拷贝内容  </span><br><span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable, mask, (<span class="hljs-type">char</span> *)&amp;abits, <span class="hljs-keyword">sizeof</span>(abits)) &lt; <span class="hljs-number">0</span>)  <br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>这样整个实验就完成了</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go：实现ping函数</title>
    <link href="/2024/03/04/Go%EF%BC%9A%E5%AE%9E%E7%8E%B0ping%E5%87%BD%E6%95%B0/"/>
    <url>/2024/03/04/Go%EF%BC%9A%E5%AE%9E%E7%8E%B0ping%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>ping函数是基于ICMP协议的，该协议运行在网络层，如果只是单纯的记忆报文的格式其实没有意义，伴随实践可以让印象更深刻。</p><p>IP协议本身不支持发现发往目的地地址失败的IP数据包，也没有提供直接的方式获取诊断信息，比如在发送途中，经过了哪些路由器，以及往返时间。所以由<code>ICMP协议</code>（<code>Internet Control Message Protocol</code>，<code>ICMP</code>）专门来负责这些事情。</p><p><strong>ICMP并不为IP网络提供可靠性，它只是用于反馈各种故障和配置信息。丢包不会触发ICMP。</strong></p><p>ICMP = ICMP 头部 + 报文，头部的结构体如下： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ICMP <span class="hljs-keyword">struct</span> &#123;<br>    Type        <span class="hljs-type">uint8</span>  <span class="hljs-comment">// 类型</span><br>    Code        <span class="hljs-type">uint8</span>  <span class="hljs-comment">// 代码</span><br>    CheckSum    <span class="hljs-type">uint16</span> <span class="hljs-comment">// 校验和</span><br>    ID          <span class="hljs-type">uint16</span> <span class="hljs-comment">// ID，一般为进程号</span><br>    SequenceNum <span class="hljs-type">uint16</span> <span class="hljs-comment">// 序号，一般表示发送报文的次数</span><br>&#125;<br>最常见的ping，对应<span class="hljs-keyword">type</span>和Code为（<span class="hljs-number">0</span>，<span class="hljs-number">0</span>）回显应答和（<span class="hljs-number">8</span>，<span class="hljs-number">0</span>）回显请求<br></code></pre></td></tr></table></figure></p><p>整个的实现过程涉及到了对go net包的应用 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main  <br>  <br><span class="hljs-keyword">import</span> (  <br>    <span class="hljs-string">&quot;bytes&quot;</span>  <br>    <span class="hljs-string">&quot;encoding/binary&quot;</span>    <span class="hljs-string">&quot;flag&quot;</span>    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;log&quot;</span>    <span class="hljs-string">&quot;net&quot;</span>    <span class="hljs-string">&quot;time&quot;</span>)  <br>  <br><span class="hljs-comment">// 1.首先定义icmp报文头  </span><br><span class="hljs-keyword">type</span> ICMP <span class="hljs-keyword">struct</span> &#123;  <br>    Type        <span class="hljs-type">uint8</span>  <br>    Code        <span class="hljs-type">uint8</span>  <br>    CheckSum    <span class="hljs-type">uint16</span>  <br>    ID          <span class="hljs-type">uint16</span>  <br>    SequenceNum <span class="hljs-type">uint16</span>  <br>&#125; <span class="hljs-comment">//顺序不能乱  </span><br>  <br><span class="hljs-keyword">var</span> (  <br>    desIP   <span class="hljs-type">string</span>  <br>    timeout <span class="hljs-type">int</span>  <br>    size    <span class="hljs-type">int</span>  <br>    count   <span class="hljs-type">int</span>  <br>)  <br>  <br><span class="hljs-comment">// 2.定义命令行参数  </span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetCommandArgs</span><span class="hljs-params">()</span></span> &#123;  <br>    flag.StringVar(&amp;desIP, <span class="hljs-string">&quot;IP&quot;</span>, <span class="hljs-string">&quot;110.242.68.42&quot;</span>, <span class="hljs-string">&quot;目标IP地址&quot;</span>)  <br>    flag.IntVar(&amp;timeout, <span class="hljs-string">&quot;Timeout&quot;</span>, <span class="hljs-number">10000</span>, <span class="hljs-string">&quot;超时设置&quot;</span>)  <br>    flag.IntVar(&amp;size, <span class="hljs-string">&quot;size&quot;</span>, <span class="hljs-number">32</span>, <span class="hljs-string">&quot;发送字节数&quot;</span>)  <br>    flag.IntVar(&amp;count, <span class="hljs-string">&quot;time&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;请求次数&quot;</span>)  <br>    flag.Parse()  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;  <br>    GetCommandArgs()  <br>  <br>    <span class="hljs-comment">//3.建议ip连接  </span><br>    conn, err := net.DialTimeout(<span class="hljs-string">&quot;ip:icmp&quot;</span>, desIP, time.Duration(timeout)*time.Millisecond)  <br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <br>       log.Println(err.Error())  <br>       <span class="hljs-keyword">return</span>  <br>    &#125;  <br>    <span class="hljs-keyword">defer</span> conn.Close()  <br>  <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;  <br>       <span class="hljs-comment">//4. 构建真实的报文头  </span><br>       icmp := ICMP&#123;  <br>          <span class="hljs-type">uint8</span>(<span class="hljs-number">8</span>),   <span class="hljs-comment">//type和Code号都不能出错</span><br>          <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>),  <br>          <span class="hljs-type">uint16</span>(<span class="hljs-number">0</span>),  <br>          <span class="hljs-type">uint16</span>(i),  <br>          <span class="hljs-type">uint16</span>(i),  <br>       &#125;  <br>  <br>       <span class="hljs-comment">//5. 写入报文  </span><br>       <span class="hljs-keyword">var</span> buffer bytes.Buffer  <br>       <span class="hljs-comment">//BigEndian表示使用大端序，在网络协议层操作二进制数字时约定使用大端序，大端序是网络字节传输采用的方式。  </span><br>       err := binary.Write(&amp;buffer, binary.BigEndian, icmp)  <br>       <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <br>          log.Println(err.Error())  <br>          <span class="hljs-keyword">return</span>  <br>       &#125;  <br>  <br>       data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, size)  <br>       buffer.Write(data)  <br>       data = buffer.Bytes()  <br>       <span class="hljs-comment">// ICMP 请求签名（校验和）：相邻两位拼接到一起，拼接成两个字节的数  </span><br>       checkSum := checkSum(data)  <br>       <span class="hljs-comment">// 签名赋值到 data 里  </span><br>       data[<span class="hljs-number">2</span>] = <span class="hljs-type">byte</span>(checkSum &gt;&gt; <span class="hljs-number">8</span>)  <br>       data[<span class="hljs-number">3</span>] = <span class="hljs-type">byte</span>(checkSum)  <br>       startTime := time.Now()  <br>  <br>       conn.SetDeadline(time.Now().Add(time.Duration(timeout) * time.Millisecond))  <br>  <br>       <span class="hljs-comment">//6. 发送报文  </span><br>       n, err := conn.Write(data)  <br>       <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <br>          log.Println(err)  <br>          <span class="hljs-keyword">continue</span>  <br>       &#125;  <br>  <br>       <span class="hljs-comment">//7. 接收报文  </span><br>       buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)  <br>       n, err = conn.Read(buf)  <br>       <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <br>          log.Println(err)  <br>          <span class="hljs-keyword">continue</span>  <br>       &#125;  <br>  <br>       t := time.Since(startTime).Milliseconds()  <br>       fmt.Printf(<span class="hljs-string">&quot;来自 %d.%d.%d.%d 的回复：字节=%d 时间=%d TTL=%d\n&quot;</span>, buf[<span class="hljs-number">12</span>], buf[<span class="hljs-number">13</span>], buf[<span class="hljs-number">14</span>], buf[<span class="hljs-number">15</span>], n<span class="hljs-number">-28</span>, t, buf[<span class="hljs-number">8</span>])  <br>  <br>    &#125;  <br>  <br>    conn.RemoteAddr()  <br>  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkSum</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">uint16</span> &#123;  <br>    <span class="hljs-comment">// 第一步：两两拼接并求和  </span><br>    length := <span class="hljs-built_in">len</span>(data)  <br>    index := <span class="hljs-number">0</span>  <br>    <span class="hljs-keyword">var</span> sum <span class="hljs-type">uint32</span>  <br>    <span class="hljs-keyword">for</span> length &gt; <span class="hljs-number">1</span> &#123;  <br>       <span class="hljs-comment">// 拼接且求和  </span><br>       sum += <span class="hljs-type">uint32</span>(data[index])&lt;&lt;<span class="hljs-number">8</span> + <span class="hljs-type">uint32</span>(data[index+<span class="hljs-number">1</span>])  <br>       length -= <span class="hljs-number">2</span>  <br>       index += <span class="hljs-number">2</span>  <br>    &#125;  <br>    <span class="hljs-comment">// 奇数情况，还剩下一个，直接求和过去  </span><br>    <span class="hljs-keyword">if</span> length == <span class="hljs-number">1</span> &#123;  <br>       sum += <span class="hljs-type">uint32</span>(data[index])  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 第二部：高 16 位，低 16 位 相加，直至高 16 位为 0    hi := sum &gt;&gt; 16  </span><br>    <span class="hljs-keyword">for</span> hi != <span class="hljs-number">0</span> &#123;  <br>       sum = hi + <span class="hljs-type">uint32</span>(<span class="hljs-type">uint16</span>(sum))  <br>       hi = sum &gt;&gt; <span class="hljs-number">16</span>  <br>    &#125;  <br>    <span class="hljs-comment">// 返回 sum 值 取反  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-type">uint16</span>(^sum)  <br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="实验结果">实验结果</h2><p><img src="Pasted%20image%2020240304185250.png"></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm">提问：如果将<span class="hljs-keyword">type</span>的值从8变成0会怎样？<br>答案：由于<span class="hljs-number">0</span>，<span class="hljs-number">0</span>是回显应答，因此服务端在收到信息后不会有任何回应，本地会显示<span class="hljs-type">IO</span> timeouy<br></code></pre></td></tr></table></figure><p><img src="Pasted%20image%2020240304185423.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>编程语言, 计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以交易为生（总结）</title>
    <link href="/2024/01/31/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <url>/2024/01/31/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>想要战胜市场，以下三点缺一不可： （1）良好的心态（一切按照指标移动，不要相信感觉） （2）符合逻辑的交易系统（成体系，成记录） （3）有效的风险管理计划（资金管理）</p><p>整个内容就是围绕这三点展开，大多数会忽视第一和第三点，只在乎第二点，其实资金管理和心态管理（保持情绪）恰恰要重要的多，不能让情绪影响到交易系统，每一个买入或卖出订单的制定都应该是繁琐的，包括了客观指标，交易评分，交易日志，交易记录，而且结束后还要复盘。</p><p>如果完成交易用的时间很短，那想必是没考虑清楚，或者对待表格等客观事物应付了事，那亏损就不远了。</p><h2 id="个体心理成为一个清醒的人">1、个体心理（成为一个清醒的人）</h2><p>胜不骄败不馁，只专注复盘和技巧的学习，是专业交易者必须的素质，自毁倾向要不得（亏的就剩这么点了，就这样了，破罐子破摔之类的），你的失败都是基于自己，市场是不会错的</p><p><strong>==市场不知道你的存在，你的存在也无法影响市场。它不会故意关照你的财富，也不会特意伤害你的资金。你要做的，只是控制自己的行为。==</strong></p><p><strong>专业的交易者冷静地运用自己的智慧交易。只有业余者才会极易兴奋或沮丧。情绪化在交易时是谁也无法承担的累赘。</strong></p><p><strong>你的买卖决定，只有在理智的情况下做出才有效，而后文的众多指标就是为了帮助你确定自己的理智。</strong></p><p>应该避免的交易心理： （1）不要一波连胜之后认为自己是天才，开始偏离交易系统（往往是通过一两次偏移带来好处之后，认为不必要再遵守交易系统，这是损失本金的开始） （2）不要否认自己的失败，像酗酒者不承认酗酒毁了自己的生活一样，认为自己都能控制，其实已经走到了悬崖边缘。连续亏损之后不承认，还加仓，等待反转，其实就是站到了悬崖边上）</p><p><strong>作为一个交易者的第一步，就是要大声承认：我就是个失败者，我对亏损无能为力。</strong></p><p>作为一个交易者，我们经常要承担交易风险，但我们不应在可预知的风险之外，再多承担任何损失。打个比方，商店店主每次进货的时候都承担着风险。如果没有卖掉，他就会有损失。聪明的商人只会承担那些不会让他生意破产的风险——即使连续犯错。进两箱货可能是在合理的风险范围内，但是进一车的货物就真的是在赌博了。</p><p>想要成为专业交易者，是一个长线任务： （1）坚定自己在市场中长期作战的意念——从现在开始至少交易20年。 （2）像海绵一般地学习，关注专家的观点，但对任何事情都要保持有益的怀疑态度。遇到有疑问的地方要刨根究底，而不是简单地接受专家的观点，或只理解他们字面上的意思。（没有弄清楚内在逻辑的观点不如不要） （3）不贪婪，不急于交易——要把你的时间用于学习，市场一直在这里，未来无尽的岁月中会有更多更好的机会。 （4）<strong>培养分析市场的方法，换句话说，就是“如果A发生，那么B很可能会发生”</strong>。市场有很多维度，要使用多种解析方法来确认自己的交易决策。要学会用历史数据测试交易决策，随后在市场上真枪实弹地进行交易。市场瞬息万变，你需要的是根据牛市、熊市、震荡市等不同的特征采用不同的工具进行交易，同时还要有所区分（详情见技术分析章节）。 （5）<strong>建立一套资金管理计划</strong>。你的第一目标是必须长期生存下去，第二目标是资本的稳定增长，第三目标才是赚取高额利润。其实第一部分就已经很难了，不要觉得目标很容易实现 （6）要认识到交易者在任何交易系统中都是最为薄弱的一环，克制情绪交易 （7）胜利者在思考、感受与行动上的方式与失败者是完全不同的。你必须深探自己的内心，驱赶那些幻觉，改变你原来的思考、感受与行动的方式</p><p>为了成功，你需要动力、知识和自律。钱很重要，但这些品质的重要性要远远大于钱。如果你足够努力地鞭策自己，按照本书所说来努力学习努力交易，你会得到很多知识，然后我们会在最后一章回到纪律的话题上，为本书的一切画上圆满的句号。</p><p><strong>谨记，你的目标是交易获利，而不是频繁交易。可以自由的选择交易行为，是个人投资者最大的优势（比如这次熊市，公募仓位限制，不能卖出，他们只能选股，不能择时）</strong></p><h2 id="群体心理">2、群体心理</h2><p><strong>股票的实时成交价是所有交易者的共识</strong></p><p>每个成功的交易者必须学会独立地思考问题，他需要强大到能独自分析市场并进行买卖决策，而不是依靠各种专家</p><p>群众有着足够的力量来创造某种市场趋势，群众或许不够理智，但却比任何单个个体要强大很多。==<strong>千万不要逆趋势交易（这次的股市就给逆势交易想要抄底的人一记重锤）</strong>==。一旦上涨趋势得以确立，你能做的只有买进或者在一边观望。<strong>千万不要仅仅是因为感觉价格过高而去卖空——再次强调，不要和趋势作对</strong>。<strong>没有哪个规定说你一定要和人群一同奔跑，但你至少不应该逆着人群行进</strong>。</p><p>尊重群众的力量，但是不要畏惧它。<strong>群体虽然拥有强大的力量，但从源头上来看他们的行为是最为简单</strong>，并且反复重现的。想要从其他交易者的口袋中获取利润？做一个独立思考的交易者吧，你可以的。</p><p>唯有坚持长期以独立的个体角度进行思考和操作，你才能成为一个成功的交易者。在交易的过程中，你必须时刻留意自己，关注自己精神状态的变化。写出自己入场与出场的条件，包括资金管理规则。<strong>只要手上还有仓位头寸，就坚决不能修改计划</strong>。</p><p>个人行为是复杂多变而难以预测的，而群体行为是简单而原始的。技术分析者研究了市场群体模式。当他们识别到先前市场变化的形态时，他们开始交易。</p><p>成功的交易建立在三大支柱之上。你需要<strong>分析多空力量的平衡</strong>。你需要实践资金管理。你需要严格服从你的交易计划，避免在市场中过于兴奋或者沮丧。</p><p>股价的波动是多空双方博弈的过程，<strong>==技术分析的本质就是分析多空力量的平衡==</strong></p><h2 id="图表分析法">3、图表分析法</h2><p>市场根本不认同斜线（趋势线），但市场能够记住价位，这就是为什么<strong>水平支撑位和阻力位有意义</strong>，而<strong>斜线趋势却是主观的甚至是自欺欺人的。</strong></p><p>只需要使用几个客观的令人信赖的图表模式即可 （1）基于水平的支撑位和阻力位 （2）每日开盘价和收盘价的关系 （3）蜡烛图高点和低点的关系 （4）袋鼠尾</p><p>每日开盘价往往反映了业余者对价值的看法</p><p>在牛市中，市场通常在周一或周二时出现当周最低价——因为业余者会兑现前一周赚到的利润，然后市场会在周四或周五创出新高</p><p>每天或每周的收盘价则往往反映了专业交易者的行为。他们全天都在盯着市场交易，对市场变化做出反应，并倾向于主宰最后1小时的交易</p><p><strong>共识：</strong> 1. 每根柱状线的最高点代表了最强多方的力量，每根柱状线的最低点代表了最强空方的力量 2. 每一根柱状线的收盘价都是当天多方和空方博弈的最终结果 3. 柱线图中最高点和最低点的距离反映了多方和空方冲突的激烈程度 4. 滑点（见导论）在市场冷清的时候往往较小。在市场冷清的时候进场比较好。遇到很长的柱状线是兑现利润的好时机</p><p>根据混沌理论，市场在大多数情况下都是混乱的，但是秩序也偶尔会在市场潮汐中存在。市场分析的本质就在于能够辨认出这些固定的模式，并且有勇气和信心利用它们进行交易。</p><h3 id="支撑位和阻力位">支撑位和阻力位</h3><p><strong>支撑位和阻力位的形成源自亏钱的记忆和悔恨，下次到同一个地方一定要止损，这也就是经常说的套闹盘，抛压大</strong></p><p><strong>小的支撑位或者阻力位会导致趋势的暂停，而主要的支撑位和阻力位则会造成趋势的反转。大量的交易者们在支撑位买入，在阻力位卖出，使得支撑位和阻力位的有效性变成了一种自我实现的预言。支撑位和阻力位的强度取决于大量交易者感受的强度</strong></p><h4 id="支撑位和阻力位的强度">支撑位和阻力位的强度</h4><p><strong>这些区域的力量取决于三个因素：区域的长度、高度，以及在区域内的成交量（深度）</strong>。 1. 长度： （1）持续两周的反复震荡区只会产生一个微小的阻力位或者支撑位； （2）持续两个月的阻力位或者支撑位会让人们习惯这个价位，并且产生一个中等强度的支撑位或者阻力位； （3）持续两年的反复震荡区则会让人接受该价位是股票的真实价值（日本，国内3000点保卫战） 2. 高度： （1）如果一个密集成交区的高度仅有现在市场总价值的1%，那就只能提供一个弱小的支撑位和阻力位 （2）如果有3%那么高，就会形成一个中等强度的支撑位或者阻力位； （3）如果是7%或者更高，那么这个密集成交区能碾碎一个大的趋势 3. 深度 大成交量表示了交易者参与程度活跃——这是高的感情投入的信号</p><p><strong>如果用股票在密集交易区的天数乘以成交的平均价格和平均成交量，你就可以测算出支撑力量或阻力的总金额。</strong></p><h4 id="交易规则">交易规则</h4><ol type="1"><li>无论何时，当大盘走势逼近支撑位或者阻力位时，设定好你的保护性止损位。 趋势在阻力位和支撑位的表现显示了其健康程度。如果走势足够强，能突破阻力区或支撑区，你的保护性止损单将不会被触发。如果走势在阻力区或支撑区开始反转，说明趋势较弱。在这种情况下你的保护性止损单就会保住你的一大笔利润。</li><li><strong>阻力位和支撑位对于长期图表比对短期图表分析更重要。</strong> 如果周线图的趋势很强势，那么日线图触及阻力位也并不用太担心。当周趋势线逼近阻力位或者支撑位时，你就应该考虑退出了。</li><li>支撑位和阻力位意味着交易的机会（假突破） 技术分析中最重要的模式之一是“假突破”，如果价格微降至支撑位一下，然后又重回支撑区域，这意味着空方已经失去他们的机会。当出现向下假突破后，线柱的收盘价收回在密集成交区之内时，标志着这是买入的机会。你应该在近期假突破点底部附近设置一个保护性止损单。</li></ol><p>专业人士会抓住假突破，然后设置一个距离买入点很近的止损单，因为既然突破的压力位，如果是假突破，那下面的空间就不大了，不会触发止损单；如果判断错误是真突破，亏损也可以接受。</p><p><strong>在日线图上买入向上突破的最佳时机，是当你发现周线图出现新的上升趋势时。</strong></p><p><strong>真正的突破一般伴随有巨额的成交量，而假突破则成交量很少</strong></p><h3 id="趋势和震荡">趋势和震荡</h3><p>上升趋势：每一次上涨的高位都会突破之前的高位，而每一次下跌都会高于之前下跌的低位 下跌趋势：每一次下跌都会击穿上一次的低位，而每一次反弹又无法高于上一次反弹的最高点 震荡区间：每一次上涨都会抵达之前的高点，而每一轮下跌也回到以前的低位 以上是完美的情况，实际总伴随各种假突破</p><p>趋势和震荡有不同的交易法则 （1）在形成趋势后要使用宽松的止损单，避免因为噪音损失利润 （2）震荡环境要收紧止损单，持续关注行情，一旦发生反转的微弱迹象，立即抛售手中的仓位 （3）趋势和震荡中另一个交易技巧的区别在于如何看待强势和弱势。 在趋势之中你得跟着强势的一方走——在上升趋势中看多，在下降趋势中看空。当你处在交易范围中，你就得做反向操作——买入弱势的一方，卖出强势的一方。</p><p>大众在大部分时间内都在乱转，这也就是为什么市场的大部分时间都处在震荡而不是趋势中。大众必须被煽动起来才能创造出一种趋势。但是大众不会兴奋太久，他们很快就会回到漫无目的的状态。<strong>所以，当你不确定这是趋势还是震荡时，</strong>专业者倾向于相信市场处于震荡区间。**</p><h4 id="判断趋势和震荡的方法">判断趋势和震荡的方法</h4><p>没有一个完美的方法，多个指标相互印证，可以提高正确的概率 （1）分析高点和低点的模式。当价格回升总是能达到更高的高位，而下跌总能停止在更高的低位，那就是一个上升的趋势。而更低的高位和更低的低位则意味着一个下降的趋势。而不规则的高点和低点则意味着震荡区域 （2）看均线。一条20-30日的均线斜率的方向展现了趋势，<strong>如果移动平均曲线没有在月内达到一个新高或者新低，那么市场就可能处于震荡区间内</strong> （3）看摆动指标。MACD柱创下新高，预示着一个强力的趋势，表明市场上最近一次顶部要被试探或者被超过 （4）看市场指标。比如趋向系统（此处不展开，后面有）</p><h4 id="立即交易还是等待回调">立即交易还是等待回调？</h4><p>当你认出一个上升趋势时，你有两个选择，要决定是立刻买进还是先等待一个回调。 （1）立即买进要承担更大的风险，因为往往此时止损单的位置比较远， （2）等到回调时入场，要面临众多想入场的人的竞争，“倒车接人”给的机会空间相当窄</p><p><strong>如果你不确定，你可以分以下几个步骤买入（在满足2%法则的基础上）：在突破迹象出现的时候（疑似突破）买入三分之一，突破的时候（确认趋势）再买入三分之一，回调时再买入三分之一</strong></p><h3 id="袋鼠尾反转的标志之一">袋鼠尾（反转的标志之一）</h3><p>当你还以为正在运行中的趋势将会继续存在时——“砰！”——三条蜡烛线形成了一个袋鼠尾，标志着市场猝不及防地发生了反转。</p><p>袋鼠尾标志着牛市或熊市最后的一击。</p><p>例子： <strong>某股票可能从日线图看已经波动了好几天了，结果周一突然一根大阳线，结果周二股票的==开点是周一线柱的底部位置==，并且没有上涨，那就应该考虑在周二收盘前做空股票</strong></p><p><strong>如果市场已经在震荡区间内持续了一周并在周三的时候收出了一根长阴线，那你就要在周四做好准备：如果交易价格在周三线柱的==顶部附近==小幅震荡，那就在周四收盘前大胆买入</strong></p><p>向上的袋鼠尾意味着应该在当前的价位上兑现盈利，而向下的袋鼠尾则是一个加仓的好机会（别忘了设置<strong>止损单</strong>，位置在袋鼠尾的中部就可以了）</p><h2 id="技术分析基于计算机">4、技术分析（基于计算机）</h2><p>第三章的部分主要是传统图表分析，公式比较简单。这部分内容可能支持更复杂的指标</p><p>研究一只股票需要12年的交易历史（两波牛市和熊市）</p><p>新手应该避免日内交易，因为依赖瞬时决策的能力（我按照文章的要求制作表格之类的要很久，日内交易是不可能做到的）；也应该避免长线交易（因为止损点往往范围大，而且速度太慢，难以快速提高自己）；还应该避免跨国交易（所以我现在打算采用定投海外股市，实操国内股市的方式）</p><p>趋势交易是新手的起点，比如说，持有某个仓位几天。挑选那些趋势很好、成交量又不错的热门股票。</p><p>其实在第三章提到各种指标的时候，就可以意识到，多种指标完全可能出现冲突的情况。因此需要挑选出几个指标组合使用。（后文会有交易打分，综合判断是否值得买入）<strong>有的指标在趋势中有效，有的波动市场有效，有的擅长抓住反转，有的擅长确定趋势的延续</strong></p><p>指标可以分为三类： （1）趋势跟随指标（同步或者滞后指标）；在大盘上涨或者下跌时最有效，震荡区间效果急剧下降 MACD线，趋向系统，能量潮 （2）震荡指标（先行或者同步指标）；有助于识别反转点 MACD柱，强力指数，随机指标，变化率，动能指标，相对力量指标，威廉百分比，埃尔德射线指标 （3）复合型指标；提供多空双方强度信息 新高新低指标、看跌/认购期权比、好友指数、交易者指数</p><p>通过多种指标结合起来，就是三重滤网交易系统（后文会讲）的精髓</p><p>记住：有时候指标信号是非常明确的，有时候又很模糊。只有当你非常确定指标发出的信号时，才能选择进场。如果你看到一个熟悉的指标，但不理解其中的意思，那么最好翻到下一页去看另一只股票（机会多的是）。个人交易者最大的好处就是没有人逼着你交易——我们能够等待最好和最清晰的信号。</p><h3 id="趋势指标">趋势指标</h3><p>移动平均和MACD线是确定趋势是什么的指标，ADX趋向系统是确定趋势程度有多大的指标。</p><h4 id="移动平均">移动平均</h4><p>（1）当EMA上涨时，作为多头进行市场交易。当价格下降到移动平均值附近时买入。一旦你成为多头，一定要在最近的低点下面设置保护性止损单。一旦价格接近高点时，就把保护性止损单移至盈亏平衡点。 （2）当EMA下跌时，作为空头进行市场交易，当价格回升接近移动平均值时卖出，然后在最近的高点之上设置保护性止损单。当价格下跌时，将保护性止损单下移到盈亏平衡价位 （3）当EMA走平，只是小幅波动时，那意味着一种漫无目的、没有趋势的市场。这种情况下不要使用趋势跟随方法 （4）EMA也能用来作为<strong>支撑位</strong>和<strong>阻力位</strong> （5）长短EMA之间构成了价值区间，时间比例2：1。记住这点能帮助你成为一个理智的交易者。一旦你懂得了如何定义价值，你就能低买高卖了</p><p>画简单移动平均的正确方法是画在滞后价格的时间长度一半距离的位置</p><h4 id="macd线">MACD线</h4><p>MACD线和信号线的交点表明了市场中空方和多方实力变换的平衡点。较快的MACD线反映的是短期内大众的心理变化，而较慢的信号线则反映了大众心理在较长期的变化</p><p>手工做出MACD指标的步骤如下： （1）计算12日收盘价的EMA； （2）计算26日收盘价的EMA； （3）用12日收盘价的EMA减去26日收盘价的EMA，将其差值画成一条实线，这就是较快的MACD线（DIFF）； （4）计算这条实线的9日EMA，将其结果画成一条虚线，这就是较慢的信号线（DEA）。</p><p>当较快的MACD线上升超过信号线时，表示多方主导了市场，这时候最好做多方；当较快的线落到较慢的信号线下面时，表示空方主导了市场，做空方比较有利。 （1）当较快的MACD线穿越到较慢的信号线上方时，为买入信号。这时候要买多，然后在近期的<strong>次低点</strong>位置设置一个保护性止损单 （2）当较快的MACD线穿越到较慢的信号线下方时，为卖出信号。这时候要卖空，然后在近期的次高位位置设置一个保护性止损单。</p><p><strong>大多数人的MACD设置为（12，26，9），这组设置并不好</strong>，可以改成（6，30，9）</p><p><strong>MACD的使用原则：</strong> 1. <strong>一个中心：以0轴为中心（快慢线运行在0轴之上为多头市场，0轴之下为空头市场）</strong> 2. <strong>两个基本点：顶背离和底背离</strong> 当股价创出新低时，而相关MACD的两线数值却未能同时创出新低，这就形成了底背离现象，是买入信号。在底背离出现时，激进的投资者可以分批建仓。而为了安全起见，稳健的投资者应耐心等待股价止跌回升后再买入。 3. <strong>四项基本原则：买点、卖点、风险点、止损点</strong> （1）一级买点：底背离之后的第二次金叉 <img src="Pasted%20image%2020240131152602.png"> （2）次级买点：快慢线上穿0轴后在0轴获得二次支撑金叉 <img src="Pasted%20image%2020240131152840.png"> （3）一级卖点和次级卖点把金叉换成死叉即可 （4）风险点：在macd的快慢线上穿0轴时候的时刻判断不了是否能够上穿0轴进入多头市场，还是在0轴受阻再次下跌，风险点不是非卖不可的点，而是一个需要随时准备卖出的点，需要保持警惕的点。<strong>这时可以结合成交量分析</strong> （5）止损点就是macd指标跌破0轴进入空头市场的点（MACD柱也可以参考）</p><h4 id="趋向系统一般选择adx">趋向系统（一般选择ADX）</h4><p>指明趋势，并显示什么时候趋势的运动值得去追逐。它能帮助交易者在大趋势的主体部分获利。</p><p>正平滑趋向线和负平滑趋向线的关系能够确定趋，正平滑趋向线在上，说明趋势向上。负平滑趋向线在上面时，就说明趋势是向下的。通过两个趋向线可以计算出ADX （1）<strong>正负趋向线交叉时是个买入卖出信号</strong> （2）ADX增大是好的买入或卖出机会，表示市场的主导力量正在变强，趋势可能持续。在ADX值上升时，最好只用趋势跟随指标。 （3）当ADX下降时，表示市场的趋势正在减弱。这时可能产生很多假突破。当ADX下降时，最好不要用趋势跟随指标。 （4）当ADX落到两条趋向线之下时，则出现了趋向系统的最佳信号。它在此区域待得越久，那么下一次趋势的基础就越强。当ADX从两条趋向线下方开始回升时，意味着市场从平静中觉醒了。到底是熊市还是牛市取决于在上面的是哪条趋向线 （5）当ADX回升超过两条趋向线时，表示市场过热了。当ADX从高于两条趋向线的地方掉头向下，表示主要的趋势受到了阻碍，这正是趋势交易兑现利润的好时机。 <img src="Pasted%20image%2020240130202649.png"></p><p>注意：<strong>ADX是软指标。EMA改变方向是硬指标</strong>。比如A点到B点，ADX也上穿了绿线，但是EMA并没有改变趋向，软指标和硬指标冲突，相信硬指标。当绿箭头的位置，硬指标 + 软指标 共同指向了合适的买入位置</p><h4 id="平均真实波幅atr">平均真实波幅（ATR）</h4><p>平均真实波幅(ATR)是真实波幅TR在某一时间段内的平均值，常用的为13日均值。</p><p>克里·洛沃恩喜欢在移动平均线附近画三组线（在高于和低于EMA1倍、2倍和3倍ATR的位置），构成ATR通道线。<strong>它们能用于设定入场点、保护性止损位和盈利目标</strong></p><p><strong>ATR通道的方法不仅在价格方面有用。我们也可以将它和其他指标结合起来，来判断趋势有可能在哪些极端价位出现反转。我在周线图的强力指数上会结合使用ATR通道。</strong></p><h3 id="震荡指标">震荡指标</h3><p>趋势跟随指标能帮助我们辨认趋势——比如MACD线或者趋向系统，而<strong>震荡指标则能帮助我们抓住反转点</strong>。无论何时市场大众被恐惧或贪婪的情绪攫住时，人们都会蜂拥而上，但是过一阵子这种强烈的情绪又会逐渐消散。</p><p><strong>震荡指标就是测量这种冲击的速度的，并能显示出何时它的能量开始减弱。</strong></p><h4 id="超买超卖">超买超卖</h4><p>超买意味着市场点位太高，随时可能回调。当震荡指标到达前期的高位水平时，就形成了超买。超卖意味着市场点位太低，随时可能反弹。当震荡指标到达前期的低位水平时，就形成了超卖。一定要记住： （1）当一波强力的上升趋势开始后，震荡指标可以持续几个星期的超买状态，这样给出的卖出信号是过早的 （2）在急剧的下跌趋势中，也可能保持几周的超卖状态，这样给出的买入信号是过早的 （3）知道什么时候使用趋势跟随指标，什么时候使用震荡指标是成熟分析师的标志</p><p><strong>可以通过水平参考线来标记超买和超卖的震荡指标，划线的位置是让震荡指标只有5%的时间超出这些线之外。每3个月重新调整线的位置</strong></p><h4 id="macd柱">MACD柱</h4><p>背离现象</p><p><strong>要注意指标两个顶部之间的对0值线的突破，是真正背离所必需的因素。MACD柱状线在达到第二个顶点之前，必须低于0点。</strong></p><h4 id="相对强弱指标rsi">相对强弱指标RSI</h4><p>相对强弱指标(RSI)是由威尔斯·威尔德发明的一个震荡指标。它通过监测任意一种交易产品的收盘价变动来测量其强度。它是一个先行或者同步指标——从不滞后。</p><p>RSI的波动区间是0～100。当它到达顶点开始下降时，就确定了市场价格的顶部。当它下跌然后开始掉头向上时，就确定了一个底部。RSI底部和顶部的模式不会随着时间跨度增大而有所改变。交易信号在短期内的RSI上看得更清楚，比如7～9天的RSI（见图27-1）。 <img src="Pasted%20image%2020240130204048.png"> （1）当其上升到下参考线之上时，预示要上涨（图中以绿色垂直箭头标示） （2）当其下跌到上参考线之下时，预示要下跌（图中以红色垂直箭头标示）</p><p><strong>图中以倾斜实线箭头和虚线红色箭头标出的是相对强弱指标出现熊市背离给出的非常强的卖出信号</strong></p><p>图中右边缘处的尖锐跳空，不顾相对强弱指标发出的买入信号，将价格推向更低位。<strong>要避免受到伤害，我们必须使用保护性止损位，因为震荡区间里最后一笔交易，很容易在新趋势开始时造成亏损</strong>（你以外还会震荡上去，其实震荡阶段结束了，新的趋势已经形成）</p><p><strong>参考上面的案例，在趋势形成的边缘使用震荡指标是危险的，因此震荡指标要搭配好止损位</strong></p><p>水平参考线一定要能够穿过RSI的最高点和最低点。这些线通常是在30%和70%的地方。一些交易者在牛市中将其设置在40%和80%的水平上，或者在熊市中将其设置在20%和60%的地方。使用5%法则：每一条线都要保证RSI在过去的4～6个月中，位于参考线之上的时间少于5%。每3个月就调整一次参考线。</p><p>RSI能传达的重要信号有两种 1. 形成超买超卖的位置（RSI超过参考线） 2. 发生背离现象， （1）当价格上涨创出新高，但是RSI的顶部却低于其前一次上涨的顶部的时候。一旦RSI从第二次顶部下跌就马上可以卖空，同时在最近的新高价上方设置保护性止损单 （2）当价格创出新低，而RSI指数的底部比其前一次下跌的底部要高。一旦RSI从第二次底部开始上扬，马上可以买进并且在近期底部的价格最低点的下方设置保护性止损单 3. RSI通常比市场价格早几天突破阻力位或者支撑位，表现出了趋势可能要改变的迹象。RSI趋势线通常会比价格趋势线早1～2天被反转 （1）当RSI的下降趋势反转时，在最近的价格高位上挂一个买单来抓住这一次向上的突破； （2）当RSI的上升趋势反转时，在最近的价格低位上挂一个卖单来抓住这一次向下的突破。</p><p>注意：一个典型的新手会犯的错误就是“采购各种指标”，主观觉得股票可能上涨，但发现趋势没改变，于是通过找几个震荡指标，发现超卖，然后急切的买入，于是赔钱了。其实，<strong>震荡指标比较敏感，是要有几个指标之间佐证，几个时间周期佐证，并且在严格的交易系统下才可以使用的。</strong></p><h2 id="成交量和时间">5、成交量和时间</h2><p>尽管价格行情十分重要，但市场所包含的远远不只有价格一个维度，成交量给我们提供了另一种极具价值的参考维度</p><p>作为经验法则，在任何一个市场上 <strong>“高成交量”意味着高于其过去两周成交量平均值25%以上的成交量 “低成交量”意味着低于其过去两周成交量平均值25%以上的成交量</strong> （1）高成交量可以确认趋势。如果价格和成交量同时达到新的顶峰水平，价格将很可能保持高位或超过前期顶部后再创新高 （2）如果在趋势持续的过程中成交量缩水，那该趋势将发生反转。市场达到新顶峰时，其对应的成交量却不及达到上一个顶峰时的成交量，你就应该兑现多头头寸上的盈利或者抓住做空的机会。<strong>但这一技巧并不一定在市场处于下降趋势中时管用</strong>，<strong>因为下降趋势可能以一个很低的成交量来持续下去</strong>。华尔街流传着这样一句话：“将价格拉上去需要大家来买入，但价格会自行下降。” （3）观察趋势中反弹的成交量情况。当上升趋势出现回落时，由于慌张的获利了结盘，成交量会增加。当这种回落持续但成交量缩水时，表明多头不再逃跑或者抛压被消耗。当成交量耗尽时，下跌带来的抛售效应已经接近其尽头，上升趋势将重新开始。 ### 集散指标(A/D) 集散指标比OBV指标得到更好的调整，因为它只用当天交易量的一定比例归入到多头或空头势力中去，按照双方当日获胜的程度作为其比例</p><p>A/D = （（收盘价 - 开盘价）/ （最高价 - 最低价） ） * 成交量</p><p>A/D高低的形态十分重要，而它的绝对值水平主要受计算基准日影响（不必太关注数值） （1）如果价格上涨创新高但A/D值却没有随之创新高，则出现了卖出信号。这种熊市背离表明市场上专业投资者在上涨过程中卖出。 （2）牛市背离发生价格创新低但A/D值却没有创新低时，表明了市场上专业投资者在下跌过程不断买入并逐步建仓，反弹即将到来（见图29-2）。 <img src="Pasted%20image%2020240131162538.png"></p><p>当你根据A/D值与价格之间的背离为依据，进行做多或做空的时候，记住就算是市场上专业的投资者也会犯错。你需要设置止损单并用巴斯克维尔的猎犬法则（见第23节）来保护自己。 （A/D是个软指标）</p><h3 id="强力指数">强力指数</h3><p>强力指数指标=今日成交量×（今日收盘价-昨日收盘价） 然后使用2日和13日均值平滑</p><p>当强力指数指标上涨到新高时，表明多头的力量很强大，上升趋势将得到持续；当强力指数指标下降到新低时，表明空头的力量很强大，下降趋势将继续维持</p><p>因为2日EMA是一个敏感的指标，我们可以用其来对其他指标给出的信号进行微调。当趋势跟随指标确认了上升趋势时，同时2日EMA值下降到0以下，此时便是一个绝佳的买点——在长期上涨趋势中的回调期进行买入（见图30-1）。当趋势跟随指标确认了下降趋势，2日EMA的上升给出绝佳的卖出区域。 （1）市场处于上升趋势时，在2日强力指数EMA变负时买入。 （2）市场处于下降趋势时，在2日强力指数EMA变正时卖出。</p><p><strong>此外，2日EMA可以帮助我们决定什么时候建仓，你可以在上升趋势中每次强力指数指标变负时加仓，你也可以在下降趋势中每次强力指数指标变正时减仓。</strong></p><p>2日EMA也能帮助我们决定何时清仓。它通过确认短期反弹或回调来实现该作用。在2日EMA值为负的时候买入的短线交易者可以在该值变正的时候卖出</p><p>强力指数指标甚至还可以让我们瞥见未来的一角。当2日EMA值在当月内降低到最低点，说明了空头力量十分强大，并且价格将降得更低；当2日EMA在当月内升高到最高点，这说明了多头力量十分强大，并且价格将升到更高水平。</p><p><img src="Pasted%20image%2020240131163343.png"></p><h3 id="技术指标结合基本面">技术指标结合基本面</h3><p>按照时间长短，可以把交易划分： （1）长期交易或长期投资。即持有仓位的时间以月为单位，有时甚至以年为单位。优点：可以获得可观的长期投资收益，同时避免每天盯盘对精力的消耗。缺点：体现在跌势中持有时间过长亏损可能会很严重，让人无法忍受。 （2）波段交易。即持有仓位的时间以日为单位，有时候以周为单位。优点：有较多的交易机会，能做到严格的风险控制。缺点：可能会错过趋势中的主升浪。 （3）日内交易。即持有仓位的时间以分钟为单位，也有以小时为单位的。优点：有很多的短线交易机会，不存在隔夜风险。缺点：需要对市场的快速反应能力，并且频繁地交易会带来较大的交易成本。</p><p>长期投资以基本面为基础，但可能遇到较大的回撤是长期投资普遍会遇到的问题（亲身经历）。很少有人能有动力持有，以苹果为例 <img src="Pasted%20image%2020240131163803.png"> （1）2003年——AAPL股价跌到10美元以下，公司能否生存下去都成了问题，你会买公司的股票吗？ （2）2006年——AAPL股价飙升到86美元，然后缩水至51美元。如果此时你持有1000股，你会继续持有下去吗？在当其股价反弹回80美元并看上去要再次下跌时，你会不会卖出呢？ （3）2008年——AAPL股价飙升到202美元，然后又降到115美元，如果你持有1000股，看到了自己（4）2009年——AAPL股价回升到了192美元，后来又降至78美元，比先前的低点还要低，你的账面资产将经受超过50%的损失，你是继续持有还是选择将其变现？</p><p>现在回想起来苹果公司股票的上涨趋势可谓气势非凡，但是扪心自问，你有能力始终持有苹果公司的股票吗？要注意苹果公司期间经历了多次下跌，<strong>有些甚至跌去了50%以上</strong>。要知道，这种程度的下跌往往是标示着上升趋势已经结束了的。</p><p><strong>应对长期投资带来的挑战的一种明智的方法就是在技术分析交易工具的帮助下坚持并执行你对基本面的判断。</strong></p><p>当你决定买入时，可以参考技术指标来确保你买入的价格相对市价买入要便宜一些。如果你的投资很成功，资产价格飞涨，可以使用技术分析工具来确认被过度估值的价格区域。在该区域内兑现你的盈利并且准备好在不可避免的下跌回调过程中再次买入。<strong>这种投资计划需要高强度的专注以及坚持不懈的精神</strong>（坚信基本面 + 坚持做波段）</p><h4 id="波段交易">波段交易</h4><p>我强烈推荐初级和中级投资者进行波段交易。你交易的越多，从中学到的也就越多，可以帮助你积累风险管理和做好交易日志记录的经验。波段交易教起你来比需要几年才能完成学习课程的长期投资更快。</p><p>（13日EMA，26日EMA + 通道 + MACD线和柱 + 动力系统 + 2日强力指数）</p><h2 id="市场指标">6、市场指标</h2><p>没啥好讲的</p><h2 id="交易系统">7、交易系统</h2><p>交易系统是寻找、进入和退出交易的一整套规则（就像手术医生做手术要麻醉，消毒，开刀等一套流程）</p><p>注意：交易系统需要经过手动测试。 准备好每日的价格和成交量数据，时间跨度至少为两年，接着开始测试自己的交易系统。一次推进一天，趋势和震荡区间会慢慢挑战你的系统，你还需要在这个过程锻炼自己的决策技巧，就像经历了股市这几年一样</p><p><strong>如果逐条逐次的测试显示的结果是积极的，你便可以开始用较小头寸的真实资金进行交易了。</strong></p><p>初学者可以从模拟交易开始，但是大多数人是自己的账户被市场打爆后才转向模拟交易的。如果一个人在模拟中没有损失，在实操时损失大，说明： （1）人们在模拟交易中会少一些情绪化，好的决策也容易在没有真实风险的情况下做出 （2）在模拟交易中，你的指令总是能完全成交，真实交易环境下则未必能轻易成交 （3）最重要的一点是，一笔好的交易，当你还在考虑的时候它往往看起来很朦胧。而看起来轻轻松松的交易机会，则往往会伴随各种未知风险。紧张的初学者很容易跳入轻松的交易机会之中，最后以损失告终。</p><p>心理因素对交易影响巨大，进行模拟交易的唯一的好处，就是测试你的纪律性和你的系统。</p><p><strong>如果你能在每天日终坚持下载行情数据，自己做功课，提前准备好下一交易日你要做的交易指令，次日观察开盘情况并记录下你的入场情况，然后每天根据市场情况调整盈利目标和止损点——如果能连续几个月坚持做这组动作，并且一天不缺地记录你的操作日志——这样你就掌握交易真实资金的纪律了。</strong>（以冲动和娱乐为主的人是做不到的，这是要吃苦的）</p><h3 id="三重滤网交易系统">三重滤网交易系统</h3><p>三重滤网交易系统称之为中期时间周期。长其一号的是长期时间周期。短其一号的是短期时间周期</p><h4 id="第一重滤网市场潮流">第一重滤网——市场潮流</h4><p><strong>总结：使用趋势跟随指标识别周趋势并随着趋势的方向交易</strong></p><p>三重滤网从分析<strong>长期图表</strong>开始，三重滤网要求我们在看日线图之前，先要去分析周线图。MACD的斜率由最近两根MACD线柱之间的关系确定，此时会给出一个信号。</p><p>当MACD的斜率转而向上时（箭头A、C和E），它只允许我们在买入或者观望的方向上交易。当斜率转而向下时，它只允许我们在卖出或者观望的方向上交易。</p><p>注意在A点或者E点的买入信号要比在C点的买入信号质量高——因为C点的买入信号产生在中心线之上。 <img src="Pasted%20image%2020240130210830.png"></p><p>交易者有三种选择：买、卖或者观望。三重滤网交易系统的第一重会帮你排除其中一个选项。（记住要在更高一级时间周期里做判断）</p><h4 id="第二重滤网市场波浪">第二重滤网——市场波浪</h4><p>当周趋势是上升的，日趋势的回调正是很好的买入机会。当周趋势是下降的，日趋势的上升正是很好的卖出机会。</p><p>第二重滤网应用的是前面章节讨论过的震荡指标。将其应用到日线图之中以识别日趋势和周趋势之间的偏离。</p><p>将震荡指标应用于日线图之中。在周线的上升趋势中，利用日线的回调来寻找买入机会；在周线的下降趋势中，利用日线的反弹来寻找卖空机会。我喜欢在第二重滤网使用强力指数(force index)，这个指标在第30节已经介绍过。其他一些震荡指标，比如相对强弱指标(RSI)、埃尔德射线(Elder-ray)和随机指标(stochastic)等表现得也很不错。</p><p><img src="Pasted%20image%2020240130211133.png"> 2日强力指数指标EMA可以用作三重滤网交易系统第二重的众多震荡指标之一。当它下降到其中心线之下的时候，强力指数标记出买入的机会。当它上升到其中心线之上的时候，它会标记出卖出的机会。当周趋势是上升的（这里用绿色的水平线标出），在日线震荡指标中仅采用买入信号，以建立多头头寸。当周趋势是下降的（这里用红色的水平线标出），在日线震荡指标中仅采用卖出的信号，以建立空头头寸。</p><p>其他的震荡指标，比如随机指标和相对强弱指标（详见第26节、第27节），当它们进入各自买卖区域的时候会发出交易信号，采取类似的处理即可</p><h4 id="第三重滤网买入技术">第三重滤网——买入技术</h4><p>平均穿透值的计算： 使用日线图中的13周期EMA作为标准，当日内价格低于13日EMA时，记录一下日内价格和EMA的距离。然后选定4-6周的时间范围，逐日计算是否有穿透以及穿透的距离，再计算出平均穿透距离</p><p>用今日的EMA值减去昨日的EMA值，将其结果加回今日的EMA值：这是对明日EMA值的一个估算。用估算的明日EMA值减去你计算的平均穿透值，作为明日设置买入订单的触发价位。</p><p>你将利用回调以折扣价完成买入交易——避免了在突破时买入须支付的溢价。</p><p><strong>但是这种方法最大的问题是牛市时可能不会有这么大的回撤，在纳斯达克指数的测试中，仅仅交易了四次。为此，可以缩短时间范围，或者换别的买入方法</strong></p><p><img src="Pasted%20image%2020240130211658.png"></p><p><strong>突破法（另一种买入方法）：</strong> 当日线趋势与周线趋势相反时，经过短暂调整日线趋势会继续与周线趋势保持同步。此处以上升趋势为例，假设周线趋势向上，日线震荡指标向下，我们可以观察每日价格是否突破前一日最高价，如果突破前一日最高价，可以买入，同时把前一日的价格低点作为止损位。如果当日没有超过前一日最高价，则按照上面的操作继续，直到买入或者周线趋势变为下降</p><p><img src="Pasted%20image%2020240130211421.png"></p><h3 id="动力系统">动力系统</h3><p>注意：动力系统是应用在三重滤网交易系统中第一重的方法</p><p>动力系统能够加强任何一种寻找交易机会的方法，无论是技术分析还是基本面分析。</p><p>要度量任意交易品种的惯性，一个好的指标是短期EMA的斜率。上升的EMA意味着具有牛市惯性，而下降的EMA则说明具有熊市惯性。任意趋势的能量可以用MACD柱状线的斜率来表示。如果它的最近一根线柱比其前一根线柱的高度要高（像字母m-M的高度变化），或者是比其前一根线柱的深度要浅（像字母y-v的深度变化），则MACD柱状线的斜率是上升的，所以它的能量是向上推动的。</p><p>如果最近一根线柱比其前一根线柱要低（像字母M-m的高度变化或字母v-y的深度变化），则MACD柱状线的斜率是下降的，所以它的能量是向下推动的。当我们使用MACD柱状线来定义能量时，它是否高于或者低于零是无关紧要的：真正重要的是最近两条MACD线柱之间的高低关系。</p><p>运用动力系统的原理，在大多数交易软件进行编程，实现价格图表或蜡烛图的颜色显示，这并非难事。当两个指标都是上升的时，线显示的是绿色；代表牛市，如果都是下降的，线显示的是红色，代表熊市；当两个指标相互方向相反时，线显示的是蓝色，代表市场是中性的</p><p><img src="Pasted%20image%2020240130212558.png"></p><p><strong>垂直的绿色箭头标志的柱线后面紧跟着红色的柱线。红色禁止你买入。最好的买入时机是当红色消失的时候。你能看到这些绿色箭头指示出一个接一个的中期底部，包括在图表右边界的买入信号。拥有一个客观的方法能让你在市场下降停止的时候有买入的信心。</strong></p><p><strong>动力系统也会对兑现利润的好时机给出建议。倾斜的红色箭头指向蓝色柱线，蓝色柱线出现在一系列远离价值区域的绿色柱线之后。它们显示牛市上行受阻的位置——兑现盈利的好时机，并等待下一个买入机会</strong></p><p><img src="Pasted%20image%2020240130212739.png"></p><p>短期动量交易者： 如果你是个短期动量交易者，一旦动力系统显示的颜色不再支持你的交易方向，则马上了结你的交易，即使在两个时间周期中只有其中一个改变了颜色。通常，日线MACD的反转要快于周线MACD。当它在上升趋势中下降，表明上升的动量正在减弱。当买入的信号消失时，马上兑现收益，而不是等待出现卖出的信号。在下降的趋势中将这个做法反转一下。一旦动力系统不再显示红色，即使两个时间周期中只有其中一个改变了颜色，也马上清空你的空头头寸。最有效的下降部分已经结束，动力系统已经完成了它的使命。</p><p>动力交易系统鼓励你小心谨慎地入场，但快速地退出。这是专业的交易方法。</p><p>如果两个时间周期中的任意一个变成了蓝色，波段交易者或许仍会持有交易头寸。波段交易者要避免，时间周期中任意一个的颜色与交易的方向变得相反。如果你是多头，时间周期中的一个变成红色，则是时候卖出并空仓观望了；如果你是空头，当动力系统开始变绿，它就发出了让你平掉空头头寸的信号。</p><h3 id="通道交易系统">通道交易系统</h3><p>之前我们已经讨论过使用两条移动均线为一组，来进行交易（见第22节）。使用这组移动均线，并将<strong>长期移动均线作为通道线的核心</strong> 上通道线=EMA+通道系数×EMA 下通道线=EMA-通道系数×EMA</p><h4 id="自动包络">自动包络</h4><p>作者使用了自动包络，当为任意市场设置通道线的时候，开始通道系数可以设置为3%或者5%，然后不断调整通道系数值，直到通道线把最近100根线柱的所有价格数据中大约95%的包含在内，在日线图上大约是5个月时间长度。</p><p>实际操作时，同花顺上的参数设置是固定的，不是自动修改通道线的，所以这个方法需要自己写代码</p><h4 id="atr通道线">ATR通道线</h4><p>三组通道线分别设置在离移动平均线的1倍、2倍和3倍ATR的位置。正常的波动往往在1倍ATR的通道内，只有极端的波动会冲出3倍ATR通道，这往往也预示着反转即将临近</p><p><img src="Pasted%20image%2020240131154258.png"> 区域A——警告。价格跑出+3倍ATR——上升趋势到达了极限。 区域B——卖出。价格不能保持在+2倍ATR上方——多头兑现利润。 区域C——警示。价格下降到+2倍ATR位置停止——为底部的标志。 区域D——警示确认。价格稳定在+2倍ATR上方——底部已经筑成。 区域E——买入。向下假突破试探了+3倍ATR的位置，但不能维持这个低价（看后续、交易量，收盘价和次日开盘价等来判断） 区域F——警告。价格跑出+3倍ATR——看+2倍ATR是否能支撑住。 区域G——警告。价格跑出+3倍ATR——看+2倍ATR是否能支撑住。 区域H——又一个警告。价格跑出+3倍ATR——看+2倍ATR是否能支撑住。 区域I——卖出。价格不能维持在+2倍ATR上方——多头兑现利润。</p><h4 id="通道-macd的实战案例">通道 + MACD的实战案例</h4><p><img src="Pasted%20image%2020240131154822.png"></p><p>区域A——当价格到达下通道线，MACD线的新低表明这个低点将会被再次确认或者突破。 区域B——通道线拒绝了突破，反弹有可能即将开始。 区域C——价格到达上通道线并且被弹回——有可能发生反转 区域D——买入。<strong>价格已经到达下通道线</strong>，<strong>但MACD显示在A与D之间有牛市背离</strong>，中间由C点隔开。 区域E——<strong>价格到达了上通道线，MACD创了新高</strong>，表明这个高点很有可能被再次确认或者突破。 区域F——完全回归价值区间；MACD向下突破到0值线之下，创造了一个熊市背离的迹象，但仍可买入等待回到前期高点。 区域G——卖出并反向做空。价格已经到达了上通道线，然而MACD在高点E和G之间已经表现出熊市背离，中间由F点区隔开</p><h2 id="标准背离通道布林通道">标准背离通道（布林通道）</h2><p>这个通道线的特别之处在于它的宽度和市场的波动有关。它们的交易规则和常规的通道不一样。 （1）计算21日EMA； （2）用收盘价减去21日EMA，得到与均值之间的偏差； （3）将这些差值的平方加总，获得总方差； （4）用总方差除以EMA的长度，得到平均方差； （5）将平均方差开平方根，得到标准差。</p><p>上下两个通道分别是EMA + 两倍标准差（或者自己设置更大的宽度）</p><p><strong>当市场的波动性增大的时候，布林通道的宽度会增加； 当市场波动性减小的时候，布林通道会变窄。 窄的布林通道表明市场处于休眠的、安静的状态。 大的行情常常从平坦的底部位置上爆发。布林通道帮助我们发现市场从安静到活跃的转变。</strong></p><h2 id="交易工具">8、交易工具</h2><p>股票、期权、期货、汇率、等</p><h2 id="风险管理">9、风险管理</h2><p>即使是最周全的交易计划也有可能会出差错，因为市场有随机性。即使是最好的分析和最清晰的交易结构也不能完全避免事故的发生。你唯一能控制的只有风险。可以通过管理交易规模、设立止损线来控制风险。这样你才能将不可避免的损失保持到最小，不让损失拖累你的账户，在长期中才能获得成功。 ### 2%法则</p><p>这个法则是用来防止“鲨鱼”一击</p><p><strong>2%原则会防止你的账户在单次交易中出现本金亏损2%以上的风险。</strong></p><p>举个例子，如果你账户中有5万美元，那么2%原则要求你每次交易承担的最大风险控制在1000美元以内。这不是交易规模，而是账户中本金风险的大小，基于入场点和止损点之间距离大小来计算。</p><p>假定你决定按40美元的价格买入股票，止损线设在38美元。这意味着你每股要承担2美元的风险。你总的可承受风险为1000美元，除以每股2美元，得到你可以交易不超过500股。当然，你愿意交易更少的股票更好，并不需要每次都以最大额度买股票。如果你对那只股票非常有信心，想尽可能多地买入，最多可买的数量为500股。</p><h4 id="如何计算合适的交易规模">如何计算合适的交易规模</h4><p>下一笔交易你准备买入或卖空多少数量的股票呢？新手经常会随意地选择一个数量，比如说1000股或200股，如果他们上一笔交易挣钱了，他们可能会多买一些，如果他们上一笔赔钱了，这一笔就会少买一些。</p><p>事实上，交易规模应该是根据公式计算出来的</p><p>A.你计划要进行的交易的最大风险额度（永远不能超过账户规模的2%）。 B.你预计的进场位和止损位之间的价差——你每股所承担的风险。 C.将A除以B，得到所能交易的最大股数。你并不一定要交易这么多，但是不应该超过这个数字。</p><h3 id="法则">6%法则</h3><p>2%法则只能防止鲨鱼，不能防止一次一次下跌的食人鱼。</p><p>6%原则给每一个账户都设定了一个当月最大回撤比例。如果你达到了限制，这个月接下来的时间就要停止交易。6%原则强制你在受到食人鱼攻击前，从水里走出来。</p><p><strong>当你这个月总损失和持仓头寸的风险额度之和达到账户总金额的6%时，在本月剩下的时间内，6%原则将不允许你进行新的交易。</strong></p><h4 id="可用风险的概念">可用风险的概念</h4><p>在你下单交易前，问一下自己：<strong>如果你所有的交易都向不利于你的方向发展怎么办？</strong> 如果你用2%原则来设定止损位和交易规模，那么6%原则能给你的账户设定最大风险额度。 （1）把你这个月所有的亏损加总 （2）把你现在所有的持仓头寸的风险额度加起来。 假如你以50美元的价格买了200股股票，止损价是48.50美元，每股承担的风险是1.50美元。这样，你该笔交易的风险额度是300美元 （3）两项相加得到总的风险额度，这个额度应该少于月初账户资产的6%</p><p><strong>6%原则将一个常见的问题——“我有足够的钱进行这次交易吗？”——转变成了一个更有意义的问题——“我对这次交易有足够的风险承受能力吗？</strong></p><p>当你已经接近6%原则的限制，但发现了一个非常有吸引力的交易机会，此时你有两种选择：你可以兑现一个盈利的持仓头寸来释放可用风险额度；也可以收紧一些持仓头寸的止损线，减小持仓的风险。只要保证你想要的交易可以进行，而原持仓头寸的止损线又不至于过紧就行</p><h2 id="实践细节">10、实践细节</h2><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">总结：一次交易 </span>=<span class="hljs-string"> 基本面分析选股 + 技术分析确定入点 + 止损位和盈利位选择 + 风险额度计算 + 对交易进行阿氏评分（确认是否买入） + 执行操作 + 制作交易表格和日志 + 持续关注 + 交易结束后复盘</span><br></code></pre></td></tr></table></figure><p>基本面选股不在这本书的范围内</p><p>之前的内容通过三重交易系统确认了买入点</p><h3 id="如何计算盈利目标">如何计算盈利目标？</h3><p>新手没有清晰的盈利目标，当股票价格上涨时他们非常高兴，而当它们下跌时他们又感到特别沮丧。他们的情绪会引导他们在最坏的时机做出反应：在最高点买入，并继续持有；在最低点卖出。</p><ol type="1"><li>波段交易：在价值区间兑现利润</li><li>日内交易：上通道线是盈利目标</li><li>长线交易：阻力位为长线交易设定的盈利目标</li></ol><p><strong>可以设置多个目标分批止盈</strong></p><h3 id="如何设置止损目标">如何设置止损目标？</h3><p>没有设止损价位的交易就是赌博，不要让止损之后立刻上涨这种事情成为不止损的理由，纪律就是纪律。</p><h4 id="安全区域止损趋势交易时">安全区域止损（趋势交易时）</h4><p>先度量市场噪声，再把止损位设在市场噪声区域外数倍的位置。</p><p>例如使用22日EMA来定义为趋势线。如果趋势是向上的，标记出所有回溯期（10～20天）内向下穿透EMA线柱的深度值，将其加总后除以向下穿透的线柱数量，得到回溯期的平均向下穿透值。它反映了当前上升趋势中平均的噪声水平</p><p>你应该把止损位设在远离市场平均噪声水平的位置，把平均向下穿透值乘以一个系数，通常是2以上的数字。如果止损位设得太近容易弄巧成拙。</p><p>注意：<strong>止损位设在并不明显的位置比较好</strong>——要么更接近市场目前水平（波段交易），要么离明显位置更远一点（长期交易）。更近的止损位可以减少亏损规模的风险但是会增加被洗盘出局的风险。更低的止损位可以躲过一些假突破，但是一旦真触及止损，亏损规模会更大</p><h4 id="次低点止损">次低点止损</h4><p>把止损位设在近期的次低点，而不是设在最低点附近。这里面的逻辑很简单——如果股价跌到了次低点附近，那么很有可能还会继续下跌并触及最低点，而这正是止损单扎堆的位置。使用尼克止损法后，同样市场下跌情况下，承受的损失和滑点要少很多</p><h4 id="atr止损">ATR止损</h4><p>当你在最近的一根线柱中入场时，把你的止损位设在离当前这根线柱的极值至少一倍ATR的位置，如果是在两倍ATR的位置设置止损位就更安全了。</p><p>你可以把它当作一种移动止损的方法，随着线柱的转变而移动它。原理还是一样的——把止损位设在市场噪声区域之外</p><p>使用移动止损的一个优点是它们逐渐减小了所暴露的风险额度。前面我们讨论过“可用风险”的概念。使用移动止损时，如果交易价格朝对你有利的方向变化时，它可以逐渐释放可用风险额度，从而允许你开始做新的交易。</p><p>但是坏处在于，其他的止损方式，随着价格上涨，止损点一开始是不变的，上涨越多离止损位越小，受到噪声波动的概率越小。而ATR是始终改变的，受到噪声波动的概率是一致的</p><h4 id="不要让盈利变成亏损">不要让盈利变成亏损</h4><p>当交易的发展已经兑现了你的预期，这笔交易的盈利潜力逐渐变小。而你的风险（盈利和止损线之间的距离）会不断增加。交易就是在管理风险，当盈利与风险的比例渐渐恶化时，你便需要减小承担的风险。通过提升止损线，保护一定比例的利润，可以使盈利与风险比例控制在更平衡的位置。</p><p>提前设定好当盈利达到多少时，将止损点变为盈亏平衡点</p><h4 id="只顺着你交易的方向移动止损线">只顺着你交易的方向移动止损线</h4><p>当接近止损线时，市场出现了一个上涨信号，此时注意千万不能给下跌更大的空间。“给下跌更大的空间”只是一种美好的、单纯的想象。这个选项不应该出现在一名严谨的交易者的工具箱中。</p><h3 id="如何评价交易">如何评价交易？</h3><p>买入评级=（最高价-买入价）/（最高价-最低价），大于50%就是不错的成绩 卖出评级=（卖出价-最低价）/（最高价-最低价），大于50%就是不错的成绩</p><p>交易评级=（卖出点-买入点）/（通道线高点-通道线低点）。任何一笔交易的获利是通道线高度的30%或是更多，就是一笔A级交易</p><p>好的通道线包含过去100天日线里90%～95%的价格（参考第22节）。你可以使用任何通道线——EMA的平行线、自动包络线、肯特纳通道或者ATR通道——只要你前后标准始终一致就行。</p><h2 id="保持良好的习惯">11、保持良好的习惯</h2><p>每天看新闻，关注宏观经济指标的日期，关注财报的日期</p><h3 id="阿氏交易评分">阿氏交易评分</h3><p>任何交易计划都要依据所采用的策略量身定做。交易计划必须能提示你检查财报期、分红派息日期，以及期货交割日期，使你避免被可预见的新闻所侵袭。它必须清楚地记录你计划好的买入价、目标价、止损价以及交易规模。</p><p>把交易计划写下来能让其变得真实。一旦你进入了一笔交易，并且你的股票开始出现波动，你可能会感到紧张，而忘了去执行特定的操作。在进入交易之前，先写下计划能帮你在风暴中建立一个理智和稳定的堡垒，它能帮助你不会忽略任何必要的事情。</p><p><img src="Pasted%20image%2020240131173615.png"></p><p>（1）强力系统的周线图（前面章节有描述）——周线图是红色得0分，周线图是绿色得1分，周线图是蓝色得2分。强力系统为红色时，是禁止交易的；绿色时还可以进行交易，但是可能有些太晚；蓝色（紧跟在红色之后）表示恐慌正在褪去，是买入的好时机。 （2）强力系统的日线图——与上一条同样的问题、同样的评分，标记在日线图上。 （3）日线价格——在日线图上，如果最新价格在其价值区间之上得0分；在价值区间范围内得1分；低于其价值得2分。价格在价值区间之上时，买入已经有些迟了；在价值区间内还可以；在价值区间之下则是一笔好买卖。 （4）假突破——没有的话得0分；已经发生得1分；很有可能将要发生得2分。 （5）完备性——没有周期符合得0分；有一个符合得1分；两个周期看起来都很完备得2分。</p><p><strong>总分7分及以上才能买入</strong></p><h3 id="写交易表格">写交易表格</h3><p><img src="Pasted%20image%2020240131174123.png"></p><h4 id="第一部分交易鉴定">第一部分：交易鉴定</h4><p>分别写下股票代码（名称）、下一个财报的披露日期、除息日、制作表格的日期</p><h4 id="第二部分交易的阿氏评分">第二部分：交易的阿氏评分</h4><p>前文提到了 #### 第三部分：市场、买入点、目标价、止损点和风险控制 最左边的五个空格要求我回答有关市场基本状况的问题。尖峰反弹信号是否有效，追踪股票均线的指标是看多还是看空，这只股票的空头净额是多少，需要多少天来补上，所有这些内容都已在本书前面描述过。最后一个空格是简短的总结。</p><p>用箭头所连接的三个空格是我决策制定过程的核心部分。它们所要的是每笔交易最重要的三个数字：买入价、目标价、止损价。</p><p>资金风险——这笔交易中，你愿意冒亏损多少钱的风险？这个数额永远不应该超过你账户资产的2%。我通常把它控制在远远低于这个门槛的位置。</p><p>持仓规模——根据持仓限额和入场点与止损点的差额，可以算出你能买多少数量。这已经在第50节“风险控制的铁三角”中详细论述过。</p><h4 id="第四部分买入之后">第四部分：买入之后</h4><p>A级盈利目标是在买入价上加日通道线高度的30%。软止损是记在脑海中的指令，而硬止损或灾难性止损是实在的指令。它不应该比第三部分中所写的止损价低。记下你将把止损位移到盈亏平衡位置的价格水平。当你执行这些必要步骤时，检查右手边的方框：设置止损价，创建一个日志，下达止盈订单。</p><h4 id="第四部分备注">第四部分：备注</h4><p>自己再补上一些买这个股票的原因，避免很快忘掉这个交易，无法复盘。 当时你在K线图最右边区域艰难地决定买入卖出，如今这些K线已经到了图表的中间位置了，这个时候你可以重新审视你当时的决定，并学会如何改进它们</p><p><strong>回顾你的资产曲线是非常必要的，因为只有上升的曲线才能证明你是一位成功的交易者。如果你的资产曲线是下行的，说明或者你的系统可能有错误，或者你的风险管理十分薄弱，或者你缺乏交易纪律性——无论是什么，你都必须查找清楚并予以解决</strong>。</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">总结：一次交易 </span>=<span class="hljs-string"> 基本面分析选股 + 技术分析确定入点 + 止损位和盈利位选择 + 风险额度计算 + 对交易进行阿氏评分（确认是否买入） + 执行操作 + 制作交易表格和日志 + 持续关注 + 交易结束后复盘</span><br></code></pre></td></tr></table></figure><p>写在最后，我的指标是什么呢？ EMA（13，26） + 布林带 + 动力系统 + MACD + 强力系统 + ADX + RSI</p>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以交易为生（下）</title>
    <link href="/2024/01/29/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2024/01/29/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本部分包含风险管理、实践细节、如何养成记录习惯</p><h2 id="风险管理">风险管理</h2><p>好的交易系统在一段时间内实现的盈利比亏损要多，但即使是设计最细致的交易系统也不能保证每次交易都成功。没有交易系统可以确保从不遭受亏损，甚至要避免出现一系列连续亏损都很难。</p><p>没有管理亏损的能力是交易中最严重的缺陷之一。当不断恶化的损失将前期很多次成功交易的利润吞没时，新手会像车头灯前被吓住的鹿一样，僵在那儿。一般人的本性都是很快就止盈，但却会一直拿着亏损的交易，希望能回本甚至盈利。</p><p>当这些业余的交易者放弃了希望，在巨亏后平掉头寸的时候，他们的账户往往已经严重亏损甚至无可挽回了。要想成为成功的交易者，你需要学习风险管理规则，并严格执行它们。</p><h3 id="情绪与概率">情绪与概率</h3><p>金钱能激发强烈的情绪。赚钱或者赔钱产生的情绪会影响我们的交易</p><p>我在事业之初，曾听一位专业的交易者说：“成功的交易应该是有些无聊的。”他每天都花费很长的时间做功课，筛选市场数据，计算风险，坚持记录。这些耗时的任务并不有趣——但他的成功正是建立在这些枯燥乏味的工作之上的。新手和赌徒们觉得很好玩，但结果是以损失为代价。</p><p>另一种错误是反复盘算持仓头寸中的盈亏。<strong>新手幻想着持仓浮盈可以买到什么</strong>，或者比较持仓浮亏和自己的工资，就吓傻了。反复想钱的问题，干扰了我们及时去做决定。<strong>专业的交易者总是集中精力管理交易，他们只有在平掉头寸之后才会去关注账户中的资金。</strong></p><p>专业的交易者不会在持仓过程中计算得失。他们只是在账期末——比如说月末，才会去统计盈亏情况。如果你要问我的持仓情况怎样，我会回答稍微盈利、较大盈利或稍微亏损（较大亏损是不可能的，因为我会及时止损）。</p><p>如果你一定要我说出具体数字，我可能会说我赚或赔了几个点，但从不会转换成具体多少金额。持仓时去计算得失是很不好的习惯，我花了好几年的时间才让自己克服掉这个不良习惯。我可以关注收益或亏损的百分点，但是我不会把它们转化成钱来考虑。</p><p>另一个关键点是：专业人士不会因为单次交易的成败而生气。在市场中有太多的随机成分。交易中我们可能每个步骤都是对的——但是仍然可能会以失败告终，就像外科医生可能把每件事情都做对了，但仍然可能救不好一个病人。</p><p><strong>在市场中，梦想是我们承担不起的奢侈品。</strong></p><p>夏皮罗博士曾做过一项测试，说明人们对待商业机会的行为模式。首先，要求一组人从两种情形中选择一项：一是75%的机会获得1000美元，25%的可能什么都没有；二是直接获得700美元。五分之四的人选择了选项二，即使是向他们解释了长期来说选项一的预期收入是750美元。大部分人都做了情绪化的决定，只得到了较小的收入。</p><p>另一个测试的两个选项：一是人们必须选择确定的亏损700美元；二是75%的可能损失1000美元，25%的可能什么都不损失。四分之三的人选择了选项二，比起确定损失700美元，他们情愿多损失50美元。为了避免风险，他们最大化了损失。</p><p><strong>情绪化交易者渴望确定的回报，放弃了利润最大但包含不确定性的机会。他们选择赌博来推迟损失兑现。==迅速兑现盈利，推迟兑现损失，这是人类的天性==</strong></p><p>（其实这个论证是有问题的，因为量化交易的理论里面有一个很重要的概念叫效用模型，因为生活成本问题，不同人的效用模型是不同的， 比如有1000w会更着重于争取100w的收益，而有1000块则会更注重不造成100的亏损）</p><p>最好的交易系统简单而稳定。它们的构成要素很少。系统越复杂，其部件出错的风险越大。</p><p>交易者喜欢用历史数据回测来优化系统，但问题是你的经纪商不会让你回到历史去交易。市场在变化，一个指标能很好地跟踪过去一个月趋势不一定会很好地预测未来一个月的走势。所以不要优化你的系统，而是解除对系统的优化。稳定的系统能经受住市场的变化，在真实交易中可以战胜过于优化的系统</p><p>最后，一旦你开发出了一个好的系统，不要再改来改去。如果你喜欢修修补补，那就再去开发一个系统。罗伯特·普莱切特(Robert Prechter)曾提出：“大多数交易者有一个很好的交易系统，但为了改造成一个完美的系统反而毁了它。</p><p><strong>一旦你有了一套能稳定运行的系统后，接下来要制定资金管理规则，帮助你从敏锐的交易系统中获得正的期望收益。资金管理规则能帮助开发出一个好的系统，但并不能拯救一个没用的交易系统。</strong></p><h3 id="风险控制的两个原则">风险控制的两个原则</h3><p>有两种方式可以快速毁掉一个账户：从不使用止损和持有相对账户来说过高比例的仓位。</p><p>没有设置止损的交易会使你暴露在无限的损失之中。在接下来的章节中，我们会讨论风险控制的原则和规则，但只有你真正使用止损策略时它们才会起作用。</p><p>另一种致命的错误是过度交易——相对于你的账户来说持有过高的仓位。这就像在一艘小船上装上了一个大帆——一阵强风会将船掀翻，而不会使它跑得更快</p><p>人们之所以持有过高比例的仓位，是由于无知或贪婪，或者是二者兼有。有一条简单的数学理论会帮助你确定每次交易的最大规模，接下来会进行介绍</p><h4 id="法则">2%法则</h4><p>单次交易出现灾难性的亏损对账户来说，就像倒霉的游泳者被鲨鱼袭击了。可怜的新手在一次交易中就亏了四分之一资金，就像是被鲨鱼咬去了一条胳膊或腿，鲜血在海里弥漫。在后面的交易中，他必须要有33%的收益才能回本，而他能够做到的机会微乎其微。</p><p><strong>==2%原则会防止你的账户在单次交易中出现本金亏损2%以上的风险。==</strong></p><p>举个例子，如果你账户中有5万美元，那么2%原则要求你每次交易承担的最大风险控制在1000美元以内。这不是交易规模，而是账户中本金风险的大小，基于入场点和止损点之间距离大小来计算</p><p>假定你决定按40美元的价格买入股票，止损线设在38美元。这意味着你每股要承担2美元的风险。你总的可承受风险为1000美元，除以每股2美元，得到你可以交易不超过500股。当然，你愿意交易更少的股票更好，并不需要每次都以最大额度买股票。<strong>如果你对那只股票非常有信心，想尽可能多地买入，最多可买的数量为500股</strong></p><p>仅仅是市场分析能力强并不能使你成为赢家。善于寻找交易机会的能力也不能保证成功。市场中不乏好的分析师，但他们很多都最终以失败出局。只有当你保护自己不会遭到市场鲨鱼式的攻击时，你才能从你的研究中获利。</p><p>我曾见过交易者连续20次、30次，甚至50次盈利，但最终结果仍然是亏损出局。当连续赢钱的时候，你觉得自己已经完全了解了这个游戏。这时，<strong>往往一次灾难性的损失会把历史的盈利一扫而空，甚至连本金都折进去。你需要能抵抗“鲨鱼的一击”的资金管理方法。</strong></p><p><strong>技术分析能帮你决定止损点位置，这会将每股损失限定在一定范围内。资金管理规则能从整体上保护你的账户。最重要的一个原则就是在每次交易中都要将你账户承担的风险控制在2%以内。</strong></p><p><strong>这条原则中的本金范围仅仅指你交易账户中的钱，并不包括你的储蓄、家中的财产、退休金账户或圣诞节储蓄。</strong></p><p>交易资产是你投入到交易中的资产，这是你真正的风险资产——属于你交易事业的资产。如果你有各自独立的股票、期货、期权账户，那就对每个账户分开运用2%原则吧。</p><p>有人问我当对某笔交易很有信心时，2%原则这个数字是否可以增加，<strong>我的回答是这就像你蹦极时，因为喜欢桥上的风景，而额外加长了蹦极绳长度一样。</strong></p><p>往往专业人士经常说，2%太高了，他们一般只愿意冒更小的风险。如果有100万美元，你肯定不愿意一笔交易在一天内就亏掉2%。一位对冲基金经理在与我咨询时说，他未来六个月的目标是增加交易规模。在单次交易中，他从不会承担超过0.5%的风险——现在他正在努力使自己将风险水平提高到1%。好的交易者会倾向于把风险远控制在2%的限制以下。无论何时，业余人士和专业人士出现对立时，你肯定知道应该选择哪一边。尽力把风险控制在2%以下吧——<strong>这绝对已经是最大的风险水平了。</strong></p><p>下一笔交易你准备买入或卖空多少数量的股票呢？新手经常会随意地选择一个数量，比如说1000股或200股，如果他们上一笔交易挣钱了，他们可能会多买一些，如果他们上一笔赔钱了，这一笔就会少买一些</p><p>事实上，交易规模应该是根据公式计算出来的，而不是随意决定的。可以使用2%原则对你可以交易的最大数量做出理性的判断。我把这个过程叫作“风险控制的铁三角”（见图50-1）</p><p><img src="Pasted%20image%2020240129143541.png"></p><p><strong>如果你的账户比较小，可能你每次交易都要使用所允许的最大量。随着你的账户增大，你可能会想让每笔交易规模差异化，比如对一般的交易是最大限额的三分之一，对比较有信心的交易使用三分之二，其他更有信心的可能就全额使用了。无论你怎么做，风险控制的铁三角总会为你设定最大允许的交易规模。</strong></p><p>在期货市场中只有运用更敏感的风险控制才能取胜。你也可以使用2%原则。 （1）计算你的账户规模2%的值——这是每次交易所能承担的最大风险水平。如果你的期货账户中有5万美元，那么最大的风险额度是1000美元。 （2）找到你感兴趣的交易品种的图表，确定好入场点位、盈利目标点位和止损点位。记住：没有这三个价位的交易不是真正的交易，而是赌博。计算你设定的入场点位和止损点位的差值。 （3）将A值除以B值，如果结果小于1，不要交易——那意味着一份合约的风险你都承担不起。</p><h4 id="法则-1">6%法则</h4><p>食人鱼是热带河流中的一种鱼，不到人类的一只手掌大，但却有一副可怕的牙齿。它们十分危险的原因是，其会以群体的方式进行攻击。不论是狗、驴还是人，只要跌入热带河流里，整群食人鱼会围上来攻击，将猎物咬光。如果是一头牛走进河里，受到了食人鱼的攻击，几分钟之后河里就只剩它的骨头了。通过2%原则可以远离鲨鱼攻击的交易者，仍然需要保护，免受市场食人鱼式的攻击。6%原则能将你从一连串致命的攻击中拯救出来。</p><p>当发现自己遇到困难时，我们中的大多数人会加大赌注。亏钱的交易者经常加大头寸，试着拯救他们的交易。亏钱时更好的选择是退后一步，停下来去思考。6%原则给每一个账户都设定了一个当月最大回撤比例。如果你达到了限制，这个月接下来的时间就要停止交易。6%原则强制你在受到食人鱼攻击前，从水里走出来。</p><p><strong>当你这个月总损失和持仓头寸的风险额度之和达到账户总金额的6%时，在本月剩下的时间内，6%原则将不允许你进行新的交易</strong></p><p>在与市场的周旋中我们都有过连续盈利的时期，当我们的每笔交易都点石成金时，应该积极地交易。</p><p><strong>同样，有一些时候我们的交易变得非常糟糕。交易系统与市场步调完全相反，接连亏损。在这个时候，要重新审视这段时期，不要给自己太大的压力，退后一步、冷静一下尤为重要。</strong></p><p>专业人士在赔钱的时候可能会去休息一下，但会继续盯着市场，等待与市场的节奏重新匹配上。而业余人士更可能加大交易规模，直到账户出现严重亏损。6%原则会使你暂停下来，这时你的账户大体上还是完整的。</p><p>==<strong>6%法则带来了可用风险的概念，以下部分非常重要！</strong>== （1）把你这个月所有的亏损加总。 （2）把你现在所有的持仓头寸的风险额度加起来。一笔持仓交易的风险额度是你入场点位和止损点位之间的价差，乘以持仓数量。假如你以50美元的价格买了200股股票，止损价是48.50美元，每股承担的风险是1.50美元。这样，你该笔交易的风险额度是300美元。如果市场向有利于你的方向发展了，你把止损价位上调到盈亏平衡的价位，你的该笔交易的风险额度就会变成零。 （3）将以上两项相加（这个月的总损失加上持仓头寸的风险额度）。如果两者之和已经超过你月初账户资产的6%时，这个月剩下的时间你都不能再增加交易头寸了，除非市场顺着你持仓的方向发展了，允许你提高了止损线。</p><p>在你下单交易前，问一下自己：如果你所有的交易都向不利于你的方向发展怎么办？如果你用2%原则来设定止损位和交易规模，那么6%原则能给你的账户设定最大风险额度。</p><p>6%原则将一个常见的问题——“我有足够的钱进行这次交易吗？”——转变成了一个更有意义的问题——“我对这次交易有足够的风险承受能力吗？”</p><p>在任何一个月份风险水平都不要超过账户资产的6%，这条限制将你总的风险保持在可控范围之内，保证能在市场中长期存活下去。你每月的总的可用风险是你账户本金的6%，每次交易前你都要问自己的第一个问题是：“考虑自己这个月所有持仓头寸和已了结的交易，我还有足够的可用风险进行这笔交易吗？”</p><p><strong>如果你根据6%原则已经不能再进行新的交易，还是要继续跟踪自己感兴趣的股票。如果你看到了一个确实想交易的机会，但没有足够的可用风险额度了，可以考虑平掉部分持仓头寸，释放出一些风险额度给它。</strong></p><p>当你已经接近6%原则的限制，但发现了一个非常有吸引力的交易机会，此时你有两种选择：你可以兑现一个盈利的持仓头寸来释放可用风险额度；也可以收紧一些持仓头寸的止损线，减小持仓的风险。只要保证你想要的交易可以进行，而原持仓头寸的止损线又不至于过紧就行（见第54节）。</p><p><strong>下面是一个非常好的参考例子</strong>，假设交易者对任何一笔交易都将风险控制在账户规模的2%水平： （1）在月底时，交易者账户中有5万美元资金，无持仓头寸。他在月初确定好了最大的风险控制指标——每笔交易采取2%原则，也就是1000美元；总账户采取6%原则，也就是3000美元风险额度。 （2）几天后他发现了一只非常有吸引力的股票A，设定好止损线后买入了该股票，风险为账户本金的2%，也就是1000美元 （3）几天后他又发现了股票B，并做了一笔相似的买入交易，增加了另外的1000美元风险 （4）在这个星期快结束时，他又发现了股票C并买入，又增加了另外的1000美元风险 （5）第二个星期，他发现一只股票D比之前的三只股票都更有吸引力，他可以买入吗？——不可以，他不应该买入，因为他整体账户的风险暴露已经达到6%了。他有三个持仓的交易，每一个的风险都是2%，意味着如果市场变坏他可能损失6%。6%原则不允许他再增加任何风险。 （6）几天后，股票A上涨了，交易者将其止损线提高到了盈亏平衡的位置。在几天前还不能买入的D股票，现在依然有吸引力。他现在可以买入了吗？——可以，他可以买它，因为现在他账户承担的风险仅为4%。在股票B上承担的风险为2%，在股票C上承担的风险也为2%，但是股票A已没有承担任何风险，因为它的止损点在盈亏平衡点之上。交易者买入股票D，占用了另外的1000美元，也就是2%的风险额度。 （7）在这星期的之后几天，交易者发现了股票E，前景非常看好。他可以买入E吗？——不可以，根据6%原则，他的账户已经暴露在了B、C和D等三个合计6%的风险中（A已经没有风险了），因此他不能买入股票E。 （8）几天后，股票B被止损了，此时股票E仍然很诱人。他可以买它吗？不可以，因为他已经在股票B上亏损了2%，股票C和D又承担了4%的风险暴露，此时买入新头寸会使他每月的风险暴露超过6% <strong>这个案例中，三个个持仓头寸并不是非常分散，如果你想进行更多次交易，那就让每笔交易承担的风险小于2%。例如，如果每笔交易的风险仅为账户资产的1%，你持有6笔头寸才达到6%的限制。当交易的账户很大时，我依然使用6%原则，但是对2%原则，我会收紧到1%以下。</strong></p><p>6%原则允许你在一个好的趋势中，增加交易规模。但是在连续亏损的趋势中，会让你提早结束交易。当市场向着有利于你的方向变化时，你可以把止损线调整到盈亏平衡的水平，这样会有更多的可用风险用于增加新的交易。另一方面，如果头寸的趋势向着不利的方向变化，并且触及止损线时，你应该立即止损，保证账户主要资产的安全，以便下个月能有个全新的开始</p><p>2%原则和6%原则为资产增值提供了准绳——持仓头寸盈利后可以新增交易。如果你买了一只股票并且涨了很多，足以把止损线提高到成本线以上时，那么你可以加仓这只股票，只要新开头寸的风险额度不超过账户资产的2%，总的账户风险也不超过6%即可。对每次加仓当作一笔单独交易进行管理</p><p>很多交易者都会有情绪波动，在市场高位时表现得兴致高昂，而在市场低位时则感到沮丧。这些情绪波动是不利于你交易的，只会起相反作用。把精力放在风险控制上是更好的选择。2%原则和6%原则可以把你的努力转换成更安全的交易。</p><p>参考文中，连续十三天亏损的案例，让它把交易数额从500股降到100股，直到开始连续盈利为止，再慢慢提高额度，这说明： 更高的风险妨碍了我们的交易能力。你需要训练自己通过计划好的步骤慢慢地接受风险。基于你交易的频繁程度，这些步骤可以以周或月为单位，但原则都是一样的——你要在两个时间单位内盈利，然后进入下一个阶段，承担更大的风险。如果你在某个时间单位内赔钱了，则后退一步，减小你承担的风险。这对巨大亏损后，想重新回到交易中的人来说尤其有帮助。你要不带恐惧地逐渐以自己的方式回到交易中。</p><p>一个很有意思的事实是：当成功的机构交易员出来自己单干时，他们中的大多数人都会赔钱。即使他们使用的可能是相同的设备、相同的交易系统，仍然保持着社会关系，但最终他们仍会失败。几个月后，很多单干的人又会重回猎头公司那儿找一份交易员的工作。为什么他们能给公司赚钱，却不能给自己赚钱呢？</p><h2 id="实践细节">实践细节</h2><p>当股票创出新高后，你会买吗？在双重顶时会卖吗？在回调中会买吗？你会寻找趋势反转吗？以上这些的方法各不相同，每种方法都可能赚钱，也可能赔钱。你应该选择那些吸引你、让你很舒服、适合你能力和气质的交易方法。没有一种交易方法是适合所有人的，就像没有一种运动是适合所有人的一样。</p><p>要想成功地交易，先要选定一种交易模式。在进行行情数据扫描之前，你应该十分清楚你想要找到什么。开发你的系统，并通过一些小交易先测试一下，确定你可以遵守交易纪律。你必须确定在你看到设计好的交易信号出现时，会按计划交易。</p><p>不同的交易风格需要不同的入场技术、不同的设定止损线和确定盈利目标的方法，以及不同的扫描行情数据的方法。但是，有几条关键的原则是适用于所有交易系统的。</p><h3 id="怎样设置盈利目标足够是关键词">怎样设置盈利目标：足够是关键词</h3><p>为交易设定盈利目标跟找工作时要想清楚自己所需要的工资和福利待遇是一样的。你实际得到的可能比预想的或多或少，<strong>但是你要有一个预期值</strong></p><p><strong>在每次交易时，记下你的入场价格、盈利目标和止损线</strong>，以便比较你的风险和收益。<strong>盈利的潜力应该至少是风险的两倍</strong>。很少值得去为了赚一美元而承担一美元的风险——那样的话还不如直接去轮盘赌桌上赌颜色。在每次交易中符合实际的盈利目标和坚定的止损线能帮你做出是否参与交易的决定。</p><p>当计算交易者的盈利潜力时，我们陷入了一个悖论之中——你的预期持有时间越长，盈利潜力越大。在一个月内，股票上涨幅度肯定能比一周多。但另一方面，你持有的时间越长，不确定性越大。<strong>对短期价格变化来说，技术分析很可靠，但是长期内可能会出现很多重大失误。</strong></p><p>在以前关于选择交易时间长度的章节中，我们检验了三种主要的选项。<strong>长线交易或者说投资，持有期是以月来衡量的，有时甚至是年。波段交易可能就几天，有时可能是几周。日内交易是以分钟来计算的，甚至很少用到小时。</strong></p><p>移动平均线和通道线可以帮助我们设定波段交易的盈利目标，它们对日内交易也是很有用的，只是要更注意使用震荡指标。一旦出现与你交易方向背离的信号，马上退出。长线交易的盈利目标通常参考前期的支撑位和阻力位</p><p>上面提到的三个目标位——移动均线、通道线和支撑/阻力位，是很合适的。它们并不是高不可攀的目标，而是很现实的。记住，“足够”是很有力的词——在生活和交易中都是如此。这使一切都在你的掌控之中，通过一个又一个交易达到“足够”后，从长时间来看，你会取得相当不错的成果。</p><p>下面举个例子来说明</p><h4 id="波段交易">波段交易</h4><p><img src="Pasted%20image%2020240129152710.png"> 表中的最后三天被标记上了a、b和c。在a日，威瑞信股票向上突破压力位，也就是图中的水平虚线，但是MACD柱甚至没能上到0值之上。第二天，也就是b日，股票开盘价在橙色线以下。但是MACD柱甚至没能上到0值之上。第二天，也就是b日，股票开盘价在橙色线以下，说明前一天是一次向上假突破（有些人称之为“逆冲”），只要MACD柱向下，形成一个熊市背离，我所要的模式就形成了，立即做空。</p><p>威瑞信整天都在下跌并且收在最低的位置。第二天，也就是c日，<strong>它试图筑一次底，因为它的价格已经在价值区间内了</strong>。我觉得已经足够了，所以平掉了仓位。我有3000股，每股扣除佣金钱赚了82美分的利润，也就是合计2460美元。如果持有更长时间，我本可以赚得更多的，但是在波段交易中，快速地赚0.25美元要好过慢慢地赚1美元。<strong>在价值区间内兑现利润减小了不确定性，也减少了你暴露于风险中的时间</strong>。</p><p><img src="Pasted%20image%2020240129153653.png"> <strong>在阻力位为长线交易设定盈利目标：</strong> 艾戈公司(IGOI)在上面所示周线图的右侧的最新交易价格为3美元偏上水平，逐渐向上的EMA确认了一轮新的上升趋势。它之前的高点是60美元以上（注意有一个“袋鼠尾”），中间最近的两次反弹都以失败告终了，最近的一次是在15美元附近，之前的一次在22美元附近（都以紫色虚线标注）。如果这里开启了新一轮的上涨趋势，应该将第一盈利目标设在15美元，第二个设在22美元</p><h3 id="怎样设定止损线不要异想天开"><strong>怎样设定止损线：不要异想天开</strong></h3><p>对长期的生存和成功来说，止损是非常必要的，但是我们大多数人都非常不情愿去使用它们，<strong>市场的反复促使我们强化不止损的坏习惯</strong>。<strong>我们都有过这样不愉快的经历：你买入了一只股票，接着它的价格跌到了止损线，结果你亏损割肉出局了——但是你又眼睁睁地看着它反转上行了，跟你最初所预想的一样。如果你不设止损线，而是一直持有这只股票，本可以赚钱而不是亏钱的。像这样双重打击几次后，你就会对止损非常厌恶了</strong></p><p>经过几次这样的事情后，你的交易逐渐开始不使用止损策略了</p><p>在一小段时间内这也确实表现得很好，没有了那样的双重打击。有些交易虽然不成功，但在没有止损线的情况下，你也退出了——<strong>此时你有足够的纪律性。但这个幸福的旅程会在一笔大的交易开始走坏时结束。你一直等着，期待它可以稍微反弹一些，让你有个更好的退出价位，但它却一直下跌。随着时间的流逝，它对你的账户造成了越来越严重的伤害——你正在被一只鲨鱼吞掉</strong>。很快你的生存会受到威胁，你的信心也濒临崩溃。</p><p><strong>（1）在“市场噪声”之外设定止损</strong>（EMA + 平均穿透 * 系数） <strong>安全区域止损</strong>在我的《走进我的交易室》一书中已有详细的描述。先度量市场噪声，再把止损位设在市场噪声区域外数倍的位置。简言之，使用22日EMA来定义为趋势线。如果趋势是向上的，标记出所有回溯期（10～20天）内向下穿透EMA线柱的深度值，将其加总后除以向下穿透的线柱数量，得到回溯期的平均向下穿透值。</p><p>它反映了当前上升趋势中平均的噪声水平。你应该把止损位设在远离市场平均噪声水平的位置。这就是为什么你需要把平均向下穿透值乘以一个系数，<strong>通常是2以上的数字</strong>。如果止损位设得太近容易弄巧成拙。</p><p>当EMA趋势是下降的时候，我们使用前期线柱的最高价向上穿透来计算安全区域。我们数一下选定期间内线柱的向上穿透情况，计算它们的平均值，得到平均向上穿透值。选一个系数乘以它，比如<strong>可以从3开始选</strong>，将得到的值加到每次高点上。<strong>在高点卖空比在低点买入需要更宽的止损空间</strong>。</p><p>正如本书中其他所有的系统和指标，<strong>安全区域不是可以取代独立思考的自动工具。你必须选好回溯期，也就是计算安全区域的时间周期</strong>。<strong>你也需要调整好乘以平均穿透值的系数，这样你的止损线才能在正常的噪声水平之外。</strong></p><p><strong>（2）不要把止损线设在明显的位置</strong>（不要选最低点，可以选次低点）</p><p>从密集的价格区间向下探出显眼的新低点，最容易吸引交易者在新低点下方设置止损位。问题是太多人在这里设止损线，造成这个区域里止损的人过多。市场有一个神秘的习惯，会很快地跌穿这些明显低点，引发止损后再反转，发动新的上升趋势。为了避免这种情况，我有几点建议。</p><p>把止损位设在并不明显的位置比较好——<strong>要么更接近市场目前水平，要么离明显位置更远一点。更近的止损位可以减少亏损规模的风险但是会增加被洗盘出局的风险。更低的止损位可以躲过一些假突破，但是一旦真触及止损，亏损规模会更大。</strong></p><p>是做选择的时候了。对短期波段交易来说，<strong>把止损设在更近的位置比较好，然而对长线交易来说，最好设定更远的止损线。记住“风险控制的铁三角”——更远的止损可以交易的规模会较小</strong>。</p><p>我喜欢一种叫尼克止损的方法，他发明的这种止损方法是<strong>把止损位设在近期的次低点</strong>，<strong>而不是设在最低点附近</strong>。这里面的逻辑很简单——如果股价跌到了次低点附近，那么很有可能还会继续下跌并触及最低点，而这正是止损单扎堆的位置。使用尼克止损法后，同样市场下跌情况下，承受的损失和滑点要少很多。</p><p>当作为空方的时候这个原则也是一样的——不把止损线设在最高点之上，而是设在次高点</p><p><img src="Pasted%20image%2020240129154518.png"></p><p>在可口可乐(KO)公司的图中，我们发现了一个伴随着牛市背离的向下假突破，动力系统从红色变成了蓝色——允许买入。如果我们做多买入，我们应该在哪里设定止损线呢？ 线柱A——最低点是37.10美元； 线柱B——最低点是37.05美元； 线柱C——最低点是36.89美元（一个向下假突破，比线柱A的最低点还低21美分）； 线柱D——最低点是37.14美元</p><p>大众通常会把止损线设在36.89美元下面，但是尼克止损会设在37.04美元——<strong>比近期的次低点少1美分，是线柱B的最低点</strong></p><p>在直觉外科公司(ISRG)的图表中，我们可以看到一个伴随着熊市背离的向上假突破，动力系统由绿变蓝——允许卖出。如果我们做空卖出，我们应该在哪里设置止损线呢？ 线柱A——前期高点447.50美元； 线柱B——最高点是444.99美元； 线柱C——最高点是447.75美元（向上假突破，比前期高点还高25美分）； 线柱D——最高点是442.03美元</p><p>你可能想要多尝试几种设立止损的方法，像在本书前面提到的抛物线止损法、安全区域止损法和波动止损法。你可以激进，也可以保守，但是要记住最重要的原则：第一是要有止损；第二是不要把止损位设在太明显的位置，也就是图上谁都能看出来的位置。设止损位时要比显眼的位置更近或更远一点——<strong>要与集中的群体保持距离，因为你并不想做一个平庸的交易者。</strong></p><p><strong>同样的道理，不要把止损位设在整数价格上</strong></p><p><strong>（3）平均真实波幅（ATR）止损</strong> 当你在最近的一根线柱中入场时，把你的止损位设在离当前这根线柱的极值至少一倍ATR的位置，如果是在两倍ATR的位置设置止损位就更安全了。你可以把它当作一种移动止损的方法，随着线柱的转变而移动它。原理还是一样的——把止损位设在市场噪声区域之外</p><p>使用移动止损的一个优点是它们逐渐减小了所暴露的风险额度。前面我们讨论过“可用风险”（见第51节）的概念。使用移动止损时，如果交易价格朝对你有利的方向变化时，它可以逐渐释放可用风险额度，从而允许你开始做新的交易</p><p>（4）出现“尖峰反弹信号”后在2倍ATR处移动止损 <img src="Pasted%20image%2020240129155735.png"> 尖峰反弹信号（在第34节中已讲述）出现在当20日新高-新低指数跌到了负500以下的时候，这意味着下跌的趋势难以进一步持续，然后指数重新反弹到这个水平之上，表明牛市在重新回来。尖峰反弹信号由垂直的绿色箭头标示。在这里，标普线是绿色的，但是当尖峰信号消失时，它会变成紫色。红线跟踪的是标普500指数线柱最高价下方2倍ATR的价位。</p><p>尖峰反弹信号发出对整个市场的买入信号，这张图表用2倍ATR收盘价止损（日内波动超过止损线不触发止损，必须收盘价在止损线之下才触发止损）来跟踪每个买入信号。注意富有成效的信号A、B和C。在写这篇文章时E点的买入信号仍然是有效的。D点的信号会导致损失——说明信号并不总是能获利。即使你不用安全区域止损或ATR止损，也务必把止损位设在离最新价格稍远一点的位置。你肯定不想像那些胆小的交易者一样把止损位设在离现在价格很近的位置，结果一些无意义的扰动就触发了止损。</p><p><strong>（5）高点放置追高的买入方法</strong> 如果你发现了一只股票正处于强劲的趋势之中，但你又不想追高，你就<strong>降一个时间周期维度。比如说，周趋势是上升的，那就下降到日线图表，你可能会发现每隔几周，日线会有一次回调到价值区间的机会。测量一下最近几次穿透到长期EMA下方深度的平均值，得到平均穿透值（见图39-3）。提前一天在低于EMA均线一个平均穿透值的距离下一个买单，未成交之前每天都需要对它进行跟踪调整</strong>。你可以利用市场噪声为进入趋势跟踪交易，找到一个好的入场价格</p><p><strong>（6）不要让盈利变为亏损</strong>（达到一定比例的盈利目标后，就可以将止损线设在盈亏平衡点，然后随着利润增大，逐渐提高止损线，保护利润）</p><p>不要让有丰厚账面浮盈的未平仓头寸变为亏损！在交易之前，就要计划在什么水平开始保护你的利润。比如有一笔交易的盈利目标是1000美元，那么在有300美元盈利的时候就需要开始保护利润。一旦你的未平仓头寸浮盈达到300美元，你可以将止损线调整到盈亏平衡的位置。我们称这种移动为“为交易翻边”</p><p>一旦你将止损线调整到盈亏平衡点，你需要专注于如何保护住部分持续增长着的浮盈。提前计划好要保护多大比例的利润。</p><p>比如，你的决定可能是一旦止损线超过盈亏平衡点了，考虑保证三分之一的浮盈。那就意味着，如果你目前的交易有600美元的账面盈利，那么至少要得到200美元。（这个比例根据信心可以改变）</p><p><strong>当交易的发展已经兑现了你的预期，这笔交易的盈利潜力逐渐变小。而你的风险（盈利和止损线之间的距离）会不断增加。交易就是在管理风险，当盈利与风险的比例渐渐恶化时，你便需要减小承担的风险。通过提升止损线，保护一定比例的利润，可以使盈利与风险比例控制在更平衡的位置。</strong></p><p><strong>（7）只顺着你交易的方向移动止损线</strong>（非常经典的案例） 当你买了一只股票，作为有纪律的交易者，会在买入价下面设定止损线。股票开始上涨，产生好看的账面浮盈。但接着，上涨停止了，开始下跌一点，然后再下跌一点，这时浮盈变成了浮亏，市场价格离你的止损线只差分毫了。这时你再分析图表，认为从图形上看，这只股票出现了很好的底部形态——牛市背离，可能会带来一波强劲的上涨趋势。接下来你该怎么做？</p><ol type="1"><li>==<strong>首先，要认识到你的错误是没有及时提高你的止损线。在最初上涨的时机中你就应该将止损线提高到盈亏平衡线之上</strong>。==没能做到这一点，导致你目前的选择余地很小，要么马上卖出承担损失，等到以后再重新买入；要么一直持有。但麻烦在于，你可能会倾向于去做第三种选择——调低止损线，“给下跌更大的空间”<strong>==（但千万别这么做！）==</strong></li><li><strong>“给下跌更大的空间”只是一种美好的、单纯的想象。这个选项不应该出现在一名严谨的交易者的工具箱中。</strong></li><li>当一笔交易表现糟糕时，符合逻辑的做法是接受出现的损失，但保持关注这只股票，做好准备，当底部出现的时候重新买进。专业交易者一般在股票步入正轨之前会尝试几次快速的试探性交易，这样佣金成本也会低一些</li></ol><p>（8）灾难性止损：专业交易者的救生衣 我在搬到湖边别墅居住后，买了一个皮划艇，接着立即买了一件救生衣。因为按照法律，我需要在皮划艇中放一件救生衣，即使是一件质量十分糟糕的也可以。但我还是花了很高的价钱买了一件质量上乘、<strong>穿着舒适的救生衣。</strong></p><p><strong>其实，我计划的只是在湖面上平静地划皮划艇，而不是去什么水流激烈的地方，因此也并不认为有一天会用到那件救生衣。那我是在浪费钱吗？如果有一辆摩托艇撞上我的皮划艇，一件高质量的救生衣可能就是生与死的区别。</strong></p><p><strong>这和止损线的作用是一样的</strong>。</p><p><strong>它们很麻烦，并且会有成本，但总会有一天，这些止损线将拯救你的账户于危机之中。记住，在股票市场中出现意外的概率可比在湖中大多了</strong></p><p>“硬止损”是一种给你的经纪商下达的指令，而“软止损”是你心中的止损线，当到需要的时候你才会去执行真实操作。<strong>新手或业余交易者一定要使用硬止损线</strong>；</p><p>对于任何一笔A级交易来说，无论做多还是做空，你都需要在图表中画出你最不希望看到的价格极值。然后在这个位置设定你的硬止损线（哪怕是专业投资者），在取消之前，这个止损线会一直有效，这就是你的“灾难性止损线”。接下来你便可以开始灵活地使用软止损了。就像有了一件可靠的救生衣，你便可以使劲地划动手中的桨了。</p><p>（9）止损线和隔夜跳空：仅对专业交易者 如果你持有的股票在休市期间出现了一个重大利空，你怎么办？在第二天早上开盘之前查看集合竞价情况，你意识到股价将大幅低开，远低于你的止损线，意味着滑点会很大。</p><p>这情况不常见，但它确实会发生。</p><p>如果你是一名新手或者业余交易者，那并没有什么可选择的，只能咬紧牙关承受损失。但对于冷静的、有纪律的专业交易者来说，还有一种方法，那就是用做日内交易的方式退出。首先，撤走止损线，开盘之后当作开盘第一秒买入了一样，后面进行日内交易的操作。</p><p>开盘跳空缺口常常伴随着反弹，这给那些机敏的交易者提供了减少损失的机会。但这样的情况并不是一定会发生，所以大多数的交易者不要轻易尝试这种技术。因为这么做可能导致亏损更多，而不是减少亏损。</p><p><strong>记住在收盘前要及时退出——已经走坏了的股票，可能当天会反弹，但明天将会有更多的卖家进场卖出，驱使股价进一步下跌。不要让一次反弹引发你对反转的希望。</strong></p><h3 id="这是a级交易嘛对自己的交易行为做出评价">这是A级交易嘛？（对自己的交易行为做出评价）</h3><p>一旦你结束了一笔交易，市场将对你的入场、退出和最重要的整体交易三方面做出评级。</p><p>如果你是一位使用周线图和日线图做波段交易的交易者，那就用日线图来计算你每笔交易的级别。你的买入评级取决于入场点、购买当日的最高点和最低点的情况。</p><p>买入评级=（最高价-买入价）/（最高价-最低价） 卖出评级=（卖出价-最低价）/（最高价-最低价） 交易评级=（卖出点-买入点）/（通道线高点-通道线低点）</p><p><strong>每笔交易我都会计算买入评级，而且我认为大于50%就是不错的成绩了，意味着我是在当日线柱的较低部分买入的</strong> <strong>每次交易我都计算卖出成绩，如果在50%以上，它就是一笔好的交易，意味着我卖到了当日日线的上半部分</strong></p><p><strong>下面看一个交易案例：</strong></p><p><img src="Pasted%20image%2020240129184743.png"></p><p>我在此处的策略是“回调到价值区域时买入”。ADSK最近出现比平均水平更深的跌幅——注意由红色箭头标注的向下假突破，接着由绿色箭头标注出的二次探底。</p><p>A日——2014年2月10日，星期一：高点是52.49美元，低点是51.75美元，上通道线是53.87美元，下通道线是47.61美元（我们需要通道高度来计算退出的交易评级）。买入价为51.77美元。 买入评级=(52.49-51.77)/(52.49-51.75)≈97%。</p><p>B日和C日——星期二和星期三：继续上涨，开始向上移动止损线</p><p>D日——星期四：高点54.49美元，低点53.39美元。卖出点为53.78美元。 卖出评级=(53.78-53.39)/(54.49-53.39)=35%。 交易评级=（卖出点-买入点）/通道高度=(53.78-51.77)/(53.87-47.61)=32%。</p><p>在这次交易中我的买入评级异常高，卖出评级比平均水平低，但是总的交易评级很好。因为忙于写作此书，我仅交易了200股，所以我扣除佣金之后的盈利只有不到400美元。如果我是通过盈利数量来评价交易评级，这次交易显得微不足道，但是我抓住了32%的通道高度，交易评级是A。</p><p>克里·洛沃恩在尖峰交易(Spike Trade)2012年年会上的发言引起了我的注意：他向所有参会者提出了一个定义——“什么是A级交易”——建立卓越交易的标准。他说：“<strong>你必须为你自己定义这种模式，如果你不知道自己的A级交易是什么样子，在市场中你根本就没有自己的业务模式</strong>。”</p><p>我很清楚自己的A级交易是什么——“价格背离加上假突破”或“回调到价值区域”。但是，如果我一时找不到A级交易，我会去找B级交易，如果真的没有合适的机会，才会转向C级交易。</p><p>那次聚会回到家后我将一张塑料纸条贴到我的交易屏幕上，写着：“这是一笔A级交易吗？”从那以后，我每次交易下单时都要问一下自己这个问题。效果很快显现出来了：<strong>随着非A级交易的急剧减少，我的股票资产曲线开始陡峭地上升</strong>。</p><p>你需要有一个明确的概念，知道什么是你的完美交易——A级交易。完美不保证一定盈利——这个市场没有绝对的保证——但这意味的是有强烈盈利潜力的交易。这也是你之前感觉很舒服的交易模式。一旦你知道这种模式是什么样的，你就可以寻找符合这种交易模式的股票了。</p><p><strong>个人交易者比机构交易者为数不多的优势之一是，我们可以在喜欢时交易，在不喜欢时不交易。我们可以自由地等待优质的交易机会出现，这对机构交易者来说是很奢侈的。不幸的是，我们中的大多数人过于急切地进行交易，没有利用好这个优越的有利条件。</strong></p><p>我把“这是一笔A级交易吗？”这个问题加入到了我的“交易准则”之中——我们将在下一章中讨论相关的交易管理表格。无论什么时候我发现有潜力的交易机会，我都会问自己这个问题，如果答案为“是”，我再开始计算风险水平、头寸规模，谋划买入价位。但如果答案为“不是”，我就会翻过这一页，继续寻找下一个交易机会（见图55-2）。</p><p>我所说的“系统”和“策略”两个词是可以互换的——它们都表示交易的计划。就像从我的这份2013年9月的交易日志中可以看到，当时在策略箱中，我使用了三个交易系统，<strong>主要的一个是“价格背离+假突破”，我也有时使用“回调到价值区域”这个策略交易</strong>——在上升趋势中的回调时买入，或在下跌趋势中的反弹时卖出。在极少数情况下，我会“针对极值进行交易”——在股价降到极低的时候买入，或在股价疯狂上涨后减速时卖出。</p><p>你的系统可能很自动化，也可能只是很概括的一些关键原则——像我的三重滤网交易系统。无论哪种方式，在你计划下一次交易的时候，<strong>你必须知道你的A级交易是什么样的。</strong></p><p><img src="Pasted%20image%2020240129190057.png"> 图55-3是从我的交易记录中摘录的，它是波段交易策略的一个非常理想的例子，我将其缩写为“01 FB+BD”——伴随有牛市背离或熊市背离的假突破。图中，斯伦贝谢公司(Schlumberger,Ltd.,SLB)的股票处于很明显的下降趋势中，当它在A点到达新低时，看起来只是漫长下跌途中的阶段底。在我看来，在MACD柱图中标出的整个椭圆形区域是一个底部，因为它从来没有向上穿透过0值线。在B区域里，图线开始变得比较有意思了：MACD柱上升到0值线以上，“打断了熊市的后背”。动力系统的周线图（此图中并没有显示）在这之前都显示为红色，现在变成了绿色——禁止买入信号被移除了。在C区域，SLB股价创下了新低，但是MACD柱的新低点却很浅，出现了牛市背离。</p><p>仔细观察在C区域中连续几条红线之后的第一条蓝线，那是MACD柱上涨形成牛市背离的地方。另外，那条上涨的日线，收在前期向下突破位的上方，图中用紫色的虚线标出：这说明前期是向下假突破。</p><p>我是在这条日线中买入的（图中用垂直绿色箭头标出）——并没有等到收盘后才做决定，在60.80美元处买入了2000股，止损线设在59.12美元。几天后，当价格开始接近上通道线，也是前期高位时，我开始兑现盈利，在66.55美元的位置卖出了1000股，剩下的是第二天以67美元的价格卖出（图中都用红色箭头标出）。我每股盈利是6美元，5个交易日内扣除佣金前收益是11950美元，这个交易系统完成了一次出色的交易。</p><p>这幅图是我在寻找股票和期货的交易机会时，会浮现在脑海中的图表。我想找到类似的图形，完成了它们的A底和B顶，而且开始下跌有形成C底的趋势。在这个图形背后，动力系统的周线图不能显示为红色，因为那将禁止买入交易</p><p>如果你要扫描更大数量的股票，需要增加一些“负面规则”。比如，你需要剔除每日成交量少于50万股或100万股的股票。这些股票的图表通常很不规则，滑点也比其他交易活跃的股票的要大。你还可能会把高价股从买入名单或低价股从卖出名单中剔除。选择筛选标准的参数，依个人而定。这也是为什么扫描最好由有经验的交易者来做。就像在撒网捕鱼之前，首先要学会用渔竿来钓鱼。</p><h2 id="保持良好的记录习惯">保持良好的记录习惯</h2><p>市场在分发奖惩方面并不始终一致。这样的情况时有发生，比如一笔缺乏计划的交易赚钱了，而一个计划周密、执行认真的交易却亏钱了。这种随机性使我们颠覆了本应遵守的原则，鼓励草率地进行交易。</p><p>记录下你的交易计划可以确保你不会错过任何一个重要的市场影响因素。记录交易日志的习惯将帮助你避免掉入冲动交易的陷阱。交易纪律和控制体重一样，对于多数人来说是很困难的。如果你不知道自己今天的体重是多少，你的体重曲线在上升还是下降，你怎么能控制它？减肥是从坚持每个清早脱光站到秤上记录下当天体重开始的。</p><p>我们都会犯错误，但是如果你能坚持复习自己的交易日志，并且反思过去的错误，你不太可能会重蹈覆辙。好的交易日志记录习惯能让你成为自己的老师，并让你的账户净值出现奇迹。</p><p>让我们来回顾一下交易日志的三个核心要素： （1）纪律的第一步是完成功课（我会提供一份功课进度表的模板）。 （2）纪律的进阶是写下你的交易计划。 （3）纪律的高潮是执行这些计划并且完成交易日志（我会提供一个在线交易日志的链接）。</p><p>我的电子表格（见图57-1）目前还在继续使用中，我仍继续对其不断调整。如果你准备使用它，我确信你也会根据自己的需要进行调整。 <img src="Pasted%20image%2020240129201323.png"></p><p>（1）查看远东市场。这条链接将我带到雅虎财经的相关网页。我会写下隔夜澳大利亚及中国市场指数的百分比变化。每个人形成记忆的方式各不相同，对我来说写下来是最有效的办法。 （2）查看欧洲市场。这里我写下德国法兰克福指数及英国富时指数的百分比变化。市场闻鸡起舞，你会体会到在美国产生的风波在重新返回西海岸之前，如何波及亚洲，然后传到欧洲的。 （3）<strong>经济日历</strong>。这条链接将我带到Briefing.com的网页，这里把每天将要发布的基本面数据整理成列。同时也会显示之前发布的数据及市场对本次发布数据的预测值。当一份重要的数据，比如失业率或产能利用率，低于或超出市场预期，你便可以期待市场将出现绚丽的烟花秀。 （4）Marketwatch网站。这是一个大众流行的网站，我会看一下今早它正在关注什么。通常来说它是反向指标。 （5）欧元汇率。我会写下最活跃的期货合约的现价，后面用动力系统状态的首字母标记——绿色(G)、蓝色(B)或者红色(R)——前面是周线图的，然后是日线图的。下面提到的其他市场，我所采用的是同样的格式。我关注欧元期货走势有两个原因。第一个原因是无论与美国股市表现一致或相反，欧元期货的走势都能延续一段时间；另一个原因是欧元期货有时候能提供非常好的日内交易机会。 （6）日元汇率。上一条所述两个原因中，第二个原因比第一个在日元汇率上更适用。 （7）原油。它是经济的血脉，并且原油期货会随着其上涨下跌而变化，原油期货是可以用来交易的。 （8）黄金。它是市场恐慌情绪与通胀预期的一个敏感指标，同时也是很受欢迎的交易品种 （9）债券。利率的上涨或下跌是股市走势的主要驱动因素之一。 （10）波罗的海干散货运价指数(BDI)。对于世界经济而言，它是一个敏感的先行指标。BDI表示干散货的运送成本，例如把纺织品从越南运往欧洲，或是把木料从阿拉斯加运往日本。BDI的波动非常大，没有直接基于BDI的交易品种，这有助于BDI更准确地反应经济活动的实际情况。如果你交易航运业的股票，这个指标格外有用。 （11）<strong>新高-新低指数</strong>。我认为新高-新低指数是股票市场最好的先行指标。我喜欢每天早上写下这个指标最新的周数据及日数据来帮助记忆。 （12）芝加哥期货期权交易所波动率指数（VIX指数），也被称为“恐慌指数”。人们调侃：“VIX走高，放心买入；VIX走低，小心慢行。”横批是，“提防VIX的ETF”——VIX的ETF因在交易中与VIX指数不同步而臭名昭著。 <strong>（13）标准普尔500指数。我会写下前一个交易日指数的收盘价，并且将动力系统周线和日线显示状态的首字母标写在后面。</strong> <strong>（14）日线的价值。我转到标普指数的日线图，留意最新一根线柱是收在价值区域的上方、正中还是下方，以及它与通道线的关系。这帮助我识别现在市场是超买了还是超卖了。</strong> <strong>（15）强力指数指标。我会注意这个指标的13日EMA均线是在它中心线的上方还是下方（对应牛市或熊市）以及是否有背离。</strong> （16）对标普指数的预判。测验自己对市场预测的精准度：写下对今天收盘价会比开盘价高还是低的预测，如果没有观点就空着。根据自己的预测是否正确，次日我会给这一栏涂上绿色或红色。 （17）在电子表格的最后一行，我会总结今天将如何交易：积极地、保守地、防御地（仅进行平仓交易），日内的交易或者完全不进行交易。</p><h2 id="如何判断交易想法的可靠性">如何判断交易想法的可靠性</h2><p>每一个诞生的交易想法，在心中肯定都是可靠的，可能是踩中了几个关键点位，可能是基本面好转，但依赖感觉而不是客观数字的想法是不应该执行的，因此需要对交易想法进行评判</p><p>在展示我的阿氏交易评分之前，有一些注意事项：你将要看到的这个评分系统是为特定交易系统而设置的——我的“伴随背离的假突破”策略。如果是其他的交易系统则需要不同的评分测试方式，<strong>但你可以将我的交易阿氏评分作为设计自己评分系统的基础。</strong></p><p>交易阿氏评分需要对体现交易策略核心的五个问题给出明确的答案。随着你为自己的策略发展出了属于自己的阿氏评分，我建议保持问题数目不要超过五个，且答案得分仍是0分、1分和2分三种。简洁能够让这种测试更加客观、实用和快捷。</p><p>当看到交易机会时，我会抽出一张空白的交易单，圈出我对五个问题的回答。 在红色框画圈的得0分，在黄色框画圈的得1分，在绿色框画圈的得2分。 我在每个分数框里填上得分，然后将五个得分加总。如果我圈出的是红色框，我还会在其旁边写上价格到什么位置时我会将其改为更令人喜爱的黄色或绿色。那时，计划的评分会得到提升，在那个价格可能可以进行交易。 图58-1展示的是做多的交易阿氏评分，而图58-2展示的是空头交易的交易阿氏评分。</p><p><img src="Pasted%20image%2020240129202240.png"></p><p>（1）强力系统的周线图（前面章节有描述）——周线图是红色得0分，周线图是绿色得1分，周线图是蓝色得2分。强力系统为红色时，是禁止交易的；绿色时还可以进行交易，但是可能有些太晚；蓝色（紧跟在红色之后）表示恐慌正在褪去，是买入的好时机。 （2）强力系统的日线图——与上一条同样的问题、同样的评分，标记在日线图上 （3）日线价格——在日线图上，<strong>如果最新价格在其价值区间之上得0分；在价值区间范围内得1分；低于其价值得2分。</strong> 价格在价值区间之上时，买入已经有些迟了；在价值区间内还可以；在价值区间之下则是一笔好买卖。 （4）假突破——没有的话得0分；已经发生得1分；很有可能将要发生得2分。 （5）完备性——没有周期符合得0分；有一个符合得1分；两个周期看起来都很完备得2分。</p><p>我通常会用两个时间周期来分析市场。对任何策略来说必须有其中之一符合一种入场交易的完备形态。极少情况下两个时间周期的形态都是完备的——在一个完备，另一个可以接受的情况下就可以进行交易了。如果没有一个时间周期的形态看起来是完备的，则不是一笔A类交易——抛弃这只股票，转移到另一只上面去。</p><p><strong>计算任何一只股票的阿氏评分都不会花费超过一分钟。我只想进行那些得分在7分及以上，并且没有任何一个框是0分的交易机会</strong>。<strong>遇到这样的交易机会，我会继续执行我的交易计划，选择进场点、目标价、止损价和交易规模等</strong></p><p>交易的阿氏评分为潜在的交易提供了客观的评级。我们有成千上万的交易工具，没有必要将精力耗费在差劲的标的上。使用交易阿氏评分能帮助你聚焦于最有前景的机会上。</p><h3 id="如何使用交易表">如何使用交易表</h3><p><strong>当你对某只股票产生兴趣，并且交易的阿氏评分肯定了你的交易想法，完成交易表将有助于你专注于此交易最核心的部分。</strong></p><p><img src="Pasted%20image%2020240129202553.png"></p><h4 id="第一部分----交易鉴定">第一部分----交易鉴定</h4><p>绿色条纹标志为多头交易。 用一张指甲盖大小的、画有牛市背离伴随假突破的K线图作为图标，标示出这种策略。 第一个空格用来填写股票代码。 接下来一个空格用来记录下一个财报披露的日期。你可以在很多免费网站上找到它们。例如www.Briefing.com,www.earning.com，或者www.Finviz.com等。 很多交易者在股票将要公布财报时会避免持有该股票。因为差劲的盈利表现对你的持仓很不利。写下披露的日期，以强迫自己避免陷入麻烦。 再下一个空格用来记录除息日——如果有的话。我通常在http://finance.yahoo.com上查找。分红时，股票持有者需要缴税，而空头必须支付分红。所以人们都不希望在分红那天持有该股票。 最后一个空格是我做计划的日期。</p><h4 id="第二部分交易的阿氏评分">第二部分：交易的阿氏评分</h4><p>我的交易阿氏评分描述如上。记住，每种策略都需要符合其特点的阿氏评分。十分欢迎你用符合自己交易系统特点的问题来代替我设置的问题。例如，你的问题可能是随机摆动指标是处于哪种状态：超买（0分）、超卖（1分）或者超卖伴随着牛市背离（2分）。当你将交易阿氏评分的各项得分加总时，将下面这个重要问题的答案写下来：这会是一笔A级交易么？如果总分在7分以下，则放弃这只股票，去寻找其他的</p><h4 id="第三部分市场买入点目标价止损点和风险控制">第三部分：市场、买入点、目标价、止损点和风险控制</h4><p>最左边的五个空格要求我回答有关市场基本状况的问题。<strong>尖峰反弹信号</strong>是否有效，<strong>追踪股票均线的指标是看多还是看空，这只股票的空头净额是多少</strong>，<strong>需要多少天来补上</strong>，所有这些内容都已在本书前面描述过。</p><p><strong>最后一个空格是简短的总结。</strong></p><p><strong>用箭头所连接的三个空格是我决策制定过程的核心部分。它们所要的是每笔交易最重要的三个数字：买入价、目标价、止损价。</strong></p><p><strong>资金风险——这笔交易中，你愿意冒亏损多少钱的风险？这个数额永远不应该超过你账户资产的2%。我通常把它控制在远远低于这个门槛的位置。</strong></p><p><strong>持仓规模——根据持仓限额和入场点与止损点的差额，可以算出你能买多少数量。这已经在第50节“风险控制的铁三角”中详细论述过</strong></p><h4 id="第四部分买入之后">第四部分：买入之后</h4><p>A级盈利目标是在买入价上加日通道线高度的30%。软止损是记在脑海中的指令，而硬止损或灾难性止损是实在的指令。它不应该比第三部分中所写的止损价低。</p><p><strong>记下你将把止损位移到盈亏平衡位置的价格水平</strong>。当你执行这些必要步骤时，检查右手边的方框：设置止损价，创建一个日志，下达止盈订单。</p><p>当你开始制作自己的交易表时，只能复制第1、3和4这三个部分，但第2部分需要自己制作——制作符合你自己系统或策略的交易阿氏评分。</p><h2 id="交易日志">交易日志</h2><p><img src="Pasted%20image%2020240129203552.png"> A部分：交易日志需要我回答为何决定交易这只股票。我通常会空着这个格子，因为我喜欢用Snaglt软件在线图上写下这些观点。在欧特克(ADSK)的例子中，我附上了合成的线图，包括周线图、日线图和25分钟线图。 B部分：记录下入场和退出的日期和价格。记录滑点和买入量、卖出量及交易等级。 C部分：退出的原因，需要附上显示入场点和退出点的合成线图。 D部分：退出策略的清单要比交易策略的清单长。退出的原因可能是到了目标价或止损价，也可能是到了价值区间或包络线。我也可能会因为股票不再延续趋势方向或者开始掉转方向而选择退出。还有两种消极的退出：已无法承受下跌的痛苦，或是买入后发现这是一笔糟糕的交易。 E部分：交易后的回顾分析。我喜欢在退出交易两个月后回顾这笔交易。我设计了一个跟踪图表，用箭头标记出入场点和退出点，然后写下时过境迁后对这次交易的评论。这是吸取经验教训最好的方法。</p><p>我们中的大部分人会很快忘掉过去的交易，但是交易日志网站会提示你对它们进行回顾。当时你在K线图最右边区域艰难地决定买入卖出，如今这些K线已经到了图表的中间位置了，这个时候你可以重新审视你当时的决定，并学会如何改进它们。</p><p>记录交易日志会有三大好处。 第一个好处是即时的——写完日志能有更好的<strong>秩序感</strong>。 第二个好处是会在1～2个月后，当你开始回顾已经结束了的交易时。 第三个好处是，当你积累了几十个记录后，你会有多种方法去分析它们，并且能从你的资金曲线中有所成长。</p><p>在退出交易一两个月之后，回顾每笔交易是最好的学习方式之一。交易信号在图形右侧时，可能会显得模糊不定。而当你在图形中间看到它们时，已变得无比清晰。回顾你已经完成了的交易，并且加上一个“交易后”图表，能让你重新评估自己当时所做的决定。现在你可以清楚地看出自己做得对还是不对。你的日志能给你珍贵的经验和教训。</p><p><strong>回顾你的资产曲线是非常必要的（以月为单位），因为只有上升的曲线才能证明你是一位成功的交易者。如果你的资产曲线是下行的，说明或者你的系统可能有错误，或者你的风险管理十分薄弱，或者你缺乏交易纪律性——无论是什么，你都必须查找清楚并予以解决。</strong></p><p>但是，资产曲线将你所有的交易汇集到一起，是十分初级的分析工具。网页版交易日志能让你细化，追踪特定市场的资产曲线、交易策略、退出战术等。例如，我可以将做多和做空的操作分开来画资产曲线，也可以将采用不同策略、不同退出甚至不同交易想法来源的交易分别绘制资产曲线。相信我，一旦你看到退出的交易资产曲线的特点是“不能承受这样的痛苦”，你将再也不会不设置止损线了！</p>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以交易为生（中）</title>
    <link href="/2024/01/28/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
    <url>/2024/01/28/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>这部分主要包括如何构建交易系统</p><p>交易系统是寻找、进入和退出交易的一整套规则 一些人有着严格定制化的交易系统，给个人留有的决策空间很小——我们可以称他们为机械化的交易者。而另一些人给自我判断留下巨大的空间——我们称他们为自由决策的交易者</p><p>不管你采用什么样的交易方法，<strong>交易系统的重要优势是你可以在闭市的时间并且当你处于冷静的状态时，去设计它。交易系统会成为你在市场波动中的理性行为之锚。</strong></p><p>毋庸置疑，一个合适的交易系统是被写下来的。交易系统需要被记录下来是因为在现实的市场压力之下，一些重要的步骤很容易被遗忘</p><p>机械交易者建立了一整套准则，用历史数据进行测试，然后把它们放到系统中进行自动交易。再进一步，他的软件开始提示入场、目标和退出指令。一个机械交易者应该准确地按系统提示的进行操作。他们是否要遵循他的计划或者尝试扭曲、忽视这些信号便是另一番情况了，但是以上这些是系统应当运作的方式</p><p>自主决策的交易者在市场中每天都会更新交易策略。他会更倾向于比机械性交易者检查更多的因素，在不同时段给予它们不同的权重，并且更协调地跟随着最新市场行为的变化</p><p>谈及交易设置，在你交易操作之前，计划好所有相关的目标数值是非常重要的。<strong>在你还没有承担真实的风险之前，你是更加客观的</strong>；一<strong>旦你进入交易，你会倾向于认为“有更大的空间”。这也是失败者怎样从小的回撤变成灾难性损失的。我曾经建议过一个人在浮亏200美元时割肉，他拒绝了，直到账面损失98000美元时才清仓</strong></p><p>我们将会在后面章节讨论“风险控制的铁三角”概念的时候集中说明风险和资金管理。在这时候，我只想明确风险管理在严肃交易中是必不可少的。看着天花板说“我要交易500股”“我要交易1000股”，或诸如此类随意的数字，是不可取的。在本书后面的章节，你将学习到一些<strong>基于你的账户规模和风险容忍度之上的简单的公式，来计算交易持仓量。</strong></p><p>在写这本书的时候，我有三条投资的策略： （1）我最喜欢的是背离时的假突破； （2）第二条是股价在强势趋势中回调到价值区间时； （3）最后一条，我偶尔退到另一个极端——会在已过度扩张的趋势反转时下筹码。 每一个交易策略都有其准则，但是核心是——我只会进行符合其中之一策略的交易。对老手来说绝不会做过于随机的事情</p><p>请注意每个交易计划都需要以下几个重要特征： （1）交易设置——为每一笔交易计划好三个关键的数字：<strong>买入价位、盈利目标价位和止损价位</strong>。在进入市场进行交易之前，你需要决定你将愿意以什么价格成交，你期望从市场中获得的收益和你愿意遭受的风险。潜在收益与风险的比例通常最好要超过2∶1。唯一可以偏离这条准则的交易时机是，当技术指标的信号特别强烈的时候。当然，<strong>不要捏造你的目标来把一个不是很确定的交易转为一个可以接受的交易。你的交易目标需要贴近实际。</strong> （2）风险管理——事先确定你能承受在这笔交易中损失多少钱。用最大损失金额除以股数，得到每一股的可承受的损失——也就是你的买入价格和止损价格之间的差额。这将限制你交易的股数。 （3）最后同样重要的是，每一笔单独的交易都必须建立在特定的系统和战略之上。“在我看来很不错”这种想法并不是一个系统！当你听到一些股票提示或者看到脱缰而上的趋势时，会很容易变得激动。但是要告别像小狗追逐汽车那样去追逐股票了。如果你想以交易为生，你需要确定清楚自己的交易计划、战略或系统——用自己喜欢的方式来称它们——仅仅参与那些符合它们标准的交易机会。 注意：对每个计划的交易都要从三个重要的角度去考虑。我们会在这里做简短的介绍，之后在讲特定交易系统和风险管理的时候再做详尽的阐述。这三条要求对于严肃认真进行交易的任何人来说都是至关重要的。</p><h2 id="三重滤网交易系统">三重滤网交易系统</h2><p>三重滤网交易系统对每次操作进行三重测试或过滤。许多交易机会在一个蜡烛图界面看起来非常有吸引力，但在另一个时间周期的界面却看起来情况相反。通过三重滤网交易系统筛选的交易机会成功可能性要大很多。</p><p>实际上市场是如此复杂，很难用一种指标来分析，不同的指标在相同的市场之中给出相互矛盾的信号。趋势跟随指标随着股价的上升而上升并给出买入信号，然而此时震荡指标会显示为超买，而给出卖出信号。趋势跟随指标在股价下降的趋势中同步向下，并给出卖出的信号；但此时震荡指标却显示为超卖，并给出买入的信号。</p><p>趋势跟随指标在市场做趋势运动时能盈利，但在市场区间震荡时会导致受双倍的损失。震荡指标在震荡区间内能盈利，但是当市场开始形成趋势的时候，会给出过早的、危险的信号。交易者常说“学会和趋势做朋友”和“让你的盈利跑起来”。他们有时候也说“低买，高卖”。但是为什么要在趋势上升的时候卖？还有涨得多高算高呢？</p><p><strong>如果你更多地使用趋势跟随指标，结果将会指向一个方向，但如果你更多地使用震荡指标，结果会指向另一个方向。交易者总是能找到符合他所想听的信息的一组技术指标</strong></p><p>三重滤网交易系统设计出来就是为了过滤掉趋势跟随指标和震荡指标的缺陷，同时保留它们的优势</p><h4 id="选择时间周期">选择时间周期</h4><p>有一个重大的困境是交易品种的趋势在不同时间周期下很可能并非同时上升或下降的。任意品种的日线图可能展现的是向上的趋势，然而周线图显示的却是下降的趋势，反之亦然。我们需要一个系统来解决不同时间周期之间信号的冲突。</p><p><strong>三重滤网交易系统建立的基础是，市场的每一个时间周期对其大一号或小一号的时间周期，大概是五倍的关系</strong></p><p>开始时不妨问问自己，哪一个是你最喜欢的时间周期。周线图、日线图，还是10分钟或者其他线图？无论你喜欢用哪一个时间周期，三重滤网交易系统称之为中期时间周期。长其一号的是长期时间周期。短其一号的是短期时间周期。一旦你选定了中期时间周期，你先不用去看它，而是先去查看大一号的长期时间周期的线图，并且在长期时间周期线图里做好战略决策，然后再回到中期时间周期的线图中去</p><p>举个例子，如果有一笔交易你想持有几天或者几个星期，你的中期时间周期很可能被定义为日线图。周线图是尺度大一号的时间周期，即长期时间周期。1小时线图是尺度小一号的时间周期，因此是短期时间周期。</p><p>三重滤网交易系统首先要求你去检查长期时间周期图表，找出长期图表中的大趋势。它仅允许你顺着大趋势的方向进行交易。它使用中期图表中的趋势与长期趋势方向相反时的机会建立头寸。举个例子来说，就是当周趋势是上升的时候，则在日趋势下降时买入。当周趋势是下降的时候，则日趋势上升时是卖出的机会。</p><ol type="1"><li><p><strong>第一重滤网——市场潮流</strong> 三重滤网从分析长期图表开始——首先分析比你准备用以交易的时间周期大一个尺度的时间周期。大多数交易者仅仅对日线图给予关注，每个人都看着相同的几个月的数据。如果你开始分析周线图时，你的视角会比你的竞争者大出五倍。</p><p>开始的第一步，你需要选择你喜欢的时间周期作为中期时间周期。此时，甚至不用瞥一眼中期时间周期，因为先去看它会使你产生先入为主的偏见。直接去看大一个尺度的时间周期——你的长期时间周期图表。在那里你将做出市场是牛市还是熊市的战略决策。然后，再回到中期时间周期来，开始做策略性的决策，比如在什么位置买入和在什么位置设置止损。</p><p>最初版本的三重滤网使用周线MACD的斜率作为周线趋势的跟随指标（见图39-1）。它非常敏感并能给出许多的买卖信号。后来，我转而使用周线指数移动平均的斜率来作为长期图表的趋势跟随工具。再后来我发明了动力系统（后面章节将会对动力系统进行描述），并开始在第一重滤网中使用它。动力系统结合了前两者的优点。它不像MACD那样急剧变化但又要比EMA斜率的反应更加迅速。</p><p><strong>使用周线图MACD作为三重滤网中的第一重（我这里应该是月线图）</strong> 三重滤网要求我们在看日线图之前，先要去分析周线图。MACD的斜率由最近两根MACD线柱之间的关系确定。 这个指标会在它的斜率转而向上时发出买入的信号，在斜率向下时发出卖出的信号。 <strong>最佳的买入信号出现在MACD低于中心线位置，但方向转而向上的时候</strong> <strong>最佳的卖出信号出现在当MACD在中心线上方位置，但方向转而向下的时候</strong>（详见第32节的指标部分）。</p><p><strong>当MACD的斜率转而向上时（箭头A、C和E），它只允许我们在买入或者观望的方向上交易。当斜率转而向下时，它只允许我们在卖出或者观望的方向上交易。</strong> <img src="Pasted%20image%2020240128190043.png"> 注意在A点或者E点的买入信号要比在C点的买入信号质量高——因为C点的买入信号产生在中心线之上。在春天的时候买入总比在夏天的时候买入要好。在图表的右边界上，上升的趋势十分强势，因为信号E点伴随着涨背离：价格的底部变深（A和E）伴随着MACD指标的底部变浅了。</p></li></ol><p><strong>第一重滤网总结：使用趋势跟随指标识别周趋势并随着趋势的方向交易。</strong></p><p><strong>交易者有三种选择：买、卖或者观望。三重滤网交易系统的第一重会帮你排除其中一个选项。它的作用像监察员一样，在上升的趋势里只允许你选择买入或者观望；在下行的趋势里只允许你卖空或观望。你必须顺应潮流的方向，否则它会禁止你下水。</strong></p><ol start="2" type="1"><li><p><strong>第二重滤网——市场波浪</strong> 当周趋势是上升的，日趋势的回调正是很好的买入机会。当周趋势是下降的，日趋势的上升正是很好的卖出机会。</p><p>第二重滤网：将震荡指标应用于日线图之中。在周线的上升趋势中，利用日线的回调来寻找买入机会；在周线的下降趋势中，利用日线的反弹来寻找卖空机会。我喜欢在第二重滤网使用强力指数(force index)，这个指标在第30节已经介绍过。其他一些震荡指标，比如相对强弱指标(RSI)、埃尔德射线(Elder-ray)和随机指标(stochastic)等表现得也很不错。</p><p>当周趋势是上升的，三重滤网仅允许采用日线图震荡指标发出的买入信号，而不会允许采用其发出的卖空信号。2日强力指数指标EMA在降到0值以下的时候，只要它不是下降到了几周内的新低点，就会发出买入信号。当周趋势是下降的，强力指数指标会在上升到中心线上方的时候，只要它不是上升到几周内的新高点，就发出卖空的信号</p><p>2日强力指数指标EMA可以用作三重滤网交易系统第二重的众多震荡指标之一。当它下降到其中心线之下的时候，强力指数标记出买入的机会。当它上升到其中心线之上的时候，它会标记出卖出的机会。当周趋势是上升的（这里用绿色的水平线标出），在日线震荡指标中仅采用买入信号，以建立多头头寸。当周趋势是下降的（这里用红色的水平线标出），在日线震荡指标中仅采用卖出的信号，以建立空头头寸。</p><p>总结：在第一层滤网的趋势上进行交易，趋势是上涨，则在回调时利用震荡指标寻找买入机会</p></li><li><p><strong>第三重滤网——买入技术</strong> 后续再补充，暂时没看懂</p></li></ol><p><img src="Pasted%20image%2020240128190943.png"></p><h4 id="止损和止盈目标">止损和止盈目标</h4><p>对于成功的交易来说合适的资金管理是至关重要的。一个纪律严明的交易者会在盈利目标处兑现利润和快速止损，他们的表现远比那些抱有幻想和在错误交易上逗留的交易者要好。</p><p>在你进入一个交易之前，写下三个数字：<strong>买入价位、盈利目标价位和止损价位</strong>。<strong>没有定好这三个数字的交易便是赌博。</strong></p><p>三重滤网交易系统要求<strong>使用长期图表来设置止盈点</strong>，<strong>使用中期图表来设置止损点</strong>。如果你是使用周线图和日线图搭配的，则在周线图上设好盈利目标，在日线图上设好止损目标。当在日线图的回调中买入时，用周线图的价值区间（见两条EMA线）作为盈利目标是一个好的选择。用25分钟线和5分钟线搭配使用做日内交易时，在25分钟线上找到盈利目标，然后在5分钟线设置好止损位，当你控制住了风险的时候，你更容易得到一个好的结果。</p><p>三重滤网交易系统需要设置相对保守的止损价位。它既然让你按照市场大趋势的方向进行交易，就不允许为损失留太多空间。跟上潮流或者马上退出。我们之后将在第54节回到这个话题，“如何设置止损点”。</p><h2 id="动力系统">动力系统</h2><p>要度量任意交易品种的惯性，一个好的指标是短期EMA的斜率。上升的EMA意味着具有牛市惯性，而下降的EMA则说明具有熊市惯性。</p><p>任意趋势的能量可以用MACD柱状线的斜率来表示。如果它的最近一根线柱比其前一根线柱的高度要高（像字母m-M的高度变化），或者是比其前一根线柱的深度要浅（像字母y-v的深度变化），则MACD柱状线的斜率是上升的，所以它的能量是向上推动的。如果最近一根线柱比其前一根线柱要低（像字母M-m的高度变化或字母v-y的深度变化），则MACD柱状线的斜率是下降的，所以它的能量是向下推动的。</p><p>当我们使用MACD柱状线来定义能量时，它是否高于或者低于零是无关紧要的：真正重要的是最近两条MACD线柱之间的高低关系。 <img src="Pasted%20image%2020240129205211.png"></p><p>（1）EMA上升、MACD上升（特别是小于0时）=动力系统显示是绿色，牛市，禁止卖空，允许买入或观望。 （2）EMA下降、MACD下降（特别是大于0时）=动力系统显示是红色，熊市，禁止买入，允许卖出或观望。 （3）EMA上升、MACD下降=动力系统显示是蓝色，中性，无禁止事项。 （4）EMA下降、MACD上升=动力系统显示是蓝色，中性，无禁止事项。</p><p>最初，我想用这个系统完全实现自动化交易——绿色时买入，红色时卖空，当颜色变换后则兑现利润。<strong>对动力系统做的回测让我打消了这个主意</strong>。<strong>自动交易系统成功抓住了每一个趋势机会，但是在区间震荡时，它会在红色和绿色之间反复转换，结果两头都遭受亏损</strong>。</p><p>**动力系统不是一个自动交易系统，而是一个监测系统！能够加强任何一种寻找交易机会的方法，无论是技术分析还是基本面分析。</p><p><img src="Pasted%20image%2020240129213854.png"> <strong>垂直的绿色箭头标志的柱线后面紧跟着红色的柱线。红色禁止你买入。最好的买入时机是当红色消失的时候。你能看到这些绿色箭头指示出一个接一个的中期底部，包括在图表右边界的买入信号。拥有一个客观的方法能让你在市场下降停止的时候有买入的信心。</strong></p><p><strong>动力系统也会对兑现利润的好时机给出建议。倾斜的红色箭头指向蓝色柱线，蓝色柱线出现在一系列远离价值区域的绿色柱线之后。它们显示牛市上行受阻的位置——兑现盈利的好时机，并等待下一个买入机会。</strong></p><h4 id="入场时机">入场时机</h4><p><strong>在你将动力系统应用到最喜欢的市场时，记住三重滤网系统要求在多于一个时间周期内进行分析。选择你最喜欢的时间周期，并将之定为中期时间周期。将其周期乘以5倍，找到长期时间周期。==如果你最喜欢的图表是日线图，首先去分析周线图，并做出看多或看空的战略决策。再使用动力系统来决定何时允许进行买入或者卖空。</strong>==</p><p><strong>如果你认为市场正在形成顶部，趋势即将反转。监控周线图和日线图的动力系统，如果任意一个仍然显示是绿色，说明上升趋势依然没有消失，禁止卖空。当两个时间周期的绿色都消失了时，你才可以卖空。</strong></p><p>时间周期越短，它的信号就会越敏感：日线图上的动力系统开始改变颜色总会先于周线图。当做日内交易时，5分钟线图改变颜色要比25分钟线图早。</p><p>如果我的分析表明市场正在筑底，即将开始反转，我会等到日线图不再显示变红，开始变蓝，甚至变绿，然后我再去观察周线图，这时它仍然是红色的。<strong>一旦周线图从红色变蓝，系统会开始允许买入。这种技术防止我当市场仍在下降的时候过早买入。</strong></p><p><strong>记住，动力交易系统是一个监测系统。它不会告诉你应该做什么——但是它会很明确地告诉你不该做什么。不要违背这个监测。</strong></p><p>许多技术分析软件都包含一种功能，叫“条件格式”。它允许根据EMA和MACD的斜率给柱线或蜡烛图上色。<strong>如果你使用的软件平台不允许条件格式功能，你仍然有办法使用动力系统。直接观察EMA和MACD的斜率：将它们结合起来分析，你就知道最新一根线柱应该是什么颜色了。</strong></p><p>如果懂编程的话，你可以给动力系统加入更多的功能。你可以检验EMA的不同长度或者MACD的不同设置，来找到市场中最合适你的那些组合。日内交易者可以编制警示声音来协助监测多个市场中颜色的变化，而不必紧盯着屏幕。</p><h4 id="退出时机">退出时机</h4><p>如果你是个短期动量交易者，一旦动力系统显示的颜色不再支持你的交易方向，则马上了结你的交易，即使在两个时间周期中只有其中一个改变了颜色。通常，日线MACD的反转要快于周线MACD。当它在上升趋势中下降，表明上升的动量正在减弱。</p><p>当买入的信号消失时，马上兑现收益，而不是等待出现卖出的信号。在下降的趋势中将这个做法反转一下。一旦动力系统不再显示红色，即使两个时间周期中只有其中一个改变了颜色，也马上清空你的空头头寸。最有效的下降部分已经结束，动力系统已经完成了它的使命。</p><p>==<strong>动力交易系统鼓励你小心谨慎地入场，但快速地退出。这是专业的交易方法。初学者往往与之背道而行，猛然跳入交易中，然后永不再退出，期待市场改变方向。</strong>==</p><p>如果两个时间周期中的任意一个变成了蓝色，波段交易者或许仍会持有交易头寸。波段交易者要避免时间周期中任意一个的颜色与交易的方向变得相反。如果你是多头，时间周期中的一个变成红色，则是时候卖出并空仓观望了；如果你是空头，当动力系统开始变绿，它就发出了让你平掉空头头寸的信号。</p><p>动力系统通过展示通常什么情况下漫无目的、毫无组织的群体开始变得情绪化并开始奔跑，以帮助你在市场混乱的狂流中识别出秩序。在趋势的形态刚刚浮现时入场，并在其开始沉入混乱的海洋前退出。</p><h2 id="通道交易系统">通道交易系统</h2><p>当价格开始上升的时候，它经常在碰到隐形的天花板时停止上涨。它的下降似乎也在碰到隐形的地板时停止下跌。<strong>通道帮助我们预测未来在哪儿最可能遇到支撑线和阻力线。</strong></p><p>通道能帮助识别买卖机会和避免错误的交易。交易通道的最初研究者是薛斯，他在他1970年出版的《股票交易时机的获利法宝》一书中，进行了阐述。</p><p>后来，伟大的数学家本华·曼德博(Benoit Mandelbrot)被埃及政府聘请建立一个棉花价格的数学模型——棉花是埃及主要出口农产品。经过广泛的调研，他做出了结论：“价格围绕价值上下波动。”这听起来简单，但是事实上是很深刻的。</p><p><strong>如果我们接受了这个数学发现，并且如果我们能够有手段来定义价值，并且能测量平均的波动，我们将会拥有一个交易系统</strong>：只需要在价格低于价值的时候买入，在达到价值的时候兑现利润；在价格高于价值的时候卖空，然后在回到价值时回补空头头寸。</p><p>我有一个严格的 准则就是：==<strong>永远不要在上通道线之上买入，也不要在下通道线之下卖出</strong>==。 这 个准则会导致我错过一些趋势机会，但我的安全性得到了极大的提升</p><h3 id="构建通道的两种方法">构建通道的两种方法</h3><p>我们可以通过绘制两条平行于一条移动均线的线组，来构建一个通道：一条线在移动平均线上方，另一条线在移动平均线下方。我们可以根据市场的波动性来改变两条通道线之间的距离（标准背离通道）。</p><p>以移动均线为对称中心的通道线对股票和期货交易都很有用。标准背离通道（有时也叫作<strong>布林通道</strong>）对于期权交易十分有用。</p><p>通道界定了价格正常波动和不正常波动之间的界限。价格在通道中运行是正常的，只有非正常的时间驱动才会使价格波动到通道之外。价格在通道的下轨线之下的时候，是被低估了；价格在通道的上轨线之上的时候，是被高估了。 #### 对称的通道</p><p>之前我们已经讨论过使用两条移动均线为一组，来进行交易。使用这组移动均线，并将<strong>长期移动均线作为通道线的核心</strong>。举个例子来说，<strong>如果你使用13日和26日EMA这组线，则通道线是平行于26日EMA线的。</strong></p><p>通道的宽度依赖于交易者选择的系数。这个系数通常用EMA的百分比来表示。 上通道线=EMA+通道系数×EMA 下通道线=EMA-通道系数×EMA</p><p>当为任意市场设置通道线的时候，<strong>开始通道系数可以设置为3%或者5%，然后不断调整通道系数值，直到通道线把最近100根线柱的所有价格数据中大约95%的包含在内，在日线图上大约是5个月时间长度</strong>。这很像试穿衬衫：你寻找那些穿起来不是太松也不是太紧的衬衣，只把你的手腕和脖子露在外头。同样，只有极端的价格会跑到已经画好的通道外面。</p><p><strong>波动较大的市场需要较宽的通道，而沉寂的市场需要较窄的通道。</strong></p><p><strong>便宜的股票通常比高价股票有更高的波动率。</strong></p><p><strong>长时间周期的线图需要的通道更宽。根据经验，周线图的通道宽度会是日线图的两倍。</strong></p><p>我过去常常靠手动画通道线，直到我的程序员为几个软件包编写了一个插件，叫作<strong>自动包络</strong>。它能自动地为任意交易品种，在任意时间周期里，画出正确的通道线（见图41-1）。在为多款流行程序设计的“埃尔德盘”中可以找到它。</p><p><img src="Pasted%20image%2020240129221257.png"></p><p>这个图表展示了2014年3月期的欧元外汇期货(ESH14)最近几个月时间内的交易情况。期货要比不透明的外汇交易要透明和真实很多。只要我需要做外汇交易，我首选外汇期货。</p><p>指数移动平均反映了在一定时间内市场对于价值的一致认同。 当价格靠近移动均线时，市场定价是公允的。 当价格下降到靠近下通道线的时候，则是被低估的； 当价格上升到接近上通道线时，则是被高估的。 通道线帮助我们在市场便宜的时候找到买入机会，而在市场被高估的时候找到做空的机会。</p><p>在上通道线上，熊市的背抵着墙壁与牛市进行搏斗；而在下通道线，牛市的背抵着墙壁与熊市搏斗。当我们的背抵着墙壁的时候，我们都会更加努力地战斗，这也是为什么通道线通常能守住的原因。</p><p><strong>如果上涨的高度突破了上通道线，并且收盘价在通道线上方，这显示上升趋势异常强劲。当反弹未能触及上通道线时，则是熊市的信号，因为表明牛市变得更加虚弱</strong>。这反过来同样适用于下降的趋势。</p><p>最好的交易信号是用通道线和其他技术指标结合给出的 （1）当价格达到上通道线，而诸如MACD柱状线之类的指标却出现了熊市背离，则是卖出的信号。它说明多头正变得虚弱，价格上涨过度了 （2）当价格达到了下通道线，而指标出现了牛市背离，则是买入的信号。它表明熊市正变得弱势，价格已经到了低点。我们必须在多个时间周期中分析市场。当周线图是上升时，就要在日线图中寻找买入机会。当周线图是下降的时候，就要在日线图中寻找卖出机会。 （3）当通道是上升的时候，在接近移动均线的位置做多，当到达上通道线的时候兑现利润；当通道是下降的时候，在接近移动均线的位置做空，当到达下通道线的时候兑现利润。 当通道上升时，最好只在多头方向进行交易，在长期和短期移动均线之间的价值区间中买入，然后在上通道线位置上卖出；当通道是下降的，最好在价值区间内卖空，然后在下通道线位置回补头寸。</p><p>例子： <img src="Pasted%20image%2020240129222200.png"></p><p>区域A——当价格到达下通道线，MACD线的新低表明这个低点将会被再次确认或者突破。 区域B——通道线拒绝了突破，反弹有可能即将开始。 区域C——价格到达上通道线并且被弹回——有可能发生反转。 区域D——买入。价格已经到达下通道线，但MACD显示在A与D之间有牛市背离，中间由C点隔开 区域E——价格到达了上通道线，MACD创了新高，表明这个高点很有可能被再次确认或者突破。 区域F——完全回归价值区间；MACD向下突破到0值线之下，创造了一个熊市背离的迹象，但仍可买入等待回到前期高点 区域G——卖出并反向做空。价格已经到达了上通道线，然而MACD在高点E和G之间已经表现出熊市背离，中间由F点区隔开。</p><h4 id="标准背离通道布林通道">标准背离通道（布林通道）</h4><p>这个通道线的特别之处在于它的宽度和市场的波动有关。它们的交易规则和常规的通道不一样。</p><p>当市场的波动性增大的时候，布林通道的宽度会增加；当市场波动性减小的时候，布林通道会变窄。窄的布林通道表明市场处于休眠的、安静的状态。大的行情常常从平坦的底部位置上爆发。布林通道帮助我们发现市场从安静到活跃的转变。</p><p>这些布林通道对于期权交易者十分有用，因为期权价格很大部分是由市场波动性所驱动。狭窄的布林通道指导你在波动性低、期权相对便宜的时候买入。宽的布林通道指导你在波动性很高、期权价格很高的时候卖出。</p><h2 id="交易工具">交易工具</h2><p>交易工具被分为不同的门类。它们在电脑屏幕上的图表看起来可能很相似，但不要让它们的外表欺骗了你。它们每一类都有各自的优点和不足。它们提供的机会不同，具有的风险也不同。你所要做的最重要的市场决定之一就是选择什么品种去交易</p><p><strong>不管是哪一类，你需要确保所选交易工具满足两个重要的条件：流动性和波动性</strong></p><p><strong>流动性</strong>指与这一类别中的其他交易品种相比的日均成交量。日均成交量越大，你进入和退出交易就越容易。在流动性不好的股票中，你或许能建立浮盈的持仓，但当你退出时，却变成亏损，因为买卖价差特别大。</p><p><strong>波动性</strong>是交易品种短期运动的范围。交易品种的波动性越高，交易机会就越多。受欢迎的股票往往波动性很大。许多公共事业部门公司的股票流动性很好，但因为波动性很低，而很难交易——它们常常在狭窄的价格区间里震荡。</p><p>关于卖空可以看《以交易为生Ⅱ：卖出的艺术》 #### 股票</p><p>找到自己有精力可以关注的股票数量</p><h4 id="etf">ETF</h4><p>此时的ETF只能买卖净值，作者认为ETF有些远离市场，而且不能做空，不喜欢，认为这样白白被收买入费用，而且还不见得比股票跑的好。现在国内的情况反而反过来，场内ETF开户可以免5，而股票则要比较高的印花税，而且不免5，因此我目前资金支撑不起直接买贵的股票，比如五粮液一手就13000</p><h4 id="期权">期权</h4><h4 id="期货">期货</h4><p>期货是以确定时间和确定价格，交割确定数量特定商品的合约</p><p>买入股票的人会成为公司股东中的一员，但是当你买一份期货合约的时候，你没有拥有任何东西。你只是买入了一份有约束力的合约，在未来的时点要买入某种商品，它可能是一车小麦，也可能是一捆国债。而卖给你期货的人则承诺了交割的义务。你用来买股票的钱会转移到卖出股票的人手中，但是在期货市场中，你存放的保证金还在清算中心，作为担保品，确保期货到期时你会按时交割。那就是为什么过去叫它“诚实金”。在股票市场中，你会为借钱而付出利息，但是在期货市场中，你还能获取保证金的利息。</p><p>在股票市场中，大多数人都只做多，只有很少人做空。在期货市场中，与期权市场一样，多头的规模和空头的规模总是相等的，因为如果有人买入一份开仓期货合约，必须有另外一个人对应地卖出开仓，也就是做空。<strong>如果你想交易期货，要对做空操作很顺手。</strong></p><p>新手在期货市场的生存率很低——据说十分之九的新手在最初几个月就会被洗出局。要理解，危险的并不是期货本身，而是新手的风险管理能力欠缺。期货给成熟的交易者提供了非常好的交易机会，但是对业余交易者来说是很危险的。在你到期货市场中冒险之前，必须培养自己卓越的资金管理能力（将在第49～51节中详细讲述）。</p><p>对于有很强资金管理能力的交易者，期货是非常有吸引力的。高收益率需要铁一般的纪律。新手炒变化更慢的股票会更好一些。一旦成为成熟的交易者，你观察期货会更加清晰。另外，读一些介绍性的书，比如乔治·安杰尔(George Angell)的《期货市场取胜之道》(Winning in the Futures Market)就是一本很好的书，其他的还有特维莱斯(Teweles)和琼斯(Jones)的《期货交易实用指南》(The Futures Game)。</p><p>套期保值是持有与其商品现货头寸相反方向的期货头寸。例如，大糖果厂商就能预测未来几个月需要多少糖。在糖的价格合适时，他可以在纽约或伦敦的期货市场买入相应数量的糖期货。在未来的几个月，他们需要的糖，通过持有糖期货的方式套期保值了，当他们需要进货的时候就卖掉相同数量的期货合约。如果糖的价格上涨了，糖果厂买入原材料需要支付更高价格，但是他们持有的期货头寸的盈利大致抵消了现货的损失。如果糖的价格下跌了，他们在期货合约上是赔钱的，但买入原材料的成本下降了。而那些没有进行套期保值的竞争对手正在经历着风险。如果价格下降了，他们会买到便宜货，得到一笔意外之财，但是如果价格上升了，他们就亏惨了。进行套期保值的消费者可以集中注意力于他们的核心业务，不用受到未来价格波动的干扰。比如航空公司提前几年就可以知道未来需要多少航空燃油，买入期货合约可以保护他们免受燃油价格波动的影响，而原油价格暴涨暴跌是很常见的。</p><p>商品生产者同样可以从套期保值中获利。农业生产者可以在价格足以保证获利的时候，提前出售他们的小麦、咖啡和棉花。他们可以卖空足够的期货合约来覆盖他们预期的产量。从这点上来说，他们没有价格风险。如果价格下跌了，他们会通过期货市场的盈利来弥补现货市场的损失。如果价格上涨了，他们在期货市场的头寸会有所损失，但是在更高的价格上卖出真实的商品又把损失弥补回来了。</p><p>在美国，玉米、糖和平缓时期的铜等品种对初学者来说是比较好的市场。它们流动性好，波动性大而且单价不是很贵。</p><p>我们在第9章（风险管理），将再讲到期货市场。你将学到期货合约是否适合交易取决于标的资产的价格、波动性和你账户里的资金规模。</p><h4 id="外汇">外汇</h4>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以交易为生（上）</title>
    <link href="/2024/01/27/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2024/01/27/%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9F%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本部分包括了以交易为生需要的： 心理建设 + 技术面指标</p><h2 id="个体心理">1. 个体心理</h2><p>要战胜市场，我们必须记住交易的三大要素：<strong>良好的心态、一套合逻辑的交易系统、 有效的风险管理计划</strong>。它们就像凳子的三条腿一样——缺了哪一条，凳子都会倒。新手的通病是——只关注技术指标和交易系统而忽略其他要素</p><p>你得清醒地意识到自己的自我毁灭倾向。不要把自己的损失归咎于坏运气或者是其他人，你应该为最终结果负责。开始坚持记日志吧——<strong>记录你全部的交易记录，记录你为什么买入卖出，寻找成功和失败的重复模式。那些不会向历史学习的人注定会重复历史</strong></p><p>在一波连胜之后，业余的交易者开始误认为自己是天才，自己如此擅长交易，每一次交易都能成功，这种感觉令人着迷。这正是他们开始偏离规则、损失资本的开始。</p><p>成功的交易者，他们有一个突出的标志，那就是能够让自己的资金稳步增长而非大起大落。</p><p>对于交易风险的定义会改变你管理资金的方法（详见第9章，风险管理）。单次交易的最大风险额度不应超过账户资产的2%。如果你有10000美元，则不应超过200美元。如果你的资金量较小，就限定自己少买一些股票，选择便宜一点的期货或迷你合约</p><p>你有保存自己的交易记录吗？股市赌徒的一个明显特征就是从来不做合格的交易记录。优秀的商人都会将交易记录保存完好。你的记录必须包括每次买入与卖出的价格和日期、滑点、佣金、止损点、对止损点的所有调整、买入的原因、目标价位、最大浮盈、达到止损点后的最大浮亏，以及任何有必要记录的数据——以便于以后回顾自己的交易</p><p>在交易风险覆盖范围内交易就像无酒精的生活。交易者在交易前必须先假设自己亏损，就像酒鬼必须承认自己是酒鬼才能开始戒酒一样</p><p><strong>市场不知道你的存在，你的存在也无法影响市场。它不会故意关照你的财富，也不会特意伤害你的资金。你要做的，只是控制自己的行为。</strong></p><p>金融市场是整个地球上最有娱乐性的地方，但是情绪化交易却是最致命的</p><p>道格拉斯曾警告说：“如<strong>果市场的行为让你觉得迷惑，那只是因为你自己的行为是古怪而失调的。当你连自己要做什么都不知道时，你怎么可能判断出市场的下一步动向</strong>？你唯一能够掌控的就只有你自己。作为一名交易者，你有权利决定是自己赚钱还是被别人赚钱。”他补充道：“能持续获利的交易者，都是将自律的态度应用到交易中的人。</p><p>想要成为专业的交易者，可以看看以下的单子： （1）坚定自己在市场中长期作战的意念——从现在开始至少交易20年 （2）像海绵一般地学习，关注专家的观点，但对任何事情都要保持有益的怀疑态度。遇到有疑问的地方要刨根究底，而不是简单地接受专家的观点，或只理解他们字面上的意思。 （3）不贪婪，不急于交易——要把你的时间用于学习，市场一直在这里，未来无尽的岁月中会有更多更好的机会 （4）培养分析市场的方法，换句话说，就是“<strong>如果A发生，那么B很可能会发生</strong>”。市场有很多维度，要使用多种解析方法来确认自己的交易决策。要学会用历史数据测试交易决策，随后在市场上真枪实弹地进行交易。市场瞬息万变，<strong>你需要的是根据牛市、熊市、震荡市等不同的特征采用不同的工具进行交易，同时还要有所区分</strong>（详情见技术分析章节） （5）建立一套资金管理计划。你的第一目标是必须长期生存下去，第二目标是资本的稳定增长，第三目标才是赚取高额利润 （6）要认识到交易者在任何交易系统中都是最为薄弱的一环，需要学会克制情绪化交易 （7）胜利者在思考、感受与行动上的方式与失败者是完全不同的。你必须深探自己的内心，驱赶那些幻觉，改变你原来的思考、感受与行动的方式。这样的改变通常都不容易，但如果你想成为一名专业交易者，你必须专注于自我改善和培养自己的个性</p><h2 id="群体心理">2、群体心理</h2><p>成功的交易者必须学会独立地思考问题，他需要强大到能独自分析市场并进行买卖决策</p><p>群众有着足够的力量来创造某种市场趋势，群众或许不够理智，但却比任何单个个体要强大很多。千万不要逆趋势交易。一旦上涨趋势得以确立，你能做的只有买进或者在一边观望。千万不要仅仅是因为感觉价格过高而去卖空——再次强调，不要和趋势作对。没有哪个规定说你一定要和人群一同奔跑，但你至少不应该逆着人群行进</p><p>大多数离开原有平台的交易者开始用自己的钱冒险时，他们便开始被困于恐惧、贪婪、兴奋或恐慌等负面情绪中，很少能成功地交易自己的账户——这证明了心态才是交易成败的关键</p><p>群体十分简单原始，所以交易策略也应该简单。你不用把自己当成一个火箭专家那样去设计复杂的计划。如果价格走势与你的预测相反，就止损退出。永远不要与群体叫板——你要做的很简单：利用自己的判断力，决定什么时候加入群体什么时候离开观望</p><p>你需要认真地准备好你的交易计划，切忌随着价格的瞬息万变而情绪化交易。最好是可以亲手将你的计划书写在纸面上，这样可以更确切地认识到自己应该在什么条件下开始交易或者退出交易。交易的过程中不要肆意制订交易计划，否则你就会很容易被群体情绪同化</p><p>在交易的过程中，你必须时刻留意自己，关注自己精神状态的变化。写出自己入场与出场的条件，包括资金管理规则。只要手上还有仓位头寸，就坚决不能修改计划。</p><p>当价格趋向上涨，多方将更为乐观，并不介意为此多花一些钱买入，他们在高位继续买入是因为他们预期价格将进一步上涨。当贪婪而乐观的多方遇到了恐惧而保守的空方，市场就会反弹。这样的感受愈强烈，反弹程度就会愈发剧烈。而只有当多方失去热情，这种反弹才会结束</p><p>当价格下跌，空方感受到乐观的情绪，从而不会介意在更低的价格上卖空。多方将感到恐惧，仅在折价条件下才会购买股票。当空方以胜利者自居时，他们继续在更低的价格上卖空，使得下跌趋势继续。当空方开始谨慎行事，拒绝在更低价格卖空时，这种下跌才会停止</p><p><strong>个人的自由行为难以预测，而群体行为更为简单，且易于被追踪：当你分析市场的时候，你便是在分析市场行为。你需要识别群体移动的方向以及多空双方改变的速度</strong>。</p><p><strong>持续上涨的时间越长，越多的分析师会被困在群体的无意识之中，忽视了危险的信号，并错失了最终的反转。持续下跌的时间越长，越多的分析师会被困在悲观看空的情绪之中，忽视了牛市的信号</strong></p><p>这儿有一个帮助你检测你的偏差的方法。如果你想买入，把你的行情图上下颠倒，观察是否像是卖出信号。如果仍然像是买入信号，在你再次翻转行情图之后，你就需要将多头的偏差移出你的系统。如果两张行情图都看着像是卖出信号，那你就需要将空头偏差移除你的体系</p><p><strong>在做金钱的交易的时候，你不需要预测未来。你需要从市场提取信息，来寻求是否空头和多头处于控制之中。你需要衡量市场上占主导地位的群体的力量并以此来决定现有趋势有多大可能会持续下去。你需要练习保守的金钱管理，从而获得长期的生存和财富积累。你必须观测你的思维的运作，避免倾向于贪婪或者恐惧。如果能够遵守这些原则，交易者会比大多数预测者要成功</strong></p><p>成功的交易建立在三大支柱之上。你需要分析多空力量的平衡。你需要实践资金管理。你需要严格服从你的交易计划，避免在市场中过于兴奋或者沮丧</p><h2 id="经典图表分析">3、经典图表分析</h2><p>在看了成千上万的图表之后，我发现市场根本不认同斜线，市场能够记住价位，这就是为什么水平支撑位和阻力位有意义，而斜线趋势却是主观的甚至是自欺欺人的</p><p>在我自己的交易过程中，我只用几个客观到足以让人信赖的图表模式。我关注基于水平的支撑区和阻力区、每日开盘价和收盘价的关系、蜡烛图高点和低点的关系，这些都是客观的</p><p>记住一条关键原则：“每一个交易价格都是所有的市场参与者价值认同瞬间达成一致的表现。”基于此，每一个价格柱状线都提供了多头和空头激烈博弈的重要的信息</p><p><strong>每日开盘价往往反映了业余者对价值的看法</strong>。业余者每天阅读早报，看前一天发生了什么，然后在开车去工作之前下订单。业余者总是在每天和每周的开始阶段异常活跃</p><p>在牛市中，市场通常在周一或周二时出现当周最低价——因为业余者会兑现前一周赚到的利润，然后市场会在周四或周五创出新高。而在熊市中，周一或周二通常会创出当周价格的高位，随后在接近周末时则会创出新低</p><p>每天或每周的收盘价则往往反映了专业交易者的行为。他们全天都在盯着市场交易，对市场变化做出反应，并倾向于主宰最后1小时的交易。他们当中的许多人在那段时间兑现利润，以避免持仓过夜</p><p>每一根柱状线的收盘价都是当天多方和空方博弈的最终结果，每根柱状线的最低点代表了最强空方的力量，多方反之</p><p><strong>柱线图中最高点和最低点的距离反映了多方和空方冲突的激烈程度</strong></p><p>一根平均长度的柱状线表明市场相对冷静。如果柱状线的长度只有平均长度的一半，说明市场疲软而冷清。如果柱状线是平均长度的两倍，则说明市场火爆，多方和空方的博弈遍及各个战场</p><p>人是有记忆的，人们记得过去的价格，而这些记忆会影响他们做出买或卖的决定。人们的记忆创造出市场价格之下的支撑位和市场价格之上的阻力位</p><p>混沌理论在最近的几十年来得到了推广。市场大部分时间段是混沌的，你只能在那些有序的时间段里才能取得一定优势，如果你在混沌时间进行交易，那么唯一赚钱的就是你的经纪商。</p><p><strong>你要时刻牢记的关键点是：一旦混沌中出现某种模式，你的交易系统应该能够迅速识别这种变化，这就是你入市交易的时候</strong>。之前我们说过，相对于专业的交易者，个人交易者的最大优势在于可以等待好的时机进行交易，而不必每天都保持活跃的交易</p><p>市场模式也具有分形结构，如果我向你展示同一市场的一些图表，一旦去掉了时间标签后，你就无法分辨出这些图表到底是月线图、周线图、日线图还是五分钟线图。下文（第39节）我们将回到这个主题，届时你就会发现为什么使用不同频率的时间进行分析如此重要。我们要确保在不同时间频率的图表中市场传达出的买卖信息能相互印证。如果不是如此，<strong>那么说明市场依然处在混沌之中，而我们则要保持观望。</strong></p><p><strong>在画支撑位线和阻力位线时，让其经过成交密集区的边缘，最好是众多柱状线主体的边缘，而非那些极限价格。交易密集区是大量交易者想法发生改变的位置，而极限价格仅仅是那些心理最脆弱的交易者恐慌的反映</strong></p><p>画水平线穿过密集区间的上边缘和下边缘。下边的线是支撑位，在这个位置买方将战胜卖方。上边的线是阻力位，在这里卖方的力量将压倒买方。每次价格触及这些界线又弹开，这些界线的力量会得到加强。要警惕支撑和阻力位附近的假突破</p><p><strong>小的支撑位或者阻力位会导致趋势的暂停，而主要的支撑位和阻力位则会造成趋势的反转</strong>。大量的交易者们在支撑位买入，在阻力位卖出，使得支撑位和阻力位的有效性变成了一种自我实现的预言</p><p>如何识别趋势呢？不是通过趋势线。我最喜欢的工具是<strong>指数移动平均</strong>，我们将在下一章中谈到这种方法。趋势线是非常主观的，它是最自欺欺人的一种工具。在趋势识别领域，计算机分析远胜于经典的图表分析方法</p><p>支撑位和阻力位之所以能够存在是因为大量交易者感到了痛苦和悔恨。在买卖中赔了钱的交易者会感到非常痛苦。</p><p>当价格跌破一个区间时，之前买进的多方就会感到痛苦。他们感觉被困住了，想等待价格回升，回本之后马上卖出股票。空方则相反，后悔自己卖出的太少。他们等待市场回升，有第二次做空的机会。多方的痛苦和空方的后悔就会形成阻力位——那是市场下降趋势中的天花板。支撑位和阻力位的强度取决于大量交易者感受的强度</p><h4 id="支撑位和阻力位的强度">支撑位和阻力位的强度</h4><p>价格在密集交易区波动越久，空方和多方投入的感情成本就越大。当多次趋势触及同一反复震荡区时，这一区域就成了一个布满弹坑的战场：防御者有大量的防御能够减弱任何攻势</p><p><strong>这些区域的力量取决于三个因素：区域的长度、高度，以及在区域内的成交量。你可以将这些因素作为交易区的长、宽、深进行可视化处理</strong> 1. 区域长度 阻力区或者支撑区持续时间越长——它持续的时间越长或者期间被冲击的次数越多——阻力或者支撑力度就越强。支撑位和阻力位就像好酒一样，时间越久越好。但是太久也没用，因为随着支撑位和阻力位变得过于久远，它们的力量就会逐渐减弱。由于失败者被不断洗出市场，由其他新进者代替，这些新进者并没有在老的价位上投入那么多感情 （1）持续两周的反复震荡区只会产生一个微小的阻力位或者支撑位； （2）持续两个月的阻力位或者支撑位会让人们习惯这个价位，并且产生一个中等强度的支撑位或者阻力位； （3）而一个持续两年的反复震荡区则会让人接受该价位是股票的真实价值，从而成为重要的阻力位或者支撑位 2. 区域高度 支撑和阻力区域越高，它的力量就越强。高大的密集成交区就像保护财产的高墙大院一样。如果一个密集成交区的高度仅有现在市场总价值的1%，那就只能提供一个弱小的支撑位和阻力位；如果有3%那么高，就会形成一个中等强度的支撑位或者阻力位；如果是7%或者更高，那么这个密集成交区能碾碎一个大的趋势 3. 区域深度 支撑区和阻力区的成交量越大，其力量越强。大成交量表示了交易者参与程度活跃——这是高的感情投入的信号。低成交量意味着交易者对在这个价位交易的兴趣不大，标志着支撑或阻力较弱</p><p><strong>如果用股票在密集交易区的天数乘以成交的平均价格和平均成交量，你就可以测算出支撑力量或阻力的总金额</strong>。当然，在做对比的时候，我们只能在同一只股票的支撑和阻力区间之间进行比较。你不能把苹果和橘子进行比较，所以也不能把苹果公司的股票和一家股价10美元、在活跃交易日也只有百万股票成交的小公司股票进行对比</p><h4 id="交易规则">交易规则</h4><ol type="1"><li>无论何时，当大盘走势逼近支撑位或者阻力位时，设定好你的保护性止损位 保护性止损是这样一种指令：当你有多仓时，在现在市场价格之下设定止损价格，一旦触及将卖出你的股票；而当你有空仓时，在市场价格之上设定止损价格，一旦触及将平掉你的空头头寸。保护性止损单能使你在趋势反转的时候不至于损失过大</li><li>阻力位和支撑位对于长期图表比对短期图表分析更重要 好的交易者会用不同的时间周期图表来监控市场，但会在长期图表分析中花更多的精力。周线图比日线图更重要。如果周线图的趋势很强势，那么日线图触及阻力位也并不用太担心。当周趋势线逼近阻力位或者支撑位时，你就应该考虑退出了</li><li>支撑位和阻力位意味着交易的机会 （1）技术分析中最重要的模式之一是“假突破”，如果价格微降至支撑位一下，然后又重回支撑区域，这意味着空方已经失去他们的机会。<strong>当出现向下假突破后，线柱的收盘价收回在密集成交区之内时，标志着这是买入的机会。你应该在近期假突破点底部附近设置一个保护性止损单</strong> （2）真正的向上趋势突破之后不会重新跌落入之前的密集交易区，就像火箭不应该在发射之后又落回发射台一样。当价格的蜡烛图又重回密集交易区时，向上的假突破发出了卖出的信号。你在做空时，在向上假突破的顶部附近设置一个保护性止损单</li></ol><p>如何设置保护性止损单　有经验的交易者总会避免在整数价格处设置保护性止损单。如果我以52美元买入一只股票，想把我的保护性止损单设置在51美元，那么我会把保护性止损单设得低于51美元几美分。如果我在一次日间交易中，在33.7美元的价位做多一只股票，并且想把保护性止损单设在33.5美元附近，我会把价格设置得比33.5美元低几美分。<strong>人们习惯使用整数，在这些整数价位会积累很多订单。我更喜欢让自己的订单远离这些订单的密集区</strong></p><h4 id="真假突破">真假突破</h4><p>在日线图上买入向上突破的最佳时机，是当你发现周线图出现新的上升趋势时。真正的突破一般伴随有巨额的成交量，而假突破则成交量很少。真正的突破时技术指标会在新的趋势方向上达到新的极限价位，而假突破则常令价格与技术指标直线出现背离。以上所述我们都将在本书之后的章节讨论</p><h4 id="趋势与交易范围">趋势与交易范围</h4><p>趋势指价格持续上涨或者下跌一段时间。<strong>在一个完美的上升趋势中</strong>，每一次上涨的高位都会突破之前的高位，而每一次下跌都会高于之前下跌的低位。而在完美的下跌趋势中，每一次下跌都会击穿上一次的低位，而每一次反弹又无法高于上一次反弹的最高点。在震荡区间内，每一次上涨都会抵达之前的高点，而每一轮下跌也回到以前的低位。<strong>完美的模式在金融市场里也没那么常见</strong></p><p><img src="Pasted%20image%2020240127205716.png"></p><p>在这个图表中可以看到12345构成了一次下跌趋势，F是一个假突破，突破30日均线后向上趋势逆转，678构成了上涨趋势，然后出现了两次假突破F，第二次假突破后，向下突破了均线，趋势再次反转。</p><p>即使只是粗略地扫一眼图表你也能发现，市场在大部分时间都处在震荡盘整中。趋势和震荡行情需要不同的交易技巧。当你在<strong>上升的趋势中做多或者在下降的趋势中做空</strong>时，你会因为对趋势的怀疑而损失一部分利润，此外你还得<strong>灵活运用宽松的保护性止损单</strong>，以免被迫出局。另外在<strong>震荡行情</strong>中，你必须运用<strong>收紧保护性止损单</strong>，时刻警惕着，一旦发生行情反转的微弱迹象，立即抛售手中的仓位</p><h4 id="难解的右侧">难解的右侧</h4><p>趋势和震荡在图表的中部很容易认出来，但是当你接近图表的右侧时，情况就越来越模糊了。过去是确定而清晰的，但是未来却是流动而不确定的。在历史的图表中趋势很容易分辨，但不幸的是经纪商不允许我们回到过去交易——我们得对右侧做出艰难的决定。</p><p>当趋势变得完全清晰起来时，趋势中一大部分赚钱的好时光已经过去了，当市场趋势消解变为震荡时，没人会为你拉响警报铃。许多图表的模式和技术指标会在右侧彼此矛盾。你必须在不确定的氛围中依靠概率做出决定。</p><p><strong>许多人在处理不确定性时都会感到不舒服。当趋势未如他们所料时，他们就会死死抱住赔钱的仓位，等待市场的反转让他们回本</strong>。<strong>专业交易者会很快从失败的交易中撤出。当市场和你的判断相反时，你应该毫不犹豫立刻止损</strong></p><h4 id="判断趋势的方法和技术">判断趋势的方法和技术</h4><p>你要牢记没有任何一种简单的魔法能够清晰明确地辨认出所有的趋势和震荡区域，你得<strong>将几种分析工具联合起来使用</strong>。没有方法是完美的，但是假<strong>如他们可以相互印证，传递出正确信息的概率上升。==当他们彼此矛盾时，你最好还是别进行交易了</strong>。==</p><p>（1）分析高点和低点的模式。当价格回升总是能达到更高的高位，而下跌总能停止在更高的低位，那就是一个上升的趋势。而更低的高位和更低的低位则意味着一个下降的趋势。而<strong>不规则的高点和低点则意味着震荡区域</strong>（见图19-1）。</p><p>（2）画一条20～30日的指数移动平均线（见第22节）。斜率的方向就显示出了趋势。<strong>如果移动平均曲线没有在月内达到一个新高或者新低，那么市场就可能处于震荡区间内</strong>。</p><p>（3）当摆动指标，比如MACD柱状线（指数平滑异同移动平均线）（见第23节）创下新高，那就预示着一个强力的趋势，表明市场上最近一次顶部要被试探或者被超过。</p><p>（4）几种市场指标，比如趋向系统（directional system，见第24节），也能帮助你判断市场趋势。趋向系统在捕捉新趋势的早期阶段尤为灵敏</p><p><img src="Pasted%20image%2020240127211129.png"></p><p>任何趋势确认的唯一标识是其高点和低点的模式。例如图19-2的联合太平洋公司日线图，一旦突破了震荡区间，其高点（绿色水平线标示）逐步抬高，同样的，其低点（红色水平线标示）底部也在抬高。<strong>试图画趋势线是很主观的，因为联合太平洋公司的低点不在一条直线上</strong>（趋势线不靠谱）。</p><p>22日指数平均线是一条叠加在价格线上的红色线，此时平稳的抬升确认了上升趋势。注意这里，当价格快速下降到移动均线时，出现了一次极佳的买入机会（我们在第22节将讲到这种模式）。</p><p>趋向系统（详见第24节）发出新趋势开始的信号的模式是，当平均趋向指标(ADX)跌落到20以下后又反弹到这个水平之上，向上穿透下趋向系统（以垂直绿色箭头标示）。</p><p>MACD柱状线（详见第23节）能识别非常强有力的趋势，当其上涨达到数月内的最高值（以绿色斜箭头标示），在图19-2的右边缘趋势是向上的，而价格略低于其前期高点。价格跌到EMA时很可能又是一次新的买入机会</p><h4 id="交易还是等待">交易还是等待</h4><p>当你已经认出一个上升趋势时，你要决定是立刻买进还是先等待一个回调。如果你快速买进，你就能跟上大盘，但是这样做不利的一面是，你的保护止损价位可能设置得很远，这就增加了你的风险</p><p>如果你等到了一次回调再入场，你的风险可能变小，但是你的对面将出现四组竞争者：想要加仓的多方，试图打平离场的空方，还没入场的交易者（比如你自己）和那些卖得太早、现在急切地想买回来的人。<strong>回调的等候区域是相当拥挤的。而且，一个深度回调可能预示着趋势开始反转而非买入的机会</strong>。同样的理由也适用于下跌趋势中的卖空情形</p><p>如果市场正处在震荡区间而你正在等待着突破，你得决定是在预期会突破时买入，还是在正突破的期间买入，又或者是在突破后的回调当中买入。<strong>如果你不确定，你可以分以下几个步骤买入：在突破迹象出现的时候买入三分之一，突破的时候再买入三分之一，回调时再买入三分之一</strong></p><p>你买入价格与保护性止损单的差距与你买入量的乘积不能超过你账户股票总价值的2% （也有设置止损的办法，就是将止损设置在关键点位以外的5-10个点）</p><p>在趋势中和震荡区间中所需要的风险管理技巧是不同的。<strong>在趋势中进行交易时，在宽松的保护性止损单上保持较小的头寸能帮你赚钱，你在控制好风险的同时也不太可能被反向波动震荡而出局。在震荡区间时，你得设置十分谨慎的止损策略，同时持有较大的头寸规模</strong>，因为此时的利润会更微博，所以止损策略要更谨慎</p><h4 id="相互冲突的时间周期">相互冲突的时间周期</h4><p>同一个市场在不同时间周期下的指标冲突是市场图表分析中的困惑之一。日线图上看似形成了趋势，可能却只是平缓周线图上的一个波动。而在日线图中的相对平缓的震荡区域却可能在小时线上显示出大量的向上或者向下的趋势，如此反复</p><p>明智的做法是这样的：在用你最喜欢的图表检验趋势前，先将图表上的时间周期提高一个尺度以验证趋势。从更高视角进行研究是<strong>三重交易系统</strong>的关键原则，这一系统我们将在后面章节中进行讨论</p><p>当专业交易者对市场产生怀疑时，他们会以长期视角来看市场，而业余的交易者往往关注短期图表。研究时视野放得越长效果越好——而且越轻松</p><h4 id="袋鼠尾">袋鼠尾</h4><p><img src="Pasted%20image%2020240127215014.png"></p><p>百健艾迪公司(BIIB)股价在出现向上翘的袋鼠尾之时，还处于稳定的上升趋势中。<strong>当日开盘价略低于前收盘价但走出了一根很高的线柱，是平时正常高度的三倍。当股价达到创纪录高位后开始回落，收盘在接近开盘的位置。第二天线柱高度是正常的高度</strong>——这样袋鼠尾的形态就完成了，趋势也反转了。</p><p>袋鼠尾在任何时候都可能出现，但是周线比日线，日线比五分钟线更靠谱</p><p><strong>袋鼠尾，也称“手指线”，是少数可信的图表信号</strong>。它们很有吸引力，也很容易辨认。<strong>如果你不能确定这是不是一个真正的袋鼠尾，那你就假定它不是，因为真正的袋鼠尾是不会出错的</strong>。它们会出现在大盘指标中也会出现在个股、期货和其他交易品种的图表中</p><p>市场总是在波动，寻找产生最大成交量的价位。如果价格上涨却没伴随着足够的成交量，市场很快就会反转，在更低的价格上寻找更多的交易。如果成交量在下降过程中萎缩，价格就会上涨，在更高的价位上寻找成交量</p><p>袋鼠尾反映了这种失败的突破。朝上的袋鼠尾反映了多方推高价格的努力失败。他们就像一队士兵，想要从敌人手里夺取一座山头，结果发现主力没有跟上来。所以他们就逃到半山腰以求保命了。而一旦丢失了山头，军队就会撤退到别处。</p><p>朝下的袋鼠尾反映了一次失败的空方突袭。空方激进地做空，打压价格——但是低价并没有吸引足够多的成交量，于是只能撤回震荡区间。在继续下跌的尝试失败之后，你觉得市场下一步会往哪儿走呢？既然低价位附近没有什么成交量，那么就上升回调吧。</p><p><strong>袋鼠尾意味着市场拒绝了某一价格</strong>。它通常会引导趋势的反转。一旦你发现了袋鼠尾，就马上朝相反方向操作吧</p><p><strong>记住逆袋鼠尾方向操作是一种短期策略。在日线图中，这些信号往往几天之后就会消失。你要在当前的市场背景下正确评估袋鼠尾。==比如当你长期看多一只股票时，一定要警惕袋鼠尾。向上的袋鼠尾意味着应该在当前的价位上兑现盈利，而向下的袋鼠尾则是一个加仓的好机会</strong>==</p><p>在市场中使用保护性止损单来防止损失和取得盈利是非常重要的。<strong>在袋鼠尾的末端设置保护性止损单会让保护性止损单太宽，承担过多风险</strong>。<strong>当你逆袋鼠尾方向交易时，将你的保护性止损单设置在袋鼠尾的中间价位</strong>。如果市场开始逼近这个价位，你就该离场了</p><p><strong>袋鼠尾形态不能预测价格走势的确切目标，但通常能持续几天，提供交易机会</strong></p><p>（看到这里，我赶紧回去看了一下最近的沪深300的线，确确实实出现了有点像袋鼠尾的形态，2024-01-18。这不是最重要的，最重要的是我发现沪深300已经站上了30日均线，布林线也已经突破了中值，然而就像前文说的，我似乎在恐慌中完全忘记了这一点，只知道前几次国家队救场大涨之后，没有止住趋势，继续出现了大跌，完全没有注意前面几次没有突破均线（也就是其实没有扭转趋势，将希望或者幻想寄托在了国家买入止住恐慌下跌，其实这都是没有意义的））</p><h2 id="计算机在交易中的应用">4、计算机在交易中的应用</h2><p>工具箱能画出MACD，移动平均，boll，RSI等指标，甚至创建自己的指标，如果你从事期权交易，工具箱还应该包括期权定价模型</p><p>好工具箱的另一个特征是其具有扫描股票的能力。比如说你想找出纳斯达克100指数成分股中，指数移动平均指标正在上涨的股票，并且其价格不超过其指数移动平均数的1%。你的软件能找出这些股票吗？它允许你把一些基本面数据加入到搜索条件中去吗，比如每股收益上升？想想你到底需要哪些指标，然后问问哪些软件开发者能够满足你的要求</p><p>这本书中的大部分图表都是用这种免费服务做出来的，如StockCharts.com，因为我想让你们看到即使花费很少也可以做到很多</p><p>无论何时你想交易时，你必须知道你的优势——<strong>是什么能让你赚钱</strong>。辨认图形模式的能力就是我的一种优势，但是如果一只股票的交易历史太短，就没有模式供你辨认。这就是我避免交易新近上市（上市时间短于一年）的股票的原因</p><p>收集和分析数据时，不要在同一时间追踪太多的市场。<strong>要关注数据的深度和质量而不是数量。首先从关注重要市场指数开始</strong>，比如道琼斯指数、纳斯达克指数以及标准普尔指数。许多专业交易者专注于相对较少的几只股票。他们了解了这些股票并且开始熟悉它们的交易模式</p><p>你可以从关注<strong>12只股票</strong>开始。许多专业交易人员都把他们关注的股票限制在100只以内，他们每周末都复盘这些股票并且在笔记本上记下关于它们的笔记。他们可能从这个股票池中选取不超过十只看起来在下周会有一波行情的股票，然后集中精力关注它们</p><p>新手应该避免日内交易。日内交易要求瞬时决策的能力，如果一旦停止思考你就死定了。在你考虑做日内交易前，首先要成为一个有竞争力的趋势交易者或者中长线交易者</p><p>趋势交易是个很好的起点。比如说，持有某个仓位几天。挑选那些趋势很好、成交量又不错的热门股票。开始时只买上几手</p><hr><p>技术指标能够帮助你识别趋势和反转。它们比图表模式更加客观，而且能够提供空方和多方之间力量均衡的洞见</p><p>一个巨大的挑战就是许多指标之间会相互冲突。一些指标在趋势形成的市场中有效，而一些指标则在波动的市场中有效。一些指标擅长抓住反转的点，而另一些指标则更擅长确定趋势的持续。这就是为什么从那么多指标中挑选出少数几个指标并将其联合使用是非常有必要的</p><p>大多数指标是基于5个相同的数据的：开盘价、最高价、最低价、收盘价和成交量。价格是最基本的，其他指标都是从中衍生出来的。用10个、20个、50个指标并不能让你的分析更深入，因为它们都是基于相同的东西</p><p>我们可以把所有指标分成3类：<strong>趋势跟随指标、震荡指标和其他指标</strong> （1）趋势跟随指标在大盘上涨或者下跌时最有效，但在大盘震荡区间效果急剧下降。包括移动平均值、MACD线（moving average convergence-divergence，指数平滑异同移动平均线）、趋向系统、能量潮(on-balance volume)以及收集派发指标等。趋势跟随指标属于<strong>同步或者滞后指标</strong>，<strong>它们在趋势反转之后才反转</strong> （2）震荡指标在震荡区间的市场中能判断出拐点，但是在大盘趋势逐渐形成时，它给出的信号是不成熟和危险的。它们包括<strong>MACD柱状线</strong>(MACD-histogram)、强力指数指标、随机指标、变化率、动能指标、相对力量指标、埃尔德射线指标(Elder-ray)、威廉百分比(Williams %R)以及其他指标。震荡指标是先行指标或者同步指标，常常比K线先反转 （3）其他指标能够提供有关大众心理的洞见。复合型指标能够提供多空双方强度的信息。它们包括新高-新低指标、看跌/认购期权比(put/call ratio)、好友指数(bullish consensus)、交易者指数以及其他指数。它们可以是先行或者同步指标。</p><p><strong>将不同组中的不同指标结合起来是很有用的，可以抵消各个指标的缺点同时保留它们的优点。这正是“三重滤网交易系统”的目标所在</strong></p><p>当我们开始探索技术指标时，我们最好谨慎行事。有时候它们的信号是非常明确的，有时候又很模糊</p><p>多年之前我就学会了，只有当我非常确定指标发出的信号时，我才会选择进场。<strong>如果我发现自己一直盯着图表试图理解其中的信号，那么我会翻到下一页去看另一只股票</strong>（！！！！）</p><p>如果你看到一个熟悉的指标，但不理解其中的意思，最可能的原因是你试图分析的这只股票<strong>正处在混乱阶段</strong>。（如果指标信号不明确，那就不要试图理解其中的意思，可以选择放弃，个人交易者最大的好处就是没有人逼着你交易——我们能够等待最好和最清晰的信号）</p><p>当你看到不同的指标的信号时，记住你不能把交易建立在一个单一的指标之上。我们要挑选几个我们理解并信任的指标，把它们结合到一个交易系统中。下一章我们将要考察这些指标，本书的后面我们会看到如何从这些指标中构建自己的交易系统</p><h3 id="移动平均">移动平均</h3><p>移动平均就是市场的一组摄影照片——它能把几天的价格结合起来。市场由大量的群体组成，而移动平均的斜率能够辨认出大众惯性的方向。</p><p>移动平均代表着股票价格在一段时间内平均一致的价值。移动平均值中最重要的信息就是其斜率的方向。当斜率上升时，表示大众正在变得乐观——倾向于看多。</p><p>它的斜率下降意味着大众开始变得悲观——倾向于看空。当价格升至移动平均值之上时，大众比之前乐观；当价格降至移动平均值之下时，大众比之前更悲观</p><p>在寻找交易机会的时候不能改变指标的时间长度。通过改变时间长度来创造出你想看到的信号恰恰会让你的指标失去其最具价值的特征——它们的客观性。最好的做法是设定一套参数，然后一直用它们</p><p>移动平均帮助我们顺着趋势进行交易。移动平均中最重要的信息是其斜率的方向（见图22-1）。它反映了市场的惯性。当EMA上涨时，最好是买入。当斜率下降时，卖空则会给你带来利润 （1）当EMA上涨时，作为多头进行市场交易。当价格下降到移动平均值附近时买入。一旦你成为多头，一定要在最近的低点下面设置保护性止损单。<strong>一旦价格接近高点时，就把保护性止损单移至盈亏平衡点。</strong> （2）当EMA下跌时，作为空头进行市场交易，当价格回升接近移动平均值时卖出，然后在最近的高点之上设置保护性止损单，当价格下跌时，将保护性止损单下移到盈亏平衡价位。 （3）<strong>当EMA走平，只是小幅波动时，那意味着一种漫无目的、没有趋势的市场。这种情况下不要使用趋势跟随方法</strong></p><p><strong>移动平均能帮助你分辨并追随趋势，但是它们也会在震荡区间内发出很多假突破信号。我们将在“三重滤网交易系统”那一节中找到这个困境的解决之道</strong></p><p>移动平均也能用来作为支撑位和阻力位</p><p>移动平均除了用于价格上，还可以用到其他指标上。比如，<strong>有些交易者喜欢用5日移动平均成交量。当成交量低于其5日平均成交量时，意味着人们对这只股票当前趋势的兴趣在减弱</strong>，也就是说其趋势可能会反转。当成交量超过其移动平均量时，表明大众对这只股票的兴趣很强烈，因此确认了价格的趋势。当我们考察强力指数（第30节）时，我们会用到指标的移动平均。</p><p>移动平均不但可以基于收盘价计算，也可以基于最高价和最低价的中间价来计算。这对日内交易者十分有用</p><p>我无论何时分析图表，都喜欢用两条而不是一条EMA线。长期EMA显示长期价值的连续变动，而短期EMA显示短期市场价值的连续变动。记住，保持两条EMA之间参数的比例大致为2∶1。想要更简单和高效，则最好在所有时间周期——周线图、日线图、甚至分时图，都用相同的一组参数。</p><p>因为短期EMA代表着短期内市场对价值的一致认同，而长期EMA代表着长期内市场对价值的一致认同，我相信价值就存在于这两条线之间。我将两条EMA之间的空间称为价值区间(value zone)</p><h4 id="价格价值以及价值区间">价格、价值以及价值区间</h4><p>我们买入价值被低估的股票，卖出价值被高估的股票——但是如何定义价值呢？</p><p>基本面分析师会研究它的资产负债表和年报，但是这些数据完全不像它们表面看起来那样客观。公司会粉饰它们的财务数据。并不只有基本面分析师才能使用“价值”这个概念。</p><p>技术分析师可以通过跟踪短期EMA和长期EMA之间的差价来定义价值。其中短期EMA反映短期的市场价值变动，另一个长期EMA反映长期的市场价值变动。价值就存在于两条移动平均曲线之间</p><p><strong>若准备买入一只股票，当其在价值区间时买入是比较有利的，而不是在价值区域之上多花钱去买</strong>。类似地，若是做空，待其反弹进入价值区域时再建立空头头寸，而不是在价格崩溃时卖空</p><p>非常重要的一点是：仅仅使用单一的指标或者一对移动平均指标是没法进行成功的交易的。市场是如此复杂，你不可能用一个单一的工具从其中赚钱。我们需要用多个指标来建立一个交易体系，并用多个时间周期来分析市场</p><p>记住这点能帮助你成为一个理智的交易者。一旦你懂得了如何定义价值，你就能低买高卖了。当我们在第41节（通道交易系统）仔细介绍价格通道，或者说包络线时，我们会回过头来继续寻找市场低估和高估时的交易机会</p><h3 id="macd线和macd柱状线">MACD线和MACD柱状线</h3><p>MACD线和信号线的交点表明了市场中空方和多方实力变换的平衡点。较快的MACD线反映的是短期内大众的心理变化，而较慢的信号线则反映了大众心理在较长期的变化</p><p>MACD线和信号线的交叉意味着市场趋势发生了变化。顺势的方向是沿着交点的方向进行交易。这个方法产生的假突破比基于简单移动平均的方法产生假突破要少很多 （1）当较快的MACD线穿越到较慢的信号线上方时，为买入信号。这时候要买多，<strong>然后在近期的次低点位置设置一个保护性止损单</strong>（千万不能忘记止损单）</p><p><img src="Pasted%20image%2020240128143105.png"> 注意该图表中其他几个形态。当ABX股价下跌到历史低点——图中B点，MACD线没有去确认：没有跌到新低而是走出了个双底。于是新低B点变成了向下假突破，是牛市来临的信号。在C点，空头试图最后一次把ABX股价压低，也没得到MACD线的确认，该线维持了稳定的上升趋势。在图表的右边缘，MACD线达到了上行运动的新高点，表现很强劲。两条EMA线都在上行，确认了牛市的趋势</p><p>相比原始的MACD线，MACD柱状线能够提供更深刻的关于多空力量均衡的信息。它不仅能分辨出哪种力量处于主导地位，而且能够分辨其力量是在逐渐增强还是在减弱。MACD柱状线是技术分析师最好用的工具之一。</p><p>MACD柱状线=MACD线-信号线 <img src="Pasted%20image%2020240128144049.png"></p><p>当两条MACD线交叉时，由两线衍生而出的MACD柱会穿过0线。你能在图中看到MACD线指示的买入和卖出信号（图中标识为绿色和红色箭头）。这些信号通常是滞后的，而MACD柱能给出很好的信号。</p><p>先看一个例子。比较道琼斯指数的低点D和F，指数的第二个底部只是稍稍更低（事实形成了一个向下假突破），<strong>但同时第二个底部附近的MACD柱比前一个底部的MACD柱浅多了，说明空头已经很虚弱，很可能会发生向上的反转</strong>。</p><p><strong>MACD柱状线揭示了市场长期价值和短期价值之间的差异。较快的MACD线反映的是短期内市场对价值的共识，而较慢的信号线反映的是长期市场对价值的共识。MACD柱状线对两者之间的差异进行了跟踪</strong>（所以可以比较两次低点或高点的MACD柱长度的变化）</p><p>当较快的MACD线上升得比较慢的信号线快时，MACD柱状线会上升。说明多方的力量比之前更强——这是做多的好时机。当较快的MACD线下降得比较慢的信号线快时，MACD柱状线会下降，说明空方的力量在增强——这是做空的好时机。</p><p>当MACD柱状线的斜率方向和价格的变动同向时，趋势就是稳定的。当MACD柱状线的斜率方向与价格的变动方向相反时，趋势的稳定程度就值得怀疑了</p><p><strong>MACD柱状线的斜率方向比柱状线的正负重要得多。最好是根据MACD柱状线的斜率方向来进行交易，因为它能告诉你在空方和多方中，到底是谁在主导市场。最好的买入信号是当MACD柱状线低于0值，而它的斜率方向是朝上的，表明空方的力量已经是强弩之末了；最好的卖出信号发生在MACD柱状线高于0值，而它的斜率方向是朝下的，表明多方已经耗尽了最后的力量。</strong></p><h4 id="交易规则-1">交易规则</h4><p>MACD柱状线能够发出两种交易信号。一种是<strong>普通信号</strong>，发生在每一个价格蜡烛线上；另一种信号很稀有——在一只股票的日线图上一年里可能只会出现几次，但是是<strong>非常强烈的信号</strong>。这种信号在周线图上更少见，但在日内图表中出现得比较频繁。</p><ol type="1"><li><p>普通信号： （1）当MACD柱状线停止下跌开始上升时就买入，在近期的次低点下方设置保护性止损单 （2）当MACD柱状线停止上升开始下跌时就卖出，在近期的次高点上方设置保护性止损单。</p><p>（周线更有意义！） <strong>MACD柱状线在日线图中频繁地上升下降，所以每次转向都进行交易是不切实际的。在周线图上MACD柱状线斜率的变动更有意义</strong>。这也是这个指标被纳入三重滤网交易系统（见第39节）的原因。将指数移动平均和MACD柱状线结合起来使用能帮你创造出“动力系统”，在第40节会详细介绍这一系统</p><p><strong>如果日线的MACD柱状线创出了三个月内的新高，说明多方的力量很强，价格还可以再创新高。如果日线的MACD柱状线创出了三个月内的新低，说明空方力量很强，价格可能会再次试探甚至突破之前的低点</strong></p><p>如果在价格上升的过程中，MACD柱状线创出新高，说明上升的趋势是健康的，可以预期市场会继续上涨，再次试探甚至超过之前的高点；如果在价格下降的过程中，MACD柱状线创出新低，说明空方力量很强，价格可能会再次试探甚至突破之前的低点。</p><p>当你在周线图上使用MACD线和MACD柱状线时，不必等到周五再去寻找信号。趋势可能在周中就已经发生了反转</p></li><li><p><strong>背离信号</strong></p><p><strong>注意：如果你需要用尺子去量一量看看这是不是背离信号，那么它肯定不是</strong></p><p><strong>要注意指标两个顶部之间的对0值线的突破，是真正背离所必需的因素。MACD柱状线在达到第二个顶点之前，必须低于0点</strong></p><p>MACD柱状线和价格出现背离的情形并不常见，但是它们却传达出了某些最强有力的信号。它们往往标志着重要的转折点。<strong>它们并不一定会出现在每个重要的顶部或底部，但是一旦你看到一个，你就知道一次大的反转可能即将到来</strong></p><p>（1）底背离（牛市背离）</p><p><img src="Pasted%20image%2020240128145922.png"></p><p>在A区域，当时雷曼兄弟破产了，一浪接一浪的卖出冲击着市场，道琼斯指数像自由落体一样下跌。MACD线柱图创出历史新低，说明空头极端强大，A区域的底部价格很可能会被重新试探甚至突破。</p><p>在B区域，MACD线柱图反弹到0值线之上，<strong>“打破了这个熊市”</strong>。<strong>要注意这个短暂的反弹触及到了两条移动平均线之间的“价值区间”</strong>——这是熊市反弹时一个比较常见的目标。</p><p>在区域C，道琼斯指数滑向了一个新的熊市低点，但MACD柱状线的底部则浅得多。而之后的回升，完成了一次牛市背离，这是非常强烈的买入信号。<strong>另一个关键点是，当MACD柱状线从第二个底部开始反转时，它就发出了买入的信号。它不必再次穿过0值线，在MACD柱状线低于0时，只要停止下降，负值开始缩小，就是买入信号了</strong></p><p>简单来说：底背离一般出现在股价的低位区。当股价 K 线图上的股票走势，股价还在下跌，底部不断下降，而 MACD 指标图形上的由绿柱构成的图形的走势是一底比一底高，即当股价的低点比前一次低点底，而柱子的低点却比前一次的低点高，<strong>同时出现了对0值的突破</strong>，<strong>反弹触及到了价值区间</strong>，这叫底背离现象。</p><p>（2）顶背离（熊市背离） <img src="Pasted%20image%2020240128151523.png"></p><p>简单来说：当股价 K 线图上的股票走势一峰比一峰高，股价一直在向上涨，而 MACD 柱的走势却一峰比一峰低，即当股价的高点比前一次的高点高、而 MACD 指标的高点比指标的前一次高点低，<strong>同时，出现了0值线的突破</strong>，<strong>中间的值穿透到了价值区间</strong>，这叫顶背离现象</p><p>在X区域，道琼斯指数和其MACD柱状线同时上升到牛市的新高点，说明多头的力量十分强大。这意味着未来很有可能会再次试探甚至突破顶部X点的价格。注意，MACD柱状线的X部分，其形态很复杂，但并不是一个背离，因为它的中间部分并未沉到0值线之下去。</p><p>在Y区域，MACD柱状线跌落到0值线之下了，<strong>“打破了这个牛市”</strong>。要注意，<strong>价格穿透到了两条移动均线之间的“价值区间”的下方</strong>。这是牛市中断时一个相当普遍的信号。同样要注意到在底部Y处，有一个“袋鼠尾”。在Z区域，道琼斯指数上升到一个牛市新高，但MACD柱状线的上升有点缺乏活力，反映出牛市的虚弱。在峰值处开始的跳水，完成了熊市背离，给出了强烈的卖出信号，预示着近30年最严酷的一个熊市。</p><p>另一个关键点是，当MACD柱状线从第二个顶点开始下降时，就已经是卖出的信号了。我们不必等到它再次穿越0值。虽然MACD柱状线仍然高于零点，只要停止上涨，并且新柱线长度比之前的柱线长度更短时，就发出了卖出信号了。</p><p><strong>三重牛市或熊市背离</strong>由三组价格和震荡指标的底部或者三组价格和震荡指标的顶部组成。它们比普通的背离更加强烈。要产生三重背离，普通的牛市背离或者熊市背离首先要出现失效。这也是需要做好审慎的资金管理的又一个理由！如果你在假突破时只损失了一小部分钱，那你能保持充足的资金和良好的心态再次入场交易。震荡指标第三次探顶或者探底一定比第一次浅，但并不一定要比第二次浅。</p></li></ol><h4 id="巴斯克维尔的猎犬">巴斯克维尔的猎犬</h4><p>这个信号产生在，当可信赖的图表或者指标的模式出现，但价格并没有走向你期望的方向时。比如，当背离模式出现，显示上升的趋势可能要结束了，但是价格却还在持续上涨，这种情形称为“巴斯克维尔的猎犬”。</p><p>当市场对一个完美的信号无动于衷时，那就是“巴斯克维尔的猎犬”的信号。这就表示在表象之下有更基础的东西在发生变化。这时候要做好准备，迎接一波新的大趋势</p><h3 id="趋向系统">趋向系统</h3><p>趋向系统是一种趋势跟随的方法，它能指明趋势，并显示什么时候趋势的运动值得去追逐。它能帮助交易者在大趋势的主体部分获利。</p><p>如何构建趋向系统？计算比较复杂，这里只放概念，方便查询 （1）确定“趋向运动”(directional movement,DM)：比较今天和昨天交易价格波动区间 （2）确定市场的“真实波幅”(true range,TR)。TR总是正值 （3）计算每日“趋向指数”（directional indicators,+DI和-DI）。通过计算DM占TR的百分比——从而可以比较各个不同市场的趋向指数大小。每个DI都是正值 （4）计算“平滑趋向线”（smoothed directional indicators,+DI13和-DI13），通过移动平均来平滑+DI和-DI （5）计算“<strong>平均趋向指标</strong>”(average directional indicator,ADX)。这个指标是趋向系统独特的组成部分</p><h4 id="交易规则-2">交易规则：</h4><p>（1）当+DI13高于-DI13时，做多头（PDI &gt; MDI）；当-DI13高于+DI13时（PDI &lt; MDI），做空头。同时，ADX上升的时候是最佳的交易时机，表示主导力量正在增强。 （2）当ADX下降时，表示市场的趋势正在减弱。这时可能产生很多假突破。当ADX下降时，最好不要用趋势跟随指标。 （3）当ADX降到两条趋向线之间时，表示市场是平静、死气沉沉的。此时不要用趋势跟随系统交易。但要做好交易的准备，因为这是暴风雨之前的平静，大趋势将会从这种平静中出现。 （4）当ADX落到两条趋向线之下时，则出现了趋向系统的最佳信号。它在此区域待得越久，那么下一次趋势的基础就越强。当ADX从两条趋向线下方开始回升时，意味着市场从平静中觉醒了。当ADX从趋向线下方的低点上升了4步（比如从9到13），这就是一个新趋势的号角（见图24-2）。<strong>那表示新的牛市或者熊市正在形成，到底是熊市还是牛市取决于在上面的是哪条趋向线。</strong></p><p><img src="Pasted%20image%2020240128160849.png"></p><p>（5）当ADX回升超过两条趋向线时，表示市场过热了。当ADX从高于两条趋向线的地方掉头向下，表示主要的趋势受到了阻碍，这正是趋势交易兑现利润的好时机</p><p>你或许发现了图中字母区域也发现了类似的做空信号，但一名严谨的交易者不会对每个见到的信号都去交易：在3美元价格附近做空一只从45美元掉下来的股票，意味着去追已经严重老化的趋势。在右边缘附近，你能看到价格回落到价值区间，提供了很好的多头加仓时机</p><p>市场指标既会给你一些硬指标，也会给一些软指标。例如，移动平均值改变方向就是一个硬指标，而ADX的下跌就是一个软指标。一旦你看到ADX下降，此时要加仓就应该非常小心。应该先兑现盈利，减轻仓位，然后再寻找出场的机会</p><h4 id="平均真实波幅来自波动率的帮助">平均真实波幅——来自波动率的帮助</h4><p>克里·洛沃恩喜欢在移动平均线附近画三组线：在高于和低于EMA1倍、2倍和3倍ATR的位置。它们能用于设定入场点、保护性止损位和盈利目标 <img src="Pasted%20image%2020240128162344.png"></p><h4 id="atr通道线">ATR通道线</h4><p>入场点：在“移动平均”那一节中，我们知道在价格低于价值的时候买入——低于EMA的时候，是一个好主意。但是要低于价值多远的距离？如果是普通回调往往会在负一倍的ATR处见底</p><p>保护性止损位：最好让你的保护性止损位在至少离入场点一倍ATR距离的地方。如果小于这个距离，会让你的保护性止损价位落入市场噪音区间之中，很可能被短期的随机波动所触及。所以把你的保护性止损位设置得远一点，使得只有真正的反转才能触及你的保护性止损单</p><p>盈利目标：你买入一只股票之后，可以根据那只股票的强势程度，在1倍、2倍甚至3倍ATR的位置，来设置你兑现利润的止盈价位。克里喜欢分几步兑现利润并退出，比如在1倍ATR处挂三分之一持仓量的卖单，在2倍的地方再挂三分之一，其余的挂在3倍ATR处。</p><p>在任何市场中，长时间价格波动超过3倍ATR——3倍的平均真实波幅——都非常少见。这通常意味着行情非常极端。无论何时你看到市场波幅超出3倍ATR之外，不论是上升还是下跌，你都有理由相信会出现一波回调</p><p>ATR通道的方法不仅在价格方面有用。我们也可以将它和其他指标结合起来，来判断趋势有可能在哪些极端价位出现反转。我在<strong>周线图的强力指数上会结合使用ATR通道</strong></p><h3 id="震荡指标">震荡指标</h3><p>趋势跟随指标能帮助我们辨认趋势——比如MACD线或者趋向系统，而震荡指标则能帮助我们抓住反转点。</p><p>震荡指标能识别市场大众的极端情绪，能够帮助你发现市场中乐观或悲观情绪难以持续的价位。专业交易者总会逆着极端情绪而来，他们会在衍生品上对赌价格将回归理性</p><p>超买意味着市场点位太高，随时可能回调。当震荡指标到达前期的高位水平时，就形成了超买。超卖意味着市场点位太低，随时可能反弹。当震荡指标到达前期的低位水平时，就形成了超卖</p><p>一定要记住，<strong>这些高低位水平并不是绝对的。当一波强力的上升趋势开始后，震荡指标可以持续几个星期的超买状态，这样给出的卖出信号是过早的</strong>。同样，在急剧的下跌趋势中，也可能保持几周的超卖状态，这样给出的买入信号是过早的。<strong>知道什么时候使用趋势跟随指标，什么时候使用震荡指标是成熟分析师的标志</strong>（见第39节）</p><p>我们已经考察过一个重要的震荡指标了——MACD柱状线。我们之所以提前考察MACD柱状线，因为它是从趋势跟随指标——MACD线中衍生出来的，马上我们将会探讨几个非常流行的震荡指标：<strong>随机指标(stochastic，KDJ指标</strong>)和<strong>相对强弱指标(relative strength index,RSI)</strong></p><h4 id="相对强弱指标rsi">相对强弱指标RSI</h4><p>随机指标考察的是每个收盘价和最近的高低价区间之间的关系。它由两条线组成：快速线K和慢速线D。它通过监测任意一种交易产品的收盘价变动来测量其强度。它是一个先行或者同步指标——从不滞后。 <img src="Pasted%20image%2020240128170348.png"></p><p>相对强弱指标仅仅基于收盘价，相比随机指标其噪声较小。当其上升到下参考线之上时，预示要上涨（图中以绿色垂直箭头标示）；当其下跌到上参考线之下时，预示要下跌（图中以红色垂直箭头标示）。</p><p>图中以倾斜实线箭头和虚线红色箭头标出的是相对强弱指标出现熊市背离给出的非常强的卖出信号。股价上升到新高，但相对强弱指标并没有触及其上参考线，显示这次上涨隐藏着的虚弱</p><p>图中右边缘处的尖锐跳空，不顾相对强弱指标发出的买入信号，将价格推向更低位。要避免受到伤害，我们必须使用保护性止损位，因为震荡区间里最后一笔交易，很容易在新趋势开始时造成亏损</p><p>超买和超卖的RSI位置随着市场的不同而不同，甚至在同一个市场中每年的情形也不相同。并没有一个神奇方法能够判断所有的顶部和底部。超买和超卖信号就像用窗口的温度计判断冷热一样，同样的温度在冬天和夏天有着不同的意义</p><p>水平参考线一定要能够穿过RSI的最高点和最低点。这些线通常是在30%和70%的地方。一些交易者在牛市中将其设置在40%和80%的水平上，或者在熊市中将其设置在20%和60%的地方。使用5%法则：每一条线都要保证RSI在过去的4～6个月中，位于参考线之上的时间少于5%。每3个月就调整一次参考线</p><p>RSI指标也存在背离的情况，和MACD相似</p><p>RSI通常比市场价格早几天突破阻力位或者支撑位，表现出了趋势可能要改变的迹象。RSI趋势线通常会比价格趋势线早1～2天被反转。 <strong>（1）当RSI的下降趋势反转时，在最近的价格高位上挂一个买单来抓住这一次向上的突破；</strong> <strong>（2）当RSI的上升趋势反转时，在最近的价格低位上挂一个卖单来抓住这一次向下的突破。</strong></p><p>当RSI上升超过其上参考线时，表明多方很强势，但是市场已经超买了而且已经进入了应该卖出的区域。当RSI下跌到其下参考线以下时，它表明空方力量很强，但是市场已经超卖了而且已经进入了应该买入的区域</p><p><strong>只有当周趋势上涨时，根据日线RSI指标发出的买入信号进行买入才比较有利。同样地，只有当周趋势是下降时，根据日线RSI指标发出的卖出信号进行卖出才比较有利。（见第39节）</strong> （周线趋势（均线） + RSI确定拐点） （1）当RSI击穿其下参考线，又回升到下参考线上方时买入； （2）当RSI上升到上参考线上方，又回落到上参考线下方时卖出。</p><p>一个典型的新手会犯的错误就是“采购各种指标”。交易者可能感觉股票市场会上涨，但是他却发现道琼斯指数和标准普尔指数的移动平均还在下跌。但他并不相信这些下跌的信号，他开始浏览软件里的菜单，然后找到了几个震荡指标，比如随机指标或者RSI。它们确实看起来已经超卖了（这在下跌的趋势中是常见的现象），这个急切的交易者就把它们看作买入的信号。下跌还在继续，他就赔钱了——然后他就开始抱怨技术分析没什么用</p><p><strong>用少数几个指标（包括多个时间周期），并有一个严格的分析体系，效果会好很多。我们会在“三重滤网交易系统”那一节再次回到这一重要的主题。</strong></p><h2 id="成交量和时间">成交量和时间</h2><p>（1）成交量：很多交易者只把注意力放在价格行情上，尽管价格行情十分重要，但市场所包含的远远不只有价格一个维度，成交量给我们提供了另一种极具价值的参考维度 （2）时间：市场在同一时刻按照不同的时间周期同时存在并发展着。<strong>不管你多么仔细地分析某个日线图，它的趋势都很可能被另一个时间周期的运动所颠覆</strong></p><p><strong>为经验法则，在任何一个市场上，“高成交量”意味着高于其过去两周成交量平均值25%以上的成交量，而“低成交量”意味着低于其过去两周成交量平均值25%以上的成交量</strong> （1）高成交量可以确认趋势。如果价格和成交量同时达到新的顶峰水平，价格将很可能保持高位或超过前期顶部后再创新高。 （2）如果市场价格创下新低但成交量却创下新高，则该底部将再次确认或者创新低。一个极高成交量的底部后面常常会跟着一个较小成交量的底部，这时便是绝佳的买入机会。 （3）如果在趋势持续的过程中成交量缩水，那该趋势将发生反转 （4）观察趋势中反弹的成交量情况。当上升趋势出现回落时，由于慌张的获利了结盘，成交量会增加。<strong>当这种回落持续但成交量缩水时，表明多头不再逃跑或者抛压被消耗</strong>。当成交量耗尽时，下跌带来的抛售效应已经接近其尽头，上升趋势将重新开始。</p><h3 id="以成交量为基础的指标">以成交量为基础的指标</h3><p>种种基于成交量的指标相对于成交量柱来说提供了更加精确的时机信号。这些指标包括下面将介绍的能量潮指标(OBV)和集散指标(A/D)。强力指数指标将价格和成交量数据结合起来，帮助我们发现在哪个区域价格可能发生反转</p><h4 id="能量潮指标obv">能量潮指标OBV</h4><p>一个创新高的OBV表明多头势力强大，空头受到重创，价格将会上升；一个创新低的OBV表明空头势力强大，多头受到重创，价格将会下降。当OBV的走势偏离了价格的走势时，这意味着大众的情绪和大众对价格的共识相偏离，人们将更可能跟随直觉而不是理性的思考，这也是为什么成交量经常先于价格变化而变化</p><h4 id="集散指标ad">集散指标(A/D)</h4><p>集散指标比OBV指标得到更好的调整，因为它只用当天交易量的一定比例归入到多头或空头势力中去，按照双方当日获胜的程度作为其比例</p><p>如果收盘价高于开盘价，当日多头获胜，则A/D值为正；如果收盘价低于开盘价，则当日空头获胜，A/D值为负；如果收盘价和开盘价一致，则当日多空双方打成平手，A/D值为0。所有日A/D值的滚动计算创造了累计A/D的指标</p><p>比如说，如果当日最高价与最低价之间差距是5个点，开盘价与收盘价之间的差距是2个点，则当日成交量的2/5归功于获胜方。就如同OBV一样，<strong>A/D高低的形态十分重要，而它的绝对值水平主要受计算基准日影响</strong></p><p>专业投资者全天都十分积极活跃，他们经常和业余投资者对着干，进行反向交易。随着交易不断进行下去，业余投资者和动作较慢的机构投资者买卖行为所引起的市场波澜也逐渐消退。在临近收盘时，专业投资者此时更可能主导市场。</p><p>收盘价显得尤为重要，因为交易账户的结算都以收盘价为准。A/D值追踪了业余投资者和专业投资者当日对战的结果，当收盘价高于开盘价时，即专业投资者比业余投资者更倾向于看多时，A/D值将上升；当收盘价低于开盘价时，即专业投资者比业余投资者更倾向于看空时，A/D值将下降。与专业投资者同方向下注、与业余者反方向下注比较有利。</p><p>最好的交易信号出现在A/D值背离价格走向时。 （1）如果价格上涨创新高但A/D值却没有随之创新高，则出现了卖出信号。这种熊市背离表明市场上专业投资者在上涨过程中卖出。 （2）牛市背离发生价格创新低但A/D值却没有创新低时，表明了市场上专业投资者在下跌过程不断买入并逐步建仓，反弹即将到来（见图29-2）。</p><p><img src="Pasted%20image%2020240128173246.png"></p><p>“大事发生之前总会有其征兆”是一句古老的谚语，这句话对于技术分析派来说意义重大。谷歌公司的股票GOOG持续下跌已经数月了，但是其上升的A/D值表明大资金正在不断地买入。该股票在B处创造了比A处更低的底部价格，但是其A/D值的底部却抬高了。同样重要的是，A/D值在价格暴涨之前还创了新高（在图中由垂直箭头标出），紧接着公司就公布了好得出人意料的业绩报告。一些人之前便知道了接下来将要发生的事，他们大规模的买入被累积A/D值形态和向上的突破所确认。技术分析有助于减少外部投资者和内幕信息知情人之间的信息地位差距</p><p>当你根据A/D值与价格之间的背离为依据，进行做多或做空的时候，<strong>记住就算是市场上专业的投资者也会犯错。你需要设置止损单并用巴斯克维尔的猎犬法则保护自己</strong></p>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FaceChain</title>
    <link href="/2024/01/26/FaceChain/"/>
    <url>/2024/01/26/FaceChain/</url>
    
    <content type="html"><![CDATA[<p>简述：论文主要是提出了一个框架，解决换脸的问题，即用户上传多张自己的个性化照片，让模型来完善其他细节（例如衣服，背景）。它通过集成了多个模型搭建了一套完整的脸部ID保留和处理流程 感想：这篇论文兼顾了学术创新和工业应用，非常值得参考</p><p><img src="Pasted%20image%2020240126132705.png"></p><p>整个流程是用户上传照片，然后： 1. 预处理（用户上传的图像可能不符合要求） （1）检测图像的方向，保证图像的角度正确，<a href="https://modelscope.cn/models/Cherrytest/rot_bgr">模型地址</a> （2）图像的方向正确后，人脸的方向可能不正确，使用<a href="https://modelscope.%20cn/models/damo/cv_ddsar_face-detection_%20iclr23-damofd">DamoFD</a>（一种人脸检测器）获得多个图像人脸的检测结果，然后使用最小二乘法，计算标准人脸模板的坐标和旋转矩阵，旋转图像 （3）使用DamoFD获得人脸框，再使用<a href="https://modelscope.cn/models/%20damo/cv_resnet101_image-multiple-humanparsing">M2FP</a>（Masked-attention Mask Transformer model for human parsing）裁剪人脸并缩放大小，控制在图像的0.35-0.45倍， （4）使用<a href="https://modelscope.cn/models/%20damo/cv_unet_skin-retouching">ABPN</a>（自适应混合金字塔网络）进行皮肤修饰</p><ol type="1"><li><p>给上传的图片打标签（训练lora时需要对应的文本标签，因此标签必须合适） （1）将人像输入<a href="https://github.com/KichangKim/DeepDanbooru">DeepDanbooru</a>（一个文本注释模型），可以得到初步的tag，然后删掉一部分人类身份相关的标签，比如嘴唇，眼睛耳朵等（<strong>这些特征需要通过参考图像引入，不能通过文本，否则身份一致性难保持</strong>） （2）再通过<a href="https://%20modelscope%20.%20cn%20/%20models%20/%20damo%20/%20cv%20_%20resnet34%20_%20face-attribute-recognition_fairface">FairFace</a>（人脸属性模型），预测每张图像的性别和年龄，根据所在区间确定关键词。 <img src="Pasted%20image%2020240126152208.png"></p></li><li><p>训练方法 分别训练一个face lora和一个style lora，前者用个性化肖像训练，后者用大量照片同类型照片训练，例如证件照、艺术照等，确定生成图像的风格</p></li><li><p>推理过程 （1）将face LoRA和style LoRA的权重融合到Stable Diffusion模型中，权重分别是0.25和1.0，生成多张个性化的图片 （2）这些图片可能还是不够精确，因此通过人脸质量评估模型<a href="https://www.modelscope.cn/models/damo/cv_manual_face-quality-assessment_fqa">FQA</a>（Face Quality Assessment）从训练数据重筛选出一个质量最好的人脸图像 （3）使用<a href="https://www.modelscope.cn/models/damo/cv_unetimage-face-fusion_damo">人脸融合模型</a>进一步改善面部细节。使得输出肖像能够保留主要的外观特征，同时显示更精致的面部细节生成（即生成的图像和训练图像融合到一起） （4）采用<a href="https://www.modelscope.cn/models/damo/cv_ir_face-recognition-ood_rts">随机温度缩放</a>（RTS）（一种针对分布内和分布外样本的鲁棒人脸识别模型）来计算面部相似度。选择面部相似度高的肖像作为输出</p></li></ol><h2 id="inpainting">inpainting</h2><p>利用专门针对独特面部 ID 进行训练的 LoRA 模型，再加上集成的风格背景，可以生成具有高 ID 保真度的相关肖像照片。但是，在现实场景和应用中，经常出现用户已经确定了他们满意的图像的情况——这些图像具有精心设计的构图、灯光和背景布置。在这种情况下，用户的要求是自然地用特定的ID替换所选图像中的人脸。为了解决这个问题，论文设计了一个基于SD的修复框架。这允许基于指定的模板图像自然地重绘指定的面部ID。</p><p>涉及到这种人脸替换问题，最容易想到的方法就是使用controlnet执行扩散完成修复，然而这样做会引发问题： （1）原始模板人脸和指定ID的人脸不兼容，使用canny得到的边缘进行扩散会导致人脸结构改变 （2）重绘的区域和原始图像的衔接出可能出现断层（不一致） （3）在扩散过程结合 ControlNet、LoRA 模型和模板的图像隐空间等多个控制会产生不利影响，尤其是在身份ID的保留方面，因此需要对ID进行更多的控制</p><p>为了解决问题，提出了一个二级修复流程： <img src="Pasted%20image%2020240126161225.png"></p><p>流程1： （1）面部变形算法来生成 68 个面部标志，作为OpenPose controlnet的输入 （2）生成一张保留了ID的图像 （3）计算仿射变换矩阵 M，将生成的面部标志与原始参考的面部标志完美对齐 矩阵M表示生成人脸和参考人脸之间的变形过程，解决了参考图像和ID面部特征点不匹配的问题</p><p>流程2： （1）使用M2FP human parsing model，生成面部mask并适当扩展 （2）OpenPose controlnet（使用上面变形后得到的面部特征点）（保留面部结构） + Canny controlnet（保留面部之外区域的结构） + 较大的inpainting strength（0.65）（保证重绘得到的图片仍然是指定ID） = 实现人脸的和谐替换</p><h2 id="facechain在虚拟试衣上的应用">FaceChain在虚拟试衣上的应用</h2><p>给定待试穿服装的真实或虚拟模特图像，以及经过训练的人脸LoRA模型，FaceChain可以重新绘制服装外部的区域，包括人物和背景，以获得虚拟试穿结果。</p><p>重绘过程也是基于SD的修复过程，和inpainting很相似。然而，由于这两个任务的要求不同，可以使用不同的空间条件控制。由于需要重新绘制衣服外部的所有区域而不仅仅是面部区域，因此面部标志与保留部分之间的交互要低得多。此外，服装外部区域的图像内容可能对图像生成有害，尤其是当我们尝试将输入模板的虚拟模型更改为真实模型时。因此，我们在OpenPose-ControlNet中不使用扭曲的人脸标志，并将修复强度调整为1.0以避免输入模板的图像潜在的影响。然后，在虚拟试穿中生成具有和谐身体姿势的肖像极其重要，尤其是手部的详细姿势，因为大多数现有的SD模型无法生成令人满意的手部姿势。</p><p>为了解决问题 （1）OpenPoseControlNet 使用全身姿势蒸馏（DWPose）估计器提取的骨骼和手部姿势，以获得更准确的手势 （2）Depth-ControlNet 在手部区域使用深度估计（论文Towards robust monocular depth estimation: Mixing datasets for zero-shot cross-dataset transfer） 以获取手部的 3D 细节 （3） Canny-ControlNet 使用身体区域的 Canny 边缘来实现更和谐的身体姿势。 （4）背景用提示词来控制 生成的虚拟试穿图像可以放入inpainting pipeline中，以进一步提高身份保留效果</p><h2 id="让证件照说话">让证件照说话</h2><p>用户选择一张人脸图像，然后用户提供一个音频片段，FaceChain使用它们输出说话的视频</p><p>论文选择sadtalker作为基模型，因为wav2lip和video-retalking只能改变面部的嘴唇，而SadTalker提出的PoseVAE和ExpNet可以改变头部姿势和面部分别表达，其中头部姿势可以进行控制，例如眨眼频率。</p><p>由于SadTalker的输入和输出分辨率为256或512，如果原始输入图像中的人脸分辨率比较大，或者用户只是想让整体分辨率更高，论文也支持使用GFPGAN作为后处理模块，可以将视频分辨率提高一倍。至于音频剪辑，支持三种选项来提供：(i) TTS 合成、(ii) 麦克风录音和 (iii) 本地文件上传。至于TTS合成，我们使用Microsoft Edge的API，因为它支持多语言混合输入，并且支持多语言合成，这使得FaceChain对全球用户更加友好 <img src="Pasted%20image%2020240126164700.png"></p><h2 id="未来值得探索的方向">未来值得探索的方向</h2><p>（1）能够处理不同年龄和性别的多个主题的个性化生成框架</p><p>（2）改进数据处理机制以完美地保留身材，这将需要更多样化的训练数据</p><p>（3）<strong>支持模型融合过程中风格和面部 LoRA 模型的自适应权重选择</strong></p><p>（4）将不同的风格信息编码为统一的模型，可以通过特定的触发提示激活</p><p>（5）为 FaceChain 开发定制的相似度排名和<strong>面部融合模型</strong></p><p>（6）<strong>探索用于定制肖像生成的免训练框架</strong>。目前 FaceChain 中使用的方法需要为每个人类 ID 训练一个新模型，这对于广泛采用来说计算成本可能很高</p>]]></content>
    
    
    <categories>
      
      <category>图像生成</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>研报阅读攻略</title>
    <link href="/2024/01/14/%E7%A0%94%E6%8A%A5%E9%98%85%E8%AF%BB%E6%94%BB%E7%95%A5/"/>
    <url>/2024/01/14/%E7%A0%94%E6%8A%A5%E9%98%85%E8%AF%BB%E6%94%BB%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>研报是投资者都会看的内容，但是大部分人也只是随便看看，不仅没有目的，也不成体系，其实没有太大用处。而且很多研报质量也不怎么样，但是通过正确的搜索和阅读方法，也会以了解到很多东西。</p><h2 id="研报的价值在哪">研报的价值在哪？</h2><p>研报是分析师对宏观、行业、公司做出的投资分析和结论。市场上最常见的是卖方研报，它主要是卖方（大部分是券商分析师）给买方（机构投资者，如基金经理）提供的投资分析服务，因此研报从一开始就不是为我们普通投资者准备的。</p><p>我们现在能在互联网上搜到的研报大部分都是他们的客户那里流出来的，<strong>我们并不是第一时间看到的研报的人，所以想要跟着研报去追热点就完全没必要了</strong>，我们已经在时间上被机构投资者甩下几个小时甚至是几天了</p><p>由于A股不能做空，因此几乎所有的研报都是看涨，因为看跌也没用。因此常见的研究报告评级都是“买入”或“增持”，“中性”都很少了，“减持”和“卖出”基本上很难看到。所以看跌和看涨某公司并不是研报的主要价值。研报的最大价值其实是：<strong>帮助投资者了解政策、行业和基本面</strong>。</p><h2 id="如何选择研报">如何选择研报？</h2><p>很多研报可能是证券公司的任务，甚至可能是实习生写的，而且数量众多，同质化严重。要想选出好的研报，最简单的方式就是看作者：<strong>新财富分析师榜单</strong>。虽然该榜单也有拉票等乱象，但我们可以重点关注排名靠前的分析师，它们的分析会靠谱一些。</p><p>就算结论可能有误，学习分析的逻辑思维也是相当重要的，看研报一定要记住：<strong>重逻辑，轻结论</strong></p><p>研报具体可以分为四类：宏观研报、策略研报、行业研报、个股研报</p><h2 id="如何阅读宏观研报">如何阅读宏观研报</h2><p>宏观分析的常见报告就是对各种经济数据点评预测，例如GPD、CPI、PPI、消费、投资数据等，通过发电量来推断生产活动，通过猪肉价格推断通胀水平，另外还有对一些新的政策和事件点评，这些报告的发表频率很高。</p><p>常见的标题： 《11月美国CPI点评：通胀创新高，但基本符合预期》 《中央经济工作会议点评:重回2018年底，买股票，恒指28000!》 《2021年11月金融数据点评:企业信贷继续下滑宽信用效果仍未体现》</p><p>这些研报的特点是<strong>同质化严重</strong>，如果关注某个数据或事件的点评（点评报告），看<strong>宏观研究领域的新财富分析师的研报</strong>就可以。宏观分析或多或少都会带一些预测，例如预测一下未来的流动性是宽松还是紧缩，未来的经济增速有多高等等，要学会综合多个知名分析师的观点而不是只听一家之言，看看他们的预测逻辑谁能说服自己。</p><p><strong>除了点评报告之外，宏观研报还有一种是深度报告</strong>，特点就是页数会多一点，通常15页以上。例如对人口的专题研究、大类资产配置建议、经济展望等。例如广发证券的《新经济：宏观视角分析纲要》这篇报告其中一部分就教我们跟踪新兴产业的景气度可以看哪些指标。</p><p><strong>这种深度报告非常值得阅读</strong>，不仅是报告，更是学习资料。可以慢慢模仿分析师的风格，建立自己的分析框架</p><h2 id="如何阅读策略研报">如何阅读策略研报</h2><p>策略研报说白了就是研究市场会涨还是跌（但基本上都是涨~），研究哪个板块、行业会有机会。</p><p>策略研报和其他类型的研报一个最大的不同就是它并不是千篇一律的看涨，而是会给出分析师自己对行业板块的选择，会有一些不同的结论，所以就很看分析师的能力了，首先当然还是看新财富分析师了，都是经过客户检验的</p><p>但是这些策略研报不见得靠谱，还是那句话，<strong>重逻辑轻结论</strong>。比如站在2024年01月14日，看2021年底对2022年的A股策略研报，都说看多价值股，看多医药消费。但是很明显，2022和2023是长达俩常年的熊市，价值不断创新低，五粮液跌到130以下。</p><p>所以策略的预测看看也就行了，研报一次推荐7，8个板块，总有几个表现好的。但是我们如果按他推荐的板块全部配置，还不如直接买宽基指数得了。所以策略研报看上去很有用，但是又感觉不是特别有用。</p><p>策略研报一般也分为月度，季度，年度。这个根据投资风格自己选择即可，多看分析师推荐的理由而不是推荐的结果。</p><h2 id="如何阅读行业研报">如何阅读行业研报</h2><p>行业研报应该是最有阅读价值的研报了，主要就是对各种细分行业进行研究，例如新能源行业、光伏行业、白酒行业等。有助于投资者了解一个行业的现状，例如渗透率，市场规模，竞争格局等。</p><p>我们知道，一般的<a href>投资框架</a>要求在购买股票时，判断是否是“好生意”，“好行业”。这就要求我们了解渗透率，市场规模等数据，而这些数据是普通投资者难以去统计收集的。</p><p>行业研报可以分为定期报告、行业点评、深度研究等。</p><h4 id="定期报告">定期报告</h4><p>定期报告可以按照时间分类，例如周报一般是更新这周该行业的数据、事件和公告，这些研报的数据往往滞后，价值不大。一般时间间隔越长的定期报告价值越大</p><h4 id="行业点评">行业点评</h4><p>行业点评报告是在重要数据发布或重要事件发生时，分析师给出自己的点评，它和定期报告不同的是它的时效性更强。</p><p>一般阅读行业点评和定期报告的目的是追踪数据，例如新能源汽车产量、销量，行业渗透率等。关注1-2个分析师的点评即可</p><h4 id="行业深度研究">行业深度研究</h4><p><strong>行业深度研究是价值最大的研报</strong>，分析师花那么多精力写几十页的报告，肯定看好这个行业。但是只看结论是不行的，投资者阅读深度报告最大的价值在于了解一个行业的形式，学习其中的逻辑思维能力。</p><p>因为深度报告的数量不多，因此新财富分析师以外分析师的报告也可以读一读。</p><p>一般这类的报告会在包括： 1. 介绍背景知识，行业概况，也包括了一些专业知识； 2. 然后从供给和需求两个角度去分析<strong>行业集中度</strong>、<strong>市场份额</strong>、行业各厂商之间的对比、国内外厂商的竞争优势对比； 3. 可能还会包括对市场空间的测算（这部分也是猜，知道即可，不必太当真）； 4. 最后还可能包含对行业重点公司的介绍，方便去读对应的个股研报</p><p><strong>通常了解一个行业都是从该类行业的深度报告开始</strong>，如果有新财富分析师近期写的深度报告最好</p><p>但是行业研究并不是阅读一篇深度报告就够了，这只是一个起始点，让我对这个行业有个初步印象，如果想要更全面的了解这个行业，还需要阅读更多的该行业深度报告作为补充，同时还要去查阅一些重点公司的财报以及通过其他的渠道去搜索想要知道的答案 （通过知乎、B站等渠道）</p><h2 id="如何读个股研报">如何读个股研报</h2><p>个股研报就是针对单只股票的研究报告，分为事件研报和个股深度研报</p><p>事件研报是个股研报的一种，一般在发生一些事件之后发出，这些报告的内容一般很少，只是针对事件做点评，很多都是实习生做的。适合了解该行业的人来看。</p><p>有些出名的公司也会有个股深度研报，一般包含以下内容： 1. 公司介绍，这部分一般是从招股说明书或者年报里抄的，包含发展历程、股权架构等 2. 分析公司的行业（多好多好），这里聊的比较浅，建议结合行业深度研报使用 3. 经营分析，一般就是在说公司的产品多有竞争力，业务多有发展潜力。这部分内容更多是梳理公司业务，其他的不必太在意 4. 财报分析，从总收入，净利润，EPS，毛利率等指标分析，让读者对公司业绩有个印象 5. 业绩预测模型，这部分看看就好，不必当真 6. 风险提示，这部分是提醒投资者后续跟踪这个公司需要关注的内容</p><p>个股深度研报通常都是普及型的作用，为我们搭建了一个公司的全景图，对于入门是有非常大的帮助的。但是如果想要搞清楚这个公司，还要看更多的报告，同时结合相关的行业分析，以及外部资料（例如财报、其他人的评论）来分析，必要时还要看宏观分析</p><h2 id="研报从哪里获得">研报从哪里获得？</h2><p>网上大多数找到的都是广告软文，所以不推荐直接搜索</p><p>雪球，东方财富一般会有一些个股的免费研报，但是比较少</p><p>发现研报：如果不开会员每天只能看几篇，开了之后可以看几百票</p><p>萝卜投研：800一年</p><p>慧博投研：几千一年</p><p>嗨皮土豆：免费</p><p>剩下的慢慢积累把</p><h2 id="总结">总结</h2><ol type="1"><li>看研报主要看行文逻辑和数据，别太在意预测结果</li><li>多看深度研报</li></ol><p><a href="https://haipitudou.com/">嗨皮土豆</a> <a href="https://wk.askci.com/ListTable">前沿知识库 (askci.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>积极型资产配置</title>
    <link href="/2024/01/11/%E7%A7%AF%E6%9E%81%E5%9E%8B%E8%B5%84%E4%BA%A7%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/01/11/%E7%A7%AF%E6%9E%81%E5%9E%8B%E8%B5%84%E4%BA%A7%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>本书的主要目的是为经济和市场建立一个分析框架，学习： （1）经济周期是如何更替的 （2）不同的经济周期应该如何配置资产</p><p>这是一本美国的书，因为国情的不同，在具体的<strong>宏观经济指标</strong>选择上会有所不同，本书采用美林时钟，可能以利率为轴会更有参考性，这部分的内容会通过<a href>宏观经济、利率趋势与资产配置</a>补充讲解</p><p>但总的来说，本书涉及到的理论知识和分析方法都是很有参考价值的</p><h2 id="货币管理的基本原则">1. 货币管理的基本原则</h2><h4 id="分散投资">（1）分散投资</h4><ul><li><p>使用分散投资可以减小<strong>投资个体公司的非系统性风险</strong>（不受市场波动影响的个体公司承担的风险） 大概6-8支股票即可。 <img src="Pasted%20image%2020231210154234.png"></p></li><li><p>使用分散投资可以减小来自市场波动的系统性风险（普遍的市场下降风险） 分散投资许多公司，不能避免自己受到市场普遍下降的影响，但通过分散投资不同的资产类别可以控制系统性风险。因此，一个好的分散投资应该是平衡的，包含了很多没有密切相关性的资产。 <strong>举个例子：如果股票的整体行情不好，那么分散买多只股票意义不大，但是买和股票相关性较低的其他资产例如贵金属和现金，那么风险会得到缓冲。</strong></p></li></ul><p>下表给出了不同资产之间的相关性： <img src="Pasted%20image%2020231210154904.png"></p><h4 id="时间与复利">（2）时间与复利</h4><p>这一点不用多说</p><h2 id="宏观经济指标">2. 宏观经济指标</h2><p>经济增长和经济紧缩之间的交替被成为经济周期，从一个波谷到另一个波谷的时间平均为42个月（基钦周期）。经济周期实质上是对人类心理的反应（谨慎，乐观，贪婪，恐惧），只要人性不变，则经济周期不变。</p><p>本章节的内容是理解经济周期，一般人对它的理解可能是：经济按照周期或多或少的重复出现。但其实这样是不对的，<strong>每个经济周期都有自己的特点</strong>，不论是持续时间还是强度，都会有不同。42个月只是一个平均值。 <strong>即：没有一个经济周期模式会以完全相同的方式重复出现</strong></p><p>造成这种现象的原因有三点： - （1）基钦周期受到另外两个大周期的支配---朱格拉周期（10年期周期）和康德拉季耶夫周期（50年期周期），技术驱动长周期的上升。 - （2）经济体包含了不同的部分，不同的部分上涨和下降的比例不同，周期也就不同 - （3）经济体系在不停的发生改变，例如美国先后经历农业主导、制造业主导、服务业主导</p><p>问题：既然经济体包含不同的部分，那我们应该分析一个周期？ 答案：经济体内部可以分为先行部分，中间部分，滞后部分，整体保持着经济周期的规律。</p><h4 id="经济事件的次序">经济事件的次序</h4><p>一个完整的经济流程：央行降息释放流动性，货币的使用价格变低，股市走出底部，利率敏感的先行指标上升（例如房地产），再之后是同步指标（比如制造业，非农就业人口上升），随着更多人就业，商品价格走出低谷，最后是经济滞后指标（厂房和设备）。</p><p><img src="Pasted%20image%2020231210162712.png"></p><p>个体对于经济环境中急剧且没有预料的变化所进行调整的意愿是理解经济周期变动的关键。因此关注经济活动的<strong>变动率</strong>比关注经济活动的现状更重要，下面是一个例子： <img src="%5BPasted%20image%2020231210163559.png"></p><p>利率的下降对经济的影响都有延时，毕竟过渡扩张的公司还需要时间偿还贷款、改进资产负债表等。就像利率上涨很快时，虽然心里感觉痛苦，但却不能触摸到利率的存在，但工业品和房地产都是可以触碰到的实物。房地产的低谷与经济复苏的开端之间平均间隔是6个月左右。</p><p>房地产对长期利率更敏感： <img src="Pasted%20image%2020231210170137.png"> 可以看出来，利率波动越剧烈，则收益率与住房开工率的相关性越强。尽管我们不能将证券市场的强烈反弹当作住房市场强势的信号，但可以说：<strong>除非债券市场反弹在前，即债券交易量增加，否则住房市场不太可能启动。</strong></p><p>房地产行业的低估会波及到其他高端、利率敏感的行业，比如汽车。虽然房地产本身的GDP占比不大，但非常重要。（1）它意味着消费者开始克服不愿意消费的心理状态；（2）住房数量增加会对经济有乘数效应，比如增加洗衣机之类的需求</p><h4 id="经济指标来展示经济事件的顺序">经济指标来展示经济事件的顺序</h4><p>这部分的指标都是美国的，国内需要替换为对应的其他指标 （1）先行指标 - BCI-01 制造业平均工时 雇主总是会在增加和减小劳动力数量前调整工人的工作时间 - BCI-05 每周平均失业保险金初始申请人数（国内不排除失真的情况） - BCI-08 制造商是所得到的消费品及原料新订单 - BCI-32 延迟交付扩散指数 - BCI-19 标准普尔500指数，股票是未来经济活动的风向标 - BCI-106 货币供应量，即M2 - BCI-129 10年期国债收益率与美联储基金的利率差 长期利率和短期利率的差别或价差通常被称为收益率曲线。这个指标是通过算出10年期国债利率与联邦基金利率之间的价差得到的，联邦基金利率是银行间市场的<strong>隔夜拆借利率</strong>。它被认为是货币政策和金融市场状况的指示器，因为当短期利率相对较低时，这个利率差就会增加。当这个利率差变成负数的时候（即短期利率高于长期利率，收益率曲线出现反转的时候)，这个指标被当作经济即将发生衰退的强烈指示信号。 - BCI-83 消费者预期指数，反应消费者对未来经济状况的态度变化。</p><p>（2）同步指标 - BCI-41 非农业就业人数，这个指标是最贴近经济健康状况的指标。 - BCI-51 扣除转移支付的个人收入，用来衡量所有人的真实工资，收入水平决定消费水平 - BCI-47 工业生产指数 - BCI-57 制造业和贸易销售额</p><p>（3）滞后指标 - BCI-91 平均持续性失业，当经济衰退开始后，这个指标会出现急剧上升 - BCI-77 制造业和贸易存货对销售额比率。当经济放缓时，存货会增加 - BCI-101 工商业贷款余额 - BCI-95 消费者劳务价格指数变化</p><p>下图展示了三个指标的变化，动量指标是根据KST公式计算（第三章讲解） <img src="Pasted%20image%2020231210173835.png"></p><p>紧缩货币供给指标可以看作流动性的替代指标，它=M2 / 工业原材料现货价格指数，比CPI更好，因为CPI受市场驱动，变化更快。使用多个指标的好处是，当一个指标发生偏移，其他指标可以交叉检验。 <img src="Pasted%20image%2020231210174053.png"></p><p>之前说到每个周期的构成是不同的，从指标之间的对比可以看出来。</p><p><img src="Pasted%20image%2020231210174557.png"></p><p>有的时候指标变化温和，有时变化很大。在多数时间下，这些指标是相互重叠的，这种方法不完美，但可以确定经济周期是经过了一系列按时间顺序发展的时间的。</p><p><strong>补充几个国内指标： 1、领先指标：PMI，利率，M2，新开工项目，房地产开发土地面积，商品房新开工面积，物流指数，恒生内地流通股指数，消费者预期指数，股票指数 </strong> <strong>2、同步指数：财政税收，居民可支配收入，工业增加值，工业从业人数，工业企业利润，固定资产投资，社零，进出口</strong></p><p><strong>3、滞后指标：财政收入，工商业贷款，居民储蓄，CPI，库存</strong></p><p>在实际应用时，可以对不同类型指标按特定权重加权处理，从而得到趋势线 <img src="Pasted%20image%2020231210192618.png"></p><p><strong>就像一列火车一样，经济事件发生的顺序：</strong></p><p>火车头：央行在经济衰退阶段向经济系统注入的流动性。货币量增加，商业银行可以给企业贷更多的钱。</p><p>第一列车厢：利率下跌，货币市场价格下跌，信贷宽松，消费者贷款和消费意愿增强。</p><p>第二列车厢：股市上涨，货币供应量增加和利率下降是经济稳定的基础，稳定后股市上涨。</p><p>第三列车厢：对利率敏感的经济先行部门，比如房地产和公共事业类的，因为它们的负债多。</p><p>第四列车厢：经济同步部门，比如制造业，同时非农就业人数增加，贸易额增加。</p><p>第五列车厢：滞后指标，比如商品价格的上涨，人工成本上涨，利率上涨</p><h2 id="资产配置">3. 资产配置</h2><p>每个市场都有两个转折点，一个顶部，一个底部，这意味着，一个典型的周期有6个转折点，我们称之为6个阶段。就像日历一样，每个阶段都有自己的特征。一个完整的周期时间长度就是基钦周期的长度，<strong>差不多41个月</strong>，阶段6一般时间比较段，差不多2~3个月，<strong>其他每个阶段约8个月</strong>，当然了这只是大致的时间，有的会长一些有的会稍短一些。从6个阶段我们可以看出，为上面我们投资的时间至少要6个月了，是因为至少要走完一个阶段。</p><p><strong>阶段一（只有债券是牛市）</strong> 这个阶段股票市场和商品还处于熊市，现金与股票和商品是负相关的，<strong>应该持有现金，同时开始配置债券</strong>，这个时间段由于货币供给的增加以及贷款需求降低导致短期利率开始走低，债券价格开始上涨，因为新债利率低，没人要，大家都抢老债，导致债券价格上涨。<strong>阶段一是配置债券的最佳时机</strong>。配置股票风险比较高，但是<strong>公共事业类和金融类</strong>以及日常消费品行业和公共运输类股票的<strong>股票偶尔在阶段一也会盈利</strong>。因为利率下降，对重资产和高负债的公共事业类和金融类企业就是业绩改善，股票会有好的表现。<strong>商品这个阶段还会下降，不要配置</strong>。</p><p><strong>阶段二（债券和股票是牛市，商品熊市）</strong> 阶段二不要配置现金，股票经历了阶段一的筑底开始最广泛，最快速增长。<strong>这个阶段配置股票收益高，风险低</strong>。股票市场发力意味着经济的复苏。这个阶段配置一些周期消费比如汽车，耐用消费品比如家电。这个阶段商品价格仍然在下跌，不建议配置。</p><p><strong>阶段三（债券股票商品三牛）</strong> 阶段三是黄金阶段，债券股票和商品都是牛市，但是这个阶段债券价格虽然还在上涨，但是涨幅已经没有股票和商品大，<strong>最好减少债券的比例，多配置股票和商品</strong>。另外<strong>持有的债券也要从长债换成短债</strong>。股票方面，大部分股票都在长，可以配置低贝塔指的股票组合，或者<strong>干脆配置指数</strong>。商品市场已经筑底，所以一些对通货膨胀敏感的股票也可以<strong>关注，比如采矿，石油等</strong>，如果你不习惯于做商品，那么可以<strong>通过连接性基金代替</strong>。</p><p><strong>阶段四（债券熊市，股票和商品牛市）</strong> 债券市场开始走熊，而股票和商品依然保持牛市。利率到达顶峰，通常是个尖头形状，而在底部，通常是一个杯托的形状，所以底部会更缓和一些，在第四个阶段，<strong>很显然利率即将触及顶部了，债券要尽早离手</strong>。<strong>股票</strong>要从早期的周期领先行业<strong>切换到业绩驱动型行业</strong>。这些行业包括资<strong>源型行业和基础行业，技术，卫生保健，耐用消费品和工业股表现强劲</strong>。商品此时也已经是牛市，所以买入一些大宗商品，也会有表现机会。</p><p><strong>阶段五（只有商品牛市）</strong> 利率达到顶峰开始回落，此时要更多的配置现金，而降低权益类资产的配置了。这个阶段持有债券，会受到比较大的损失，利率已倒顶点，债券向上空间不大，但向下的空间不小，另外，违约也开始增多，所以<strong>不建议在这个期间持有债券</strong>，可以完全用货币市场基金代替你的债券。 <strong>阶段Ⅴ股票表现最好的就是原材料</strong>。但这个阶段大部分股票都在下跌，上涨的股票越来越少。此时通胀会上升的比较厉害，<strong>商品的走势也会迭创新高</strong>。<strong>经济过热已经显现</strong>。</p><p><strong>阶段六（没有一个牛市，现金为王）</strong> 没有一个市场是牛市，此时就四个字<strong>现金为王</strong>，最好全都换成货币基金，躲避几个市场下跌的风险。这个时候通常都是加息的末尾，利率从高位开始下降，但市场已经形成了股债商品三杀，如果是保守的投资者，你可以一直持有现金，等待阶段一出现。 阶段六时间比较短，<strong>一般只有2~3个月或者稍长一点时间</strong>。尽管如此，<strong>大量的金融灾难都在这个极短的时间内发生</strong>，因此这个阶段一定要特别谨慎。</p><p>阶段六有个判断指标，就是<strong>铜价和PPI双下行的时候，基本就是阶段六</strong></p><p>总结如下： <img src="Pasted%20image%2020240113192332.png"></p><p>有人会问，<strong>我到底该如何去发现这6个阶段呢</strong>，其实有的是机会，只要记住这六个阶段的演化顺序，当利率即将触底，债券价格开始上升的时候，就是第一个阶段，而当债券已经上涨了，你就应该去考虑股市的问题了，用我们的周期理论，你就应该尽快想到，<strong>股市可能会在2年内有行情</strong>。而一旦股市牛市开始的时候，你就要抛售债券，转向商品强周期，而一旦股市到顶，你要远离债券，股市，并逐渐减仓商品，然后直到现金为王。所以，识别第一个阶段很重要，第一个阶段你识别出来，然后后面也就顺理成章，用逻辑推演就可以了。</p><p>不过也要说明一点，逻辑关系只是理论上的，有的时候可能会略有偏差，比如有的时候，股票会跟债券同时启动，也有的时候商品价格会比股票先涨。所以投资市场是科学也是艺术，而艺术就是他的随机性，大概率是按照这个逻辑推演的，但小概率也会发生奇葩的情况。</p><p><strong>长期持有股票，是最好的投资，也是唯一能够跑赢通货膨胀的方式</strong>，而持<strong>有股票最大的成本就是要承担他短期的波动性</strong>，从1926年到1991年，如果持有股票1年为周期计算，那么有60%的时间，股票的投资收益都超过了国债。然而如果持有股票时间增加到5年，那么股票好于债券的时间将超过7成，随着持有股票的时间增加，那么你的股票跑赢债券的概率也就越大。<strong>持有期20年的话，那么投资股票100%的跑赢债券</strong>。</p><p><a href="https://zhuanlan.zhihu.com/p/346676749">《积极型资产配置指南》 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构</title>
    <link href="/2023/12/19/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/12/19/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="slice和数组">1. Slice和数组</h2><p>新建数组必须指定长度，而且长度不可修改。所以在go中一般使用的是更具有灵活性的切片</p><h4 id="nil切片和空切片">nil切片和空切片？</h4><p>slice的底层数据结构是一个结构体，包含len，capacity和一个指向数组的pointer。nil在go中引用类型数据结构的零值（<strong>pointer、channel、func、interface、map或slice</strong>）。因此nil切片和空切片的本质区别在于，切片的pointer是否为nil。 <code>var s [] slice</code>是nil切片，<code>s := []int</code> 和 <code>s := make([]int,0)</code>是空切片 总结： - nil切片的长度和容量都是0，空切片的长度为0，容量由指向的底层数组决定<br>- 空切片 != nil切片<br>- nil切片的ptr指针是nil，而空切片的ptr指针指向底层数组的地址<br>- nil切片也切片，具有和普通切片相同的行为，所以nil切片具有切片同样的行为操作 - <strong>在判断切片是否为空时不能使用nil作为判断标准，应该使用len = 0作为标准</strong></p><h4 id="slice扩容">slice扩容</h4><p>切片使用<strong>runtime/slice.go</strong> 包下的<code>growslice()</code>方法进行扩容 如果当前切片的容量小于 1024,那么新切片的容量翻倍；<br>如果当前切片的容量大于 1024,那么新切片的容量每次增加25% 实际操作时还会根据结构体的情况进行内存对齐 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">newcap := old.<span class="hljs-built_in">cap</span> <br>doublecap := newcap + newcap<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;<br>   newcap = <span class="hljs-built_in">cap</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-keyword">if</span> old.<span class="hljs-built_in">cap</span> &lt; <span class="hljs-number">1024</span> &#123;<br>      newcap = doublecap <span class="hljs-comment">// * 2 </span><br>   &#125; <span class="hljs-keyword">else</span> &#123;<br><br>      <span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123; <span class="hljs-comment">// 25%</span><br>         newcap += newcap / <span class="hljs-number">4</span> <br>      &#125;<br>      <span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;<br>         newcap = <span class="hljs-built_in">cap</span><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>当slice容量不足时，会根据切片元素的大小和新容量计算内存，将超出切片长度的内存清空，并拷贝旧切片的内存数据到新申请的内存中（<strong>这意味着底层的数组指针发生了改变</strong>），最后返回</p><h4 id="切片作为参数传递">切片作为参数传递</h4><p>理解了切片的数据结构就不难理解这个问题，当切片作为参数传递时，其实只是传了一个实参的拷贝，实参和形参的地址不同，但切片的pointer是相同的。</p><p>即slice有两个，地址不同，但是数据结构中的pointer是一样的，其他一个slice修改变量会导致另一个slice同步修改 如果触发了扩容机制，会返回一个新pointer，此时进行修改则不再同步 如果想要扩容后仍然同步，则需要在传参时传递切片的pointer <strong>注意：理解这一点非常重要，不然可能在函数运行时引发不知名bug</strong></p><h4 id="内存逃逸问题">内存逃逸问题</h4><p>Go的内存分配有栈（stack）和堆（heap）两种</p><p>内存逃逸的本质是<strong>内存被分配到了堆上</strong> 。堆内存的分配不如栈内存快，且需要gc进行内存回收。 由于Slice底层还是一个指针，当指针类型作为返回时，会发生内存逃逸</p><p>Golang的逃逸分析的基本原则是：如果函数返回了变量的引用，那么这个变量就会逃逸。 编译器可以通过分析代码，决定变量分配的地方： - 如果变量在函数外没有被引用，那么优先分配在栈（stack）上 栈的分配速度快，只需要CPU的两个指令“PUSH”和“RELEASE“进行分配和释放。 - 如果变量在函数外被引用，那么优先分配在堆（heap）上，没有在函数外被引用也可能分配在堆上，比如当变量过大时（Go栈的最大值为64位下1G，32位下250M） 堆的分配速度较慢，首先需要找到一块大小合适的内存块，还需要gc垃圾回收才能释放。</p><p>常见的内存逃逸情况： （1）函数内将局部变量指针返回，被外部引用，其生命周期大于栈，溢出 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUser</span><span class="hljs-params">()</span></span> *User&#123;<br>user := User&#123;&#125;<br><span class="hljs-keyword">return</span> &amp;user<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>_ = NewUser()<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>（2）对象太大，超过栈帧大小 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>    _ = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>) <br>    _ = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10000</span>) <br>&#125;<br></code></pre></td></tr></table></figure></p><p>（3）闭包引用逃逸 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    a, b := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>        a, b = b, a+b<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 在<code>Fibonacci()</code>函数中，a,b是一个本地的变量，因为被闭包引用，所以被分配在了堆上。</p><p>（4）动态类型逃逸 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; <br>    a := <span class="hljs-number">1</span> <br>    fmt.Println(<span class="hljs-string">&quot;a逃逸，a:&quot;</span>, a) <br>&#125;<br></code></pre></td></tr></table></figure> 因为<code>fmt.Println</code>函数参数类型是interface{}，在 interface 类型上调用方法都是动态调度的，即方法的真正实现只能在运行时知道</p><p>（5）slice，map和channel的指针引用 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := <span class="hljs-built_in">make</span>([]*<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>    b := <span class="hljs-number">12</span><br>    a[<span class="hljs-number">0</span>] = &amp;b<br>    c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*<span class="hljs-type">int</span>)<br>    d := <span class="hljs-number">14</span><br>    c[<span class="hljs-string">&quot;aaa&quot;</span>] = &amp;d<br>    e := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>    f := <span class="hljs-number">15</span><br>    e &lt;- &amp;f<br>&#125;<br></code></pre></td></tr></table></figure> 变量<code>b</code>,<code>d</code>,<code>f</code>的内存都被移动到堆上，因为在Golang中，slice，map，channel引用指针的变量，一定会逃逸。 这是在Golang中，slice，map，channel对指针的引用性能低的根本原因</p><p>总的来说： 栈内存的分配和回收是非常快速的，只需要2条CPU指令,<code>PUSH</code> 和 <code>RELEASE</code>。而堆内存，分配需要找到合适大小的内存块，回收则是通过GC。因此，通过内存的逃逸分析，可以尝试将不必要分配在堆上的变量分配在栈上，减少分配堆内存的开销和GC的压力。</p><p>启示： 1. <strong>对于性能要求比较高且访问频次比较高的函数调用，应该尽量避免使用接口类型</strong> 2. <strong>不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销更大</strong> 3. <strong>预先设定好slice长度，避免频繁超出容量，重新分配</strong></p><h4 id="copy的使用">copy的使用</h4><p>在完成leetcode77.组合问题时出现的情况： 1. 使用slice作为一种全局的参考，必须使用深拷贝，否则后面修改了，前面添加进ans的结果也都会修改。 2. 使用copy( destSlice, srcSlice []T) int时，必须提前把长度开辟好，copy过程不会自动扩容 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    ans := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)<br>    tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">var</span> backtrack <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>,k <span class="hljs-type">int</span>,level <span class="hljs-type">int</span>)</span></span><br>    backtrack = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>,k <span class="hljs-type">int</span>,level <span class="hljs-type">int</span>)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> k == <span class="hljs-built_in">len</span>(tmp)&#123;<br>            t := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,k) <span class="hljs-comment">//必须提前指定大小为k，因为在copy时不会自动扩容</span><br>            <span class="hljs-built_in">copy</span>(t,tmp) <span class="hljs-comment">//如果没有深拷贝，会存在所有答案都相同的问题</span><br>            ans = <span class="hljs-built_in">append</span>(ans,t)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> i:=level;i &lt;= n;i++&#123;<br>            tmp = <span class="hljs-built_in">append</span>(tmp,i)<br>            backtrack(n,k,i+<span class="hljs-number">1</span>)<br>            tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    backtrack(n,k,<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="参考资料">参考资料</h4><p><a href="https://juejin.cn/post/7095097471608553503">Golang | 深入理解数据结构之Slice - 掘金 (juejin.cn)</a></p><h2 id="链表">2. 链表</h2><p><a href="https://pkg.go.dev/container/list">官方文档</a></p><p>链表的知识没有切片那么繁琐，<strong>只要能随手手撕结构体+配套方法即可</strong>（可参见leetcode 707）。 go中自带的链表结构体定义在container/list/list.go中。 list本身是一个结构体，每个节点（element）也是一个结构体。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Element is an element of a linked list.  </span><br><span class="hljs-keyword">type</span> Element <span class="hljs-keyword">struct</span> &#123;  <br>    <span class="hljs-comment">// Next and previous pointers in the doubly-linked list of elements.  </span><br>    <span class="hljs-comment">// To simplify the implementation, internally a list l is implemented    // as a ring, such that &amp;l.root is both the next element of the last    // list element (l.Back()) and the previous element of the first list    // element (l.Front()).    next, prev *Element  </span><br>  <br>    <span class="hljs-comment">// The list to which this element belongs.  </span><br>    list *List  <br>  <br>    <span class="hljs-comment">// The value stored with this element.  </span><br>    Value any  <br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// List represents a doubly linked list.  </span><br><span class="hljs-comment">// The zero value for List is an empty list ready to use.  </span><br><span class="hljs-keyword">type</span> List <span class="hljs-keyword">struct</span> &#123;  <br>    root Element <span class="hljs-comment">// sentinel list element, only &amp;root, root.prev, and root.next are used  </span><br>    <span class="hljs-built_in">len</span>  <span class="hljs-type">int</span>     <span class="hljs-comment">// current list length excluding (this) sentinel element  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>go中的list是一个双向链表，下面是两种初始化方式 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;container/list&quot;</span><br>   <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> <br>   <span class="hljs-comment">// 使用list.New()直接初始化</span><br>   l1 := list.New()<br>   l1.PushFront(<span class="hljs-number">1</span>)<br>   fmt.Println(l1.Front().Value) <span class="hljs-comment">// 1</span><br><br>   <span class="hljs-comment">// 使用list.List&#123;&#125;延迟初始化</span><br>   l2 := list.List&#123;&#125;<br>   l2.PushFront(<span class="hljs-number">2</span>)<br>   fmt.Println(l2.Front().Value) <span class="hljs-comment">// 2</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure></p><p>go链表包含哨兵节点，哨兵节点的两个指针next和prev分别指向第一个节点和最后一个节点，不保存其他有效数值。因此<strong>go的链表也可以当成栈和队列来使用</strong>。</p><h2 id="哈希表">3. 哈希表</h2><p>哈希是非常常见的数据结构，在C语言中有多种实现方式： <img src="20231211212721.png"> <img src="20231211212822.png"></p><p>哈希表底层基于数组实现，哈希函数的选择在很大程度上能够决定哈希表的读写性能 ，当发生哈希冲突时，哈希表的读写性能通常会下降到<code>O(logN)</code>甚至<code>O(N)</code>级别。 可以总结出影响哈希表性能的一些因素: - 哈希函数是否完美，是否能够尽量减少哈希冲突的发生 - 当哈希冲突发生时，如何解决哈希冲突 - 哈希表底层基于数组实现，当数组接近被填满时，发生哈希冲突的概率会大大增大，因此需要对数组做扩容。如何选择合适的<code>扩容阈值</code>并且如何做<code>数组扩容</code>也会影响哈希表的性能与稳定性</p><p>go map初始化： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">myMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></p><h4 id="map的遍历">map的遍历</h4><p>在使用go range遍历map时： - key是乱序的 - 每个key value使用的内存相同，每次将不同的key value值拷贝到那块内存中 - 遍历时，如果一个元素还没有被访问到就被删除或者新增了一个元素，该元素不会被访问到 - 被遍历的map是原map的copy，但共用同一片底层内存。在遍历过程中对此map元素的修改将体现到循环变量中</p><p>map的key值不能是func()，map和Slice，但可以是channel。因为channel创建后指针是不会再发生变化的，slice、map、func()可能会发生变化</p><p>如果将interface{}作为key，但是传入func()，则会抛出runtime.panic</p><h4 id="源码结构">源码结构</h4><p>map运行中主要使用 runtime/map.go中的hmap来表示： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">//hmap的结构体</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br><br>   count     <span class="hljs-type">int</span>     <span class="hljs-comment">//  当前哈希表中的元素数量</span><br>   flags     <span class="hljs-type">uint8</span>   <span class="hljs-comment">// 扩容标志位</span><br>   B         <span class="hljs-type">uint8</span>   <span class="hljs-comment">// 哈希表中桶的数量为2的B次方</span><br>   noverflow <span class="hljs-type">uint16</span>  <span class="hljs-comment">// 记录溢出桶的大致数量 当溢出桶的数量不多时，值为精确值当;溢出桶的数量过多时， 为大致值</span><br>   hash0     <span class="hljs-type">uint32</span> <span class="hljs-comment">// hash种子</span><br><br>   buckets    unsafe.Pointer <span class="hljs-comment">// 容量为2^B的桶数组，存储具体 key/value 的 bucket 数组，里面每个 bucket 本质也是指向结构体的一个指针，其指向的结构体是 bmap</span><br>   oldbuckets unsafe.Pointer <span class="hljs-comment">// 扩容时保存旧的桶</span><br>   nevacuate  <span class="hljs-type">uintptr</span>        <span class="hljs-comment">// 用于记录数据转移的进度，低于此值的数据已经从旧桶转移到了新桶中</span><br><br>   extra *mapextra <span class="hljs-comment">// 溢出桶</span><br>&#125;<br><br><span class="hljs-comment">//溢出桶</span><br><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>   overflow    *[]*bmap <span class="hljs-comment">// 溢出桶</span><br>   oldoverflow *[]*bmap <span class="hljs-comment">// 旧的溢出桶</span><br>   nextOverflow *bmap <span class="hljs-comment">// 指向空闲溢出桶的指针</span><br>&#125;<br><br><br><span class="hljs-comment">// 源代码中的bmap，但不是实际运行的样子</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>tophash [bucketCnt]<span class="hljs-type">uint8</span><br>&#125;<br><span class="hljs-comment">// bmap在编译时计算大小，使用反射机制构成真正的bmap类型</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash     [bucketCnt]<span class="hljs-type">uint8</span> <span class="hljs-comment">//存放了Hash值的前8位，用于插入时候的快速比较等场景</span><br>    keys        [bucketCnt]keyType<br>    values      [bucketCnt]valueType<br>    pad         <span class="hljs-type">uintptr</span><br>    overflowPtr <span class="hljs-type">uintptr</span><br>&#125;<br><br><br><br><br></code></pre></td></tr></table></figure></p><p><img src="20231211214849.png"></p><p>代码太晦涩，看着图更容易理解，buckets是一个指向bmap指针数组的指针，每个bmap指针指向一个bmap结构体。bmap结构体内部包含key数组和value数组（<strong>分开存储而不是成对存储可以有效减少填充，节约内存</strong>）。 <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">例如，有这样一个类型的 <span class="hljs-built_in">map</span>：`<span class="hljs-built_in">map</span>[int64]int8`，如果按照 `<span class="hljs-built_in">key</span>/value...` 这样的模式存储，那在每一个 <span class="hljs-built_in">key</span>/value 对之后都要额外 padding <span class="hljs-number">7</span> 个字节<br><br>而将所有的 <span class="hljs-built_in">key</span>，value 分别绑定到一起，这种形式 `<span class="hljs-built_in">key</span>/<span class="hljs-built_in">key</span>/.../value/value/...`，则只需要在最后添加 padding即可。<br></code></pre></td></tr></table></figure></p><p>一个bmap能存储8个k-v对，超过的部分会创建新的桶并通过overflow串联起来（拉链法）。</p><p>问题：既然bmap有了overflow串联溢出的桶，为什么还需要extra来保存溢出桶的指针？ 答案：这是一种优化。当<strong>map的key和val均不含指针</strong>并且可以内联(size &lt; 128字节)时，bmap可以被标注为不包含指针，这样可以<strong>避免GC时扫描整个map（扫描所有的bmap）</strong>。但是因为bmap本身就包含了一个指向溢出桶的指针<code>overflow</code>，因此<strong>hmap才增加了extra字段，用来保存溢出桶信息</strong>，这样如果bmap不包含指针(除了overflow指针)，那么<strong>GC扫描时只需要扫描extra字段中的溢出桶而不用扫描整个map</strong></p><h4 id="key的定位">key的定位</h4><p>go map的hash函数其实就是取余（但取余很慢，所以位运算代替）。</p><p>key经过hash得到的hash值总共有64个bit位： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">10010111</span> | <span class="hljs-number">000011110110110010001111001010100010010110010101010</span> │ <span class="hljs-number">01010</span><br><br>- 取后B个Bit位作为要存放的桶编号，例如上面的<span class="hljs-number">01010</span>，就是<span class="hljs-number">10</span>号桶<br>- 再用Hash值的高<span class="hljs-number">8</span>位，找到Key在桶内部的位置，这是在寻找已有的key<br><br>假定 B = <span class="hljs-number">5</span>，所以 bucket 总数就是 <span class="hljs-number">2</span>^<span class="hljs-number">5</span> = <span class="hljs-number">32</span>。首先计算出待查找 key 的哈希，使用低 <span class="hljs-number">5</span> 位 <span class="hljs-string">`01010`</span>，找到对应的 <span class="hljs-number">8</span> 号 bucket，使用高 <span class="hljs-number">8</span> 位 <span class="hljs-string">`10010111`</span>，对应十进制 <span class="hljs-number">151</span>，在 <span class="hljs-number">8</span> 号 bucket 中寻找 tophash 值（HOB hash）为 <span class="hljs-number">151</span> 的 key，找到了 <span class="hljs-number">2</span> 号槽位，这样整个查找过程就结束了。<br></code></pre></td></tr></table></figure></p><p>如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。</p><h4 id="hash函数">hash函数</h4><p>hash函数是在初始化时根据CPU确认的，默认AES。如果不支持AES，则使用mem hash</p><h4 id="map的访问">map的访问</h4><p>map的访问即通过给定的key在map中寻找其对应value，它的大致步骤如下： 1. 以64位操作系统为例，原始的key通过Hash函数映射成<strong>64位</strong>二进制。 2. <strong>末尾B位</strong>对应<code>bmap</code>的位置，从<code>[]bmap</code>中找到对应的<code>bmap</code>。 3. <strong>首8位</strong>对应该key的<code>tophash</code>，从步骤2所定位的<code>bmap</code>开始检索。首先会比较<code>bmap</code>顶层的<code>tophash</code>与原始key的<code>tophash</code>是否相同，若不相同则直接跳过比较下一个；若相同则进一步比较key是否相同。 4. 若当前的<code>bmap</code>中比较完，没有匹配到目标key，且<code>overflow</code>不为空，则继续从<code>overflow</code>指向的下一个<code>bmap</code>继续比较</p><h4 id="map的扩容与迁移">map的扩容与迁移</h4><p>map扩容的目的在于减少Hash冲突，防止算法复杂度<strong>退化</strong>，保持Hash算法O(1)的时间复杂度 - map的扩容对使用方<strong>不可见</strong>，开发者在使用map的过程中不会感知到map是否在扩容 - Go语言的map扩容是<strong>渐进式</strong>的，即整个扩容过程拆散在每一次的写操作里面，这样做的好处是保证每一次map的读写操作时间复杂度都是<strong>稳定</strong>的。</p><p>触发扩容的两个因素<br>（1）负载因子大于6.5（负载因子=元素个数/桶个数），说明桶快要装满；采用双倍扩容 （2）溢出桶太多，map 成了链表，性能大大降低；采用等量扩容，重新排列数据 - B &lt;=15，已使用的溢出桶个数 &gt;= (2^B) 时，引发等量扩容。 - B &gt; 15，已使用的溢出桶个数 &gt;= (2^15) 时，引发等量扩容。</p><p>扩容的具体方案： （1）双倍扩容：将旧桶中的数据分流至新的两个桶中（比例不定），B+1；扩容也不是申请一块内存，立马开始拷贝。而是每一次访问旧的 buckets 时，就迁移一部分，直到完成，旧 bucket 被 GC 回收。根据key重新生成哈希值，根据哈希值的底B位来决定位置中 （2）等量扩容：开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。在极端情况下，重新扩容也解决不了问题，map成了链表。这种情况可以通过哈希种子的设置避免</p><h4 id="map的迭代">map的迭代</h4><p>由于map存在<strong>渐进式扩容</strong>，因此map的迭代并不像想象中的那么直接，而需要考虑搬迁过程中的迭代。</p><p>map在搬迁过程中会通过nevacuate来记录搬迁进度，因此在迭代过程中需要同时考虑遍历旧的bmap和新的bmap。</p><p>由于map的删除是找到对应的bmap删除key/value并且清空tophash，但是并不会导致下标产生偏移。因此go map是可以在迭代时产生删除操作的</p><h4 id="float可以作为key吗">float可以作为key吗？</h4><p>可以，但是由于精度问题，所以可能出现一些诡异的问题，不建议使用</p><h4 id="参考资料-1">参考资料</h4><p>https://www.cnblogs.com/ling11/p/16318554.html https://blog.csdn.net/fengshenyun/article/details/100582529</p><h2 id="字符串">4. 字符串</h2><p>在 go 语言中，字符串实际上是一个<strong>只读</strong>的<strong>字节切片</strong>，其数据结构定义如下： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime/string.go</span><br><span class="hljs-keyword">type</span> stringStruct <span class="hljs-keyword">struct</span> &#123;<br>str unsafe.Pointer<span class="hljs-comment">// 指向底层byte数组的指针,byte是uint8的别名</span><br><span class="hljs-built_in">len</span> <span class="hljs-type">int</span><span class="hljs-comment">// 字节数组的长度 </span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>字符串常量会在编译期分配到只读段，对应数据地址不可写入，相同的字符串常量不会重复存储</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;hello&quot;</span><br>fmt.Println(a, &amp;a, (*reflect.StringHeader)(unsafe.Pointer(&amp;a)))<br>a = <span class="hljs-string">&quot;world&quot;</span><br>fmt.Println(a, &amp;a, (*reflect.StringHeader)(unsafe.Pointer(&amp;a)))<br><span class="hljs-keyword">var</span> b = <span class="hljs-string">&quot;hello&quot;</span><br>fmt.Println(b, &amp;b, (*reflect.StringHeader)(unsafe.Pointer(&amp;b)))<br>&#125;<br><br><span class="hljs-comment">/* output</span><br><span class="hljs-comment">字符串字面量 该变量的内存地址 底层字节切片</span><br><span class="hljs-comment">hello 0xc0000381f0 &amp;&#123;5033779 5&#125;</span><br><span class="hljs-comment">world 0xc0000381f0 &amp;&#123;5033844 5&#125;</span><br><span class="hljs-comment">hello 0xc000038220 &amp;&#123;5033779 5&#125;</span><br><span class="hljs-comment">*/</span><br><br>可以看到，hello在底层只存储了一份<br></code></pre></td></tr></table></figure><p>rune是int32的别名，在对字符串进行for range遍历时，是按照<strong>rune类型来解码</strong>的。rune和byte之间可以相互转换，但这个过程不是修改字节数组而是重新分配内存并copy。</p><h4 id="kmp算法是必会的">kmp算法是必会的</h4><p>如何更好地理解和掌握 KMP 算法? - 阮行止的回答 - 知乎 https://www.zhihu.com/question/21923021/answer/1032665486</p><h2 id="栈和队列">5. 栈和队列</h2><p>在go中没有现成的栈和队列结构，需要使用list来模拟。</p><p>https://xie.infoq.cn/article/e89e4df33f36f03e6d5d6116f</p><h2 id="二叉树">6. 二叉树</h2><p>二叉树需要熟记的是三种遍历方式，最主要是迭代的方式，用同一套模板：</p><p>中序遍历 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//中序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)<br>    stack := []*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span>&#123;<br>        node := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] <span class="hljs-comment">//出栈</span><br>        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span>&#123; <br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span>&#123;<br>                stack = <span class="hljs-built_in">append</span>(stack,node.Right)  <br>            &#125; <span class="hljs-comment">//右</span><br>            <br>            stack = <span class="hljs-built_in">append</span>(stack,node) <span class="hljs-comment">//中</span><br>            stack = <span class="hljs-built_in">append</span>(stack,<span class="hljs-literal">nil</span>)  <span class="hljs-comment">//中</span><br>            <br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span>&#123;<br>                stack = <span class="hljs-built_in">append</span>(stack,node.Left)<br>            &#125;<span class="hljs-comment">//左</span><br>            <span class="hljs-comment">//中序遍历从下往上数，左中右</span><br>            <span class="hljs-comment">//后序遍历从下往上数，左右中</span><br>            <span class="hljs-comment">//先序遍历从下往上数，中左右</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            node = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            ans = <span class="hljs-built_in">append</span>(ans,node.Val)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>层次遍历 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">//层次遍历</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    queue := list.New()<br>    queue.PushBack(root)<br>    ans := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>) <br>    <span class="hljs-keyword">for</span> queue.Len() &gt; <span class="hljs-number">0</span>&#123;<br>        length := queue.Len()<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">//每一层的节点列表</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>;i &lt; length;i++&#123;<br>            node := queue.Front().Value.(*TreeNode)<br>            queue.Remove(queue.Front())<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span>&#123;<br>                queue.PushBack(node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span>&#123;<br>                queue.PushBack(node.Right)<br>            &#125;<br>            tmp = <span class="hljs-built_in">append</span>(tmp,node.Val)<br>        &#125;<br>        ans = <span class="hljs-built_in">append</span>(ans,tmp)<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans  <br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Go进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构, 语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>商业模式的逻辑</title>
    <link href="/2023/12/06/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%BB%E8%BE%91/"/>
    <url>/2023/12/06/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%BB%E8%BE%91/</url>
    
    <content type="html"><![CDATA[<p>商业模式描述了企业如何创造价值、传递价值和获取价值的基本原理。</p><p>通俗来说：一个企业的商业模式，就是一个企业如何给客户带来价值，然后要把创造的价值很好的交付出去，最终赚到钱。</p><p><strong>创业的前提就是搞清楚自己的商业模式。</strong></p><p>本文会通过绘制一张商业画布的情况下，所讲述的内容在以下情况下适用： 1. 一家企业急需找到产品新方向和新模式时 2. <strong>有了一个idea，但不够产品化</strong> 3. 已经有了一个产品，但是销售情况不佳，需要进行整顿</p><p>总的来说，整篇文章的目的是帮助把一个idea产品化，体系化（可以做成PPT），同时也是教会大多普通人从体系的角度去看待商业行为（例如共享单车）</p><h2 id="概述">概述</h2><p>商业模式画布可以帮助理解商业模式的内在逻辑，这个画布从以下八个方面展开。 （回答清楚这几个问题就解答了商业模式是什么的问题） 1. 客户细分：任何的商业模式要有一个非常清晰的目标客户群。客户细分是所有商业模式逻辑上的起点，也是他的终点 2. 价值主张：客户购买或使用的理由，是整个商业模式的灵魂。营销就是围绕价值主张展开的 3. 渠道通路：如何把价值主张交付给客户 4. 客户关系：在整个闭环的商业模式中，最终致力于跟客户构建起一个什么样的关系 5. 收入来源：钱从哪里来 6. 关键业务（key activity）：为了前期的预想落地，应该做哪些行动？ 7. 核心资源：商业模式中固定不可被取消的资源体系 8. 重要伙伴： 9. 成本结构： 怎么有效的花钱，把每一笔钱最大化的、杠杆化的运用</p><p>1-5是整个商业模式的前端过程，对<strong>用户细分</strong>经过<strong>渠道通路</strong>传递<strong>价值主张</strong>，<strong>构建客户关系</strong>获取<strong>收入来源</strong></p><h2 id="客户细分">1. 客户细分</h2><p><strong>在要构建商业模式时，第一步最重要的是，要选准目标客户群体，且围绕此目标客户群体，精准分析他们的痛点，构成商业逻辑的第一步</strong>。</p><p>客户细分可以通过几种常见的角度： 1. 大众市场（不分类） 男女老少通吃的市场，例如微信、农夫山泉等都是面向大众市场</p><ol start="2" type="1"><li><p>利基市场（细分大众市场） （1）按照年龄切分，例如学而思面向K12群体（一年级到高三） （2）按照支付能力，例如法拉利和五菱宏光面对不同的收入人群 （3）按照偏好划分，例如面向旅游爱好者的马蜂窝，面向追剧爱好者的爱奇艺</p></li><li><p>区隔化市场 区隔化市场主要是体现在营销策略上，例如苹果主打高端手机，华为主打国产高端手机，小米主打性价比，vivo、oppo主打音乐手机，摄影手机。虽然手机行业面向的客户细分相似，但仍然可以细分出区隔化市场。</p></li><li><p>多元化市场 例如小米公司不只是做手机，手机有对应的客户细分，小米门锁，小米音箱，小米电视等都有对应的客户细分，这些一起够成了小米公司的多元化市场</p></li><li><p>双边或多边市场 单边市场是我买你卖的形式，双边则是不买也不卖，但提供给买卖双方的渠道。绝大多数互联网公司都是双边市场，例如淘宝入驻买家和卖家；滴滴有打车的人和司机。当双边市场逐渐复杂就会形成多边市场</p></li></ol><p>问题：如此之多的划分方法，如何知道划分方式是否好呢？ 答案：客户的购买密度</p><p>一个精准的划分会有较高的购买密度，即每百人购买我东西的人占比很高（例如30%）</p><p><img src="20231206143812.png"></p><h2 id="价值主张">2. 价值主张</h2><p>价值主张构造块用来描绘为特定客户细分创造价值的系列产品和服务。绝大多数创业项目失败在于没有一个好的价值主张</p><p>价值主张指的是，客户购买或者使用你这个产品或服务的理由。例如怕上火就喝王老吉（理由是凉茶去火），摩尔定律（微软的CPU性能高速更新），让出行更容易（滴滴打车解决出租车难的问题）</p><p>常用的价值主张类型如下，可以从中找到自己的idea的类型 1. 新颖性， 2. 性能，主打高性能 3. 定制化，主打根据个人情况定制 4. 设计感 5. 品牌身份和地位 6. 价格，主打平价亲民 7. 抑制风险 8. 便利性，主打让xxx更便利 9. 成本控制 10. 把事情做好</p><p>问题：什么叫好的价值主张： 答案：指向客户的痛点；与竞争对手的产品有明显的差异化；能够让团队变得更加兴奋，变得更加成功。</p><p>下面举几个根据价值主张开展营销的案例： 1. 农夫山泉有点甜 2. 主打除菌的舒肤佳干掉了力士香皂</p><h2 id="渠道通路">3. 渠道通路</h2><p>知道了东西要卖给谁，卖什么之后，还需要解决怎么卖的问题。</p><p>渠道通路构造块用来描绘公司是如何沟通、接触其客户细分而传递其价值主张。</p><p>一般来讲，在商业世界中，可以把商业模式分为两大类： 1. B2C（面向于个人消费者） 2. B2B（面向于政企客户）</p><p>B2C常见的类型： <img src="20231206153714.png"></p><p>B2B常见的类型： <img src="20231206153738.png"></p><p>在现在的互联网时代，APP成为了大多数创业项目的渠道通路</p><h2 id="客户关系">4. 客户关系</h2><p>客户关系构造块用来描绘公司与特定客户细分群体建立的关系类型。即：你对于客户来说是什么？</p><p>常见的客户关系： <img src="20231206153936.png"></p><p>GPT相当于顾问 有道云笔记、美图秀秀相当于个人助理 银行，证券公司等对应专属会员 马蜂和对应共创/众包，内容不是自己发布的</p><h2 id="收入来源">5. 收入来源</h2><p>收入来源构造块用来描绘公司从每个客户群体中获取的现金收入（包括一次性收入和经常性收入） <img src="20231206154312.png"></p><p>例如报纸杂志以订阅费为收入来源，谷歌以广告盈利</p><h2 id="核心资源">6. 核心资源</h2><p>核心资源构造块用来描绘让商业模式有效运转所必需的最重要因素。 <img src="20231206164804.png"></p><h2 id="关键业务">7. 关键业务</h2><p>关键业务构造块用来描绘确保其商业模式可行，企业必须做的最重要的事情。 <img src="20231206165119.png"></p><h2 id="重要伙伴">8. 重要伙伴</h2><p>重要伙伴构造块用来描绘让商业模式有效运作所需的供应商与合作伙伴的网络。 <img src="20231206165148.png"></p><p>供应商很容易理解 战略联盟指的是互相推进进步，是关系很深的合作 竞合是竞争合作，例如房地产商联合拿地分摊风险 生态伙伴是围绕一个体系一起发展，例如小米由很多周边产品，例如电视、门锁。很多不是自己开发的，是合作者开发，但是小米提供融资，分销渠道和流量支持等。大家都在小米主导的智能家居系统下</p><h2 id="成本结构">9. 成本结构</h2><p>成本结构构造块用来描绘运营一个商业模式所引发的所有成本。</p><p>通俗来讲，就是钱应该怎么花才最有效。</p><p><img src="20231206170853.png"></p><h2 id="案例">案例</h2><p><img src="20231206170906.png"></p><p><img src="20231206170919.png"></p><p><img src="20231206170933.png"></p><p><img src="20231206170941.png"></p><p><img src="20231206170946.png"></p><p><img src="20231206170957.png"></p>]]></content>
    
    
    <categories>
      
      <category>创业</category>
      
    </categories>
    
    
    <tags>
      
      <tag>商业模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Concept Sliders</title>
    <link href="/2023/11/30/Concept-Sliders/"/>
    <url>/2023/11/30/Concept-Sliders/</url>
    
    <content type="html"><![CDATA[<p>论文标题：Concept Sliders: LoRA Adaptors for Precise Control in Diffusion Models 阅读时间：2023-11-30 阅读目的：师兄推荐</p><h2 id="introduction">Introduction</h2><p>现有的文生图方法无法精确的调节连续属性（例如人的年龄或天气强度）。</p><p>文章提出了一种可解释的概念滑块来满足这个需求。</p><p>概念滑块解决了以往方法未能很好解决的几个问题。直接修改提示语可以控制许多图像属性，但由于输出对提示语-种子组合的敏感性，改变提示语往往会大幅改变整体图像结构（imagic），</p><p>PromptToPrompt需要对每个新概念进行单独的推理，而且只能支持有限的同时编辑。这些方法需要设计一个适合单个图像的提示，而不是学习一个简单的通用控制，而且如果不仔细提示，可能会引入概念之间的纠缠，例如在修改年龄时改变种族。</p><p>相比之下，<strong>概念滑块提供了轻量级的即插即用适配器，适用于预先训练好的模型，能够在单次推理中对所需概念进行精确、连续的控制，并具有高效的组合和最小的纠缠</strong></p><p>概念滑块还可以用来解决两个文生图的关键问题： 1. 修复手部畸形 2. 增强图像逼真度</p><h2 id="related-work">Related Work</h2><h4 id="图像编辑">图像编辑</h4><h4 id="引导模型">引导模型</h4><h4 id="模型编辑">模型编辑</h4><p>本文的方法可以视为是一种模型编辑，通过应用lora将语义属性单列出来，并允许对属性进行持续控制</p><h4 id="生成模型中语义引导的发展趋势">生成模型中语义引导的发展趋势</h4><p>本文的方法直接训练与语义属性相对应的低阶子空间。通过使用文本或图像对作为监督来优化特定的全局方向</p><h2 id="background">Background</h2><h4 id="lora">lora</h4><p><img src="20231206102130.png"></p><p><img src="20231206102215.png"></p><h2 id="method">Method</h2><p><strong>概念滑块其实也就是一个学会了概念方向的lora模型，例如age关于（old，young）就构成了一个概念对，概念滑块的目的就是通过Lora的方式，当lora对应权重变大时，增加或减少特定属性的表达概念，让SD意识到生成的图像应该越来越老。</strong></p><p>其实SD从大量图片中可以学习到关于old和young的概念，但是一直没有办法引导出来。</p><h4 id="文本概念如图">文本概念（如图）</h4><ol type="1"><li>在SD上分三个文本生成三个噪声</li><li>在lora上使用目标概念作为本文生成噪声</li><li>优化两个步骤之间噪声的L2 loss</li></ol><p><img src="20231209132056.png"></p><h4 id="图像概念">图像概念</h4><p>图像概念就是用多个数据对来进行学习，这些数据对最好除了想要学习的概念外都保持一致。</p><p>训练时给图像对添加噪声，然后让SD+lora去预测噪声，优化lora，让噪声和添加的噪声差距最小。 <img src="20231209132201.png"></p><h2 id="experiments">Experiments</h2><p><img src="20231209133334.png"></p>]]></content>
    
    
    <categories>
      
      <category>图像生成</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式训练</title>
    <link href="/2023/11/21/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/"/>
    <url>/2023/11/21/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<p>大规模语言型（LLM）承载着AI时代的三大核心：数据、算力、算法。</p><p>现如今，AI发展进入大模型时代。想要训练出一个好的大模型： - 烧钱 - 高质量数据 - 高效的训练框架和硬件资源 - 优秀的算法 四者缺一不可，而本系列主要关注第三点，即那么大参数量的模型是如何高效训练的？</p><p>早期的深度学习不存在多卡，都是在一张显卡上跑出结果。现在我们有了很多张卡，我们想要做的事情是什么呢？ 1. 训练更大的模型：单个显卡的显存有限，现在显卡多了，我们可以训练更大的模型 2. 更快的训练模型：原本一张卡要跑很久，现在多张卡可以极大的加速训练时间。</p><p>这是一个并行计算的任务，我们要先要明白这个过程中遇到的最大困难是什么： 1. <strong>内存限制</strong>：训练更大的模型，每块GPU中不仅要保存模型的参数，还要保存来计算梯度的中间结果。越大规模的数据，中间结果也就越多， 2. <strong>带宽限制</strong>：并行计算的过程涉及到通讯，数据在卡之间传输是需要时间的。</p><p>本文的所有内容都是围绕着解决这两个问题展开。</p><p>目前的并行方法有三种，各有不同的应用场景 1. 流水线并行 2. 数据并行（DP）、分布式数据并行（DDP），零冗余优化（Zero） 3. 张量并行</p><h2 id="流水线并行">流水线并行</h2><p>拿到多张显卡，一个很朴素的想法就是把模型拆成很多块，分别放到不同的显卡中。所有显卡串行连接起来，构成一个完整的模型。</p><p>第一块显卡上的模型forward结束，将结果发送给第二块，以此类推；最后一块显卡forward完成后开始backward，同理把计算的结果发送给倒数第二块显卡，以此类推。</p><p>如果学习过CPU的流水线计算的话，就知道这样的方式会浪费很多计算资源，例如，当第一个显卡完成forward过程后，就处于空闲状态，一直等到最后一块显卡将backward传播过来。</p><p>刚刚的情况下，显卡直接的数据传输是整个batch。流水线操作就是将这个mini-batch，拆分成多个micro-batch再操作：第一块显卡先运行第一个micro-batch，然后传输给第二块显卡，但是这之后他不闲着，立刻开始运行第二个micro-batch，以此类推。再一个epoch结束后再把micro-batch合并在一起。这样提高了GPU的使用率</p><p>流水线并行的原理很简单，但是并不常用。它面临着不同的模型不知道如何均匀拆分的问题，需要依赖算法工作人员手动调整，非常不方便，毕竟将算力分配均匀，知道以哪一层为界限分割模型，并不是一件简单的事情</p><p><a href="https://zhuanlan.zhihu.com/p/613196255">图解大模型训练之：流水线并行（Pipeline Parallelism），以Gpipe为例 - 知乎 (zhihu.com)</a></p><h2 id="数据并行dp">数据并行(DP)</h2><p>https://zhuanlan.zhihu.com/p/617133971</p><h2 id="分布式数据并行ddp">分布式数据并行（DDP）</h2><h3 id="理论部分">理论部分</h3><p>DDP是当下主流的数据并行方案，也是本文的重点。DDP不同于DP，简单来说它会将模型都拷贝到多GPU上，不像DP只会在gpu0上加载模型，因此速度在绝大多数情况下都比DP快，而且加速比例接近于GPU数量</p><p>关键参数如下： - <strong>world_size</strong>：总的进程数量，几乎在所有的DDP情况下都是使用一个GPU对应一个Process; - <strong>local_rank</strong>：当前进程对应的GPU号，它是<code>to_device()</code>方法的一个重要参数（指定加载到哪个GPU）; - <strong>global_rank(rank)</strong>：在单节点的情况下，rank和local_rank是一致的；<br><code>torch.distributed.get_rank() # 获取全局rank,单节点就是local_rank</code> - 特别注意，DDP的Batch_size就是像原本一样设定，因为DP计算实际上是收集多个GPU上的梯度汇总，平均，然而DDP其实在不加入“多GPU累积操作”的情况下，batch_size就是设置的那个，不过是进行有多少个GPU就进行多少次而已。</p><h3 id="实践部分">实践部分</h3><h4 id="单卡代码">单卡代码</h4><p>学习DDP代码最好的方式是把一段现有的单卡深度学习代码改为DDP训练的方式。我们先看一段单卡代码： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torch.utils.data.distributed<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># 数据加载部分，直接利用torchvision中的datasets</span><br>    trans = transforms.Compose([transforms.ToTensor(), transforms.Normalize((<span class="hljs-number">0.5</span>,), (<span class="hljs-number">1.0</span>,))])<br>    data_set = torchvision.datasets.MNIST(<span class="hljs-string">&quot;./&quot;</span>, train=<span class="hljs-literal">True</span>, transform=trans, target_transform=<span class="hljs-literal">None</span>, download=<span class="hljs-literal">True</span>)<br>    data_loader_train = torch.utils.data.DataLoader(dataset=data_set, batch_size=<span class="hljs-number">256</span>)<br>    <br>    <span class="hljs-comment"># 模型搭建部分，调用torchvision中的resnet</span><br>    net = torchvision.models.resnet101(num_classes=<span class="hljs-number">10</span>)<br>    net.conv1 = torch.nn.Conv1d(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>, (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), bias=<span class="hljs-literal">False</span>)<br>    net = net.cuda() <span class="hljs-comment">#把模型放到cuda上</span><br>    <br>    <span class="hljs-comment"># 定义loss与opt</span><br>    criterion = torch.nn.CrossEntropyLoss()<br>    opt = torch.optim.Adam(net.parameters(), lr=<span class="hljs-number">0.001</span>)<br>    <br>    <span class="hljs-comment"># 网络训练  </span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_loader_train):<br>            images, labels = data<br>            images, labels = images.cuda(), labels.cuda() <br>            opt.zero_grad()  <span class="hljs-comment">#清空梯度</span><br>            outputs = net(images)<br>            loss = criterion(outputs, labels)<br>            loss.backward()<br>            opt.step()<br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;loss: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(loss.item()))<br>                <br>    <span class="hljs-comment"># 保存checkpoint</span><br>    torch.save(net, <span class="hljs-string">&quot;my_net.pth&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure></p><h4 id="单机多卡">单机多卡</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torch.distributed <span class="hljs-keyword">as</span> dist<br><span class="hljs-keyword">import</span> torch.utils.data.distributed<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">from</span> torch.multiprocessing <span class="hljs-keyword">import</span> Process<br><br><span class="hljs-comment">#配置文件，指定master的位置和端口</span><br>os.environ[<span class="hljs-string">&#x27;MASTER_ADDR&#x27;</span>] = <span class="hljs-string">&#x27;localhost&#x27;</span><br>os.environ[<span class="hljs-string">&#x27;MASTER_PORT&#x27;</span>] = <span class="hljs-string">&#x27;12355&#x27;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">rank</span>):<br>    <span class="hljs-comment">#多出了ddp初始化部分</span><br>    dist.init_process_group(<span class="hljs-string">&quot;nccl&quot;</span>, rank=rank, world_size=<span class="hljs-number">3</span>)<br>    torch.cuda.set_device(rank)<br>    <br>    trans = transforms.Compose([transforms.ToTensor(), transforms.Normalize((<span class="hljs-number">0.5</span>,), (<span class="hljs-number">1.0</span>,))])<br>    data_set = torchvision.datasets.MNIST(<span class="hljs-string">&quot;./&quot;</span>, train=<span class="hljs-literal">True</span>, transform=trans, target_transform=<span class="hljs-literal">None</span>, download=<span class="hljs-literal">True</span>)<br>    <br>    <span class="hljs-comment">#多了一个sampler参数，对应ddp的sampler过程</span><br>    train_sampler = torch.utils.data.distributed.DistributedSampler(data_set)<br>    data_loader_train = torch.utils.data.DataLoader(dataset=data_set, batch_size=<span class="hljs-number">256</span>, sampler=train_sampler)<br><br>    net = torchvision.models.resnet101(num_classes=<span class="hljs-number">10</span>)<br>    net.conv1 = torch.nn.Conv1d(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>, (<span class="hljs-number">7</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), bias=<span class="hljs-literal">False</span>)<br>    net = net.cuda()<br><br><span class="hljs-comment">#模型被DistributedDataParallel包裹，并且指定使用的GPU（rank可以理解为GPU id）</span><br>    net = torch.nn.parallel.DistributedDataParallel(net, device_ids=[rank])<br>    criterion = torch.nn.CrossEntropyLoss()<br>    opt = torch.optim.Adam(net.parameters(), lr=<span class="hljs-number">0.001</span>)<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_loader_train):<br>            images, labels = data<br>            images, labels = images.cuda(), labels.cuda()<br>            opt.zero_grad()<br>            outputs = net(images)<br>            loss = criterion(outputs, labels)<br>            loss.backward()<br>            opt.step()<br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;loss: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(loss.item()))<br>    <span class="hljs-keyword">if</span> rank == <span class="hljs-number">0</span>: <span class="hljs-comment">#指定GPU保存模型</span><br>        torch.save(net, <span class="hljs-string">&quot;my_net.pth&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    size = <span class="hljs-number">3</span><br><br><span class="hljs-comment">#启动的时候引入多进程机制</span><br>    processes = []<br>    <span class="hljs-keyword">for</span> rank <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>        p = Process(target=main, args=(rank,))<br>        p.start()<br>        processes.append(p)<br><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> processes:<br>        p.join()<br></code></pre></td></tr></table></figure><p>综上，主要的变动如下： 1. 配置文件：多了master的配置文件 2. 启动过程：引入多进程机制 3. DataLoader：多了一个sampler参数 4. 模型：net被DistributedDataParallel包裹 5. 模型保存：原本直接保存，现在改为由0号GPU保存</p><p>单机多卡还有其他写法： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#import torch.multiprocessing as mp</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>world_size= <span class="hljs-number">3</span><br>mp.spawn(main,<br>args=(world_size,),<br>nprocs=world_size,<br>join=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></p><p>spawn相当于简化了process的书写。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">注意：<span class="hljs-built_in">spawn</span>函数要放入 <span class="hljs-keyword">if</span> <span class="hljs-variable">__name__</span>==<span class="hljs-string">&quot;__main__&quot;</span>: 中，不然会引发错误<br></code></pre></td></tr></table></figure><h4 id="多机分布式">多机分布式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.distributed <span class="hljs-keyword">as</span> dist<br><span class="hljs-keyword">import</span> torch.multiprocessing <span class="hljs-keyword">as</span> mp<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">from</span> torch.nn.parallel <span class="hljs-keyword">import</span> DistributedDataParallel <span class="hljs-keyword">as</span> DDP<br><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-comment">#用于获取命令行参数</span><br><span class="hljs-comment">#argparse模块是命令行选项、参数和子命令解析器</span><br><span class="hljs-comment">#argparse可以让人轻松编写用户友好的命令行接口，适用于代码需要频繁地修改参数的情况</span><br>parser = argparse.ArgumentParser()<br>parser.add_argument(<span class="hljs-string">&quot;--world_size&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)<span class="hljs-comment">#  #添加参数</span><br>parser.add_argument(<span class="hljs-string">&quot;--node_rank&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)<br>parser.add_argument(<span class="hljs-string">&quot;--master_addr&quot;</span>, default=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>)<br>parser.add_argument(<span class="hljs-string">&quot;--master_port&quot;</span>, default=<span class="hljs-string">&quot;12355&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>)<br>args = parser.parse_args()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">example</span>(<span class="hljs-params">local_rank, node_rank, local_size, world_size</span>):<br>    <span class="hljs-comment"># 初始化</span><br>    rank = local_rank + node_rank * local_size<br>    torch.cuda.set_device(local_rank)<br>    dist.init_process_group(<span class="hljs-string">&quot;nccl&quot;</span>,<br>                            init_method=<span class="hljs-string">&quot;tcp://&#123;&#125;:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(args.master_addr, args.master_port),<br>                            rank=rank,<br>                            world_size=world_size)<br>    <span class="hljs-comment"># 创建模型</span><br>    model = nn.Linear(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>).to(local_rank)<br>    <span class="hljs-comment"># 放入DDP</span><br>    ddp_model = DDP(model, device_ids=[local_rank], output_device=local_rank) <br>    loss_fn = nn.MSELoss()<br>    optimizer = optim.SGD(ddp_model.parameters(), lr=<span class="hljs-number">0.001</span>)<br>    <span class="hljs-comment"># 进行前向后向计算</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>        outputs = ddp_model(torch.randn(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>).to(local_rank))<br>        labels = torch.randn(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>).to(local_rank)<br>        loss_fn(outputs, labels).backward()<br>        optimizer.step()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    local_size = torch.cuda.device_count()  <span class="hljs-comment">#获取当前所有的GPU</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;local_size: %s&quot;</span> % local_size)<br>    mp.spawn(example,<br>        args=(args.node_rank, local_size, args.world_size,),<br>        nprocs=local_size,<br>        join=<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>假设一共有两台机器（节点1和节点2），每个节点上有8张卡，节点1的IP地址为192.168.0.1 占用的端口22335（端口可以更换），启动的方式如下： <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#节点1</span><br>python python demo.py <span class="hljs-attribute">--world_size</span>=16 <span class="hljs-attribute">--node_rank</span>=0 <span class="hljs-attribute">--master_addr</span>=<span class="hljs-string">&quot;192.168.0.1&quot;</span> <span class="hljs-attribute">--master_port</span>=22335<br><span class="hljs-comment">#节点2</span><br>python python demo.py <span class="hljs-attribute">--world_size</span>=16 <span class="hljs-attribute">--node_rank</span>=1 <span class="hljs-attribute">--master_addr</span>=<span class="hljs-string">&quot;192.168.0.1&quot;</span> <span class="hljs-attribute">--master_port</span>=22335<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式训练</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AdimateDiff</title>
    <link href="/2023/11/20/AdimateDiff/"/>
    <url>/2023/11/20/AdimateDiff/</url>
    
    <content type="html"><![CDATA[<p><a href="%5Bguoyww/AnimateDiff:%20Official%20implementation%20of%20AnimateDiff.%20(github.com)%5D(https://github.com/guoyww/animatediff/)">AnimateDiff: Animate Your Personalized Text-to-Image Diffusion Models without Specific Tuning</a></p><p>阅读时间：2023-11-20 阅读目的：在做视频大模型相关的项目，涉及到解决<strong>视频一致性</strong>问题，SD+AnimateDiff是一个比较成熟的方式，通过阅读论文看看他是怎么做的</p><h2 id="abstract">Abstract</h2><p>SD + lora和dreambooth等下游配套已经使得用户可以画出好看的图片，现在如今让图片动起来的需求越来越大。</p><p>文章提出了一个框架，让图片在现有模型下运动起来。</p><p>该框架的核心是在T2I模型中插入一个初始化的运动建模模块，并利用视频数据进行训练</p><h2 id="introduction">Introduction</h2><p>现在有文本生成视频的需求，但是现有的T2V太复杂了（引用了Gen1、VDM、magicVideo三篇论文），个性化程度不高，用户不好使用，因此论文提出了一个运动建模模块，给定个性化T2I模式，例如用户训练或从Huggingface下载的DreamBooth或LoRA，目标是在保留其原始领域知识和质量的同时，将其转换为几乎没有训练成本的动画生成器</p><p>例如：如果T2I模型是经过个性化操作的（引入了lora），在这种情况下，模型应该能够生成个性化的动画片段。能做到前景/背景分割、角色身体运动等</p><h2 id="preliminaries">Preliminaries</h2><p>让图片动起来的核心是学习到时序特征，这点T2V模型可以做到。但是个性化的图片常有，个性化的视频却不常有，使用大量个性化的视频训练一个模型并不合理。因此作者选择训练一个可推广的运动建模模块，并在推理时将其插入个性化的T2I模型。</p><figure><img src="20231120183911.png" alt="框架图"><figcaption>框架图</figcaption></figure><p>运动建模模块的细节 <img src="20231120183927.png" alt="模块细节"></p><p>大体和VDM等没区别，主要在于AnimateDiff冻结SD，只训练自己的模块</p><h2 id="我的看法">我的看法</h2><p>作者通过插入额外的初始化运动建模模块，并在视频数据上进行训练。这种方法其实和magicEdit类似：SD就负责生成图片、额外再训练一个用来保证结构完整的模块和用来时序建模的模块。将视频生成的三个核心（图像语义、运动一致性、结构控制）解耦。</p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MasaCtrl</title>
    <link href="/2023/11/18/MasaCtrl/"/>
    <url>/2023/11/18/MasaCtrl/</url>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2304.08465">[2304.08465] MasaCtrl: Tuning-Free Mutual Self-Attention Control for Consistent Image Synthesis and Editing (arxiv.org)</a></p><p>阅读时间：2023-11-17 阅读目的：知名的图像编辑算法，提出了一个新颖的观点</p><h2 id="abstract">Abstract</h2><p>现有的编辑方法要么无法在保持整体纹理和身份的同时实现有效的复杂编辑，要么需要耗时的微调来捕捉图像特定的外观。</p><p>论文提出了一种无需微调的方法，可以完成复杂的图像编辑任务，具体来说， 1. MasaCtrl将扩散模型中现有的Self-attention转换为mutual self-attention（相互自注意），这样它就可以从源图像中查询相关的局部内容和纹理以获得一致性。 2. 当前景和背景相似时，图像编辑过程容易发生混淆，因此论文进一步提出了一种mask引导的mutual self-attention。（mask可以从cross-attention中提取）（cross-attention 只有64 * 64怎么提取？）</p><h2 id="introduction">Introduction</h2><p>现有的编辑方法无法在<strong>保持整体纹理和身份的同时更改姿势和视图</strong>（例如让狗坐下，让鸟张开翅膀），从而导致编辑结果不一致。</p><p>Imagic可以完成这个任务，在进行复杂的编辑时保留原始特性。但是他需要微调整个T2I模型，然后优化文本embedding，以捕捉每次编辑的特定外观，这显然对于现实应用来说不切实际。</p><p>对于T2I问题，现实生活中存在大量应用场景，要求模型生成多个具有不同视图，但主体相同的图片，例如漫画生成和短视频生成。</p><p>本文提出了一种新方法，解决的核心问题是：如何在不微调的情况下进行复杂的编辑，同时让编辑前后主体身份保持一致（感觉视频领域也可以用上？）</p><p>具体来说： 1. 将原本T2I的self-attention替换为mutual self-attention，这样就可以通过从源图像的query中查询相关的局部结构和纹理特征以获得一致性（<strong>解决了图像编辑和图像生成一致性的问题</strong>） - 先对real image进行DDIM inversion，得到从源图像到真实图像的扩散过程（DP1） - 再在成新图像（或编辑现有图像）的扩散过程中（DP2），使用DP2中self-attention的Q来查询DP1中self-attention的K和V 2. 但是如果直接应用1.中的方法，会生成几乎与源图像相同的图像，并且不能符合target prompt。因此在应用mutual self-attention时，还需要注意控制去噪步长和选择具体的Unet层。 3. 以上方法可以很好的应用在前景和背景不纠缠的图像上，但在前景背景相似时（例如颜色和图案相似），mutual self-attention会混淆前景背景。因此还需要进一步使用交叉注意力来提取与图像中的主要对象相关联的mask，用mask来分离前景背景，并限制前景特征仅Query源图前景，背景特征仅Query背景。</p><h2 id="preliminaries">Preliminaries</h2><figure><img src="20231117214339.png" alt="整体框架图"><figcaption>整体框架图</figcaption></figure><h4 id="mutual-self-attention">mutual self-attention</h4><p>方法其实非常简单： <img src="20231118183614.png" alt="细节图"> 既然图像编辑的任务，是在保留原图身份的基础上进行运动。那么在生成图片时，可以直接去原图查询（query）相关特征，<strong>即：在特定的layer和特定的T下，使用原图的K和V</strong>。</p><p>具体使用的层数如下，按照S=4，L=10的设置。 <img src="20231118183956.png"> #### Mask-Guided Mutual Self-Attention</p><p>但是上述的方法无法分辨前景和背景，P2P告诉我们，可以利用语义cross-attention来创建mask区分源图像和目标图像中的前景背景</p><p>先以16×16的空间分辨率对所有head和layer的cross-attention map进行平均，得到N个cross-attention map。N表示文本token的数量。</p><p>这个过程可以获得前景对象相关token的平均cross-attention map，进而获得了前景mask。有了mask就可以限制生成图像仅从原图像的主体区域query相关信息</p><p><img src="20231118185145.png"></p><h2 id="我的理解">我的理解</h2><p>文章开头提出问题：无法在保持整体纹理和身份的同时更改姿势和视图</p><p>随后抛出应用场景，证明用途：漫画、生成短视频等</p><p>再提出解决方案：用mutual self-attention来保证图像主体身份的同时，改变动作。</p><p>可以扩展思考的内容主要有两条： 1. mutual self-attention可在<strong>保持特色、纹理和身份的同时改变姿态、视图、结构</strong>。似乎也可以用在短视频领域，因为短视频正面临编辑对象闪烁的问题。它（imagic + mutual self-attention 可能可以完成一个简单的动作生成） 2. 使用cross-attention map来提取前景背景的掩模，完成前景背景分离（可以用于解耦，联想到ACR中的背景前景选取内容）</p>]]></content>
    
    
    <categories>
      
      <category>图像生成</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>I2VGen-XL</title>
    <link href="/2023/11/14/I2VGen-XL/"/>
    <url>/2023/11/14/I2VGen-XL/</url>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2311.04145">I2VGen-XL: High-Quality Image-to-Video Synthesis via Cascaded Diffusion Models</a></p><p>阅读时间：2023-11-10 阅读目的：阿里出的开源视频生成模型，看看和腾讯的有什么不同</p><h2 id="我的看法">我的看法</h2><p>如何建立高质量的T2V模型？ 作者其实给出了一种解法，由于缺乏高质量的文本-视频对，因此实现视频文本对齐比图像文本对齐要难很多。因此专注建立I2V模型，以T2I + I2V 的形式实现T2V是一个很好的解法。因为现有的图像生成技术（SD）比较成熟，可以生成高质量的图像，且可控性更好。</p><p>顺着这种思路，显而易见的，I2V模型的核心就是让&quot;图像动起来&quot;。</p><p>为了让图像动起来的视频更真实，论文设计了一个二阶段级联模型，从两个角度分别解决语义一致性和时空连续性。</p><p>除了这些观点，论文其实还揭示了一些现象，而这些现象可能就是值得解决的问题： 1. 图像语义的保持程度和运动强度之间呈现出一定的权衡关系 Gen2的动作幅度很小，所以想要生成真实的长视频，运动幅度其实是一个痛点。可能需要引入一些其他技术，比如光流？ 2. 使用VQGAN做图像结构和细节提取，CLIP做语义提取，然后融合。这种技术还可以用在图像生成领域的Inversion问题上（P+） 3. 基础阶段其实就可以生成大体看起来像那么回事的模型，但是细致看就不行了。或许SDEdit相关的，基础 + 优化的结构才是解决细致问题更有效的方法（相较于直接在一个模型上拔高参数量） 4. 细化模型的作用是保留低频分量，增强高频分量，减少中频分量，低频主要是图像细节，高频是边缘和噪声。而伪影主要存在于中频</p><h2 id="abstract">Abstract</h2><p>扩散模型在视频生成领域的应用发展很快，但是语义准确性、视频清晰度和时空连续性一直面临一些问题。视频数据结构复杂、缺少对齐良好的文本视频对，使得模型难以产出高质量且符合语义视频</p><p>这篇文章提出了一种叫I2VGen-XL的方法，通过解耦这两个因素增强模型性能，并且通过静态图像作为重要指导，确保输入图像数据对齐。算法包括两个阶段： 1. 基础阶段有两个encoder，一个用来保证生成对象的语义连贯性，另一个用来保留输入图像内容 2. 精炼阶段通过加入额外的简短文本来增强视频的细节，并将分辨率提高到1280 * 720</p><p>文章总共使用了3500w个文本视频对和60亿个文本图像对来优化模型</p><h2 id="introduction">Introduction</h2><p>扩散模型在图像生成领域效果显著，使得视频生成技术也取得重大进步，但在空间一致、语义一致、视频的细节连续性上仍然存在很大不足</p><p>目前有两种解决方法： 1. 多个模型级联来逐步提高视频质量，例如<a href>Imagen video</a>。这种方法主要在每个阶段使用相同的输入来优化目标，没有明确的解耦，因此导致在每个阶段学习相似的分布，生成的视频中会产生不可忽视的噪声 2. 引入额外的指导和训练过程，例如Codef和Videocomposer。目前取得了不错的成果，但是因为缺乏充分对齐的文本-视频对，所以发展较慢</p><p>I2VGen XL首先通过利用单个静态图像作为主要条件来减少对对齐良好的文本-视频对的依赖，具体分为两个阶段： 1. 基础阶段旨在确保低分辨率生成视频的语义一致性，同时保留输入图像的内容和身份信息 通过一个CLIP编码器（语义） + 一个可学习的编码器（内容） 实现，分别提取高级语义和低级细节，然后将其合并到视频扩散模型中 2. 精炼阶段是将视频分辨率提高到1280×720，并精炼生成视频中存在的细节和伪影 用一个简单的文本作为输入来训练一个独特的视频扩散模型，优化最初的600个去噪步骤。通过去噪，从低分辨率视频中生成具有时间和空间相关性性的高清晰度视频</p><p>文章总共使用了3500w个文本视频对和60亿个文本图像对来优化模型</p><h2 id="related-works">Related Works</h2><p>原文是从扩散模型，图像生成，视频生成三个子标题展开的，我归纳如下：</p><p>上游任务：DDPM，DDIM等采样器，解决扩散模型耗时等基础问题 中游任务：各种视频生成模型（大模型） 下游任务：研究可控性（<a href>composer</a> 和 controlnet）</p><h2 id="i2vgen-xl">I2VGen-XL</h2><p>I2VGen XL的目的是从静态图像生成高质量的视频。因此，它需要实现两个关键目标 <strong>1. 语义一致性，即准确预测图像中的意图，然后生成精确的运动，同时保持输入图像的内容和结构</strong> <strong>2. 高时空连贯性和清晰度，这是视频的基本属性</strong></p><p>这两个问题分别通过基础阶段和细化阶段解决，框架图如下： <img src="image%2020231114211959.png" alt="I2VGen-XL 框架图"></p><h4 id="base-stage基础阶段">Base stage（基础阶段）</h4><p>基于VLDM训练了一个低分辨率模型，聚焦语义和细节学习 1. High-level semantics learning CLIP可以提取语义信息，但是它只能学习高级语义，会忽视参考图像中提供的细节信息，因此还需要引入一个保留图像结构和细节的encoder 2. Low-level details 为了减轻细节损失，可以<strong>从VQGAN的encoder（D.Enc）提取特征并添加到第一帧的输入噪声</strong>中。做出这样的选择是基于encoder完全重建原始图像的能力，实验证明使用local encoder可以比其他复杂的语义编辑器更好的保存图像内容，但是随着video的播放，图像畸变会更显著。即语义信息变弱，这与CLIP形成互补</p><h4 id="refinement-stage提纯阶段">Refinement stage（提纯阶段）</h4><p>在基础模型可以得到语义准确的低分辨率视频。但是面临噪声、时间和空间抖动变形的问题。因此精炼阶段的任务目标是： 1. 提高视频分辨率，从448 * 256到1280 * 720 2. 提高时空连续性，解决伪影问题</p><p>为了达成目标，训练了一个单独的VLDM，专门处理高质量、高分辨率的数据。在第一阶段生成视频的基础上使用SDEdit方法、</p><p>精炼模型与基本模型不同，使用用户提供的简单文本（比如几个单词）作为条件，而不是使用参考图像，因为当两阶段输入条件相同时，实验发现视频矫正的有效性显著降低，可能是因为引入了类似的映射削弱了模型的恢复能力，</p><p>总的来说，先使用CLIP对文本进行编码，并通过cross-attention注入3D Unet，再基于基础阶段的模型，使用高质量video训练一个high-resolution模型</p><h4 id="train-and-inference">Train and Inference</h4><ol type="1"><li>基础模型：使用<a href="https://arxiv.org/abs/2304.08818">SD2.1</a>的预训练参数初始化3D Unet，使I2VGen-XL具有初始的空间生成能力。然后再进行训练，空间层的参数更新通过一个系数γ = 0.2控制，这个系数按比例缩小</li><li>精炼模型：使用基础模型的参数初始化，然后采用相同的训练方法。为了提高模型的时空建模能力，专门再初始噪声图上采用两阶段进行训练。 （1）再整个high-resolution数据集上训练 （2）对精挑细选的100w个高质量视频子集进行一轮微调</li></ol><p>在图像生成过程中，使用去噪过程连接两个模型（类似SD2.1）。根据生成效率、生成质量以及分辨率的不同，采用DDIM和DPMsolver++</p><p>在基础模型运行结束后，将视频resize到1280 * 720，执行DDIM去噪的反向过程，再使用精炼模型去噪来获得最终的high-resolution视频，公式如下： <img src="20231114210548.png"> $ c_i $ 和 $ c_t $ 分别表示输入的参考图像和文本prompt，$ _{θ,i} $ 和 <span class="math inline">\(\epsilon_{θ,t}\)</span> 分别表示基础模型和精炼模型的去噪过程</p><h2 id="experiments">Experiments</h2><h4 id="数据集">数据集</h4><ol type="1"><li>WebVid10M</li><li>LAION-400M</li><li>其他相同类型的视频文本对和图像文本对构成的私有数据集</li></ol><h4 id="参数">参数</h4><p>优化器：AdamW，固定学习率</p><p>使用1:1:1:5的比例提供1、8、16、32帧的视频 使用1:2:4:1的比例提供1、4、8、16FPS的视频 即，当FPS=1时，输入的是静态图像</p><p>对于基础模型：使用中心裁剪得到H=256，W=448的视频 对于精炼模型：使用中心裁剪得到H=720，W=1280的视频</p><h4 id="模型对比情况">模型对比情况</h4><p>I2VGen-XL和现在最强的Gen2和Pika对比，分别生成三种视频（伪现实，现实，抽象）。优点运动性更好（Gen2和Pika用过的都知道，生成的虽然说是视频，但其实更接近静态图像），输入图像仍然会丢失一些细节。另外实验中还发现，<strong>图像语义的保持程度和运动强度之间呈现出一定的权衡关系</strong>（运动幅度大了，自然结构就不容易保持） <img src="20231114221142.png" alt="大模型对比"></p><h4 id="消融实验">消融实验</h4><p>精炼前后生成的视频差别：一眼看过去好像差别不大，但细节差距很大，比如更精致的面部和身体特征 <strong>（商用的要求）</strong>。这说明精炼后的模型空间特征的提取和表达显著增强 <img src="20231114221820.png"></p><h4 id="定性分析">定性分析</h4><figure><img src="20231114222453.png" alt="实验结果"><figcaption>实验结果</figcaption></figure><p>生成稳定的人体运动仍然是视频合成中的一个主要挑战。论文还专门验证了I2VGen XL在<strong>人体图像</strong>上的稳健性 <img src="20231114222524.png"></p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Video Diffusion Models</title>
    <link href="/2023/11/10/Video-Diffusion-Models/"/>
    <url>/2023/11/10/Video-Diffusion-Models/</url>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2204.03458">Video Diffusion Models</a></p><p>阅读时间：2023-11-10 阅读目的：在图像生成领域，学者在SD架构的基础上，通过研究Cross-attention，Self-attention等模块，诞生了很多图像编辑算法。VDM在2022-04提出，现在是各种大规模视频生成模型的主流架构。因此，想要在现在的开源大模型基础上做些什么，必须要对最基础的架构有了解</p><h2 id="introduction">Introduction</h2><p>扩散模型很有用，但是没办法用在视频生成领域，因此论文提出一种扩展Unet模型的方法，让Unet可以时序建模，应用在视频生成领域</p><h2 id="background">Background</h2><p>写了扩散模型的推导过程</p><h2 id="method">Method</h2><p><img src="20231110155354.png"></p><p>结构很简单，就是w 一个Unet结构</p><p>常规部分： 1. 先进行空间下采样（spatial downsampling），再进行空间上采样（spatial upsampling） 2. 在每一层空间上通过跳跃连接（skip connections）在上采样时同步下采样过程的特征图 3. 为了引入文本这类的条件信息，每个2D卷积残差块后面还跟着一个注意块或者说空间注意块（spatial attention block）和交叉注意力块（cross-attention block）</p><p>总结Unet的零件结构如下图：<img src="unet.jpg"></p><p>如果要细致解析Unet或学习它在AIGC领域的作用，可以看以下两篇博客： <a href="https://zhuanlan.zhihu.com/p/642354007">深入浅出完整解析Stable Diffusion中U-Net的前世今生与核心知识 - 知乎 (zhihu.com)</a> <a href="https://zhuanlan.zhihu.com/p/632809634">深入浅出完整解析Stable Diffusion（SD）核心基础知识 - 知乎 (zhihu.com)</a></p><p>改变的部分： 1. 将原UNet中的2D卷积替换成了space-only 3D卷积（space-only 3D convolution），举例来说，如果原来用的是3x3卷积，那么现在就要把它替换为1x3x3卷积（其中第一个维度对应视频帧，即时间维度，第二个和第三个维度对应帧高和帧宽，即空间维度 2. 空间注意块仍然保留，但只针对空间维度进行注意力操作，也就是把时间维度flatten为batch维度。即[B, T, C, H, W] -&gt; [B * T, C, H, W] 3. 在每个空间注意块后面，新插入一个时间注意块（temporal attention block），在第一个维度即时间维度上执行注意力，并将空间维度flatten为batch维度。 5. 在每个时间注意力块中使用相对位置嵌入（relative position embeddings），以便让网络能够不依赖具体的视频帧时间也能够区分视频帧的顺序（<a href="https://www.zhihu.com/tardis/bd/art/577855860?source_id=1001">Swin Transformer之相对位置编码详解 (zhihu.com)</a>）</p><p>这种时空分离注意力有一个好处是可以<strong>对视频和图片生成进行联合建模训练</strong>。就是说可以在每个视频的最后一帧后面添加随机的多张图片，然后通过掩码的方式来将视频以及各图片进行隔离（比如填充0），从而让视频和图片生成能够联合训练起来</p><h2 id="我的看法">我的看法</h2><p>VDM带来的贡献： 1. 时空分离注意力可以对视频和图片生成进行联合建模训练 截止2023-11-10，数据集一直是文本视频模型研究钟面临的一个重大问题。因此在大模型训练时需要辅以大量的文本图片对来学习语义信息。 2. 原本SD对应的Unet架构很有潜力，在此基础上进行微调，就可以得到一个视频生成模型</p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VideoCrafter1</title>
    <link href="/2023/11/09/VideoCrafter1/"/>
    <url>/2023/11/09/VideoCrafter1/</url>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/abs/2310.19512">VideoCrafter1: Open Diffusion Models for High-Quality Video Generation</a></p><p>阅读时间：2023-11-09 阅读目的：这是2023年10月腾讯才出的开源视频生成大模型，具有研究价值</p><h2 id="我的看法">我的看法</h2><p>作为可以上榜单的开源大模型，后续有很多可以围绕着展开的工作，相比于在SD上微调，显然在VideoCrafter1上微调会有更好的效果</p><h2 id="abstract">Abstract</h2><p>提出了第一个开源的I2V基础模型，能够将给定的图像转换为视频剪辑，同时保持内容保存约束，希望可以给社区的技术进步做出贡献</p><h2 id="introduction">Introduction</h2><p>T2I模型有：SD T2V模型有：Make-A-video、Imagen video 基于级联模型 LVDM、Magic video、ModelScope、Align your Latents 基于SD，扩展时间层 Make-A-video、Imagen video、效果还不错，但是都是闭源的，Gen-2（Gen-1的论文阅读记录<a href="https://zhuanlan.zhihu.com/p/573407864">点这里</a>）、Pika Labs、Moonvalley只能使用，没有开源模型和论文</p><p>ModelScope只能生成256 * 256的视频 Hotshot XL旨在将SDXL扩展到视频模型中，并生成8帧分辨率为512×512的gif AnimateDiff提出将LORA SD模型的时间模块与空间模块相结合，但LORA模型在风格和概念构成能力方面限制了范围。</p><p><strong>现在仍然缺乏能够生成高分辨率和高质量视频的开源通用T2V基础模型</strong></p><p>I2V模型有：Gen-2和I2VGen XL</p><p>Gen2支持I2V，但是生成的运动方式很少，并且不开源。唯一的开源通用I2V模型是I2VGen XL，模型使用图像embedding来代替文本embedding来调整预训练的T2V模型。但是，它不能很好的遵循参考内容和结构。因此，<strong>开源社区迫切需要一个良好的I2V模型</strong></p><p>所以文章分别提出了两个高质量视频生成的扩散模型：一个T2V模型，一个I2V模型</p><p>T2V模型建立在SD 2.1的基础上，通过将时间注意力层纳入SD UNet来捕捉时间一致性，采用图像和视频联合训练的策略来防止概念遗忘，可以生成1024 * 576、持续两秒的视频。</p><p>I2V模型基于T2V模型，接受文本和图像输入，使用Clip提取图像embedding并通过cross-attention注入SD的Unet结构（和SD的文本embedding注入一样）</p><h2 id="related-works">Related Works</h2><p>Imagen video和VDM提供了不错的级联方法</p><h2 id="methodology">Methodology</h2><figure><img src="20231109185415.png" alt="模型结构"><figcaption>模型结构</figcaption></figure><p>整体是在SD的Unet结构基础上做更改： 1. VAE（来自SD）负责将视频逐帧编码到隐空间 2. 讲2D卷积扩展为3D卷积，每一层还包括spatial transformers 和 temporal transformers 3. 语义注入调整为文本embedding和图像embedding的混合注入（也可以只有图像或者文本） 4. 去噪过程T和视频fps均正弦编码后通过MLP映射再相加融合</p><p>对于T2V扩散模型，条件文本embedding对最终输出视频的视觉内容起着至关重要的作用。为了以兼容的方式向视频模型提供图像信息，必须将图像投影到文本对齐的embedding空间中。我们建议学习这种具有丰富细节的嵌入，以增强视觉逼真度。</p><p>文本embedding和图像embdding的混合注入过程： <img src="20231109191442.png"> 对文本而言：通过Clip就可以得到文本embedding 对图像而言：虽然clip对齐了文本和图像，但主要是在语义级别上对齐，捕获细节的能力较弱。因此可以使用Clip VIT结构中最后一层的patch表示图像信息。然后再训练一个投影网络，将patch转化为图像embedding</p><p>最后结合文本embedding和图像embedding，注入cross-attention： <img src="Pasted%20image%2020231109195107.png"></p><h2 id="experiments">Experiments</h2><p>这种大规模通用模型，从训练细节中我们也可以学到很多东西 #### 数据集 LAION COCO：包含6亿张图像的高质量文本图像数据集 WebVid-10M：由文本描述和来自视频网站的视频所构成的短视频数据集 自己收集的数据集：包含1千万个分辨率大于1280 * 720视频的大规模高质量视频 #### 训练方法 采用SD使用的训练方法，从低分辨率到高分辨率训练 1. 用256 * 256分辨率的图像对从图像模型扩展而来的模型训练80K轮，batch_size=256 2. 用512 * 320分辨率的视频微调模型136k轮，batch_size=128 3. 用1024 * 576分辨率的视频微调模型45k轮，batch_size=64</p><p>对于I2V模型则是训练一个映射，从图像embedding到cross-attention的embedding空间</p><h4 id="评估指标">评估指标</h4><p><a href="https://evalcrafter.github.io/">EvalCrafter</a>于2023-10-17挂在arXiv上，提出了一种大型视频生成模型的测试基准和评估指标</p><p>截止写文时的榜单，Floor33就是本文对应的模型 <img src="20231109172629.png" alt="榜单"></p><h4 id="实验结果">实验结果</h4><figure><img src="20231109195235.png" alt="定量分析"><figcaption>定量分析</figcaption></figure><figure><img src="20231109195321.png" alt="人类偏好实验"><figcaption>人类偏好实验</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>投资框架</title>
    <link href="/2023/11/07/%E6%8A%95%E8%B5%84%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/11/07/%E6%8A%95%E8%B5%84%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>为了避免家庭收入下滑，也为了财务自由的梦想，理财是避不开的一条路。为了系统学习投资理财，陆陆续续看了很多书，踩了很多坑，无论投资基金还是投资股票，如果没有系统化的知识结构，没有自己的交易系统，就难免被各种消息影响，让情绪主导自己的判断。我总结出了自己的交易系统架构</p><h2 id="基本面分析">1、基本面分析</h2><p>基本面分析分为宏观基本面分析和公司基本面分析。</p><h3 id="宏观基本面分析">（1）宏观基本面分析</h3><p>宏观经济分析其实就是抓住经济周期，在经济下行期，股市大盘难以取得合适的收益。通过分析GDP增速，房地产销售面积增速，PMI，CPI，PPI，MLF并结合政策面消息可以大致定位宏观周期情况，并作出合适的资产配置 1. 利率下调（宽货币）+ M2增速下降（紧信用） = 萧条期 2. 利率下调（宽货币）+ M2增速上升（宽信用） = 复苏期 3. 利率上调（紧货币）+ M2增速上升（宽信用） = 过热期 4. 利率上调（紧货币）+ M2增速下降（紧货币） = 衰退期</p><p>单论大盘而言，有很多指标可以判断现在股市的位置： 1. 股债性价比 - 股债性价比= （1/PE）/ 十年国债收益率， 常年在1.5-3.0之间波动。利率太低时不适用 - 股债利差 = （1/PE）-  十年国债收益率，05年以来，最大值7.1%，最小值-2.6% - 大盘成长、大盘价值、小盘成长、小盘价值可能产生不一致的结构行情。前面两者加起来是沪深300，后面两者加起来是中证1000 2. 看头部公司（茅台）有没用跌到位，如果茅台一直在震荡，没有怎么下杀，下跌可能还没结束 3. 分析市场情绪（上证50ETF看跌期权隐含波动率），这个我没怎么研究过</p><h3 id="公司基本面分析">（2）公司基本面分析</h3><p>判断了整个行业周期，如果想要买股票，还要选出合适的公司，A股大量的公司中可能只有少数是值得我们长期投资的，我们需要筛选出这些公司，并且长期跟踪它们的业绩和股价情况</p><p>公司基本面的分析实际上是财务分析，因为做分析的目的说到底还是挑选出赚钱的公司。</p><p><strong>好公司 = 好数据 + 好行业 + 好生意</strong></p><h4 id="好数据">好数据</h4><p>好数据是指有好的财务报表，其中ROE是一个关键指标。</p><p>ROE的分母是净资产，也就是股东自己投入的钱，分子则代表净利润，因此，净资产收益率在数学上表示的就是“股东每投入一元钱，能产生多少净利润”，这就衡量了一家公司“用投入的钱赢得利润”的能力</p><p>ROE=净利润/平均净资产=销售净利率×总资产周转率×权益乘数 - 销售净利率 = 净利润 / 营业总收入 - 总资产周转率 = 营业总收入 / 平均总资产 - 权益乘数 = 平均总资产 / 平均净资产 从公式看，根据ROE的三个乘子，可以将赚钱的公司分为三种不同类型： （1）销售净利率高代表盈利能力很强的“茅台型”公司。消费、医疗、科技是其中的代表。护城河一般是品牌、准入门槛等 （2）周转能力很强的“沃尔玛型”公司，常出现在工业贸易和零售业。护城河一般是规模效应</p><p>具体的方法是基于3-5原则使用七步分析法： <strong>3-5原则</strong>：至少对比3-5家状况最接近的同行，看看它3~5年的历史数据（一个短周期基本就是3-5年）。如果一家公司的上市时间很短，公开披露的数据不足5年甚至不足3年，则可以放一放，。该原则贯彻在七步分析法中 <strong>七步分析法：</strong> 1. 将连续5年ROE&gt;15%的公司加入股票池 - 根据具体情况根据周期的位置可以调整，看三年还是五年，ROE是15%还是10%都没有固定的标准，选择15%是因为大盘常年的ROE在10%左右。 - 连续5年ROE都达标说明公司的盈利比较稳定 1. 现金收入比率 = 销售商品、提供劳务收到的现金/营业收入 这个指标说明了 1 元营业收入里有多少是现金。该指标值最好维持在 1 左右，即营业收入与收到的现金相近，如果达不到 0.8，说明这家公司有部分收入没有收现，盈利质量不容乐观 3. 毛利率 毛利率可以反应产品的竞争率（茅台高达90%），它不一定要比同行高，但一定不能低太多，但是当某种产品的毛利率明显高于同行时，我们要找到其中的逻辑，否则公司很有可能存在造假行为 4. 净利率 净利率和毛利率之间的差距在于期间费用，是造假重灾区，我们需要判断净利率的含金量 - 净利润的水平如何？ 和同行相比，净利润情况如何 - <strong>净利润的现金含量有多少？</strong>(造假照妖镜) 净利润现金含量 = 经营活动产生的现金流量净额 / 净利润。净利润现金含量衡量的是：一家公司的净利润里有多少为现金。该数字最好常年维持在 1 左右，笔者个人的最低限度为 0.8。<strong>现金含量低说明可能有些不好的情况，要小心！</strong> - 净利润水分如何？ <strong>扣非净利润占比 = 扣非净利润 / 净利润</strong>。数值越接近1说明盈利中的水分越少，有的公司可能通过出售一些资产来提高净利润，提高非经常性损益，显得净利率高，财务报表好看，但这其实对经营没有帮助 5. 公司周转能力（同行之间对比） - 应收账款周转率 = 营业总收入 / 平均应收账款余额 晶瑞电材、中环股份、隆基股份都是半导体材料生产商，它们是2B模式，下游都为半导体器件供应商。查询“晶瑞电材、中环股份、隆基股份最近 5 年应收账款周转率”，会发现中环股份在 2016—2018 年有最高的应收账款周转率，1 年周转达 6 次以上，这意味着中环股份只需要 2 个月就能收回客户的尾款 - 存货周转率 = 营业成本 / 平均存货余额 海天味业、恒顺醋业、千禾味业都是 A 股的调味品公司，商业模式都为 2C 模式，我们在问财上查询“海天味业、恒顺醋业、千禾味业最近 5 年存货周转率”可以发现，海天味业的存货周转率明显高于同行 6. 公司杠杆情况 - 衡量每一块钱债务有多少块现金担保 = 现金及其等价物 / 带息债务 只有带息债务是危险的，因此资产负债率仅考虑了公司整体负债水平，并没有将负债区分为有息负债或是无息负债，无法客观地评价一家公司的真实负债情况 7. 财务之外的因素？ 财务分析可以筛选出来一个数据合格的公司，但是投资还需要考虑一些财务报表之外的事情，例如是否存在护城河？<strong>别人没有，也很难拥有的那个优势就是护城河</strong>。例如茅台五粮液的护城河是社会认可度；沃尔玛的护城河是规模效应，可以把商品成本压低；医疗行业的护城河是准入门槛，病人和医生一般倾向于使用更熟悉的器械。</p><p>通过了上述关卡的公司可以认为是有好数据的公司，但只有好数据还不够。如果公司在一个夕阳行业，那么现有的好数据就只是落日余晖罢了</p><h4 id="好行业数据可以从行业研报中获取">好行业（数据可以从<a href="%5B前沿知识库%20(askci.com)%5D(https://wk.askci.com/ListTable)">行业研报</a>中获取）</h4><p>对满足好数据要求的公司，我们要进一步判断它处在什么行业。我们可以从以下三个方面来分析一个行业： 1. 行业规模 行业规模是蛋糕的大小。每个行业都是有生命周期的，有的行业处于成长期，而有的行业处于衰退期。我们要用动态的视角看待行业规模，除了这块蛋糕现在有多大，我们还应判断其未来能做到多大 2. 渗透率 渗透率衡量的就是蛋糕还有多少能吃。即使行业规模很大，但如果已经被吃掉了大部分，留下的份额也就不多了，渗透率被用来衡量一个市场的成熟度如何，例如银行业规模很大，每个人都有存款需求，但是渗透率很高 - 行业的渗透率在 <strong>10%~50%为宜</strong>，渗透率落在这个区间的行业往往会进入高速成长期（2021年10月新能源车16.4%），低渗透率意味着行业不成熟，需要观望，例如VR眼镜 3. 竞争格局 如果蛋糕足够大，而且渗透率远未饱和，那么就会有很多人想来分一杯羹，市场竞争将不可避免，商家充分竞争之后呈现的结果就是竞争格局，我们通常以<strong>市场占有率</strong>作为衡量竞争格局状况的主要指标 - 三四定律：在一个稳定的市场中，有影响力的竞争者数量不会超过三个，且最大竞争者的市场份额不会超过几者中市场份额最小者的四倍。 也就是说，在一个成熟的行业中，真正能获得理想回报率的公司只有行业前三名，剩下的公司都将挣扎在生存边缘。前三家龙头公司亦将呈现出明显的马太效应，即前一名的份额为下一名的 1.5~2 倍，第四名及以后的公司将只能吃到残羹冷炙。三四定律并非绝对，它只是亨德森在观察各个行业的发展历史后总结的经验法则，但是在许多成熟行业中，我们确实可以看到这种“赢家通吃”的现象 - 要避开的行业： （1）要避开竞争格局不明朗的行业，因为你无法确定谁会成为行业龙头 （2）要避开竞争格局永远无法集中的行业，例如餐饮业</p><h4 id="好生意">好生意</h4><p>一个身处好行业，有好数据的公司就已经值得投资了，但是我们还要进一步判断一些主观的东西。即这家公司的生意情况如何，有没有行业护城河？</p><p><strong>好公司 = 好数据 + 好行业 + 好生意</strong> 通过上述检验后脱颖而出的三好公司就是值得投资的好公司，对待这些进入投票池的但是我们仍然需要客观的回答四个问题： 1. 这家公司靠销售什么商品或服务获得利润？ 2. 它的客户为什么从它这里采购而不是其他地方？ 3. 资本逐利，为什么其他资本没有抢占它的市场份额？ 4. 假设其他产业巨头携巨资参与竞争，该公司能否保住份额?</p><h2 id="估值分析">2、估值分析</h2><p>通过了基本面分析，我们知道了现在的经济形式，也筛选出了值得投资的公司，但这并不意味就要立刻买入。价值投资很重要的一点就是给公司做估值建模。</p><h3 id="dcf自由现金流贴现法">DCF（自由现金流贴现法）</h3><p>将未来的现金流都折算到今天，但是DCF计算起来繁琐，而且结果对贴现率和增长率都很敏感，因此可以优化一下（从某博主那里学到），宁愿要模糊的正确不要精准的错误。</p><p>首先，我们需要明确一个原则：有成长性的公司，可以使用成长性对冲安全边际，但收益率（PE的倒数）绝对不能低于无风险收益率。</p><p>这一条的意思也就是说，如果按照格雷厄姆的投资标准，在广泛高估的A股市场可能挑不出来几个合适的公司，优秀的公司（例如茅台）始终等不到合适的安全边际。如果一家公司有明确的成长性，那么可能只需要收益率刚刚好高于无风险收益率就可以买入，成长性就是它的安全边际。至于如何判断有没有成长性......这只能做定性判断。</p><p>优化后的DCF认为一家资本支出低的公司，净利润可以近似为现金流，在这种情况下： 1. 合理估值上限 = 无风险利率的倒数（2.74%的十年期国债收益率 = 36.5PE），通常选25-30 2. 现在的合理估值（买入价格） = 三年后净利润（或EPS） * 合理估值上限 / 2 3. 卖出原则：50、55、60市盈率分三次清仓</p><p>注意事项： 1. 企业利润是真的吗？利润可持续吗？是否需要大量资本支出维系盈利水平？、 2. 估测三年后净利润不要使用30%以上的增速 3. 单只股票持仓不要高于40% 4. 确定性越高的企业，越倾向于在估值上限就买；确定性越低，越倾向于更低的买点。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">格雷厄姆：只要有钱投资股票，就不要推迟购买；除非整体市场估值水平超出合理估值标准<br></code></pre></td></tr></table></figure><h2 id="技术分析">3、技术分析</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">问题：在合适的经济周期选出了符合估值要求的公司，是不是就要买入了呢？<br>答案：<span class="hljs-keyword">No</span>！<br></code></pre></td></tr></table></figure><p>一家公司的股票涨跌和我们当下是否买入没有任何关系，价值投资者很容易陷入的误区就是算出了股票的合适估值，但是买入之后仍然跌跌不休。</p><p>在经济下行期，大多数公司的业绩都比较一般，就算业绩仍然保持的不错，也很难在整体下挫的大盘中独善其身，哪怕是茅台也一样。这时候市场上的投资者被情绪裹挟，基本面属于某种程度上的失效状态。</p><p>这个时候有两种解决方案： 1. 定投：由于确定了进入低估范围，用定投分散投资化解风险 2. 引入技术分析</p><p>炒股有句话不接下跌的飞刀。技术分析的核心是心理学，在平时意义不大，但是在连续下跌或者上涨过程中，大众的情绪失控时，可以作为参考指标。</p><p>提供两种指标： 1. BBI在漫长的下跌过程中，突然上穿 2. 60日均线 3. <a href="https://zhuanlan.zhihu.com/p/641622153">放量行情中展现的信息</a> 行情反转需要供需双方出现本质上的力量变化，需求减少不代表反转，顶多涨得慢，但<strong>供给增加才是，表现为放量</strong> - <strong>牛市结束的大背景下，长K+放量，考虑止盈</strong></p><h2 id="总结">总结</h2><p>投资是一门必修课，也是一门要钻研一辈子，一直关注的事业。市场先生是不会错的，会错的只有自己。本文系统总结了投资时的筛选、估值、确认买点这三个流程，心中有锚点，投资自然不慌。</p><p>最后放一些分析时可能会用到的网页</p><p>工具类： - <a href="%5B前沿知识库%20(askci.com)%5D(https://wk.askci.com/ListTable)">研报</a> - <a href="%5B财经数据%20_%20居民消费价格指数(CPI)%20_%20数据中心%20_%20东方财富网%20(eastmoney.com)%5D(https://data.eastmoney.com/cjsj/cpi.html)">PPI CPI PMI M2 新房价指数</a>和 <a href="https://tradingeconomics.com/china/indicators">China Indicators</a> - <a href="https://cn.investing.com/rates-bonds/china-10-year-bond-yield">十年期国债收益率</a> - <a href="https://www.dashiyetouzi.com/tools/stock.php?stock_id=601318">股债性价比</a> - <a href="https://eniu.com/">亿牛网----PE PB 股息率</a></p><p>知识类： - <a href="%5B自由现金流折现法（DCF）详尽讲解（附公式）%20前文：估值的方法——自由现金流贴现法（DCF）常用的估值方法有自由现金流折现法、股利贴现法、市盈率估值法、市净率估值、市...%20-%20雪球%20(xueqiu.com)%5D(https://xueqiu.com/2524803655/244192476)">DCF详解</a> - <a href="https://xueqiu.com/2598256636/236422531">如何基于投资理念和投资框架，细分基金经理的投资风格？——基金风格专题报告</a></p>]]></content>
    
    
    <categories>
      
      <category>经济管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资理财</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book Chapter3-PageTable</title>
    <link href="/2023/09/20/xv6-book-Chapter3/"/>
    <url>/2023/09/20/xv6-book-Chapter3/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter3-页表">Chapter3 页表</h1><p>之前的内容围绕进程展开，大概了解了操作系统是什么，第一个进程如何运行，操作系统提供的系统如何工作，学习了进程隔离的概念。但是既然每个进程都有自己单独的内存空间，那么这些空间到底是怎么被分配使用的？本章的所有内容都围绕物理内存和虚拟内存展开。</p><h2 id="内存">内存</h2><p>内存是计算机的核心组件，由RAM组成，断电后数据会丢失。我们可以将内存看作是一个<code>[0,max]</code> 的<strong>字节</strong>数组（RISC-V加载与储存数据都是以字节为单位，取单字或双字），那么内存地址，也就是这个大数组的索引，知道内存地址就可以快速的访问某个具体的字节。</p><p>我们知道通过ld sd等汇编指令，程序可以很轻松的访问内存空间，那么一个进程是否可以读取或写入另一个进程对应内存空间的内容？答案当然是否定，为了避免这种危险的行为，操作系统提供了虚拟内存的概念：每个进程都拥有自己独立的虚拟内存空间，虚拟内存地址从0开始，给了一种进程在使用整个内存的错觉。</p><p>由于使用的地址空间是虚拟的，自然也就不存在危险行为，不同的进程被天然隔离开。</p><p>但是如果需要CPU完成指令，终究是需要依托内存硬件的。这就涉及到虚拟地址到物理地址的映射。这个映射过程可以将虚拟地址（VA）映射到实际的物理地址（PA）上，程序运行时不需要关心物理内存到底是多少，只需要专注自己的内容即可，CPU会更根据映射关系表，从虚拟地址找到对应的物理地址，实现前后解耦。</p><p>这个映射的过程是通过CPU提供的<strong>分页硬件</strong>MMU实现的。 <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">MMU:是集成到CPU内的一个组件，主要是负责读取虚拟内存的映射表<span class="hljs-comment">(查看页表)</span>，并通过映射表将虚拟地址转换为物理地址。  <br>RISC-V指令可以操作虚拟地址<span class="hljs-comment">(VA,virtual address)</span>。<br></code></pre></td></tr></table></figure></p><p>注意：从CPU的角度来说，一旦MMU打开了，它执行的每条指令中的地址都是虚拟内存地址。 <img src="20230920190826.png"></p><p>a0寄存器中的0x1000是一个虚拟地址（VA），通过MMU映射为物理地址（PA）0xFFF0，然后再利用这个物理地址再内存中找到对应的位置。</p><p>satp(Supervisor Address Translation and Protection Registers)是存放映射表物理地址的寄存器。由于映射表保存在内存中，satp记录了这张表的开始位置，所以MMU可以通过satp迅速找到内存中保存的映射表。例如在上图中VA = 0x1000，其中satp = 0x10的物理地址中保存的是这个VA的映射表。</p><p>每个程序都会有自己独立的映射表，并且这个映射表定义了应用的地址空间。当进程上下文切换时，同时也需要切换satp寄存器的内容，从而获得新的表单。这样的话就可以将相同的虚拟地址翻译为不同的物理地址了（读写satp寄存器在CPU管理者模式，也就是操作系统内核态才可以使用）。</p><p>这个映射表被称为页表（page table），页表带来了以下好处： 1. 增强了进程间的隔离性 2. 实现了物理内存的复用</p><h4 id="内存管理">内存管理</h4><p>建立了将虚拟地址和物理地址解耦的方案，那么如何分配与管理内存空间就成为了一件需要考虑的事情，一般来说有两种方法： 1. 分段；将空间分割成<strong>不同长度</strong>的分片，这样使用灵活但是<strong>空间碎片化</strong>的问题会变得更加严重 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">外部碎片：物理内存中的空闲空间被分割成不同大小的小块，后续分配请求可能失败，因为没有一块足够大的连续空闲空间，尽管总的空闲空间超出了请求的大小。  <br>内部碎片：分配程序给出的内存块超出请求的大小，在块中超出请求的空间可能因此而未被使用，造成了发生在已分配单元内部的浪费。<br></code></pre></td></tr></table></figure> 2. 分页；将空间切成<strong>固定长度</strong>的分片，彻底解决了外部碎片的问题。每个固定长度的单元我们称之为<strong>页Page</strong>，然后我们将物理内存看成是定长槽块的阵列，这些槽块大小与页相同，每个槽块叫做<strong>页帧Page Frame</strong>，每个页帧都可以装载一个<strong>虚拟内存页</strong>。同时，分页很灵活，能很好地支持稀疏虚拟地址空间。分页的逻辑如下图所示：</p><p><img src="20230920202213.png" alt="分页"> CPU接受到一个地址（一般是uint64类型变量），由索引p + 偏移量d组成，根据p在页表中找到对应的物理页地址f。物理页地址 + 页内偏移量就可以索引到一个具体字节的物理地址。</p><p>总结：RISC-V指令（用户指令或内核指令）对<strong>虚拟地址</strong>进行操作，物理地址则是用于寻址实际物理内存RAM的（注意：RISC-V可以处理64位的虚拟地址，但物理地址只被设计成56位（够用了）），两者之间通过页表建立映射关系，页表保存在satp寄存器中，每个进程都有一个变量存储各自satp的值（注意：不是说每个进程都有自己的satp寄存器，而是每个进程有自己的页表，使用时，赋值给satp寄存器，供CPU使用）</p><p>xv6使用分页的方式管理内存，具体如下： <img src="20230920202919.png" alt="VA映射到PA"></p><p>xv6运行在Sv39 RISC-V处理器上，因此64位虚拟地址中，只有低39位在被使用，剩下的25位都暂时保留，供日后的设计者利用。蓝色部分EXT表示不被使用，剩下的39位被划分为27位索引和12位偏移量（2的12次方正好是4K，用来表示一个页内偏移量，所以一个页的大小是4KB）</p><p>前文说到，RISC-V的分页硬件，将每个虚拟地址映射到一个物理地址，页表会以某种形式的表项来保存这种映射关系，这种表项我们称之为<strong>页表条目PTE</strong>（Page Table Entry）。虚拟地址的高27位索引会指向了一个PTE。每个PTE由44位的<strong>物理页帧号PPN</strong>和10位的<strong>标志位Flags</strong>组成。总归54位，因此一个PTE可以用8个字节来存储（uint64）</p><p>PPN + Offset（偏移量） ，构成一个虚拟地址对应的物理地址，共56位。</p><p>总结：在页表转换一个虚拟地址时，首先提取出有效的39位，用高27位来索引对应的PTE，从PTE中我们可以得到44位的PPN，并且根据Flags检查一些权限，最后将44位的PPN和原虚拟地址的低12位Offset加在一起，得到最后56位的有效物理地址，接着就可以访问物理内存。</p><p>上述提到的内容是经过<strong>简化的页表的方案</strong>，实际的RISC-V页表采用的是三级页表。那么一级页表，页就是上面提到的图有什么问题呢？先给出PTE的计算公式：</p><p><strong><em>PTE 地址 = 页目录的地址 + 4 * 虚拟内存地址 / 4KB</em></strong></p><p>一级页表情况下，页目录地址由satp寄存器，虚拟内存地址也就是27位的index，这意味着每个进程需要使用2的27次方个PTE，每个PTE占8字节，总共1GB，这显然太大了，我们最终需要的仅仅是一个4KB的页（xv6进程的内存空间默认分配为4KB）。那<strong>是否可以不把所有 PTE 都放到页表中，当进程需要访问某段虚拟内存时，再把对应的 PTE 加载到内存中？</strong></p><p>答案是不行：因为 MMU 进行过虚拟内存映射时。按照公式，PTE是根据虚拟内存连续放置的，假设我们允许某些 PTE 不在物理内存，其他的PTE位置由于是计算出来的而不是查找出来的，因此这些PTE该放在哪还是放在哪，相当于那些被允许不在物理内存里的PTE，虽然人不在，但是座位却占住了，所以这种做法毫无意义。如果不按照公式，虽然PTE可以随处放了，但是查询PTE时只能顺序查找，时间复杂度从O(1)变成O(n)，性能大幅度降低</p><p>但是在三级页表的情况下，情况不一样了。 <img src="20230920212642.png" alt="三级页表"></p><p>整体的运行逻辑和一级页表没什么不同，把27位的索引平分成了9+9+9的三级索引， - 第一次页目录地址由satp提供，9位刚好可以表示512个PTE，因此L2表示偏移量，两者结合找到L1对应页目录所在位置 - L1页目录结合L1偏移量找到L0页目录的位置 - L0页目录结合L0偏移量，找到物理地址的PPN - 物理地址PPN，结合offset得到最后物理地址</p><p>问题：这个过程实际上涉及到的PTE数量似乎并不比一级页表少，为什么可以节省空间？ 1. 根据局部性原理，进程访问内存时，大部分时候只访问某一段内存，比如（8～16KB）。 2. 对于多级页表来说，因为需要按照公式计算定位，所以第一级页表，需要完整的加载所有 PTE 到内存中。按照上图，也就是 3 个 PTE，这一点也容易理解。 3. 剩下第二级第三级页表的 PTE，可以等到程序真实访问时，再加载到内存中。</p><p><strong>总而言之，多级页表情况下，只有一级页表的 PTE 条目需要完全加载到内存中（用来定位二级页表），而不同的二级页表之间，因为没有按照公式去快速定位的需求，所以二级页表可以选择是否加载到物理内存中。三级页表同理。</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**举个生动的例子**</span><br>学校有一百万个学生，每个学生都有自己的学号和手机号码，每个学生之间的学号都是连续的，也就是 1 ～ 100万。如果只有一级页表，也就是这张表里得有所有学生的信息（学号+家庭地址），校长想查找某个学生的手机号码时，先根据学号，利用公式快速算出它在表中的位置，然后找到这个位置，这个位置就记录了该学生的手机号码。<br><br><span class="hljs-strong">**但是这是一张巨大无比的表，打印出来的话，校长的公文包估计放不下去。**</span><br><br><span class="hljs-strong">**校委会就想出了多级页表的方法，将这一百万学生，按照连续的学号，分成一千个班，每个班一千个学生和一个班主任。比如 1 班学号是 1～1000，2 班是 1001～2000。**</span><br><br>校长的公文包里，每次只需要带上一张表，这张表记录了一千个班，每个班的班主任手机号。<br><br>当校长想找某个学生时，<br><br><span class="hljs-bullet">1.</span> 先根据学号，计算出他在哪个班。<br><br>2.在表中找到这个班，里面有这个班的班主任手机号。<br>（找到第二级页目录）<br><br>3.打电话给班主任，班主任再送来他们班的一张表，表中记录了这个班每个学生的手机号。<br>(等到程序真实访问时，再加载到内存中)<br><br>4.校长再根据学号，再这个班的班级表中找到这个学生和他的手机号。<br><br>上述这个过程是一个二级页表运行的过程<br></code></pre></td></tr></table></figure><h2 id="内存初始化">内存初始化</h2><p>如果没有代码，即使理解了页表运行的原理，也依然不明白如何实现，很容易忘记。在之前的文章中，我讲到了在start.c代码中，CPU特权从机器级变为特权等级，然后跳转到main.c中。<code>userinit()</code>，即运行第一个进程是main.c的最后一件事情（启动进程调度死循环不算），那么第一件事是什么呢？正是内存相关的初始化操作。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// start() jumps here in supervisor mode on all CPUs.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    、、、、、、、、、、、、<span class="hljs-comment">//省略</span><br>    kinit();         <span class="hljs-comment">// 初始化物理页</span><br>    kvminit();       <span class="hljs-comment">// 创建内核页表</span><br>    kvminithart();   <span class="hljs-comment">// 打开分页机制</span><br>    procinit();      <span class="hljs-comment">//为每个进程分配一个内核栈</span><br>    、、、、、、、、、、、、<span class="hljs-comment">//省略</span><br>  scheduler();        <br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="物理页初始化">物理页初始化</h4><p> Qemu 启动的时候会跳转到<code>0x80000000</code>，然后执行相应的指令，xv6 也就运行起来了，此时的第一件事就是初始化物理内存。所有的内容都包含在kalloc.c文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">kinit</span><span class="hljs-params">()</span>  <br>&#123;  <br>  initlock(&amp;kmem.lock, <span class="hljs-string">&quot;kmem&quot;</span>);   <span class="hljs-comment">//初始化锁，也就是给锁赋初值</span><br>  freerange(end, (<span class="hljs-type">void</span>*)PHYSTOP);  <br>&#125;<br><br><span class="hljs-comment">// extract the three 9-bit page table indices from a virtual address.  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXMASK          0x1FF <span class="hljs-comment">// 9 bits  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span><br><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa_start, <span class="hljs-type">void</span> *pa_end)</span>  <br>&#123;  <br>  <span class="hljs-type">char</span> *p;  <br>  p = (<span class="hljs-type">char</span>*)PGROUNDUP((uint64)pa_start);     <span class="hljs-comment">//使内存按照4K对齐，也就是将末尾的12位置为0</span><br>  <span class="hljs-keyword">for</span>(; p + PGSIZE &lt;= (<span class="hljs-type">char</span>*)pa_end; p += PGSIZE)  <span class="hljs-comment">//将内存按照PGSIZE（4KB）分页</span><br>    kfree(p);    <span class="hljs-comment">//初始化（或者说释放）内存空间并加入空闲列表</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>问题</strong>：什么是空闲列表（可利用空间表）？ <strong>答案</strong>：“空闲列表” 是动态内存管理的一种方法。通过把空闲内存划分成固定大小的数据块，而且利用指针字段把这些数据块链接起来，并使用一个指针指向首结点，这样就形成了一个单链表，即空闲列表（FreeList）</p><p><strong>好处</strong>：常常会有频繁申请、释放内存的需求，比如在发送网络报文时，每次都要分配内存以存储报文，等报文发送完成后又需要删除报文。为了避免频繁的new/delete对系统带来的开销，需要实现一个通用的FreeList机制。使用者总是从FreeList中分配内存，如果存在没有使用的内存块就直接摘出来使用，如果没有的话再从系统中分配。使用完毕后并不去直接delete该内存块，而是交给FreeList保管。</p><p>当用户请求分配时，系统从FreeList中删除一个结点分配之；当用户释放其所占内存时，系统即回收并将它插入到FreeList中，因此，FreeList亦称为“存储池”</p><p>FreeList有三种结点结构： 1. <strong>结点大小相同</strong>：把内存分为大小相同的若干块，将各块链接起来，分配时从头上摘取，用完后插入到头上，这实际是链式栈。 2. <strong>结点有若干规格</strong>：当用户所需内存量不同，但只允许在几种规格间选取。这种情况下，可利用空间表中可以维护几条链表，同一链表中的结点大小相同。如大小为2、4、8字节，可以构造3个链表。 3. <strong>结点大小不等</strong>：内存块大小不固定，只有一个链表。通常操作系统的可利用空间表属于此类。即FreeList中只有一个大小为整个存储区的结点。随着分配和回收的进行，FreeList的结点大小和个数也随之而变化。—— 由于结点的大小不同，在分配时并不是FreeList中的任一结点都能满足，而需要按照申请的长度在FreeList中进行检索，找到其长度大于等于申请长度的结点，从中截取合适的长度。这就涉及到分配策略 - 首次适配法：从链表头指针开始查找，找到第一个大于等于所需空间的结点即分配。（分配时查询，释放时插入表头）。优点是速度快，缺点是可能把较大块拆分成较小的块，导致后来对大块的申请难以满足，这种分配策略适合于系统事先不掌握运行期间可能出现的请求分配和释放的信息的情况。 - 最佳适配法：要求结点从小到大排列，找到第一个大于等于所需空间的结点即分配。（分配和回收时都需要查询）。优点是使无法满足大请求块的可能性降到最低，但可能导致严重的外部碎片问题 —— 这种分配策略适合请求分配内存大小范围较广的系统 - 最差适配法：要求结点从大到小排列，总从第一个结点开始分配。（分配时不需查询，回收时查询）。最佳适配法的。最差适配法的优点是使得空闲块长度趋于一致，适合于分配请求长度比较均匀的情况。</p><p>在xv6中，内存以4KB位标准大小，被切割成若干个块，不同的块之间按照单向链表的方式连接，每次进程申请内存时，就分配一个4KB的块给它。</p><figure><img src="20230921144414.png" alt="空闲链表freelist"><figcaption>空闲链表freelist</figcaption></figure><p>更深入的看kfree()代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[]; <span class="hljs-comment">// first address after kernel.  </span><br>                   <span class="hljs-comment">// defined by kernel.ld.</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> &#123;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">next</span>;</span>  <br>&#125;;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span>  <br>&#125; kmem;<br><br><span class="hljs-comment">// Free the page of physical memory pointed at by v,  </span><br><span class="hljs-comment">// which normally should have been returned by a  </span><br><span class="hljs-comment">// call to kalloc().  (The exception is when  </span><br><span class="hljs-comment">// initializing the allocator; see kinit above.)  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span>  <br>  <br>  <span class="hljs-comment">//确认是否对齐  </span><br>  <span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)  <br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);  <br>  <br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.  </span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);  <br>  <br>  r = (<span class="hljs-keyword">struct</span> run*)pa;  <br>  <br>  acquire(&amp;kmem.lock);  <br>  r-&gt;next = kmem.freelist;  <br>  kmem.freelist = r;  <br>  release(&amp;kmem.lock);  <br>&#125;  <br>  <br><br></code></pre></td></tr></table></figure> next是一个嵌套指针，自己占用了一段空间并指向一个内存块，kmem是链表的头节点，表示整个需要管理的物理内存块，访问时需要上锁。</p><p>kfree函数接收一个物理地址pa（physical address），pa指向了一个4KB大小的内存块，函数检查这个内存块是否4KB对齐，是否越界，然后填充上无效信息，将其插入到空闲列表中，表示这块空间以及被释放了，下次有进程再申请内存时可以将它分配出去。</p><p>有释放内存的函数，自然就有分配内存的函数： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate one 4096-byte page of physical memory.  </span><br><span class="hljs-comment">// Returns a pointer that the kernel can use.  </span><br><span class="hljs-comment">// Returns 0 if the memory cannot be allocated.  </span><br><span class="hljs-type">void</span> *  <br><span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span>  <br>  <br>  acquire(&amp;kmem.lock);  <br>  r = kmem.freelist;  <br>  <span class="hljs-keyword">if</span>(r)  <br>    kmem.freelist = r-&gt;next;  <br>  release(&amp;kmem.lock);  <br>  <br>  <span class="hljs-keyword">if</span>(r)  <br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk  </span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)r;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>kalloc不需要接收任何参数，直接从空闲列表取出来一块内存空间（同样是4KB），填充上无用信息并返回内存地址。</p><p>综上所述，kinit()函数是xv6初始化内存空间的函数，它将内存以4KB位单位切割成块，并串联成空闲列表，每次需要使用时直接分配即可。这个过程需要锁机制来保证安全。</p><h4 id="创建内核页表">创建内核页表</h4><p>内核使用各种设备也需要使用空间，而现代CPU允许时都必须经过MMU，因此内核页是需要页表的，但是这部分空间的映射并不是随机的，而是虚拟地址=物理地址，因此不需要额外的PTE进行表示，直接建立对应关系就可以了。例如内核本身虚拟地址和物理地址都位于<code>KERNBASE=0x80000000</code>，如何建立映射关系？看函数kvmmake <img src="20230921152857.png" alt="内核的虚拟地址映射情况"> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// qemu -machine virt is set up like this,  </span><br><span class="hljs-comment">// based on qemu&#x27;s hw/riscv/virt.c:  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">// 00001000 -- boot ROM, provided by qemu  </span><br><span class="hljs-comment">// 02000000 -- CLINT  </span><br><span class="hljs-comment">// 0C000000 -- PLIC  </span><br><span class="hljs-comment">// 10000000 -- uart0 </span><br><span class="hljs-comment">// 10001000 -- virtio disk </span><br><span class="hljs-comment">// 80000000 -- boot ROM jumps here in machine mode  </span><br><span class="hljs-comment">//             -kernel loads the kernel here  </span><br><span class="hljs-comment">// unused RAM after 80000000.  </span><br>  <br><span class="hljs-comment">// the kernel uses physical memory thus:  </span><br><span class="hljs-comment">// 80000000 -- entry.S, then kernel text and data  </span><br><span class="hljs-comment">// end -- start of kernel page allocation area  </span><br><span class="hljs-comment">// PHYSTOP -- end RAM used by the kernel</span><br></code></pre></td></tr></table></figure></p><p>kvmmake通过调用kvmmap，建立虚拟地址和硬件地址的关联，此调用发生在 xv6 启用 RISC-V 上的分页之前，因此地址直接引用物理内存。UART0，VITRIO0，PLIC的位置是通过宏定义设定好的常量，具体可参见memlayout.h文件。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Make a direct-map page table for the kernel.  </span><br><span class="hljs-type">pagetable_t</span>  <br><span class="hljs-title function_">kvmmake</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">pagetable_t</span> kpgtbl;  <br>  <br>  kpgtbl = (<span class="hljs-type">pagetable_t</span>) kalloc();  <br>  <span class="hljs-built_in">memset</span>(kpgtbl, <span class="hljs-number">0</span>, PGSIZE);  <br>  <br>  <span class="hljs-comment">// uart registers  </span><br>  <span class="hljs-comment">//因为没有打开分页功能，因此UART0此时实际表示的是物理地址</span><br>  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W); <br>  <br>  <span class="hljs-comment">// virtio mmio disk interface  </span><br>  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);  <br>  <br>  <span class="hljs-comment">// PLIC  </span><br>  kvmmap(kpgtbl, PLIC, PLIC, <span class="hljs-number">0x400000</span>, PTE_R | PTE_W);  <br>  <br>  <span class="hljs-comment">// map kernel text executable and read-only.  </span><br>  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);  <br>  <br>  <span class="hljs-comment">// map kernel data and the physical RAM we&#x27;ll make use of.  </span><br>  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);  <br>  <br>  <span class="hljs-comment">// map the trampoline for trap entry/exit to  </span><br>  <span class="hljs-comment">// the highest virtual address in the kernel.  </span><br>  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);  <br>  <span class="hljs-comment">//另外 `TRAMPOLINE` 页面是映射到物理地址 `trampoline` 上了</span><br>  <br>  <span class="hljs-comment">// map kernel stacks  </span><br>  proc_mapstacks(kpgtbl);  <br>    <br>  <span class="hljs-keyword">return</span> kpgtbl;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>具体来说，kvmmake 首先调用kalloc()函数分配一个物理内存页来保存根页表页 <strong>（kpgtbl是根目录页，也就是前文举例子时校长随身携带的那张表）</strong>。然后将 <code>UART0</code> 、<code>VIRTIO0</code>、<code>PLIC</code>、<code>KERNBASE</code> 和 <code>etext</code> 都做了直接映射（即虚拟地址和物理地址一样）；另外 <code>TRAMPOLINE</code> 页面是映射到物理地址 <code>trampoline</code> 上了，关于<code>etext 和 trampoline</code> 可以在链接脚本 <code>kernel/kernel.ld</code> 中查看到： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">OUTPUT_ARCH( <span class="hljs-string">&quot;riscv&quot;</span> )<br>ENTRY( _entry )<br><br>SECTIONS<br>&#123;<br>  . = <span class="hljs-number">0x80000000</span>;<br>  .text : &#123;<br>    *(.text .text.*)<br>    . = ALIGN(<span class="hljs-number">0x1000</span>);<br>    _trampoline = .;<br>    *(trampsec)<br>    . = ALIGN(<span class="hljs-number">0x1000</span>);<br>    ASSERT(. - _trampoline == <span class="hljs-number">0x1000</span>, <span class="hljs-string">&quot;error: trampoline larger than one page&quot;</span>);<br>    PROVIDE(etext = .);<br>  &#125;<br>  ...<span class="hljs-comment">// 后面内容省略</span><br>&#125;<br><br></code></pre></td></tr></table></figure> <code>etext</code> 是 .text 段结束位置，<code>_trampoline</code> 也是写在 .text 段中；</p><p>继续深挖kvmmap如何是如何建立映射关系的： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// add a mapping to the kernel page table.  </span><br><span class="hljs-comment">// only used when booting.  </span><br><span class="hljs-comment">// does not flush TLB or enable paging.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">kvmmap</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="hljs-type">int</span> perm)</span>  <br>&#123;  <br>  <span class="hljs-keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="hljs-number">0</span>)  <br>    panic(<span class="hljs-string">&quot;kvmmap&quot;</span>);  <br>&#125;  <br>  <br><span class="hljs-comment">// Create PTEs for virtual addresses starting at va that refer to  </span><br><span class="hljs-comment">// physical addresses starting at pa. va and size might not  </span><br><span class="hljs-comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t  </span><br><span class="hljs-comment">// allocate a needed page-table page.  </span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">mappages</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>  uint64 a, last;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  <span class="hljs-comment">// 需要映射的大小为0，panic</span><br>  <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;mappages: size&quot;</span>);<br>  <br>  a = PGROUNDDOWN(va);               <span class="hljs-comment">// 需要映射的虚拟地址的下边界</span><br>  last = PGROUNDDOWN(va + size - <span class="hljs-number">1</span>); <span class="hljs-comment">// 需要映射的虚拟地址的上边界</span><br>  <span class="hljs-comment">// 遍历每个4KB的页面</span><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">// 得到最后一级页表项</span><br>    <span class="hljs-keyword">if</span>((pte = walk(pagetable, a, <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">// 如果页表项已经有效了，说明这个页表之前已经被映射过了，panic</span><br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_V)<br>      panic(<span class="hljs-string">&quot;mappages: remap&quot;</span>);<br>    <span class="hljs-comment">// 页表项存放对应的物理地址，并设置页表项的标志位</span><br>    *pte = PA2PTE(pa) | perm | PTE_V;<br>    <span class="hljs-comment">// 映射完成</span><br>    <span class="hljs-keyword">if</span>(a == last)<br>      <span class="hljs-keyword">break</span>;<br>    a += PGSIZE;<br>    pa += PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure> 在讲MMU的原理时提到，想要定位一个PTE，需要<strong>页目录的地址+索引</strong>，pagetable参数就是页目录的地址。va和pa分别表示需要建立关联的虚拟地址和物理地址的起始位置，size用来计算结束的位置，perm则是在建立PTE关系时可以用来设定标志位。</p><p>mappages将范围虚拟地址到同等范围物理地址的映射装载到一个页表中。它以页面大小为间隔，为范围内的每个虚拟地址单独执行此操作。对于要映射的每个虚拟地址，mappages调用walk来查找该地址的PTE地址。然后，它初始化PTE以保存相关的物理页号、所需权限（PTE_W、PTE_X和/或PTE_R）以及用于标记PTE有效的PTE_V</p><p>mappages还涉及到了一些宏定义的内容，他们的定义位于riscv.h例如PGROUNDDOWN。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSIZE 4096 <span class="hljs-comment">// bytes per page  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSHIFT 12  <span class="hljs-comment">// bits of offset within a page  </span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))  <span class="hljs-comment">//向上取整对齐</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1)) <span class="hljs-comment">//向下取整对齐</span></span><br></code></pre></td></tr></table></figure></p><p>在map中涉及到了walk函数，这是内存管理的核心函数，<strong>是上文提到的三级页表原理的具体实现。</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return the address of the PTE in page table pagetable  </span><br><span class="hljs-comment">// that corresponds to virtual address va.  If alloc!=0,  </span><br><span class="hljs-comment">// create any required page-table pages.  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-comment">// The risc-v Sv39 scheme has three levels of page-table  </span><br><span class="hljs-comment">// pages. A page-table page contains 512 64-bit PTEs.  </span><br><span class="hljs-comment">// A 64-bit virtual address is split into five fields:  </span><br><span class="hljs-comment">//   39..63 -- must be zero.  </span><br><span class="hljs-comment">//   30..38 -- 9 bits of level-2 index.  </span><br><span class="hljs-comment">//   21..29 -- 9 bits of level-1 index.  </span><br><span class="hljs-comment">//   12..20 -- 9 bits of level-0 index.  </span><br><span class="hljs-comment">//    0..11 -- 12 bits of byte offset within the page.  </span><br><br><br><span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">walk</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-type">int</span> alloc)</span><br>&#123;<br>  <span class="hljs-comment">// 访问的虚拟地址超过规定的最大值</span><br>  <span class="hljs-keyword">if</span>(va &gt;= MAXVA)<br>    panic(<span class="hljs-string">&quot;walk&quot;</span>);<br><br>  <span class="hljs-comment">// 模拟三级页表访问过程，从L2-&gt;L1</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> level = <span class="hljs-number">2</span>; level &gt; <span class="hljs-number">0</span>; level--) &#123;<br>    <span class="hljs-comment">// PX(level, va)得到页表中的虚拟页号</span><br>    <span class="hljs-comment">// 根据虚拟页号来得到对应的页表项</span><br>    <span class="hljs-type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];<br>    <span class="hljs-comment">// 如果页表项是有效的</span><br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_V) &#123;<br>      <span class="hljs-comment">// 将页表项转为物理地址，并更新此时的页表</span><br>      pagetable = (<span class="hljs-type">pagetable_t</span>)PTE2PA(*pte);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果页表项是无效的</span><br>      <span class="hljs-comment">// 看是否需要分配新的页表（alloc==1)</span><br>      <span class="hljs-comment">// 需要分配，并且物理内存足够则分配新的页表</span><br>      <span class="hljs-keyword">if</span>(!alloc || (pagetable = (<span class="hljs-type">pde_t</span>*)kalloc()) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 将页表对应的4KB物理内存清空</span><br>      <span class="hljs-built_in">memset</span>(pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>      <span class="hljs-comment">// 将分配的物理地址存放在上一级页表项中，并设置页表标志位V=1</span><br>      *pte = PA2PTE(pagetable) | PTE_V;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 返回最后一级对应的页表项</span><br>  <span class="hljs-keyword">return</span> &amp;pagetable[PX(<span class="hljs-number">0</span>, va)];<br>&#125;<br><br><br>以下是这个过程使用的宏定义，被定义在riscv.h：<br><span class="hljs-comment">// shift a physical address to the right place for a PTE.  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10) <span class="hljs-comment">//右侧12位是偏移量，这个过程相当于抹掉偏移量，取出了物理地址所在页的物理地址，并空出低位10位用于设置标志位  </span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12) <span class="hljs-comment">//PTE低10位是标志位，这个操作抹掉了标志位，然后腾出来12位变成物理地址所在页的地址，与偏移量拼接后即可得到物理地址  </span></span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF) <span class="hljs-comment">//0x3FF表示低10位，而低10位正好是标志位，这个操作用来取出pte中的标志位  </span></span><br><span class="hljs-comment">//对位运算的运行真的很巧妙  </span><br>  <br><span class="hljs-comment">// extract the three 9-bit page table indices from a virtual address.  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXMASK          0x1FF <span class="hljs-comment">// 9 bits  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level))) <span class="hljs-comment">//level表示索引的层级，xv6有三级索引，这个操作是得到当前需要的索引所在的位置，例如L2位于12 + 9 * 2 =30位  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK) <span class="hljs-comment">//获得索引，例如获得L2索引则需要虚拟地址右移12 + 9 * 2 = 30位，这样最低位的9位就是L2索引的地址</span></span><br><br></code></pre></td></tr></table></figure> 函数是根据虚拟地址来找到最后一级对应的页表项，返回 0 表示没找到；alloc 参数规定了页表遍历的过程，如果遇见无效的页表是否需要分配一块新的物理内存当做页表，体现了按需分配的原则。</p><p>综上，经过上述一系列函数的操作，完成了最初那张图片所展示的内存空间映射关系。下一步就是打开分页功能。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Switch h/w page table register to the kernel&#x27;s page table,  </span><br><span class="hljs-comment">// and enable paging.  </span><br><br><br><span class="hljs-comment">//riscv.h文件下</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SATP_SV39 (8L &lt;&lt; 60) <span class="hljs-comment">// use riscv&#x27;s sv39 page table scheme.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) &gt;&gt; 12))</span><br><span class="hljs-comment">// flush the TLB.  </span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span>  <br><span class="hljs-title function_">sfence_vma</span><span class="hljs-params">()</span>  <span class="hljs-comment">//这是一条RISCV指令</span><br>&#123;  <br>  <span class="hljs-comment">// the zero, zero means flush all TLB entries.  </span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;sfence.vma zero, zero&quot;</span>)</span>;  <span class="hljs-comment">//刷新TLB</span><br>&#125;<br><br><br><span class="hljs-comment">//vm.c文件下</span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">kvminithart</span><span class="hljs-params">()</span>  <span class="hljs-comment">//被main.c调用</span><br>&#123;  <br>  w_satp(MAKE_SATP(kernel_pagetable));  <span class="hljs-comment">//kernel_pagetable是前文分配的根目录页</span><br>  sfence_vma();   <span class="hljs-comment">//刷新TLB，打开分页功能</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>问题：什么是TLB？ 答案：Translation Lookaside Buffer。TLB又称快表，在三级页表中，对于PA寻址，需要读取三次内存，代价也十分高。但在实际中，每一个处理器都会缓存最近使用VA对应的PPN，这个缓存也被称作为TLB，通常保存PTE的缓存。因此当CPU第一次翻译VA，通过三次查找页表可以获得最终的PPN，TLB会保存虚拟地址到物理地址的映射关系。那么下一次访问同一个VA时，查看TLB就会直接通过映射得到PA。(应该保存的是<strong>VA的index</strong>与<strong>最终的PPN</strong>的映射)，这种方案因为程序的局部性原理而有效。</p><h2 id="从进程的创建过程看虚拟内存">从进程的创建过程看虚拟内存</h2><p>前文讲述了xv6启动时的内存初始化操作，整个地址空间已经映射完毕，可用物理内存也已经切成块加入到Freelist中。下面我们以fork和exec为例，看一个新进程产生过程中地址分配是如何运作的。</p><h4 id="fork">fork</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create a new process, copying the parent.  </span><br><span class="hljs-comment">// Sets up child kernel stack to return as if from fork() system call.  </span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> i, pid;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span>            <span class="hljs-comment">//计划创建的子进程</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <span class="hljs-comment">//第一步，获取当前正在允许的进程</span><br>  <br>  <span class="hljs-comment">// Allocate process.  </span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;   <span class="hljs-comment">//为子进程分配内存空间</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-comment">// Copy user memory from parent to child.  </span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//创建用户内存，下文详解该函数</span><br>    freeproc(np);  <br>    release(&amp;np-&gt;lock);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br><br><span class="hljs-comment">//下文将父进程的内容都copy给子进程，包括进程大小sz，保存上下文的trapframe结构体，文件，名称</span><br>  np-&gt;sz = p-&gt;sz;  <br>  <br>  <span class="hljs-comment">// copy saved user registers.  </span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);  <br>  <br>  <span class="hljs-comment">// Cause fork to return 0 in the child.  </span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;  <br><br><span class="hljs-comment">//文件相关，暂时不管</span><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.  </span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)  <br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])  <br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);  <br>  np-&gt;cwd = idup(p-&gt;cwd);  <br>  <br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));  <br>  <br>  <span class="hljs-comment">//lab2 trace  </span><br>  np-&gt;trace_mask = p-&gt;trace_mask;  <br>  <br>  pid = np-&gt;pid;  <br><br><br><span class="hljs-comment">//新进程创建完毕，修改新建的状态，将子进程指向父进程，修改进程状态（这个过程需要上锁）</span><br>  release(&amp;np-&gt;lock);  <br>  <br>  acquire(&amp;wait_lock);  <br>  np-&gt;parent = p;  <br>  release(&amp;wait_lock);  <br>  <br>  acquire(&amp;np-&gt;lock);  <br>  np-&gt;state = RUNNABLE;  <br>  release(&amp;np-&gt;lock);  <br>  <br>  <span class="hljs-keyword">return</span> pid;  <br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，涉及到内存相关的内容就是下面这段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">// Copy user memory from parent to child.  </span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;  <br>    freeproc(np);  <br>    release(&amp;np-&gt;lock);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;<br><br><span class="hljs-comment">// vm.c</span><br><span class="hljs-comment">// Given a parent process&#x27;s page table, copy  </span><br><span class="hljs-comment">// its memory into a child&#x27;s page table.  </span><br><span class="hljs-comment">// Copies both the page table and the  </span><br><span class="hljs-comment">// physical memory.  </span><br><span class="hljs-comment">// returns 0 on success, -1 on failure.  </span><br><span class="hljs-comment">// frees any allocated pages on failure.  </span><br><br><span class="hljs-comment">//每个进程都有一个根页目录，old和new是父进程和子进程指向根页目录的指针，sz是父进程占用内存大小</span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">uvmcopy</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> old, <span class="hljs-type">pagetable_t</span> new, uint64 sz)</span>   <br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;  <br>  uint64 pa, i;  <br>  uint flags;  <br>  <span class="hljs-type">char</span> *mem;  <br><br><span class="hljs-comment">//因为进程可能大于4kB，也就是由多个页组成，在虚拟内存机制下，页内部是连续的，但是不同页之间不一定连续，因此需要循环找到每一页进行拷贝</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;   <br>    <span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)    <span class="hljs-comment">//根据old页目录地址 + 虚拟地址找到PTE</span><br>      panic(<span class="hljs-string">&quot;uvmcopy: pte should exist&quot;</span>);  <br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)             <span class="hljs-comment">//PTE有效性检查</span><br>      panic(<span class="hljs-string">&quot;uvmcopy: page not present&quot;</span>);  <br>    pa = PTE2PA(*pte);               <span class="hljs-comment">//根据PTE找到物理页的首地址</span><br>    flags = PTE_FLAGS(*pte);         <span class="hljs-comment">//设置PTE标识位</span><br>    <span class="hljs-keyword">if</span>((mem = kalloc()) == <span class="hljs-number">0</span>)        <span class="hljs-comment">//分配一页物理内存</span><br>      <span class="hljs-keyword">goto</span> err;  <br>    memmove(mem, (<span class="hljs-type">char</span>*)pa, PGSIZE);   <span class="hljs-comment">//拷贝</span><br>    <span class="hljs-keyword">if</span>(mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//在虚拟地址和新分配的物理地址之间建立映射关系，这样新进程的页表就构建好了</span><br>      kfree(mem);  <br>      <span class="hljs-keyword">goto</span> err;  <br>    &#125;  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  <br> err:  <br>  uvmunmap(new, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">1</span>);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>整个函数的思路是 1. 因为进程可能大于4kB，也就是由多个页组成，在虚拟内存机制下，页内部是连续的，但是不同页之间不一定连续，因此需要循环找到每一页进行拷贝。i从0开始一直到SZ停止，意味着需要拷贝整个进程的内存空间。 2. old是父进程的页目录虚拟地址，new是新建的子进程页目录虚拟地址（暂未赋值），通过walk函数找到进程的物理地址 3. 为子进程分配新的物理内存，并设置PTE标志位，再将父进程的物理内存复制到子进程的内存 4. 建立子进程虚拟地址与子进程物理地址的映射关系、 5. <code>uvmunmap</code>函数，如果在分配内存或者建立映射关系时出现错误，说明这次拷贝任务失败，需要将循环过程中之前已经分配的内容都释放（这一步在工程上非常重要，不然会出现看起来已经被分配，但无法使用的，也无法被回收的内存）</p><h4 id="exec">exec</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>  <br><span class="hljs-title function_">exec</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> **argv)</span>  <br>&#123;  <br>  <span class="hljs-type">char</span> *s, *last;  <br>  <span class="hljs-type">int</span> i, off;  <br>  uint64 argc, sz = <span class="hljs-number">0</span>, sp, ustack[MAXARG], stackbase;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> <span class="hljs-title">elf</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> <span class="hljs-title">ph</span>;</span>  <br>  <span class="hljs-type">pagetable_t</span> pagetable = <span class="hljs-number">0</span>, oldpagetable;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  begin_op();  <br>  <br>  <span class="hljs-keyword">if</span>((ip = namei(path)) == <span class="hljs-number">0</span>)&#123;  <br>    end_op();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>  ilock(ip);  <br>  <br>  <span class="hljs-comment">// Check ELF header  </span><br>  <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;elf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(elf)) != <span class="hljs-keyword">sizeof</span>(elf))  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <span class="hljs-keyword">if</span>(elf.magic != ELF_MAGIC)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <br>  <span class="hljs-keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <br>  <span class="hljs-comment">// Load program into memory.  </span><br>  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="hljs-keyword">sizeof</span>(ph))&#123;  <br>    <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;ph, off, <span class="hljs-keyword">sizeof</span>(ph)) != <span class="hljs-keyword">sizeof</span>(ph))  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    <span class="hljs-keyword">if</span>(ph.type != ELF_PROG_LOAD)  <br>      <span class="hljs-keyword">continue</span>;  <br>    <span class="hljs-keyword">if</span>(ph.memsz &lt; ph.filesz)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    <span class="hljs-keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    uint64 sz1;  <br>    <span class="hljs-keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    sz = sz1;  <br>    <span class="hljs-keyword">if</span>((ph.vaddr % PGSIZE) != <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    <span class="hljs-keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>  &#125;  <br>  iunlockput(ip);  <br>  end_op();  <br>  ip = <span class="hljs-number">0</span>;  <br>  <br>  p = myproc();  <br>  uint64 oldsz = p-&gt;sz;  <br>  <br>  <span class="hljs-comment">// Allocate two pages at the next page boundary.  </span><br>  <span class="hljs-comment">// Use the second as the user stack.  sz = PGROUNDUP(sz);  </span><br>  uint64 sz1;  <br>  <span class="hljs-keyword">if</span>((sz1 = uvmalloc(pagetable, sz, sz + <span class="hljs-number">2</span>*PGSIZE)) == <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  sz = sz1;  <br>  uvmclear(pagetable, sz<span class="hljs-number">-2</span>*PGSIZE);  <br>  sp = sz;  <br>  stackbase = sp - PGSIZE;  <br>  <br>  <span class="hljs-comment">// Push argument strings, prepare rest of stack in ustack.  </span><br>  <span class="hljs-keyword">for</span>(argc = <span class="hljs-number">0</span>; argv[argc]; argc++) &#123;  <br>    <span class="hljs-keyword">if</span>(argc &gt;= MAXARG)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    sp -= <span class="hljs-built_in">strlen</span>(argv[argc]) + <span class="hljs-number">1</span>;  <br>    sp -= sp % <span class="hljs-number">16</span>; <span class="hljs-comment">// riscv sp must be 16-byte aligned  </span><br>    <span class="hljs-keyword">if</span>(sp &lt; stackbase)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    <span class="hljs-keyword">if</span>(copyout(pagetable, sp, argv[argc], <span class="hljs-built_in">strlen</span>(argv[argc]) + <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">goto</span> bad;  <br>    ustack[argc] = sp;  <br>  &#125;  <br>  ustack[argc] = <span class="hljs-number">0</span>;  <br>  <br>  <span class="hljs-comment">// push the array of argv[] pointers.  </span><br>  sp -= (argc+<span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(uint64);  <br>  sp -= sp % <span class="hljs-number">16</span>;  <br>  <span class="hljs-keyword">if</span>(sp &lt; stackbase)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <span class="hljs-keyword">if</span>(copyout(pagetable, sp, (<span class="hljs-type">char</span> *)ustack, (argc+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(uint64)) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">goto</span> bad;  <br>  <br>  <span class="hljs-comment">// arguments to user main(argc, argv)  </span><br>  <span class="hljs-comment">// argc is returned via the system call return  // value, which goes in a0.  p-&gt;trapframe-&gt;a1 = sp;  </span><br>  <br>  <span class="hljs-comment">// Save program name for debugging.  </span><br>  <span class="hljs-keyword">for</span>(last=s=path; *s; s++)  <br>    <span class="hljs-keyword">if</span>(*s == <span class="hljs-string">&#x27;/&#x27;</span>)  <br>      last = s+<span class="hljs-number">1</span>;  <br>  safestrcpy(p-&gt;name, last, <span class="hljs-keyword">sizeof</span>(p-&gt;name));  <br>      <br>  <span class="hljs-comment">// Commit to the user image.  </span><br>  oldpagetable = p-&gt;pagetable;  <br>  p-&gt;pagetable = pagetable;  <br>  p-&gt;sz = sz;  <br>  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="hljs-comment">// initial program counter = main  </span><br>  p-&gt;trapframe-&gt;sp = sp; <span class="hljs-comment">// initial stack pointer  </span><br>  proc_freepagetable(oldpagetable, oldsz);  <br>  <br>  <span class="hljs-keyword">return</span> argc; <span class="hljs-comment">// this ends up in a0, the first argument to main(argc, argv)  </span><br>  <br> bad:  <br>  <span class="hljs-keyword">if</span>(pagetable)  <br>    proc_freepagetable(pagetable, sz);  <br>  <span class="hljs-keyword">if</span>(ip)&#123;  <br>    iunlockput(ip);  <br>    end_op();  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;  <br>  <br><span class="hljs-comment">// Load a program segment into pagetable at virtual address va.  </span><br><span class="hljs-comment">// va must be page-aligned  </span><br><span class="hljs-comment">// and the pages from va to va+sz must already be mapped.  </span><br><span class="hljs-comment">// Returns 0 on success, -1 on failure.  </span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  <br><span class="hljs-title function_">loadseg</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-keyword">struct</span> inode *ip, uint offset, uint sz)</span>  <br>&#123;  <br>  uint i, n;  <br>  uint64 pa;  <br>  <br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;  <br>    pa = walkaddr(pagetable, va + i);  <br>    <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)  <br>      panic(<span class="hljs-string">&quot;loadseg: address should exist&quot;</span>);  <br>    <span class="hljs-keyword">if</span>(sz - i &lt; PGSIZE)  <br>      n = sz - i;  <br>    <span class="hljs-keyword">else</span>  <br>      n = PGSIZE;  <br>    <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)pa, offset+i, n) != n)  <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  &#125;  <br>    <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>我们拆开了看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">begin_op();  <br><br><span class="hljs-comment">//path是可执行文件的位置</span><br><span class="hljs-keyword">if</span>((ip = namei(path)) == <span class="hljs-number">0</span>)&#123;   <span class="hljs-comment">//namei是文件系统的内容，没学，暂时搁置</span><br>  end_op();  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;  <br>ilock(ip);<br><br></code></pre></td></tr></table></figure><p>exec通过路径名打开文件，然后读取该文件的<strong>ELF Header</strong>（kernel/elf.h）。</p><p>xv6的所有应用程序以通用的<strong>ELF格式</strong>来描述。一个ELF二进制文件大概这样组成（更准确的定义，建议查阅相关资料，这里进行简单的不严谨的说明）：一个ELF Header，后面紧跟一系列的Program Section Headers。每个Program Section Header都对应一段需要加载到内存中的程序，xv6的应用程序只有一个Program Section Header，而在其它操作系统上可能有好几个。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// File header</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> &#123;</span><br>  uint magic;  <span class="hljs-comment">// must equal ELF_MAGIC</span><br>  uchar elf[<span class="hljs-number">12</span>];<br>  ushort type;<br>  ushort machine;<br>  uint version;<br>  uint64 entry;<br>  uint64 phoff;<br>  uint64 shoff;<br>  uint flags;<br>  ushort ehsize;<br>  ushort phentsize;<br>  ushort phnum;<br>  ushort shentsize;<br>  ushort shnum;<br>  ushort shstrndx;<br>&#125;;<br><br><span class="hljs-comment">// Program section header</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> &#123;</span><br>  uint32 type;<br>  uint32 flags;<br>  uint64 off;<br>  uint64 vaddr;<br>  uint64 paddr;<br>  uint64 filesz;<br>  uint64 memsz;<br>  uint64 align;<br>&#125;;<br><br><span class="hljs-comment">// Format of an ELF executable file</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_MAGIC 0x464C457FU  <span class="hljs-comment">// &quot;\x7FELF&quot; in little endian</span></span><br><br><span class="hljs-comment">// Values for Proghdr type</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_LOAD           1</span><br><br><span class="hljs-comment">// Flag bits for Proghdr flags</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_EXEC      1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_WRITE     2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_READ      4</span><br><br></code></pre></td></tr></table></figure></p><p>exec读取了文件系统上的文件之后，第一件事就是先检查该文件是否包含ELF二进制文件 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Check ELF header  </span><br><span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;elf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(elf)) != <span class="hljs-keyword">sizeof</span>(elf))  <span class="hljs-comment">//readi用来从inode获取数据</span><br>  <span class="hljs-keyword">goto</span> bad;  <br><span class="hljs-keyword">if</span>(elf.magic != ELF_MAGIC)  <br>  <span class="hljs-keyword">goto</span> bad;  <br></code></pre></td></tr></table></figure></p><p>完成检验后，exec为用户进程调用<code>proc_pagetable（proc.c）</code>，该函数通过<code>uvmcreate</code>创建一个空的用户页表，然后在该用户页表上添加了trampoline（位于虚拟地址最高位）和trapframe（trampoline下面）的映射，其它的虚拟地址空间都暂时为空。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">  <br><span class="hljs-keyword">if</span>((pagetable = proc_pagetable(p)) == <span class="hljs-number">0</span>)  <br>  <span class="hljs-keyword">goto</span> bad;<br><br><span class="hljs-comment">//proc.c</span><br><span class="hljs-comment">// Create a user page table for a given process,</span><br><span class="hljs-comment">// with no user memory, but with trampoline pages.</span><br><span class="hljs-type">pagetable_t</span><br><span class="hljs-title function_">proc_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>&#123;<br>  <span class="hljs-type">pagetable_t</span> pagetable;<br><br>  <span class="hljs-comment">// An empty page table.</span><br>  pagetable = uvmcreate();<br>  <span class="hljs-keyword">if</span>(pagetable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// map the trampoline code (for system call return)</span><br>  <span class="hljs-comment">// at the highest user virtual address.      </span><br>  <span class="hljs-comment">// only the supervisor uses it, on the way</span><br>  <span class="hljs-comment">// to/from user space, so not PTE_U.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,<br>              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,<br>              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> pagetable;<br>&#125;<br><br><span class="hljs-comment">// create an empty user page table.</span><br><span class="hljs-comment">// returns 0 if out of memory.</span><br><span class="hljs-type">pagetable_t</span><br><span class="hljs-title function_">uvmcreate</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">pagetable_t</span> pagetable;<br>  pagetable = (<span class="hljs-type">pagetable_t</span>) kalloc();<br>  <span class="hljs-keyword">if</span>(pagetable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>  <span class="hljs-keyword">return</span> pagetable;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>一个可执行二进制程序（在 linux 下为一个进程单元），在存储时（<strong>没有加载到内存运行</strong>），至少拥有三个部分，分别是代码段(text)、数据段(data)、和bss段（未初始化的全局变量，不占用可执行文件的空间）。当应用程序运行时（<strong>运行态</strong>），此时需要另外两个域：<strong>堆</strong>和<strong>栈</strong>。正在运行的程序：**代码段 + 数据段 + bss 段 + 堆 + 栈。 - 代码段：程序执行的指令 - 数据段：已初始化的全局变量和静态局部变量 - bss段：存放程序中未初始化和初始化为 0的全局变量的一块内存区域，在程序载入时由内核清零 - 堆：动态分配的内存，FIFO的数据结构 - 栈：局部变量，参数，返回值，LIFO的数据结构</p><figure><img src="20231016200329.png" alt="一个可执行程序的内存结构"><figcaption>一个可执行程序的内存结构</figcaption></figure><p>exec对于每个程序段，先是调用<code>uvmalloc</code>分配足够的物理帧，更新了用户页表。然后调用<code>loadseg</code>加载程序段到这些物理帧中。<code>loadseg</code>将虚拟地址传给<code>walkaddr</code>，<code>walkaddr</code>又通过<code>walk</code>查找相关PTE，将va转换为pa，最后<code>walkaddr</code>成功返回<code>uvmalloc</code>分配的物理帧的物理地址，<code>loadseg</code>再调用<code>readi</code>，真正地将程序段加载到物理内存中。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// Load program into memory</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="hljs-keyword">sizeof</span>(ph))&#123;<br>  <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;ph, off, <span class="hljs-keyword">sizeof</span>(ph)) != <span class="hljs-keyword">sizeof</span>(ph))<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>(ph.type != ELF_PROG_LOAD)<br>    <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-keyword">if</span>(ph.memsz &lt; ph.filesz)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)<br>    <span class="hljs-keyword">goto</span> bad;<br>  uint64 sz1;<br>  <span class="hljs-comment">// 再通过uvmalloc为每个ELF段分配内存</span><br>  <span class="hljs-keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  sz = sz1;<br>  <span class="hljs-keyword">if</span>(ph.vaddr % PGSIZE != <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-comment">// 然后通过loadseg把段的内容载入物理内存中</span><br>  <span class="hljs-comment">// loadseg通过walkaddr找到写入ELF段的内存的物理地址；通过readi来将段的内容从文件中读出</span><br>  <span class="hljs-keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>&#125;<br><br><br><span class="hljs-comment">// Load a program segment into pagetable at virtual address va.</span><br><span class="hljs-comment">// va must be page-aligned</span><br><span class="hljs-comment">// and the pages from va to va+sz must already be mapped.</span><br><span class="hljs-comment">// Returns 0 on success, -1 on failure.</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">loadseg</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-keyword">struct</span> inode *ip, uint offset, uint sz)</span><br>&#123;<br>  uint i, n;<br>  uint64 pa;<br><br>  <span class="hljs-keyword">if</span>((va % PGSIZE) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;loadseg: va must be page aligned&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    pa = walkaddr(pagetable, va + i);<br>    <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;loadseg: address should exist&quot;</span>);<br>    <span class="hljs-keyword">if</span>(sz - i &lt; PGSIZE)<br>      n = sz - i;<br>    <span class="hljs-keyword">else</span><br>      n = PGSIZE;<br>    <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)pa, offset+i, n) != n)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// Look up a virtual address, return the physical address,</span><br><span class="hljs-comment">// or 0 if not mapped.</span><br><span class="hljs-comment">// Can only be used to look up user pages.</span><br>uint64<br><span class="hljs-title function_">walkaddr</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va)</span><br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  uint64 pa;<br><br>  <span class="hljs-keyword">if</span>(va &gt;= MAXVA)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  pte = walk(pagetable, va, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(pte == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*pte &amp; PTE_U) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  pa = PTE2PA(*pte);<br>  <span class="hljs-keyword">return</span> pa;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="缺页中断">缺页中断</h2><p>前文提到，节省空间是计算机使用三级页表的原因之一。因为局部性原理，部分PTE被用到的概率不大，因此存储在外部存储硬件上，既然没有装进去所有的PTE，那自然可能会存PTE不在内存中的情况，这时就需要触发缺页中断，将PTE从外部存储加载到内存中</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab2 system calls</title>
    <link href="/2023/09/04/Lab2-system-calls/"/>
    <url>/2023/09/04/Lab2-system-calls/</url>
    
    <content type="html"><![CDATA[<p><a href="%5B%5BLab:%20System%20calls%20(mit.edu)%5D(https://pdos.csail.mit.edu/6.S081/2021/labs/syscall.html)%5D">课程地址</a>_</p><p>本次实验是需要完成一些系统调用功能，在开始前需要先理解进程相关的概念和系统调用的原理</p><h2 id="系统调用的原理">系统调用的原理</h2><p>回顾第二章书本上的知识，我们知道程序一般运行在用户态，只有遇到以下三种情况才会陷入中断进入内核态： 1. <strong>系统调用</strong>：当用户程序执行<strong>ecall</strong>指令要求内核为其做某事时。 2. <strong>异常</strong>：一条指令(用户或内核)做了一些非法的事情，如除以零或使用无效的虚拟地址。 3. <strong>中断</strong>：当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时。</p><p>所以研究系统调用，其实也就是研究中断（trap）过程是如何发生的。宏观上可分为四个步骤，本文会针对这四个步骤，结合xv6系统进行详细的讲解： 1. 中断请求 2. 保护现场 3. 中断处理 4. 中断返回</p><p>以上过程自然离不开与寄存器打交道，例如<strong>satp寄存器用于控制分页系统</strong>，以下是与trap相关的寄存器概述，这些寄存器可以分为两类： <strong>1. 发生中断时，硬件自动写入的寄存器</strong> - <code>sepc</code>：当trap发生时，RISC-V会将程序计数器保存在这里(因为<code>PC</code>会被<code>stvec</code>覆盖)。<code>sret</code>(从trap中返回)指令将<code>sepc</code>复制到<code>pc</code>中。内核可以写<code>sepc</code>来控制<code>sret</code>的返回到哪里。 - <code>scause</code>：RISC -V在这里放了一个数字，描述了trap的原因。 - <code>stval</code>：<code>scause</code> 不足以存下中断所有的必须信息。例如缺页异常，就会将 <code>stval</code> 设置成需要访问但是不在内存中的地址，以便于操作系统将这个地址所在的页面加载进来。</p><p><strong>2. 指导硬件处理中断的寄存器</strong> - <code>stvec</code>：保存内核中断处理流程的入口地址，内核在这里写下trap处理程序的地址；RISC-V跳转到这里来处理trap。 - <code>sstatus</code>：具有许多状态位，控制全局中断等。<code>sstatus</code>中的<strong>SIE</strong>位控制设备中断是否被启用，如果内核清除<strong>SIE</strong>，RISC-V将推迟设备中断，直到内核设置<strong>SIE</strong>。<strong>SPP</strong>位表示trap是来自用户模式还是supervisor模式，并控制<code>sret</code>返回到什么模式。 - <code>sie</code>：即 Supervisor Interrupt Enable，用来控制具体类型中断，例如其中的 STIE 控制时钟中断 - <code>sip</code>：即 Supervisor Interrupt Pending，和 <code>sie</code> 相对应，记录每种中断是否被触发。仅当 <code>sie</code> 和 <code>sip</code> 的对应位都为 1 时，意味着开中断且已发生中断，这时中断最终触发。 - <code>sscratch</code>：内核在这里放置了一个值，在trap处理程序开始时可以方便地使用。在用户态保存内核栈的地址，在内核态值为 0。为什么需要内核栈？因此中断处理流程也需要利用内存空间，很可能需要使用栈，而程序当前的用户栈是不安全的（说不定指针不断运行到其他进程的空间，破坏了隔离性）。因此，我们还需要一个预设的安全的栈空间，存放在这里。</p><p>有了上述与中断相关的寄存器，自然也就有与中断相关的指令： <strong>1. 进入和退出中断</strong> - <code>ecall</code>：触发中断，进入更高一层的中断处理流程之中。用户态进行系统调用进入内核态中断处理流程，内核态进行 SBI 调用进入机器态中断处理流程，使用的都是这条指令。 - <code>sret</code>：从内核态返回用户态，同时将 <code>sepc</code> 的值赋值给 <code>pc</code>。（如果需要返回到 <code>sepc</code> 后一条指令，就需要在 <code>sret</code> 之前修改 <code>sepc</code> 的值） - <code>ebreak</code>：触发一个断电 - <code>mret</code>：从机器态返回内核态，同时将 <code>pc</code> 的值设置为 <code>mepc</code>。</p><p><strong>2. 操作CSR</strong> 只有一系列特殊的指令（CSR Instruction）可以读写 CSR - <code>csrrw dst, csr, src</code>（CSR Read Write）同时读写的原子操作，将指定 CSR 的值写入 <code>dst</code>，同时将 <code>src</code> 的值写入 CSR。 - <code>csrr dst, csr</code>（CSR Read）：仅读取一个 CSR 寄存器。 - <code>csrw csr, src</code>（CSR Write） ：仅写入一个 CSR 寄存器。</p><p>微观上，RISC-V硬件对每一个trap操作（除定时器中断外），都会执行如下步骤： 1. 如果该trap是设备中断，且sstatus SIE位为0，则不执行以下任何操作 2. 通过清除 SIE 来禁用中断 3. 复制 pc 到 sepc 4. 将当前模式(用户态或特权态)保存在 sstatus 的 SPP 位 5. 在 scause 设置该次trap的原因 6. 将模式转换为特权态 7. 将 stvec 复制到 pc 8. 从新的pc开始执行</p><h4 id="中断请求">中断请求</h4><p>当使用到<code>write，read，open</code>等系统调用时，会使用<code>ecall</code>指令发起中断请求 - <code>ecall</code>是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用</p><p>在xv6中，<code>user/cat.c</code>文件是<code>cat shell</code>指令的源码，其中涉及到了<code>read</code>函数，它声明在<code>user/user.h</code>文件中，但是<code>read</code>函数的实现在<code>kernel/sysfile.c</code>文件中。显然<code>cat</code>并不是直接调用<code>sysfile.c</code>文件中的函数来达成目标的，毕竟一个在用户态，一个在内核态。</p><p>既然<code>read</code>在用户态的角度看不见具体的逻辑实现，那它为什么能正常运行呢？只声明不实现的函数是无法正常使用的呀？</p><p>仔细观察user文件架，我们可以发现虽然没有<code>read</code>函数的c语言实现，但其实存在汇编实现。用户在c代码中使用<code>read</code>函数时，其实是在运行<code>usys.S</code>文件（由<code>usys.pl</code>文件得来，make指令才能看见）中<code>read</code>函数。 <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">c</span>语言如何调用汇编函数？步骤：<br><span class="hljs-number">1</span>、先在汇编程序中声明函数属性为GLOBAL<br><span class="hljs-number">2</span>、在<span class="hljs-keyword">c</span>文件开头声明该函数<br><span class="hljs-number">3</span>、按照C语言正常调用函数的方式调用该函数<br></code></pre></td></tr></table></figure></p><p>当然，这个汇编函数虽然名称也叫<code>read</code>，但并不是在执行读取文件的逻辑，而是在建立用户态与内核态的桥梁。<code>usys.pl</code>脚本的实现如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">#!/usr/bin/perl -w  <br>  <br># Generate usys.S, the stubs <span class="hljs-keyword">for</span> syscalls.  <br>  <br>print <span class="hljs-string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;  <br>  <br>print <span class="hljs-string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;  <br>  <br>sub entry &#123;  <br>    my $name = shift;  <br>    print <span class="hljs-string">&quot;.global $name\n&quot;</span>;  <br>    print <span class="hljs-string">&quot;$&#123;name&#125;:\n&quot;</span>;  <br>    print <span class="hljs-string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;  <br>    print <span class="hljs-string">&quot; ecall\n&quot;</span>;  <br>    print <span class="hljs-string">&quot; ret\n&quot;</span>;  <br>&#125;  <br>     <br>entry(<span class="hljs-string">&quot;fork&quot;</span>);  <br>entry(<span class="hljs-string">&quot;exit&quot;</span>);  <br>entry(<span class="hljs-string">&quot;wait&quot;</span>);  <br>entry(<span class="hljs-string">&quot;pipe&quot;</span>);  <br>entry(<span class="hljs-string">&quot;read&quot;</span>);  <br>entry(<span class="hljs-string">&quot;write&quot;</span>);  <br>entry(<span class="hljs-string">&quot;close&quot;</span>);  <br>entry(<span class="hljs-string">&quot;kill&quot;</span>);  <br>entry(<span class="hljs-string">&quot;exec&quot;</span>);  <br>entry(<span class="hljs-string">&quot;open&quot;</span>);  <br>entry(<span class="hljs-string">&quot;mknod&quot;</span>);  <br>entry(<span class="hljs-string">&quot;unlink&quot;</span>);  <br>entry(<span class="hljs-string">&quot;fstat&quot;</span>);  <br>entry(<span class="hljs-string">&quot;link&quot;</span>);  <br>entry(<span class="hljs-string">&quot;mkdir&quot;</span>);  <br>entry(<span class="hljs-string">&quot;chdir&quot;</span>);  <br>entry(<span class="hljs-string">&quot;dup&quot;</span>);  <br>entry(<span class="hljs-string">&quot;getpid&quot;</span>);  <br>entry(<span class="hljs-string">&quot;sbrk&quot;</span>);  <br>entry(<span class="hljs-string">&quot;sleep&quot;</span>);  <br>entry(<span class="hljs-string">&quot;uptime&quot;</span>);<br></code></pre></td></tr></table></figure></p><p><code>usys.pl</code>是一个Perl语言文件。即使对Perl语言并没有深入了解，但根据语法规则可以大概了解它的作用：这个脚本文件将根据输入的字符名，通过<code>entry()</code>格式化生成文本文件。</p><p><code>usys.pl</code>的输入是系统调用的名称，输出内容则保存为<code>kernel/usys.S</code>。这样每个系统调用都在<code>usys.S</code>文件中都有一个实现，通过<code>global</code>声明后，用户在使用同名的函数时，会执行这里的<code>entry()</code>中的逻辑： 1. 将系统调用的ID存入a7寄存器 - 虽然输入的是名称（字符串），但是<code>kernel/syscall.h</code>文件下将字符串映射为了编号 2. 执行ecall命令 - <code>ecall</code>是RISC-V的一个可以控制寄存器的汇编指令，用于在运行时向环境发出请求，如系统调用</p><p>这样就通过<code>ecall</code>指令（中断请求）将需要的系统调用从用户态传递给了内核态。在ecall调用过程中会发生（和前文中讲到的微观操作一致，但这里只写主要内容）： 1. 关中断 2. 代码从<code>user mode</code>改到supervisor mode 3. 程序计数器<code>PC</code>的值保存进 <code>SEPC</code> 寄存器 4. CPU执行<code>STVEC</code>寄存器指向的指令（<code>PC</code>重置为 <code>STVEC</code> 寄存器的值）</p><p>问题：那么<code>STVEC</code>寄存器的值到底是多少？ 答案：<code>STVEC</code>是一个特权寄存器，只能在supervisor mode下执行，每次从内核空间返回到用户空间之前，内核会设置<code>STVEC</code>寄存器指向内核希望中断代码运行的位置（由<code>trap.c</code>中的代码设置）。</p><p>Xv6在内核页表和每个用户页表中的<strong>同一个虚拟地址</strong>上映射了 <code>trampoline page</code> 。<code>STVEC</code> 寄存器保存的地址是 <code>trampoline page</code> 的起始位置，主要执行一些保护用户态寄存器的操作。<code>trampoline page</code> 的首地址是 <code>uservec</code> 函数。所以其实<code>STVEC</code>指向了<code>kernel/trampoline.S</code>文件中的<code>uservec</code>函数。</p><p><strong>综上，其实操作系统伪装了一个系统调用的实现，当使用<code>read</code>等函数时并没有真正的读写逻辑，而是利用ecall发起中断，并通过寄存器将函数的ID告知内核，方便在内核找到函数真正的实现。</strong></p><h4 id="保护现场">保护现场</h4><p>上文讲到CPU将执行<code>uservec</code>函数（<code>kernel/trampoline.S</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c">.globl uservec  <br>uservec:      <br>   #  <br>        <span class="hljs-meta"># trap.c sets stvec to point here, so  </span><br>        <span class="hljs-meta"># traps from user space start here,  </span><br>        <span class="hljs-meta"># in supervisor mode, but with a  </span><br>        <span class="hljs-meta"># user page table.  </span><br>        #  <br>        <span class="hljs-meta"># sscratch points to where the process<span class="hljs-string">&#x27;s p-&gt;trapframe is  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # mapped into user space, at TRAPFRAME.  </span></span><br><span class="hljs-string"><span class="hljs-meta">        #  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # swap a0 and sscratch  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # so that a0 is TRAPFRAME  </span></span><br><span class="hljs-string"><span class="hljs-meta">        csrrw a0, sscratch, a0 </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # save the user registers in TRAPFRAME  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd ra, 40(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd sp, 48(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd gp, 56(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd tp, 64(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t0, 72(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t1, 80(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t2, 88(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s0, 96(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s1, 104(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a1, 120(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a2, 128(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a3, 136(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a4, 144(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a5, 152(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a6, 160(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd a7, 168(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s2, 176(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s3, 184(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s4, 192(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s5, 200(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s6, 208(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s7, 216(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s8, 224(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s9, 232(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s10, 240(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd s11, 248(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t3, 256(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t4, 264(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t5, 272(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t6, 280(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">   # save the user a0 in p-&gt;trapframe-&gt;a0  </span></span><br><span class="hljs-string"><span class="hljs-meta">        csrr t0, sscratch  </span></span><br><span class="hljs-string"><span class="hljs-meta">        sd t0, 112(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld sp, 8(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld tp, 32(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld t0, 16(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp  </span></span><br><span class="hljs-string"><span class="hljs-meta">        ld t1, 0(a0)  </span></span><br><span class="hljs-string"><span class="hljs-meta">        csrw satp, t1  //切换到内核页表</span></span><br><span class="hljs-string"><span class="hljs-meta">        sfence.vma zero, zero  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # a0 is no longer valid, since the kernel page  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # table does not specially map p-&gt;tf.  </span></span><br><span class="hljs-string"><span class="hljs-meta">  </span></span><br><span class="hljs-string"><span class="hljs-meta">        # jump to usertrap(), which does not return  </span></span><br><span class="hljs-string"><span class="hljs-meta">        jr t0</span></span><br></code></pre></td></tr></table></figure><p>在进程的结构中有一个结构体变量名为<code>trapframe</code>，它的作用是： 1. 发生中断时，保存进程在用户态使用的各种寄存器的值，以便于到时候恢复进程运行状态。 2. 保存完成后，加载进程在内核态运行需要使用的寄存器的值</p><p>在上面的代码中： 1. 先使用<code>csrrw</code>指令，将a0寄存器设置为<code>sscratch</code>寄存器的值，此时a0指向进程的<code>trapframe</code>结构。按照特定的顺序，保存寄存器的值。从偏移量40开始是因为，0到40（5 * 8）之间保存了5个内核态相关的值<code>（kernel_satp，kernel_sp，kernel_trap，epc，kernel_hartid）</code>，具体可参考<code>proc.h</code>文件中<code>trapframe</code>的结构。 2. 恢复内核栈指针，将5个内核态相关的值加载进寄存器中，然后强制跳转执行<code>usertrap</code>函数（地址存储在<code>p-&gt;trapframe-&gt;kernel_trap</code>）。</p><h4 id="中断处理">中断处理</h4><p>在保存好上下文之后就要开始执行中断处理的逻辑了，这里使用的栈已经从用户栈变成了内核栈 <code>usertrap</code>函数的代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  </span><br><span class="hljs-comment">// handle an interrupt, exception, or system call from user space.  </span><br><span class="hljs-comment">// called from trampoline.S  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;  <br>  <br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)   <span class="hljs-comment">//判断中断是否合法</span><br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);  <br>  <br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),  </span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.  </span><br>  w_stvec((uint64)kernelvec);  <br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>    <br>  <span class="hljs-comment">// save user program counter.  </span><br>  p-&gt;trapframe-&gt;epc = r_sepc();  <span class="hljs-comment">//保存sepc寄存器的值，前文提到了ecall指令执行后会将当前的PC保存到sepc中，因此 p-&gt;trapframe-&gt;epc其实指向ecall的最后一条指令</span><br>    <br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;   <span class="hljs-comment">//scause记录了发生中断的原因，8是系统调用的代号</span><br>    <span class="hljs-comment">// system call  </span><br>  <br>    <span class="hljs-keyword">if</span>(p-&gt;killed)  <br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);  <br>  <br>    <span class="hljs-comment">// sepc points to the ecall instruction,  </span><br>    <span class="hljs-comment">// but we want to return to the next instruction.    </span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;   <span class="hljs-comment">//此时epc指向ecall，我们恢复上下文后执行下一条指令，因此+4</span><br>  <br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,  </span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.    </span><br>    intr_on();   <span class="hljs-comment">//开中断，允许内核在执行系统调用时嵌套中断</span><br>  <br>    syscall(); <br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;  <br>    <span class="hljs-comment">// ok  </span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());  <br>    p-&gt;killed = <span class="hljs-number">1</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-keyword">if</span>(p-&gt;killed)  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);  <br>  <br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.  </span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)  <br>    yield();  <br>  <br>  usertrapret();  <br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>usertrap</code>负责中断处理，主要通过调用三个函数完成<code>syscall,yield,usertrapret</code></p><p><code>yield</code>是在发生时钟中断时的处理逻辑，进程修改自己的状态并自愿放弃CPU使用权 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Give up the CPU for one scheduling round.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  acquire(&amp;p-&gt;lock);  <br>  p-&gt;state = RUNNABLE;  <br>  sched();  <br>  release(&amp;p-&gt;lock);  <br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>syscall()</code>是在发生系统调用时的处理逻辑： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> num;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  num = p-&gt;trapframe-&gt;a7;  <br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;  <br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <span class="hljs-comment">//执行系统调用</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,  <br>            p-&gt;pid, p-&gt;name, num);  <br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>前文讲到在使用函数<code>read</code>时，并没有真正的实现代码，而是一步一步走到了这里，现在终于可以开始执行具体的<code>read</code>逻辑了。在<code>syscall</code>函数中，a7寄存器中保存了<code>read</code>的编号，系统调用表提供了一个从编号到对应函数指针的实现，通过函数指针就能找到对应需要执行的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//syscalls是一个函数指针数组</span><br><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;  <br>[SYS_fork]    sys_fork,   <span class="hljs-comment">//sys_fork是一个宏定义，其实是数字1</span><br>[SYS_exit]    sys_exit,   <span class="hljs-comment">//同理</span><br>[SYS_wait]    sys_wait,  <br>[SYS_pipe]    sys_pipe,  <br>[SYS_read]    sys_read,  <br>[SYS_kill]    sys_kill,  <br>[SYS_exec]    sys_exec,  <br>[SYS_fstat]   sys_fstat,  <br>[SYS_chdir]   sys_chdir,  <br>[SYS_dup]     sys_dup,  <br>[SYS_getpid]  sys_getpid,  <br>[SYS_sbrk]    sys_sbrk,  <br>[SYS_sleep]   sys_sleep,  <br>[SYS_uptime]  sys_uptime,  <br>[SYS_open]    sys_open,  <br>[SYS_write]   sys_write,  <br>[SYS_mknod]   sys_mknod,  <br>[SYS_unlink]  sys_unlink,  <br>[SYS_link]    sys_link,  <br>[SYS_mkdir]   sys_mkdir,  <br>[SYS_close]   sys_close,  <br>&#125;;<br></code></pre></td></tr></table></figure><p><code>sys_read</code>代码如下，此时才执行真正的<code>read</code>逻辑 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_read</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span>  <br>  <span class="hljs-type">int</span> n;  <br>  uint64 p;  <br>  <br>  <span class="hljs-keyword">if</span>(argfd(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, &amp;f) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;n) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;p) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  <span class="hljs-keyword">return</span> fileread(f, p, n);  <br>&#125;<br></code></pre></td></tr></table></figure></p><p><code>p-&gt;trapframe-&gt;a0 = syscalls[num]();</code>完成了系统调用过程并将返回值保存在a0寄存器，系统调用逻辑执行完毕，因此需要开始中断返回。</p><h4 id="中断返回">中断返回</h4><p><code>usertrapret</code>函数被<code>usertrap</code>调用，用来从内核态返回用户态 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  </span><br><span class="hljs-comment">// return to user space  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();   <br>  <br>  <span class="hljs-comment">// we&#x27;re about to switch the destination of traps from  </span><br>  <span class="hljs-comment">// kerneltrap() to usertrap(), so turn off interrupts until  </span><br>  <span class="hljs-comment">// we&#x27;re back in user space, where usertrap() is correct.  </span><br>  intr_off();  <span class="hljs-comment">//关中断，不能在执行中断恢复过程时嵌套中断</span><br>  <br>  <span class="hljs-comment">// send syscalls, interrupts, and exceptions to trampoline.S  </span><br>  <span class="hljs-comment">// 因为在执行ecall指令后，CPU几哦执行STVEC寄存器指向的指令（PC重置为 STVEC寄存器的值）</span><br>  <span class="hljs-comment">// 所以设置STVEC寄存器的值为我们想要中断发生时执行的代码的地址（前文提到的uservec函数）</span><br>  w_stvec(TRAMPOLINE + (uservec - trampoline));  <br>  <br>  <span class="hljs-comment">// set up trapframe values that uservec will need when  </span><br>  <span class="hljs-comment">// the process next re-enters the kernel.  </span><br>  <span class="hljs-comment">// 和发生中断时保存上下文类似，内核使用完毕，即将进入用户态，要将目前的值保存起来，</span><br>  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="hljs-comment">// kernel page table  </span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack  </span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;  <br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid()  </span><br>  <br>  <span class="hljs-comment">// set up the registers that trampoline.S&#x27;s sret will use  // to get to user space.     // set S Previous Privilege mode to User.  </span><br>  <span class="hljs-comment">// 设置CPU特权等级，从supervisor mode 到user mode（也就是将操作系统从内核态修改为用户态）</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_sstatus();  <br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// clear SPP to 0 for user mode  </span><br>  x |= SSTATUS_SPIE; <span class="hljs-comment">// enable interrupts in user mode  </span><br>  w_sstatus(x);  <br>  <br>  <span class="hljs-comment">// set S Exception Program Counter to the saved user pc.  </span><br>  w_sepc(p-&gt;trapframe-&gt;epc);   <span class="hljs-comment">//修改sepc寄存器的值，在sret指令后，sepc的值会写入pc，此时sepc指向ecall的下一条指令</span><br>  <br>  <span class="hljs-comment">// tell trampoline.S the user page table to switch to.  </span><br>  uint64 satp = MAKE_SATP(p-&gt;pagetable);  <br>  <br>  <span class="hljs-comment">// jump to trampoline.S at the top of memory, which   </span><br>  <span class="hljs-comment">// switches to the user page table, restores user registers,  </span><br>  <span class="hljs-comment">// and switches to user mode with sret.  </span><br>  uint64 fn = TRAMPOLINE + (userret - trampoline);  <br>  <br>  <span class="hljs-comment">//调用userret函数（trampoline.S），userret(TRAPFRAME, pagetable)</span><br>  ((<span class="hljs-type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp); <br>&#125;<br><br></code></pre></td></tr></table></figure></p><p><code>userret</code>函数如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c">.globl userret  <br>userret:  <br>        <span class="hljs-meta"># userret(TRAPFRAME, pagetable)  </span><br>        <span class="hljs-meta"># switch from kernel to user.  </span><br>        <span class="hljs-meta"># usertrapret() calls here.  </span><br>        # a0: TRAPFRAME, in user page table.   函数传参时使用a0，a1寄存器<br>        # a1: user page table, <span class="hljs-keyword">for</span> satp.  <br>  <br>        <span class="hljs-meta"># switch to the user page table.  </span><br>        csrw satp, a1  <br>        sfence.vma zero, zero  <br>  <br>        <span class="hljs-meta"># put the saved user a0 in sscratch, so we  </span><br>        <span class="hljs-meta"># can swap it with our a0 (TRAPFRAME) in the last step.  </span><br>        ld t0, <span class="hljs-number">112</span>(a0)  <br>        csrw sscratch, t0  <br>  <br>        <span class="hljs-meta"># restore all but a0 from TRAPFRAME  </span><br>        ld ra, <span class="hljs-number">40</span>(a0)  <br>        ld sp, <span class="hljs-number">48</span>(a0)  <br>        ld gp, <span class="hljs-number">56</span>(a0)  <br>        ld tp, <span class="hljs-number">64</span>(a0)  <br>        ld t0, <span class="hljs-number">72</span>(a0)  <br>        ld t1, <span class="hljs-number">80</span>(a0)  <br>        ld t2, <span class="hljs-number">88</span>(a0)  <br>        ld s0, <span class="hljs-number">96</span>(a0)  <br>        ld s1, <span class="hljs-number">104</span>(a0)  <br>        ld a1, <span class="hljs-number">120</span>(a0)  <br>        ld a2, <span class="hljs-number">128</span>(a0)  <br>        ld a3, <span class="hljs-number">136</span>(a0)  <br>        ld a4, <span class="hljs-number">144</span>(a0)  <br>        ld a5, <span class="hljs-number">152</span>(a0)  <br>        ld a6, <span class="hljs-number">160</span>(a0)  <br>        ld a7, <span class="hljs-number">168</span>(a0)  <br>        ld s2, <span class="hljs-number">176</span>(a0)  <br>        ld s3, <span class="hljs-number">184</span>(a0)  <br>        ld s4, <span class="hljs-number">192</span>(a0)  <br>        ld s5, <span class="hljs-number">200</span>(a0)  <br>        ld s6, <span class="hljs-number">208</span>(a0)  <br>        ld s7, <span class="hljs-number">216</span>(a0)  <br>        ld s8, <span class="hljs-number">224</span>(a0)  <br>        ld s9, <span class="hljs-number">232</span>(a0)  <br>        ld s10, <span class="hljs-number">240</span>(a0)  <br>        ld s11, <span class="hljs-number">248</span>(a0)  <br>        ld t3, <span class="hljs-number">256</span>(a0)  <br>        ld t4, <span class="hljs-number">264</span>(a0)  <br>        ld t5, <span class="hljs-number">272</span>(a0)  <br>        ld t6, <span class="hljs-number">280</span>(a0)  <br>  <br>   <span class="hljs-meta"># restore user a0, and save TRAPFRAME in sscratch  </span><br>        csrrw a0, sscratch, a0  <br>          <br>        <span class="hljs-meta"># return to user mode and user pc.  </span><br>        <span class="hljs-meta"># usertrapret() set up sstatus and sepc.  </span><br>        sret<br></code></pre></td></tr></table></figure></p><p><code>userret</code>代码的主要功能和<code>uservec</code>正好相反，后者是将用户运行时的寄存器信息保存起来，切换到内核页表；前者是将这些保存起来的寄存器值恢复回去，切换到用户页表</p><p>随着<code>sret</code>指令的调用，整个中断过程完成，sepc寄存器中的值填回pc，用户程序恢复正常执行</p><h2 id="system-call-tracing">System call tracing</h2><p>参照教程，在实验2前应该： - 仔细阅读<code>Chapter 2、 Chapter 4 的 Sections 4.3 and 4.4</code> - 仔细阅读<code>user/user.h</code>,<code>user/usys.pl</code>，学习xv6中工具函数和系统调用原型 - 仔细阅读<code>kernel/syscall.h</code>,<code>kernel/syscall.c</code>,系统调用实现 - 仔细阅读<code>kernel/proc.h</code>,<code>kernel/proc.c</code>，进程代码实现</p><p>如果是从前文一步一步看到这里，那么这些代码相当于已经看过了，下面直接看练习要求： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">实验要求：<br><br>实现一个系统调用追踪的功能：trace mask command命令，<br>- mask 表示系统调用号的掩码<br>- command 表示命令<br>- 能够实现如下效果<br><br><span class="hljs-comment">//因由于read的系统调用号是5，因此（1 &lt;&lt; 5,10000) 如果输入的数字从右往左第六位为1，则需要追踪read，即十进制数字32表示仅需要追踪read系统调用</span><br>$ trace <span class="hljs-number">32</span> grep hello README<br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">1023</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">966</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">70</span><br><span class="hljs-number">3</span>: syscall read -&gt; <span class="hljs-number">0</span><br><br><span class="hljs-comment">//2147483647的二进制是1111111111111111111111111111111，因为所有位都为1，说明所有系统调用都需要追踪</span><br>$ trace <span class="hljs-number">2147483647</span> grep hello README<br><span class="hljs-number">4</span>: syscall trace -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">4</span>: syscall exec -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">4</span>: syscall open -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">1023</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">966</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">70</span><br><span class="hljs-number">4</span>: syscall read -&gt; <span class="hljs-number">0</span><br><span class="hljs-number">4</span>: syscall close -&gt; <span class="hljs-number">0</span><br><br><span class="hljs-comment">//没有trace指令，不追踪，不能影响其他程序的正常运行</span><br>$ grep hello README<br>$<br><br><span class="hljs-comment">//fork的系统调用号是1，因此(1 &lt;&lt; 2，2)如果输入的数字从右往左第二位为1，则仅需要追踪fork，</span><br>$ trace <span class="hljs-number">2</span> usertests forkforkfork<br>usertests starting<br>test forkforkfork: <span class="hljs-number">407</span>: syscall fork -&gt; <span class="hljs-number">408</span><br><span class="hljs-number">408</span>: syscall fork -&gt; <span class="hljs-number">409</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">410</span><br><span class="hljs-number">410</span>: syscall fork -&gt; <span class="hljs-number">411</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">412</span><br><span class="hljs-number">410</span>: syscall fork -&gt; <span class="hljs-number">413</span><br><span class="hljs-number">409</span>: syscall fork -&gt; <span class="hljs-number">414</span><br><span class="hljs-number">411</span>: syscall fork -&gt; <span class="hljs-number">415</span><br><br></code></pre></td></tr></table></figure></p><p>理解了需求，再结合前文提到的系统调用过程，可以想想我们为了完成任务可以做些什么？ 首先，一个完整的系统调用从一个用户态的<code>shell</code>函数开始，trace.c文件已经提供给了我们： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br>  <br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>  <br>&#123;  <br>    <span class="hljs-type">int</span> i;  <br>    <span class="hljs-comment">//存储待跟踪程序的名称和参数  </span><br>    <span class="hljs-type">char</span> *nargv[MAXARG];  <br>  <br>    <span class="hljs-comment">//保证trace的参数不少于三个，并且跟踪的系统调用号在0-99之间  </span><br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">3</span> || (argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &gt; <span class="hljs-string">&#x27;9&#x27;</span>))&#123;  <br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: %s mask command\n&quot;</span>, argv[<span class="hljs-number">0</span>]);  <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br>    <span class="hljs-comment">//调用trace系统调用，传入待跟踪系统调用号  </span><br>    <span class="hljs-keyword">if</span> (trace(atoi(argv[<span class="hljs-number">1</span>])) &lt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;%s: trace failed\n&quot;</span>, argv[<span class="hljs-number">0</span>]);  <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br>    <span class="hljs-comment">//保存待跟踪程序的名称和参数  </span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123;  <br>        nargv[i<span class="hljs-number">-2</span>] = argv[i];  <br>    &#125;  <br>    <span class="hljs-comment">//运行待跟踪的程序  </span><br>    exec(nargv[<span class="hljs-number">0</span>], nargv);  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <br>&#125;<br></code></pre></td></tr></table></figure> 由于trace的语法规定了，第二个参数必须是待追踪系统调用的数字，因此具体的执行逻辑就是通过<code>argv[2]</code>取出这个数字，然后传递到内核态，然后执行一系列的操作。</p><p>当我们需要完成一个系统调用，有了用户态的代码，自然需要增加对该系统调用的用户态声明，即在<code>user/user.h</code>文件中新增trace的系统调用声明<code>int trace(int);</code></p><p>有了声明就需要有实现，但这个实现不是真正的函数实现，而是凭借<code>ecall</code>指令进入内核态，这个部分是<code>usys.pl</code>负责完成，因此需要在代码中增添<code>entry(trace)</code></p><p><code>entry(trace)</code>，将trace的系统调用名称放入a7寄存器，下一步就是通过系统调用名称在系统调用表中找到对应的系统调用编号。因此需要在<code>kernel/syscall.h</code>中新增<code>#define SYS_trace  22</code>，并且在<code>kernel/syscall.c</code>中增添<code>sys_trace</code>的函数声明<code>extern uint64 sys_trace(void);</code>，在系统调用表中新增<code>SYS_trace</code>（即22号调用）到函数实现的映射关系，<code>[SYS_trace]   sys_trace,</code></p><p>最后，这是个和进程相关的系统调用，因此在<code>kernel/sysproc.c</code>中新增<code>sys_trace</code>函数的实现。</p><p>完成了前面的步骤，看着下面空荡荡的函数代码，我们应该怎么去完成一个trace任务呢？ <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>由于我们可能会追踪任何一个系统调用，但我们不可能修改所有系统调用的代码，因此可以想到从他们共有的内容下手，<strong>由于所有的系统调用都是通过<code>syscall.c中的syscall</code>函数来执行的，并且所有系统调用的运行参数和结果均保存在<code>proc</code>结构体中的<code>trapframe</code>结构体中，例如a7保存当前进程系统调用的编号，a0表示系统调用执行的结果。因此只需要<code>proc结构体 + syscall函数</code>，我们就可以达成任务目标。</strong></p><p>可以考虑先在proc结构体中添加一个标记，作为判断执行trace的判断标准，然后在syscall添加一段逻辑：如果当前proc对应的标记为真，则打印输出当前系统调用的结果。</p><p>总结以上过程： 1. 在proc结构体中添加标记：<code>int trace_mask;</code> 2. 修改<code>syscall</code>函数：<code>num</code>是系统调用号，如果<code>（1 &lt;&lt; num）与mask（用户输入的值）的&amp;运算结果为1</code>，则说明需要执行<code>trace</code>操作，例如如果<code>mask</code>的第二位和第六位都为1，则<code>num</code>为<code>read</code>和<code>fork</code>时就需要执行<code>trace</code>操作。 注意：由于在内核态只能拿到系统调用编号，但是用户希望在看到的是系统调用的名称，因此还需要一个表格，建立从系统调用编号到系统调用名称的映射，也就是下面代码中的<code>syscalls_name</code> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//lab2 trace 添加识别名  </span><br>   <span class="hljs-type">char</span>* syscalls_name[<span class="hljs-number">23</span>] = &#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;fork&quot;</span>, <span class="hljs-string">&quot;exit&quot;</span>, <span class="hljs-string">&quot;wait&quot;</span>, <span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;read&quot;</span>, <span class="hljs-string">&quot;kill&quot;</span>,                <span class="hljs-string">&quot;exec&quot;</span>,  <span class="hljs-string">&quot;fstat&quot;</span>, <span class="hljs-string">&quot;chdir&quot;</span>, <span class="hljs-string">&quot;dup&quot;</span>, <span class="hljs-string">&quot;getpid&quot;</span>, <span class="hljs-string">&quot;sbrk&quot;</span>, <span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-string">&quot;uptime&quot;</span>,                   <span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;write&quot;</span>, <span class="hljs-string">&quot;mknod&quot;</span>, <span class="hljs-string">&quot;unlink&quot;</span>, <span class="hljs-string">&quot;link&quot;</span>, <span class="hljs-string">&quot;mkdir&quot;</span>, <span class="hljs-string">&quot;close&quot;</span>, <span class="hljs-string">&quot;trace&quot;</span>&#125;;<br>   <br>   <span class="hljs-type">void</span>  <br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> num;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  num = p-&gt;trapframe-&gt;a7;  <br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;  <br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <br>    <span class="hljs-comment">//---------------------添加的部分--------------------------------------</span><br>    <span class="hljs-keyword">if</span>(p-&gt;trace_mask &amp; (<span class="hljs-number">1</span> &lt;&lt; num))&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid,syscalls_name[num],p-&gt;trapframe-&gt;a0);  <br>    &#125;  <br>    <span class="hljs-comment">//--------------------------------------------------------------------</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,  <br>            p-&gt;pid, p-&gt;name, num);  <br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>由此可见，trace操作的核心代码并不在<code>sys_trace</code>函数中，而是在<code>syscall</code>函数，那么<code>sys_trace</code>函数是干什么用的？</p><p>答案：取参数。用户态的trace.c代码中写明，使用trace时会传递一个参数，表示需要监视的系统调用号，而函数传参则是通过寄存器，第一个参数保存在a0寄存器，取参数需要使用<code>syscall.c中的argraw，argaddr，argint</code>三个函数，具体的实现可以看代码，<code>argraw(n)</code>是获取了发生中断时，<span class="math inline">\(a_n\)</span>寄存器对应的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> uint64  <br><span class="hljs-title function_">argraw</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <span class="hljs-keyword">switch</span> (n) &#123;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a0;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a1;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a2;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a3;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a4;  <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:  <br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a5;  <br>  &#125;  <br>  panic(<span class="hljs-string">&quot;argraw&quot;</span>);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>&#125;<br> <br><span class="hljs-comment">// Fetch the nth 32-bit system call argument.  </span><br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">argint</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> *ip)</span>  <br>&#123;  <br>  *ip = argraw(n);  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>sys_trace</code>代码如下，将取回的参数放入proc结构体 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64  <br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> mask;  <br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;mask) &lt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>  myproc()-&gt;trace_mask = mask;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>另外，实验要求fork新诞生的子进程执行系统调用时也要打印出来，因此需要修改fork代码，子进程的<code>trace_mask</code>值应与父进程保持一致：<code>np-&gt;trace_mask = p-&gt;trace_mask;</code></p><p>这样整个实验就完成了</p><h2 id="section"></h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab1 Xv6 and Unix utilities</title>
    <link href="/2023/08/14/Lab1-Xv6-and-Unix-utilities/"/>
    <url>/2023/08/14/Lab1-Xv6-and-Unix-utilities/</url>
    
    <content type="html"><![CDATA[<p><a href="%5BLab:%20Xv6%20and%20Unix%20utilities%20(mit.edu)%5D(https://pdos.csail.mit.edu/6.828/2021/labs/util.html)">课程地址</a>_</p><h2 id="配置环境">1. 配置环境</h2><ul><li><p>安装依赖 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu<br></code></pre></td></tr></table></figure> 出现网速不够的情况自行换源</p></li><li><p>git获取课程配套代码 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021<br></code></pre></td></tr></table></figure> 在根目录下运行<code>make qemu</code>，看见如下输出即启动成功 <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qemu</span>-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m <span class="hljs-number">128</span>M -smp <span class="hljs-number">3</span> -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.<span class="hljs-number">0</span><br><br><span class="hljs-attribute">xv6</span> kernel is booting<br><br><span class="hljs-attribute">hart</span> <span class="hljs-number">1</span> starting<br><span class="hljs-attribute">hart</span> <span class="hljs-number">2</span> starting<br><span class="hljs-attribute">init</span>: starting sh<br></code></pre></td></tr></table></figure></p></li></ul><h2 id="sleep指令">2. sleep指令</h2><p><strong>实验要求</strong>：为 xv6 系统实现 UNIX 的 sleep 程序。你的 sleep 程序应该使当前进程暂停相应的时钟周期数，时钟周期数由用户指定。例如执行 sleep 100 ，则当前进程暂停，等待 100 个时钟周期后才继续执行。</p><p>安装好xv6系统内核后，观察项目代码（我这里已经编译过，所以实际可能有所不同），可以发现用户态的代码聚集在user文件夹下，内核态的代码聚集在kernel文件夹下</p><p>课程需要我们仿照user目录下的命令（例如ls），写一个sleep命令，在开始这个任务前，我们有一些前置工作需要完成 1. 阅读<a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6 book</a>中的Chapter 1 2. 阅读user/目录下的所有程序，理解如何编写一个命令行程序</p><p><a href>这个链接</a>包含了我对整本书的阅读理解</p><p>通过观察user文件夹下的其他代码，可以发现如果想要实现自己的函数，需要将代码放在user文件夹下，然后将文件名称写入makefile的UPROGS <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">UPROGS=\  <br>   $U/_cat\  <br>   $U/_echo\  <br>   $U/_forktest\  <br>   $U/_grep\  <br>   $U/_init\  <br>   $U/_kill\  <br>   $U/_ln\  <br>   $U/_ls\  <br>   $U/_mkdir\  <br>   $U/_rm\  <br>   $U/_sh\  <br>   $U/_stressfs\  <br>   $U/_usertests\  <br>   $U/_grind\  <br>   $U/_wc\  <br>   $U/_zombie\<br>   $U/_sleep\  <span class="hljs-comment">//新的代码要按格式加在这里</span><br></code></pre></td></tr></table></figure></p><p>所有实验都只能使用XV6所提供的函数，记录在user.h文件下 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// system calls  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> __<span class="hljs-title function_">attribute__</span><span class="hljs-params">((<span class="hljs-keyword">noreturn</span>))</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">void</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">exec</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>**)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">mknod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">short</span>, <span class="hljs-type">short</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> stat*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">mkdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">getpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">sbrk</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;   <span class="hljs-comment">//本次实验需要使用的系统调用</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">uptime</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;  <br>  <br><span class="hljs-comment">// ulib.c  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-keyword">struct</span> stat*)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">void</span> *<span class="hljs-title function_">memmove</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*, <span class="hljs-type">int</span>)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">strchr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">char</span> c)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">strcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*, ...)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, ...)</span>;  <br><span class="hljs-type">char</span>* <span class="hljs-title function_">gets</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">int</span> max)</span>;  <br>uint <span class="hljs-title function_">strlen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">void</span>* <span class="hljs-title function_">memset</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">int</span>, uint)</span>;  <br><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(uint)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">atoi</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span>;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">memcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *, uint)</span>;  <br><span class="hljs-type">void</span> *<span class="hljs-title function_">memcpy</span><span class="hljs-params">(<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *, uint)</span>;<br></code></pre></td></tr></table></figure></p><p>模仿其他文件例如rm.c，我们可以发现，需要使用int等数据类型，因此需要引入kernel/types.h头文件，还需要包含系统调用声明的头文件user.h，stat.h中包含了与文件相关的结构体。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//rm.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>   <br><span class="hljs-comment">//程序入口，argc表示参数个数，argv分别表示每个具体参数,argv[0]是命令本身</span><br>&#123;  <br>  <span class="hljs-type">int</span> i;  <br>  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;   <span class="hljs-comment">//error处理</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: rm files...\n&quot;</span>);  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);   <br>  &#125; <br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;   <span class="hljs-comment">//循环获取参数然后执行操作</span><br>    <span class="hljs-keyword">if</span>(unlink(argv[i]) &lt; <span class="hljs-number">0</span>)&#123;  <br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;rm: %s failed to delete\n&quot;</span>, argv[i]);  <br>      <span class="hljs-keyword">break</span>;  <br>    &#125;  <br>  &#125;  <br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//正常退出</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>通过观察rm.c以及其他要求观察的代码，我们可以发现实现一个可以在shell中运行程序需要按照如下模板： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从kernel和user中获取需要的头文件，sleep不需要文件操作，所以不需要stat.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br><br><span class="hljs-comment">//程序入口，argc表示参数个数，argv分别表示每个具体参数,argv[0]是命令本身</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>   <br>&#123;  <br><span class="hljs-comment">//参数处理模块</span><br><span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>)&#123;  <br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: xxx files...\n&quot;</span>);  <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);   <br>&#125; <br><br><span class="hljs-comment">//获取参数，执行程序的模块</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;   <br><br>    &#125;  <br><br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//正常退出</span><br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>按照要求完成sleep代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: sleep &lt;ticks&gt;\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> ticks = atoi(argv[<span class="hljs-number">1</span>]); <br>    sleep(ticks);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure> 在目录下使用执行测试：./grade-lab-util sleep 结果如下： <img src="20230718234029.png" alt="实验结果"></p><h2 id="pingpong">3. pingpong</h2><p><strong>实验要求</strong>：使用 UNIX 系统调用编写一个程序 pingpong ，在一对管道上实现两个进程之间的通信。父进程应该通过第一个管道给子进程发送一个信息 “ping”，子进程接收父进程的信息后打印 <pid>: received ping ，其中是其进程 ID 。然后子进程通过另一个管道发送一个信息 “pong” 给父进程，父进程接收子进程的信息然后打印 <pid>: received pong ，然后退出。</pid></pid></p><p><strong>实验提示</strong>： - 使用 pipe 创建管道。 - 使用 fork 创建一个子进程。 - 使用 read 从管道读取信息，使用 write 将信息写入管道。 - 使用 getpid 获取当前 进程 ID 。 - 将程序添加到 Makefile 中的 UPROGS 。 - xv6 上的用户程序具有有限的库函数可供它们使用。你可以在 user/user.h 中查看，除系统调用外其他函数代码位于 user/ulib.c 、user/printf.c 、和 user/umalloc.c 中。</p><p><strong>实验代码</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br>    pipe(p);<br>    pipe(p1);  <span class="hljs-comment">//开启两个管道，p用于父进程向子进程传输，p1则相反</span><br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;  <br>        close(p[<span class="hljs-number">1</span>]);       <span class="hljs-comment">//子进程关闭p的写入端，管道不能有多余的端口</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];  <br>        read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-number">10</span>);  <span class="hljs-comment">//利用p从父进程读取信息</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf);  <span class="hljs-comment">//打印读取到的信息</span><br>        close(p[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//关闭p的读取端，完成一次传输</span><br>        close(p1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//子进程关闭p1的读取端，准备向父进程传输信息</span><br>        write(p1[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">//写入信息</span><br>        close(p1[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//写入完成，关闭p1的写入端</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        close(p[<span class="hljs-number">0</span>]);     <span class="hljs-comment">//父进程关闭p的读取端，管道不能有多余的端口</span><br>        write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;pong&quot;</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment">//向子进程传输信息</span><br>        close(p[<span class="hljs-number">1</span>]);   <span class="hljs-comment">//写入完成，关闭p的写入端口</span><br>        close(p1[<span class="hljs-number">1</span>]);    <span class="hljs-comment">//关闭p1管道的写入端，准备从子进程读取信息</span><br>        <span class="hljs-type">char</span> buf1[<span class="hljs-number">10</span>];  <br>        read(p1[<span class="hljs-number">0</span>], buf1, <span class="hljs-number">10</span>); <span class="hljs-comment">//利用p1从子进程读取信息 </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received %s\n&quot;</span>, getpid(), buf1); <br>        close(p1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//读取完成，关闭读取端</span><br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <span class="hljs-comment">//正常结束，退出</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>整个实验其实是考察对管道的理解程度，让我们熟练应用管道</p><h2 id="primes">3. primes</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc make makefile概述</title>
    <link href="/2023/08/07/gcc-make-makefile%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/08/07/gcc-make-makefile%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>MIT6.S081的实验都是基于C语言完成的，每当完成一个新函数（例如Lab1的sleep函数），都需要将它加入到makefile文件中编辑，那么弄清楚makefile，gcc相关的一些编译知识就非常有必要了。</p><h2 id="gcc概述">GCC概述</h2><p>gcc是一个编译器，将一个c语言代码编译为可执行文件的流程如下： <img src="20230714160858.png"></p><p><strong>1. 预处理（pre-processing）</strong> <code>gcc -E hello.c -o hello.i</code>，将引入的头文件（#include）和定义的宏（#define）扩展到代码中，预处理之后的程序还是文本，可以用文本编辑器打开，上述命令中-E是让编译器在预处理之后就退出，不进行后续编译过程</p><p><strong>2. 编译（compilation）</strong> <code>gcc -S hello.i -o hello.s</code>，将预处理过的文件编译成汇编程序，在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error）</p><p><strong>3. 汇编（assembly）</strong> <code>gcc -c hello.s hello.o</code>，将汇编程序转换成目标文件，二进制格式机器码，每一个源文件都需要产生一个目标文件</p><p><strong>4. 链接（linker）</strong> <code>gcc hello.o -o hello</code>，将一个或多个目标文件连接成最终的可执行文件</p><h2 id="gcc常用参数">GCC常用参数</h2><ol type="1"><li>--version 查看版本</li><li>-v（verbose冗长的），输出编译的详细信息</li><li>-std 指定标准</li><li>-o 指定输出文件的名称</li><li>-Wall 输出所有的警告信息</li><li>-c 只将源文件编译为 object 文件（*.o），而不进行链接，之后可以使用 <code>gcc -o myprog.exe file1.o file2.o</code> 将多个 object 文件连接成可执行文件</li><li>-shared 编译为共享库（<em>.dll，</em>.so）</li><li>-S 编译为汇编代码</li></ol><h2 id="makefile">Makefile</h2><p><strong>会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力</strong>。因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按<strong>类型、功能、模块</strong>分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作</p><p>因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile成为了一种在工程方面的编译方法。</p><p>但是不同的厂商make各不相同，本介绍只对GNU的make进行介绍。</p><h4 id="makefile里有什么">Makefile里有什么？</h4><p>Makefile里主要包含了<strong>五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</strong></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book Chapter2</title>
    <link href="/2023/07/27/xv6-book-Chapter2/"/>
    <url>/2023/07/27/xv6-book-Chapter2/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter2-操作系统组织结构">Chapter2 操作系统组织结构</h1><p>Chapter 1中主要提到了操作系统提供的常见接口（系统调用），并且利用这些接口实现了一些可以在shell窗口运行的程序，但是并没有进入到内核中去。</p><p>一个操作系统最核心的功能就是给用户提供使用硬件的环境，可以井井有条的运行多个程序。这个过程涉及到了几个问题： 1. 操作系统如何为进程分配资源？（资源分配） 2. 操作系统如何确保所有进程都能执行？即使进程数量大于CPU数量（进程调度）， 3. 一个进程发生故障怎样才能不影响其他进程？（隔离） 4. 进程之间如何拥有安全的交互渠道?（管道） 总的来说，上面的问题可以展现出人们对操作系统的三个核心需求：多路复用，隔离和交互</p><p>Chapter 2的主要目标就是： 1. 理解如何组织操作系统（单片内核）以实现这三个核心需求 2. 弄清楚xv6系统启动时运行的第一个进程（xv6系统的隔离单元）</p><p>注意：Xv6运行在多核RISC-V微处理器上，它的许多底层功能（例如进程实现）是针对于RISC-V的。RISC-V是64位CPU，而xv6是用“LP64”C语言编写的，这意味着C编程语言中的long数据类型和指针大小是64位，而int是32位。本书假设读者已经在某些架构上做了一些机器级编程，并将介绍risc - v特定的思想</p><h2 id="操作系统抽象硬件资源的意义">操作系统抽象硬件资源的意义</h2><p>为什么要有操作系统？能不能让应用程序直接和硬件发生交互？ 答案是肯定的，在这种情况下，每个应用程序都有自己定制的库，可以根据硬件的特性，以最适合的方式组织应用程序的代码设计，例如嵌入式设备的操作系统</p><p>但是这样做的缺点是：如果有多个应用程序同时执行（通用PC需要同时执行很多程序），每个程序必须定期的放弃自己目前占用的CPU，使得其他程序可以运行。这个过程要求程序相互信任且不会发生错误，在普遍的计算机设备上显然是不现实的</p><p>因此在大多数情况下，将应用程序隔离，禁止直接访问敏感的硬件资源，并将资源抽象成一种服务，是更好的方案</p><p>举个例子，假如有甲乙丙丁四个人去办公室盖公章，操作系统就像一个公章管理者，提供一种叫做&quot;盖公章&quot;的服务，甲乙丙丁四人只需要请求这个服务，操作系统就会将公章交给他使用并进行监督，一旦使用时间到了就交给下一个人。如果没有操作系统，那么每个人都可以来争抢公章并使用，一旦甲抢到了公章并且长时间使用不归还，那么其他人就一直无法完成盖公章的任务</p><p>再从计算机的角度考虑，Unix应用程序仅通过文件系统的open、write、read和close四个系统调用与存储交互，具体的磁盘管理由操作系统来完成</p><p>再比如，Unix在进程之间切换CPU，即使A程序陷入死循环，不用担心其他程序无法运行。看起来A一直死循环占用CPU，但其实每过一定时间，A会被迫暂停运行，由其他程序占用CPU</p><p>总的来说，使用操作系统抽象硬件资源的好处和API编程时&quot;封装&quot;的好处类似（方便好用，隐藏内部复杂的实现细节，可移植性，可维护性等等）</p><h2 id="cpu对进程隔离的硬件级别支持">CPU对进程隔离的硬件级别支持</h2><p>我们需要一个操作系统来为应用程序提供底层硬件的抽象服务，而系统调用接口就是操作系统具体提供服务的方式，这既为程序员提供了便利，又提供了强隔离的可能性。</p><p>为了达成这一点，操作系统必须使得应用程序不能访问其他进程的内存以及操作系统的数据结构和指令，即不同的进程之间需要相互隔离。<strong>CPU的特权等级机制为这一要求的实现提供了硬件级别的支持</strong>（通过设置一个模式位来实现）</p><p>例如，RISC-V有三种执行CPU指令的模式：User级中运行用户程序；Supervisor级中运行操作系统内核（和设备驱动）；Machine级中运行BootLoader和其它固件。 正常情况下，处理器一直在某个特权等级下运行，除非进入trap（诸如软硬件中断、异常等）才有可能发生特权等级的转换</p><p>对于现代操作系统（如Linux、Windows等）而已，用户程序都运行在用户态，当它们需要切换到内核态以获得更高权限时，需要向操作系统申请；而操作系统内核和设备驱动程序则默认就运行在内核态。每个用户线程也拥有两个栈，一个是用户态栈，一个是内核态栈，分别当处于用户态和内核态时使用。操作系统的用户态和内核态对应到处理器的硬件层面上，即为不同的特权等级。在RISC-V中，用户态一般对应User Mode，而内核态一般对应Supervisor Mode。</p><p>一般来说用户程序一直运行在用户态中，只有当发生中断才会转到内核态中 中断可以分为三类： 1. 系统调用（又称陷入），在程序中使用系统调用引起； 2. 异常，当应用程序运行时出现异常时（比如最常见的缺页异常）也会切换到内核态进行处理； 3. 外部中断，由CPU外部引起的中断（或者说与CPU执行指令无关的事件），如I/O中断、时钟中断</p><h2 id="单片内核与微内核">单片内核与微内核</h2><p>我们已经知道了操作系统的一些重要指令只有在Supervisor模式下才能执行，那么究竟操作系统的哪些指令应该放在Supervisor模式运行？一种可能性是整个操作系统驻留在内核中，因此所有系统调用的实现都以Supervisor模式运行，这种组织方式被称为<strong>单片内核</strong>。整个操作系统以完全硬件特权运行。</p><p>这种组织使得操作系统的不同部分更容易协作，例如一个操作系统可能有一个缓冲缓存，它可以被文件系统和虚拟内存系统共享；缺点是操作系统不同部分之间的接口通常很复杂，而且内核中出现错误时会导致所有应用程序崩溃（例如windows蓝屏），计算机必须重新启动。</p><p>为了减少在内核中出错的风险，操作系统设计者可以尽量减少在管理模式下运行的操作系统代码的数量，并在用户模式下执行大部分操作系统。这种内核组织称为<strong>微内核</strong>，如下图所示。 <img src="20230718182913.png" alt="微内核"></p><p>文件系统作为用户级进程运行。作为进程运行的操作系统服务称为服务器。为了允许应用程序与文件服务器交互，内核提供了一个进程间通信机制，将消息从一个用户模式进程发送到另一个用户模式进程。例如，如果像shell这样的应用程序想要读取或写入文件，它会向文件服务器发送消息并等待响应，内核中只保留最基本的功能（进程管理、内存管理和通信）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown">微内核和单片内核（宏内核）的区别：<br>微内核：将非基本的操作系统功能从内核移到用户态，内核中只保留最基本的功能（进程管理、内存管理和通信）<br>缺点：效率低，需要频繁地在用户态和内核态之间切换<br>优点：<br><span class="hljs-bullet">1.</span> 便于扩展操作系统，新服务可以在用户空间增加，几乎不需要修改内核。<br><span class="hljs-bullet">2.</span> 精简内核，代码量减少，更容易实现，更好debug。<br><span class="hljs-bullet">3.</span> 微内核相比于宏内核更加稳定，因为大部分功能外移，内核中可能出现的错误也相应地减少。<br><br>宏内核：将操作系统的所有功能最为一个紧密的整体都放在内核中。<br>缺点：不易扩展，内核出错概率更大，debug难<br>优点：执行效率高<br><br>微内核的操作系统有：Window,Minix,Mac等等。<br>宏内核的操作系统有：Unix，Linux等等。<br></code></pre></td></tr></table></figure><p>XV6的内核源文件（位于kernel文件目录下）如下图所示，按照模块化的概念，源代码被粗略的分成多个文件，每个文件都注释了各自的作用。defs.h文件下定义了模块间的接口。 <img src="20230718183155.png" alt="xv6源文件结构"></p><p>虽然kernel实现的比较简单，代码量甚至比一般的微内核还少，但因为XV6在内核中实现了<strong>整个操作系统</strong>，内核接口就是操作系统接口，所以XV6属于宏内核</p><h2 id="操作系统的启动过程">操作系统的启动过程</h2><p>虽然已经明白了理解了操作系统内核的概念，但是它看起来仍然是一个虚无缥缈的东西，只有先弄清楚操作系统宏观意义上是如何启动的，我们才能进一步深入操作系统内部去理解它提供的服务。</p><p>因此我们需要先弄清楚，一台计算机在刚刚通电，<strong>内存为空的情况下</strong>，CPU是如何一步一步将操作系统运行起来的？</p><p>当risc-v计算机通电后， 1. 首先把CPU所有寄存器初始化（初始值由CPU制造商设置），除了CS寄存器的值设为0xFFFF，其他寄存器的值都为0，这样，根据CS 和 IP的值就可以找到指令的物理地址0xFFFF:0x0000，也就是0xFFFF0。这个地址存放CPU的第一条指令。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">CS的全拼为Code segment，即代码段寄存器，对应于内存中的存放代码的内存区域，用来存放内存代码段区域的入口地址（段基址）<br>IP全称instruction Pointer，指针寄存器，用来记录偏移量<br>CPU在执行指令时，通过CS和IP来确定要执行的下一条指令的内存地址，计算方式一般为CS左移<span class="hljs-number">4</span>位然后加上IP寄存器<br><br>例如：<span class="hljs-number">0xFFFF0</span> = <span class="hljs-number">0xFFFF</span> &lt;&lt; <span class="hljs-number">4</span> + <span class="hljs-number">0x0000</span><br></code></pre></td></tr></table></figure> 2. CPU开始从寄存器读取并运行指令，0xFFFF0存放的是一条无条件跳转指令JMP，跳转到BIOS的位置。（Bios是一段写在ROM中的程序，内容不会随着断电小时） 3. BIOS首先先进行POST（Power－On Self Test，<strong>加电后自检</strong>）。POST主要检测系统中一些关键设备例如内存和显卡等设备是否正常工作；如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。 4. 之后CPU开始寻找引导扇区，将引导扇区中的指令加载到物理内存 0x7C00处， 修改IP寄存器的值跳转到0x7C00执行指令，从而实现了将 CPU的使用权交给引导扇区中的 Boot 程序。 5. 引导加载器装载XV6内核到内存0x8000000开始的存储空间中，然后在machine mode下，CPU从kernel/entry.s处的_entry处开始执行指令</p><h3 id="entry.s">entry.S</h3><p>进入到entry.S <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c">        <span class="hljs-meta"># qemu -kernel loads the kernel at 0x80000000  </span><br>        <span class="hljs-meta"># and causes each hart (i.e. CPU) to jump there.  </span><br>        <span class="hljs-meta"># kernel.ld causes the following code to  </span><br>        <span class="hljs-meta"># be placed at 0x80000000.  </span><br>.section .text<br>.global _entry  <br>_entry:  <br>        <span class="hljs-meta"># set up a stack for C.  </span><br>        # stack0 is declared in start.c,  <br>        <span class="hljs-meta"># with a 4096-byte stack per CPU.  </span><br>        <span class="hljs-meta"># sp = stack0 + (hartid * 4096)</span><br><br>#将stack0读取到SP寄存器<br>        la sp, stack0  <br>#把<span class="hljs-number">4096</span>这个立即数存放到a0寄存器中<br>        li a0, <span class="hljs-number">1024</span>*<span class="hljs-number">4</span>  <br>        #将CPU的id读取到寄存器a1<br>        csrr a1, mhartid<br>        <span class="hljs-meta">#addi mul add三条运算指令完成sp = stack0 + (hartid * 4096)计算     </span><br>        addi a1, a1, <span class="hljs-number">1</span><br>        mul a0, a0, a1  <br>        add sp, sp, a0  <br>        #指令跳转，jump to <span class="hljs-title function_">start</span><span class="hljs-params">()</span> in start.c  <br>        call start  <br>spin:  <br>        j spin<br></code></pre></td></tr></table></figure></p><p>entry.s其实干了这些事情：为每个CPU分配了栈空间。 stack0是一个声明的外部符号，把它作为CPU的上栈的起始地址，然后按照公式，<code>sp = stack0 + (hartid * 4096)</code>，算出每个CPU对应的栈起始地址（sp是堆栈指针寄存器，hartid是CPU id，csr是控制和状态寄存器，csrr是读取csr寄存器的内容，la是地址加载指令，li是立即数加载指令）。</p><p>注意：此时CPU仍然处于machine mode，还没有切换到Supervisor Mode</p><h3 id="start.c">start.c</h3><p>代码比较长，因此会分成三个部分讲解</p><ul><li><strong>第一部分</strong> 完成了栈初始化后，CPU接下来要干什么？看看start.c的第一部分代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;param.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memlayout.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span>  </span><br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">timerinit</span><span class="hljs-params">()</span>;  <br>  <br><span class="hljs-comment">// entry.S needs one stack per CPU.  </span><br>__attribute__ ((aligned (<span class="hljs-number">16</span>))) <span class="hljs-type">char</span> stack0[<span class="hljs-number">4096</span> * NCPU];  <br>  <br><span class="hljs-comment">// a scratch area per CPU for machine-mode timer interrupts.  </span><br>uint64 timer_scratch[NCPU][<span class="hljs-number">5</span>];  <br>  <br><span class="hljs-comment">// assembly code in kernelvec.S for machine-mode timer interrupt.  </span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">timervec</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li></ul><p>__attribute__定义了entry.S中的栈，要求16bit对齐</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">什么是内存对齐？<br>计算机中内存空间是按照<span class="hljs-built_in">byte</span>划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是：在访问特定类型变量的时候通常在特定的内存地址访问，这就需要对这些数据在内存中存放的位置有限制，各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。<br>内存对齐是编译器的管辖范围。表现为：编译器为程序中的每个“数据单元”安排在适当的位置上。<br><br>如果放置数据不考虑对齐，<span class="hljs-number">32</span>位的<span class="hljs-meta">CPU</span>读取一个<span class="hljs-number">4</span>字节的interesting最多需要两次内存访问（左图），如果对齐则只需要一次（如右图）<br></code></pre></td></tr></table></figure><p><img src="20230727122632.png" alt="内存对齐"> timer_scratch是一组共享变量，用于每个CPU的machine mode定时器中断 timervec是timer中断处理函数，在接下来的timerinit中会用到</p><ul><li><strong>第二部分</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// entry.S jumps here in machine mode on stack0.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">start</span><span class="hljs-params">()</span>  <br>&#123;  <br>  <span class="hljs-comment">// set M Previous Privilege mode to Supervisor, for mret.  </span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_mstatus();  <br>  x &amp;= ~MSTATUS_MPP_MASK;  <br>  x |= MSTATUS_MPP_S;  <br>  w_mstatus(x);  <br>  <br>  <span class="hljs-comment">// set M Exception Program Counter to main, for mret.  </span><br>  <span class="hljs-comment">// requires gcc -mcmodel=medany  </span><br>  w_mepc((uint64)main);  <br>  <br>  <span class="hljs-comment">// disable paging for now.  </span><br>  w_satp(<span class="hljs-number">0</span>);  <br>  <br>  <span class="hljs-comment">// delegate all interrupts and exceptions to supervisor mode.  </span><br>  w_medeleg(<span class="hljs-number">0xffff</span>);  <br>  w_mideleg(<span class="hljs-number">0xffff</span>);  <br>  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);  <br>  <br>  <span class="hljs-comment">// configure Physical Memory Protection to give supervisor mode  </span><br>  <span class="hljs-comment">// access to all of physical memory.  w_pmpaddr0(0x3fffffffffffffull);  </span><br>  w_pmpcfg0(<span class="hljs-number">0xf</span>);  <br>  <br>  <span class="hljs-comment">// ask for clock interrupts.  </span><br>  timerinit();  <br>  <br>  <span class="hljs-comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().  </span><br>  <span class="hljs-type">int</span> id = r_mhartid();  <br>  w_tp(id);  <br>  <br>  <span class="hljs-comment">// switch to supervisor mode and jump to main().  </span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;mret&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>CPU在entry.S定义了栈，然后从entry.S代码发生跳转，目的地是start.c文件中的start函数，这一段代码出现了很多读写寄存器的函数，下面进行讲解。 <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">注意：<span class="hljs-built_in">start</span>.c代码不像其他程序有main入口，因此<span class="hljs-built_in">start</span>不会像一个调用一样返回(没有returning)。由于它处于machine <span class="hljs-built_in">mode</span>下，因此其实是通过操作寄存器将这些事情设置的像一个正常执行的普通调用一样。<br></code></pre></td></tr></table></figure></p><p>无论何时，一个 RISC-V 硬件线程（hart）总是会运行在某一个特权级，而这个信息则是通过两个二进制位编码记录在了多个 <strong>CSR</strong> 寄存器（control and status registers）中，其中就包括状态寄存器（Status Register）</p><p>状态寄存器分为两种（mstatus/sstatus）作用在于记录并控制当前 CPU 的运行状态，<code>mstatus</code> 对应 M 模式，<code>sstatus</code> 对应 S 模式，具体字段如下图所示，本代码通过操作mstatus寄存器的MPP和SPP字段来达到修改CPU特权等级的目的。 <img src="20230727125258.png" alt="mstatus寄存器"></p><p>如下是代码中不容易理解的一些函数： 1. <strong>mstatus</strong>(Machine Status Registers)：保存了上一个特权模式，调用mret指令就立刻进入保存好的特权模式。因此设置好mstatus寄存器的值，再调用mret指令可以达到切换特权等级的目的。w_mstatus即write mstatus，写入mstatus寄存器，同理r_mstatus即read mstatus，表示读取mstatus寄存器的内容。 2. <strong>mepc</strong>(Machine Exception Program Counter Registers)：设置mret的返回地址。本代码将它设置为内核main函数的地址，因此mret指令完成，CPU会查询mepc寄存器，开始执行main函数。 3. <strong>satp</strong>(Supervisor Address Translation and Protection Registers)：页表寄存器，写入0就禁用了页表硬件。w_satp表示写入页表寄存器。 4. <strong>asm</strong> <strong>volatile</strong>(“xxx”); “<strong>asm</strong>” 表示后面的代码为内嵌汇编, “<strong>volatile</strong>” 表示编译器不要优化代码,后面的指令保留原样。括号里面的xxx是汇编指令。 通过这些函数，我们大概能猜到整个代码的逻辑：通过设置mstatus的模式为Supervisor Mode，mret的返回地址设置为main，再调用mret成功设置特权等级，并且让CPU紧接着准备执行main代码，这样xv6就在Supervisor Mode中进入内核程序主函数了。</p><p>具体过程如下： 1. 通过在寄存器<code>mstatus</code>中，设置之前的特权模式为Supervisor Mode(24-27行) <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_mstatus();  <br>  x &amp;= ~MSTATUS_MPP_MASK;  <br>  x |= MSTATUS_MPP_S;  <br>  w_mstatus(x);  <br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSTATUS_MPP_MASK (3L &lt;&lt; 11) <span class="hljs-comment">// previous mode.</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSTATUS_MPP_M (3L &lt;&lt; 11)   3L表示long 3，3是machine mode的编码</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSTATUS_MPP_S (1L &lt;&lt; 11)   1是super</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MSTATUS_MPP_U (0L &lt;&lt; 11)</span><br>riscv.h文件中定义了这几个<br></code></pre></td></tr></table></figure> 2. 通过写入main地址到寄存器<code>mepc</code>，设置返回地址为main的地址(31行) <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">w_mepc((uint64)main);  <br></code></pre></td></tr></table></figure> 3. 通过写入0到页表寄存器<code>satp</code>，在Supervisor Mode中将<strong>虚拟地址禁用</strong>(34行) <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// disable paging for now.  </span><br>w_satp(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure> 4. 将所有的异常与中断托付给Supervisor Mode(37-39行) <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// delegate all interrupts and exceptions to supervisor mode.  </span><br>w_medeleg(<span class="hljs-number">0xffff</span>);  <br>w_mideleg(<span class="hljs-number">0xffff</span>);  <br>w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);<br></code></pre></td></tr></table></figure> 事实上，在RISC-V的标准定义中，所有陷阱默认都是由机器模式(M-mode)来处理的。然而，在支持操作系统的设备上往往都实现了监管者模式(S-Mode)，如果按照默认模式发生中断则应该首先陷入M-Mode下的中断处理程序，然后触发一个S-Mode下的中断再mret回S-Mode下处理，这个过程过于繁琐且需要程序员自己实现，所以：</p><p>RISC-V标准为了应对这种情况提出了陷阱委派机制。也就是说在M-Mode下可以配置寄存器，从而使得S-Mode下的所有陷阱都被S-Mode下的陷阱处理函数自动接管。有两个寄存器，medeleg和mideleg，分别用来管理异常和中断的委派。</p><ol start="5" type="1"><li>使Supervisor Mode能够接触到所有物理内存(43-44行)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// configure Physical Memory Protection to give supervisor mode  </span><br><span class="hljs-comment">// access to all of physical memory.  </span><br>w_pmpaddr0(<span class="hljs-number">0x3fffffffffffff</span>ull);  <br>w_pmpcfg0(<span class="hljs-number">0xf</span>);<br></code></pre></td></tr></table></figure></li><li>请求时钟中断，clock初始化（具体实现在后文讲解） <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ask for clock interrupts.  </span><br>timerinit();  <br></code></pre></td></tr></table></figure></li><li>获取CPU的ID并保存在tp寄存器中 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().  </span><br>  <span class="hljs-type">int</span> id = r_mhartid();  <br>  w_tp(id);  <br></code></pre></td></tr></table></figure></li></ol><ul><li><strong>第三部分</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arrange to receive timer interrupts.  </span><br><span class="hljs-comment">// they will arrive in machine mode at  </span><br><span class="hljs-comment">// at timervec in kernelvec.S,  </span><br><span class="hljs-comment">// which turns them into software interrupts for  </span><br><span class="hljs-comment">// devintr() in trap.c.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">timerinit</span><span class="hljs-params">()</span>  <br>&#123;  <br>  <span class="hljs-comment">// each CPU has a separate source of timer interrupts.  </span><br>  <span class="hljs-type">int</span> id = r_mhartid();  <br>  <br>  <span class="hljs-comment">// ask the CLINT for a timer interrupt.  </span><br>  <span class="hljs-type">int</span> interval = <span class="hljs-number">1000000</span>; <span class="hljs-comment">// cycles; about 1/10th second in qemu.  </span><br>  *(uint64*)CLINT_MTIMECMP(id) = *(uint64*)CLINT_MTIME + interval;  <br>  <br>  <span class="hljs-comment">// prepare information in scratch[] for timervec.  </span><br>  <span class="hljs-comment">// scratch[0..2] : space for timervec to save registers.  // scratch[3] : address of CLINT MTIMECMP register.  // scratch[4] : desired interval (in cycles) between timer interrupts.  uint64 *scratch = &amp;timer_scratch[id][0];  </span><br>  scratch[<span class="hljs-number">3</span>] = CLINT_MTIMECMP(id);  <br>  scratch[<span class="hljs-number">4</span>] = interval;  <br>  w_mscratch((uint64)scratch);  <br>  <br>  <span class="hljs-comment">// set the machine-mode trap handler.  </span><br>  w_mtvec((uint64)timervec);  <br>  <br>  <span class="hljs-comment">// enable machine-mode interrupts.  </span><br>  w_mstatus(r_mstatus() | MSTATUS_MIE);  <br>  <br>  <span class="hljs-comment">// enable machine-mode timer interrupts.  </span><br>  w_mie(r_mie() | MIE_MTIE);  <br>&#125;<br></code></pre></td></tr></table></figure><p>第三部分是时钟中断的初始化，可以先放着不管，后续有实验内容帮助理解中断的过程。</p><h3 id="main.c">main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;param.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memlayout.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span>  </span><br>  <br><span class="hljs-keyword">volatile</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> started = <span class="hljs-number">0</span>;  <br>  <br><span class="hljs-comment">// start() jumps here in supervisor mode on all CPUs.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">main</span><span class="hljs-params">()</span>  <br>&#123;  <br>  <span class="hljs-keyword">if</span>(cpuid() == <span class="hljs-number">0</span>)&#123;  <br>    consoleinit();  <br>    printfinit();  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xv6 kernel is booting\n&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    kinit();         <span class="hljs-comment">// physical page allocator  </span><br>    kvminit();       <span class="hljs-comment">// create kernel page table  </span><br>    kvminithart();   <span class="hljs-comment">// turn on paging  </span><br>    procinit();      <span class="hljs-comment">// process table  </span><br>    trapinit();      <span class="hljs-comment">// trap vectors  </span><br>    trapinithart();  <span class="hljs-comment">// install kernel trap vector  </span><br>    plicinit();      <span class="hljs-comment">// set up interrupt controller  </span><br>    plicinithart();  <span class="hljs-comment">// ask PLIC for device interrupts  </span><br>    binit();         <span class="hljs-comment">// buffer cache  </span><br>    iinit();         <span class="hljs-comment">// inode table  </span><br>    fileinit();      <span class="hljs-comment">// file table  </span><br>    virtio_disk_init(); <span class="hljs-comment">// emulated hard disk  </span><br>    userinit();      <span class="hljs-comment">// first user process  </span><br>    __sync_synchronize();  <br>    started = <span class="hljs-number">1</span>;  <br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-keyword">while</span>(started == <span class="hljs-number">0</span>)  <br>      ;  <br>    __sync_synchronize();  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hart %d starting\n&quot;</span>, cpuid());  <br>    kvminithart();    <span class="hljs-comment">// turn on paging  </span><br>    trapinithart();   <span class="hljs-comment">// install kernel trap vector  </span><br>    plicinithart();   <span class="hljs-comment">// ask PLIC for device interrupts  </span><br>  &#125;  <br>  <br>  scheduler();          <br>&#125;<br></code></pre></td></tr></table></figure><p>在执行完 start 函数后，开始执行 main 函数。首先，判断当前的 CPU 的 ID 是否为主 CPU（cpuid() == 0） 。</p><p>如果是主 CPU ，则执行一系列的初始化操作，包括： - <code>consoleinit();</code>控制台初始化； - <code>printfinit();</code>打印模块初始化； - <code>kinit();</code>和 <code>kvminit();</code>创建内核页表； - <code>kvminithart();</code>打开分页机制； - <code>procinit();</code>创建进程表； - <code>trapinit();</code>和 <code>trapinithart();</code> 和<code>plicinit();</code> 设置系统中断向量和系统中断初始化； - <code>plicinithart();</code>设备中断初始化； - <code>binit();</code>和<code>iinit();</code>磁盘缓冲和磁盘节点的初始化； - <code>fileinit();</code>文件系统的初始化； - <code>virtio_disk_init();</code>磁盘初始化； - <code>userinit();</code>创建第一个用户进程，第一个进程执行一个小程序 user/initcode.S ，该程序通过调用 exec 系统调用重新进入内核； - <code>sync_synchronize();</code> 是 gcc 提供的原子操作，保证内存访问的操作都是原子操作； - <code>started = 1;</code> 是设置初始化完成的标志。</p><p>如果不是主 CPU ，首先循环等待主 CPU 初始化完成，当主 CPU 初始化完成，则初始化完成标志 started 为 1 ，跳出循环。然后同样是： - <code>sync_synchronize();</code> gcc 提供的原子操作，保证内存访问的操作都是原子操作。 - <code>kvminithart();</code> 打开分页功能 - <code>trapinithart();</code>和 <code>plicinithart();</code>设置系统和设备的中断初始化。</p><p>以上函数的声明都包含在kernel/defs.h文件中。</p><h2 id="第一个用户进程">第一个用户进程</h2><p>从main.c代码中我们可以发现在启动第一个进程之前，还有很多准备工作。我们暂时不去看他们，先学习第一个进程对应的代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Set up first user process.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">userinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>    <span class="hljs-comment">//新建进程的结构体</span><br>  <br>  p = allocproc();   <span class="hljs-comment">//第一个进程分配空间等初始化步骤基本都在该函数中进行，具体看下文</span><br>  initproc = p;  <br>    <br>  <span class="hljs-comment">// allocate one user page and copy init&#x27;s instructions  </span><br>  <span class="hljs-comment">// and data into it.  </span><br>  uvminit(p-&gt;pagetable, initcode, <span class="hljs-keyword">sizeof</span>(initcode));   <br>  p-&gt;sz = PGSIZE;   <span class="hljs-comment">//sz变量表示进程的最大内存空间</span><br>  <br>  <span class="hljs-comment">// prepare for the very first &quot;return&quot; from kernel to user.  </span><br>  <span class="hljs-comment">// user program counter</span><br>  <span class="hljs-comment">//指令指针指向初始化代码的入口点，即地址0。</span><br>  p-&gt;trapframe-&gt;epc = <span class="hljs-number">0</span>;  <br>  <span class="hljs-comment">// user stack pointer </span><br>  <span class="hljs-comment">//栈指针被设置为虚拟空间最大值（初始化）</span><br>  p-&gt;trapframe-&gt;sp = PGSIZE;  <br>  <br>  safestrcpy(p-&gt;name, <span class="hljs-string">&quot;initcode&quot;</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;name));   <span class="hljs-comment">//设置进程的名称，方便调试</span><br>  p-&gt;cwd = namei(<span class="hljs-string">&quot;/&quot;</span>);   <span class="hljs-comment">//指定进程的工作目录</span><br>  <br>  p-&gt;state = RUNNABLE;   <span class="hljs-comment">//进程已经初始化完毕，修改状态，表示它可以被调度了</span><br>  <br>  release(&amp;p-&gt;lock);   <span class="hljs-comment">//完成对进程的操作，释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure></p><hr><p>这段代码内部完成了很多事情，把他拆开来看：</p><p><strong>1. allocproc函数</strong>（构建新进程） <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//进程表，NPROC表示支持的最大进程数量，xv6设置为64</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> <span class="hljs-title">proc</span>[<span class="hljs-title">NPROC</span>];</span><br><br><span class="hljs-comment">// Look in the process table for an UNUSED proc.  </span><br><span class="hljs-comment">// If found, initialize state required to run in the kernel,  </span><br><span class="hljs-comment">// and return with p-&gt;lock held.  </span><br><span class="hljs-comment">// If there are no free procs, or a memory allocation fails, return 0.  </span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc* <br><span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>  <br><br><span class="hljs-comment">//proc是进程表，&amp;proc[NPROC]是获取数组首地址，循环通过递增指针的方式遍历进程表</span><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    acquire(&amp;p-&gt;lock);  <span class="hljs-comment">//每个表格中的进程要加锁才能进行操作，同时该函数会关闭中断避免死锁</span><br>    <span class="hljs-keyword">if</span>(p-&gt;state == UNUSED) &#123;   <span class="hljs-comment">//寻找第一个state为UNUSED（未使用的）进程</span><br>      <span class="hljs-keyword">goto</span> found;   <span class="hljs-comment">//找到空位，可以执行初始化进程的操作</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;   <br>      release(&amp;p-&gt;lock);   <span class="hljs-comment">//未找到空位，释放当前指针所指向进程的锁，然后继续循环寻找</span><br>    &#125;  <br>  &#125;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  <br>found:   <br>  p-&gt;pid = allocpid();   <span class="hljs-comment">//为进程分配pid（进程的编号，唯一标识）</span><br>  p-&gt;state = USED;   <span class="hljs-comment">//将state设置为USED（已使用），state用于描述进程的状态</span><br>  <br>  <span class="hljs-comment">// Allocate a trapframe page.  </span><br>  <span class="hljs-comment">//为进程分配trapframe（用于保存中断时的进程上下文），这个结构在中断章节会进一步讲解</span><br>  <span class="hljs-comment">//kalloc函数可以分配物理内存，失败则返回0，这里是</span><br>  <span class="hljs-keyword">if</span>((p-&gt;trapframe = (<span class="hljs-keyword">struct</span> trapframe *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p);   <span class="hljs-comment">//如果分配失败，则将设置的pid等信息全部还原</span><br>    release(&amp;p-&gt;lock);   <span class="hljs-comment">//释放锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-comment">// An empty user page table.</span><br>  p-&gt;pagetable = proc_pagetable(p);  <span class="hljs-comment">//为进程分配页表</span><br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable == <span class="hljs-number">0</span>)&#123;  <br>    freeproc(p);  <span class="hljs-comment">//如果分配失败，则将设置的pid等信息全部还原</span><br>    release(&amp;p-&gt;lock);   <span class="hljs-comment">//释放锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>  &#125;  <br>  <br>  <span class="hljs-comment">// Set up new context to start executing at forkret,  </span><br>  <span class="hljs-comment">// which returns to user space.  memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));  </span><br>  <span class="hljs-comment">//context是保存内核中进程上下文切换时寄存器值的结构体</span><br>  <span class="hljs-comment">//当调用ret指令时，指令寄存器pc会被重置为ra寄存器所保存的地址</span><br>  <span class="hljs-comment">//进程调度切换上下文后会有ret指令，所以此处ra其实指定了CPU加载该进程后运行的程序是什么</span><br>  p-&gt;context.ra = (uint64)forkret;   <br>  p-&gt;context.sp = p-&gt;kstack + PGSIZE;   <br>  <span class="hljs-comment">//sp 栈指针,kstack是内核栈的地址，PGSIZE是常量，表示每个页的大小（4096 字节）</span><br><br>  <span class="hljs-keyword">return</span> p;  <br>&#125;<br></code></pre></td></tr></table></figure> 这是一个使用static修饰的函数，返回一个进程结构体指针的。static 常在两种情况下使用： 1. 变量：static变量不会在函数重新进入时再次赋初值；不会在函数结束时而释放（存储在全局区） 2. 函数：static函数只能在本文件中调用，不能在其他文件中调用</p><p>函数的逻辑如下图：</p><p><img src="20230816182438.png" alt="运行流程图"> 在新建进程时有三个结构体非常重要，后续会进一步讲解，这里只需要知道它们是干什么的即可： 1. 保存进程运行情况的trapframe（栈帧） 2. 上下文切换时记录状态的context 3. pagetable（页表）</p><p><strong>2. 分配物理内存（虚拟地址映射）</strong></p><p>在申请完进程结构体后，进程中保存的栈指针其实是个虚拟地址，让进程有自己在使用整个内存空间的错觉，其实要真正使用，还需要为进程分配真实的物理地址 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Load the user initcode into address 0 of pagetable,  </span><br><span class="hljs-comment">// for the very first process.  </span><br><span class="hljs-comment">// sz must be less than a page.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">uvminit</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uchar *src, uint sz)</span>  <br>&#123;  <br>  <span class="hljs-type">char</span> *mem;  <br>  <br>  <span class="hljs-keyword">if</span>(sz &gt;= PGSIZE)  <br>    panic(<span class="hljs-string">&quot;inituvm: more than a page&quot;</span>);  <br>  mem = kalloc();   <span class="hljs-comment">//kalloc会分配一个4k大小的物理内存并返回指针</span><br>  <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);   <span class="hljs-comment">//将物理内存初始化为0</span><br>  <span class="hljs-comment">//mappages将进程结构体中的虚拟内存pagetable映射到物理内存mem</span><br>  mappages(pagetable, <span class="hljs-number">0</span>, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);  <br>  memmove(mem, src, sz);  <span class="hljs-comment">//src指向位置的，大小为sz的内容，复制到mem指向的空间中</span><br>&#125;<br></code></pre></td></tr></table></figure> 上述代码涉及到虚拟内存和页表相关的知识，后续会进一步讨论</p><hr><p>在介绍完第一个进程创建过程中非常重要的两个函数调用后，我们可以回头再看第一个进程初始化的代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Set up first user process.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">userinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>    <span class="hljs-comment">//新建进程的结构体</span><br>  <br>  p = allocproc();   <span class="hljs-comment">//第一个进程分配空间等初始化步骤基本都在该函数中进行，具体看下文</span><br>  initproc = p;  <br>    <br>  <span class="hljs-comment">// allocate one user page and copy init&#x27;s instructions  </span><br>  <span class="hljs-comment">// and data into it.  </span><br>  uvminit(p-&gt;pagetable, initcode, <span class="hljs-keyword">sizeof</span>(initcode));   <br>  p-&gt;sz = PGSIZE;   <span class="hljs-comment">//sz变量表示进程的最大内存空间</span><br>  <br>  <span class="hljs-comment">// prepare for the very first &quot;return&quot; from kernel to user.  </span><br>  <span class="hljs-comment">// user program counter</span><br>  <span class="hljs-comment">//指令指针指向初始化代码的入口点，即地址0（虚拟地址）。</span><br>  p-&gt;trapframe-&gt;epc = <span class="hljs-number">0</span>;  <br>  <span class="hljs-comment">// user stack pointer </span><br>  <span class="hljs-comment">//栈指针被设置为虚拟空间最大值（初始化），进行压栈操作，sp会减小（xv6的栈是倒着的）</span><br>  p-&gt;trapframe-&gt;sp = PGSIZE;  <br>  <br>  safestrcpy(p-&gt;name, <span class="hljs-string">&quot;initcode&quot;</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;name));   <span class="hljs-comment">//设置进程的名称，方便调试</span><br>  p-&gt;cwd = namei(<span class="hljs-string">&quot;/&quot;</span>);   <span class="hljs-comment">//指定进程的工作目录</span><br>  <br>  p-&gt;state = RUNNABLE;   <span class="hljs-comment">//进程已经初始化完毕，修改状态，表示它可以被调度了</span><br>  <br>  release(&amp;p-&gt;lock);   <span class="hljs-comment">//完成对进程的操作，释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure> 上述代码中，完成了进程创建和虚拟地址映射两个操作后，剩下的就是对进程的细微调整 1. 初始化栈帧的epc指针和sp指针 2. 为进程命名 3. 指定工作目录 4. 修改进程状态为就绪态，随时等待CPU&quot;宠幸&quot; 5. 完成对进程结构体的更改，释放锁</p><p>然而完成了对第一个进程结构体的创建，不代表第一个进程已经运行起来了。我们还需要理解进程这个结构体是怎么运行起来的（如何被CPU使用）</p><p><strong>2. scheduler（进程调度）</strong></p><p>在main.c函数中，我们可以发现完成userinit后会调用scheduler()函数，这个函数是一个死循环： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-CPU process scheduler.  </span><br><span class="hljs-comment">// Each CPU calls scheduler() after setting itself up.  </span><br><span class="hljs-comment">// Scheduler never returns.  It loops, doing:  </span><br><span class="hljs-comment">//  - choose a process to run.  </span><br><span class="hljs-comment">//  - swtch to start running that process.  </span><br><span class="hljs-comment">//  - eventually that process transfers control  </span><br><span class="hljs-comment">//    via swtch back to the scheduler.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">scheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span>  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();  <br>    <br>  c-&gt;proc = <span class="hljs-number">0</span>;  <br>  <span class="hljs-keyword">for</span>(;;)&#123;  <br>    <span class="hljs-comment">// Avoid deadlock by ensuring that devices can interrupt.  </span><br>    intr_on();  <br>  <br>    <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;  <br>      acquire(&amp;p-&gt;lock);  <br>      <span class="hljs-keyword">if</span>(p-&gt;state == RUNNABLE) &#123;  <br>        <span class="hljs-comment">// Switch to chosen process.  It is the process&#x27;s job  </span><br>        <span class="hljs-comment">// to release its lock and then reacquire it        // before jumping back to us.        p-&gt;state = RUNNING;  </span><br>        c-&gt;proc = p;  <br>        swtch(&amp;c-&gt;context, &amp;p-&gt;context); <br>  <br>        <span class="hljs-comment">// Process is done running for now.  </span><br>        <span class="hljs-comment">// It should have changed its p-&gt;state before coming back.        c-&gt;proc = 0;  </span><br>      &#125;  <br>      release(&amp;p-&gt;lock);  <br>    &#125;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>每个CPU都会执行这个代码，在初始化CPU结构体之后开始循环。具体的逻辑很容易理解： - 打开中断（在之前的操作中，中断是关闭的，在开始执行进程前要打开中断避免死锁） - 遍历进程表，找到就绪态的进程 - 给进程上锁，运行进程 - 运行结束，释放锁 - 继续遍历</p><p>可以发现核心代码就是循环体中的<code>swtch(&amp;c-&gt;context, &amp;p-&gt;context);</code> 为什么把进程结构体的上下文和CPU结构体的上下文传入swtch就可以实现进程的切换了？ <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"># Context <span class="hljs-keyword">switch</span>  <br>#  <br><span class="hljs-meta">#   void swtch(struct context *old, struct context *new);  </span><br>#   <br># Save current registers in old. Load from new.      <br>  <br>  <br>.globl swtch  <br>swtch:  <br>        sd ra, <span class="hljs-number">0</span>(a0)   <span class="hljs-comment">//0(a0)的意思是a0寄存器的内容作为基址 + 0得到真正的地址</span><br>        sd sp, <span class="hljs-number">8</span>(a0)  <br>        sd s0, <span class="hljs-number">16</span>(a0)  <br>        sd s1, <span class="hljs-number">24</span>(a0)  <br>        sd s2, <span class="hljs-number">32</span>(a0)  <br>        sd s3, <span class="hljs-number">40</span>(a0)  <br>        sd s4, <span class="hljs-number">48</span>(a0)  <br>        sd s5, <span class="hljs-number">56</span>(a0)  <br>        sd s6, <span class="hljs-number">64</span>(a0)  <br>        sd s7, <span class="hljs-number">72</span>(a0)  <br>        sd s8, <span class="hljs-number">80</span>(a0)  <br>        sd s9, <span class="hljs-number">88</span>(a0)  <br>        sd s10, <span class="hljs-number">96</span>(a0)  <br>        sd s11, <span class="hljs-number">104</span>(a0)  <br>  <br>        ld ra, <span class="hljs-number">0</span>(a1)  <br>        ld sp, <span class="hljs-number">8</span>(a1)  <br>        ld s0, <span class="hljs-number">16</span>(a1)  <br>        ld s1, <span class="hljs-number">24</span>(a1)  <br>        ld s2, <span class="hljs-number">32</span>(a1)  <br>        ld s3, <span class="hljs-number">40</span>(a1)  <br>        ld s4, <span class="hljs-number">48</span>(a1)  <br>        ld s5, <span class="hljs-number">56</span>(a1)  <br>        ld s6, <span class="hljs-number">64</span>(a1)  <br>        ld s7, <span class="hljs-number">72</span>(a1)  <br>        ld s8, <span class="hljs-number">80</span>(a1)  <br>        ld s9, <span class="hljs-number">88</span>(a1)  <br>        ld s10, <span class="hljs-number">96</span>(a1)  <br>        ld s11, <span class="hljs-number">104</span>(a1)  <br>          <br>        ret<br></code></pre></td></tr></table></figure></p><p>swtch函数其实是用汇编代码实现的（swtch.S），它的作用就是切换CPU运行时使用的寄存器的值，也就是进程的context结构体中记录的内容。具体来说，上面的代码就是实现了先保存现在寄存器的值到<strong>a0寄存器</strong>指向的位置，再加载新的值到<strong>a1寄存器</strong>指向的位置： - sd是指store doubleword，将寄存器的值存入存储器 - ld则是load doubleword，将存储器的值加载进寄存器 - ret指令，CPU会将PC重置为ra寄存器的值 a0寄存器对应了swtch函数的第一个参数，是当前进程的context对象的地址，保存它的意义在于当前进程因为各种原因被调度走了，下次还可以在上次CPU中断的位置继续完成任务。 a1寄存器对应了swtch函数的第二个参数，是即将要CPU执行的进程对应的context结构体地址</p><p>注意：一般来说，ra寄存器存放目前进程代码执行到的位置，方便下一次CPU调度该进程时可以接着执行，但由于是第一个进程，ra寄存器实际指向了我们想要执行的第一个程序</p><p>还记得吗？在新建第一个进程的时候，<code>p-&gt;context.ra = (uint64)forkret;</code> 新进程的ra寄存器的值被设定为forkret函数的地址，所以第一个进程实际上会先完成forkret函数的工作 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// A fork child&#x27;s very first scheduling by scheduler()  </span><br><span class="hljs-comment">// will swtch to forkret.  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">forkret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> first = <span class="hljs-number">1</span>;  <br>  <br>  <span class="hljs-comment">// Still holding p-&gt;lock from scheduler.  </span><br>  release(&amp;myproc()-&gt;lock);  <br>  <br>  <span class="hljs-keyword">if</span> (first) &#123;  <br>    <span class="hljs-comment">// File system initialization must be run in the context of a  </span><br>    <span class="hljs-comment">// regular process (e.g., because it calls sleep), and thus cannot    // be run from main().    first = 0;  </span><br>    fsinit(ROOTDEV);  <br>  &#125;  <br>  <br>  usertrapret();  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>forkret函数会初始化文件系统，注意：文件系统的初始化代码因为涉及到sleep系统调用，因此必须通过一个常规的进程运行，而不是再上文的main.c中进行</p><p>完成初始化后，程序会执行usertrapret()函数，这是一个从内核态返回用户态的函数。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  </span><br><span class="hljs-comment">// return to user space  </span><br><span class="hljs-comment">//  </span><br><span class="hljs-type">void</span>  <br><span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();  <br>  <br>  <span class="hljs-comment">// we&#x27;re about to switch the destination of traps from  </span><br>  <span class="hljs-comment">// kerneltrap() to usertrap(), so turn off interrupts until  // we&#x27;re back in user space, where usertrap() is correct.  intr_off();  </span><br>  <br>  <span class="hljs-comment">// send syscalls, interrupts, and exceptions to trampoline.S  </span><br>  w_stvec(TRAMPOLINE + (uservec - trampoline));  <br>  <br>  <span class="hljs-comment">// set up trapframe values that uservec will need when  </span><br>  <span class="hljs-comment">// the process next re-enters the kernel.  p-&gt;trapframe-&gt;kernel_satp = r_satp();         // kernel page table  </span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack  </span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;  <br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid()  </span><br>  <br>  <span class="hljs-comment">// set up the registers that trampoline.S&#x27;s sret will use  // to get to user space.    // set S Previous Privilege mode to User.  </span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_sstatus();  <br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// clear SPP to 0 for user mode  </span><br>  x |= SSTATUS_SPIE; <span class="hljs-comment">// enable interrupts in user mode  </span><br>  w_sstatus(x);  <br>  <br>  <span class="hljs-comment">// set S Exception Program Counter to the saved user pc.  </span><br>  w_sepc(p-&gt;trapframe-&gt;epc);  <br>  <br>  <span class="hljs-comment">// tell trampoline.S the user page table to switch to.  </span><br>  uint64 satp = MAKE_SATP(p-&gt;pagetable);  <br>  <br>  <span class="hljs-comment">// jump to trampoline.S at the top of memory, which   </span><br>  <span class="hljs-comment">// switches to the user page table, restores user registers,  </span><br>  <span class="hljs-comment">// and switches to user mode with sret.  uint64 fn = TRAMPOLINE + (userret - trampoline);  </span><br>  ((<span class="hljs-type">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>这部分代码涉及到了中断的内容，会在后续章节学习，只需要知道： 1. 在这段代码中先将内核层级设定为用户态 2. 通过<code>w_sepc(p-&gt;trapframe-&gt;epc);</code> 设置PC（程序计数器）的值为寄存器中预先存好的值 3. CPU因为从PC处执行指令，因此执行<code>p-&gt;trapframe-&gt;epc</code>指向的代码。</p><p>在第一个进程中，epc指向虚拟地址0，该虚拟地址绑定的物理地址实际指向initcode <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a user program that calls exec(&quot;/init&quot;)  </span><br><span class="hljs-comment">// od -t xC initcode  </span><br>uchar initcode[] = &#123;  <br>  <span class="hljs-number">0x17</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x13</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x45</span>, <span class="hljs-number">0x02</span>,  <br>  <span class="hljs-number">0x97</span>, <span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x93</span>, <span class="hljs-number">0x85</span>, <span class="hljs-number">0x35</span>, <span class="hljs-number">0x02</span>,  <br>  <span class="hljs-number">0x93</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x70</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,  <br>  <span class="hljs-number">0x93</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,  <br>  <span class="hljs-number">0xef</span>, <span class="hljs-number">0xf0</span>, <span class="hljs-number">0x9f</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0x2f</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6e</span>, <span class="hljs-number">0x69</span>,  <br>  <span class="hljs-number">0x74</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>,  <br>  <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>  <br>&#125;;<br></code></pre></td></tr></table></figure> 这其实是initcode二进制代码的十六进制显示，也就是说CPU要开始加载initcode代码</p><p>也就是下面的汇编代码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"># Initial process that execs /init.  <br># This code runs in user space.  <br>  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;syscall.h&quot;</span>  </span><br>  <br><span class="hljs-meta"># exec(init, argv)  </span><br>.globl start  <br>start:  <br>        la a0, init    <span class="hljs-comment">//la将一个内存地址的值加载到rd寄存器中</span><br>        la a1, argv    <br>        li a7, SYS_exec <span class="hljs-comment">//li可以将任意的32位数据或者地址加载到指定的寄存器中</span><br>        ecall  <br>  <br><span class="hljs-meta"># for(;;) exit();  </span><br><span class="hljs-built_in">exit</span>:  <br>        li a7, SYS_exit  <br>        ecall  <br>        jal <span class="hljs-built_in">exit</span>  <br>  <br><span class="hljs-meta"># char init[] = <span class="hljs-string">&quot;/init\0&quot;</span>;  </span><br>init:  <br>  .<span class="hljs-built_in">string</span> <span class="hljs-string">&quot;/init\0&quot;</span>  <br>  <br><span class="hljs-meta"># char *argv[] = &#123; init, 0 &#125;;  </span><br>.p2align <span class="hljs-number">2</span>  <br>argv:  <br>  .<span class="hljs-type">long</span> init  <br>  .<span class="hljs-type">long</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure> 这段汇编代码的主要作用是触发系统调用exec（这个系统调用的作用前文已经讲过），执行名为init的程序（由user/init.c编译得到），如果exec失败，则循环运行一个不会返回的系统调用exit</p><p>init的代码如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// init: The initial user-level program  </span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/spinlock.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/sleeplock.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/file.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span>  </span><br>  <br><span class="hljs-type">char</span> *argv[] = &#123; <span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-number">0</span> &#125;;  <br>  <br><span class="hljs-type">int</span>  <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <br>&#123;  <br>  <span class="hljs-type">int</span> pid, wpid;  <br>  <br>  <span class="hljs-keyword">if</span>(open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="hljs-number">0</span>)&#123;  <br>    mknod(<span class="hljs-string">&quot;console&quot;</span>, CONSOLE, <span class="hljs-number">0</span>);  <br>    open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR);  <br>  &#125;  <br>  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stdout  </span><br>  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stderr  </span><br><br>  <span class="hljs-comment">//启动shell</span><br>  <span class="hljs-keyword">for</span>(;;)&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: starting sh\n&quot;</span>);   <br>    pid = fork();  <br>    <span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>)&#123;  <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: fork failed\n&quot;</span>);  <br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;  <br>      exec(<span class="hljs-string">&quot;sh&quot;</span>, argv);  <br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: exec sh failed\n&quot;</span>);  <br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>    &#125;  <br><br><span class="hljs-comment">//shell启动成功，进入死循环，</span><br>    <span class="hljs-keyword">for</span>(;;)&#123;  <br>      <span class="hljs-comment">// this call to wait() returns if the shell exits,  </span><br>      <span class="hljs-comment">// or if a parentless process exits.      wpid = wait((int *) 0);  </span><br>      <span class="hljs-keyword">if</span>(wpid == pid)&#123;  <br>        <span class="hljs-comment">// the shell exited; restart it.  </span><br>        <span class="hljs-keyword">break</span>;  <br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wpid &lt; <span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: wait returned an error\n&quot;</span>);  <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <br>      &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// it was a parentless process; do nothing.  </span><br>      &#125;  <br>    &#125;  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p>init会在需要的情况下创建一个新的控制台设备文件，然后把它作为描述符0，1，2打开。接下来它将不断循环，开启控制台 shell，处理没有父进程的僵尸进程，直到 shell 退出，然后再反复。系统就这样运行起来了。</p><h2 id="现实情况">现实情况</h2><p>大多操作系统都采用了进程这个概念，而大多的进程都和 xv6 的进程类似。但是真正的操作系统会利用一个显式的链表在常数时间内找到空闲的 <code>proc</code>，而不像本文 <code>allocproc</code> 中那样花费线性时间；xv6 使用的是朴素的线性搜索，找第一个空闲的 <code>proc</code>（详情见前文的scheduler.c代码）。</p><p>注意：xv6 的地址空间结构有一个缺点，即无法使用超过 2GB 的物理 RAM。当然我们可以解决这个问题，不过最好的解决方法还是使用64位的机器。</p><h2 id="结尾">结尾</h2><p>完成了对书籍第二章内容的阅读和扩展阅读，写成了这一篇笔记，在开始第三章学习之前，要先进入到系统调用相关的练习中了。</p><p>感谢你能看到这里！幸苦了！！</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-book Chapter1</title>
    <link href="/2023/07/14/xv6-book-Chapter1/"/>
    <url>/2023/07/14/xv6-book-Chapter1/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter1-操作系统接口">Chapter1 操作系统接口</h1><p>操作系统是硬件的抽象表示，需要通过接口对用户程序提供服务。unix的接口设计十分成功，而xV6是一个模仿unix设计的操作系统，理解xv6是理解现代操作系统的良好开端。</p><p>但是哪怕是简单的xv6系统，我们也需要一个框架形的学习方式，Chapter 1主要从用户使用操作系统的角度出发，先介绍操作系统提供的接口，即系统调用。</p><p>用户的程序运行在用户态，内核执行的程序运行在内核态，如果用户需要发起需要操作系统参与的活动时（例如读写磁盘，删除文件），不能直接执行操作，而是要利用操作系统的提供的接口，这个接口被成为系统调用（系统调用是一串预先实现好的函数）。如下图所示</p><p><img src="20230711210052.png"></p><p>为什么要这样做呢？ 1. <strong>它为用户空间提供了一种统一的硬件的抽象接口</strong>，用户程序不必关心底层的具体实现。例如对于读写操作，用户不关心存储介质是固态硬盘还是机械硬盘，只需要往文件中读写即可，至于信息到底保存在哪里，如何与硬件对接，由操作系统负责完成 2. <strong>系统调用保证了系统的稳定和安全</strong>。作为硬件设备和应用程序之间的中间人，内核可以基于权限和其他一些规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确地使用硬件设备，例如窃取其他进程的资源。 3. <strong>假设没用内核，应用程序可以随意访问硬件，几乎就没法实现多任务和虚拟内存</strong></p><p>下图列出了xv6操作系统的所有系统调用，本章的其余部分概述了xv6的服务——进程、内存、文件描述符、管道和文件系统——并通过代码片段对它们进行了说明，并讨论了shell (Unix的命令行用户界面)如何使用它们。 注意：进入unix系统看到的<strong>shell窗口是一个用户程序</strong>而不是内核的一部分，xv6的shell代码可以在user/sh.c找到。 <img src="20230711215725.png" alt="系统调用列表"></p><h2 id="进程与内存">进程与内存</h2><p>xv6进程由用户空间内存(指令、数据和堆栈)和内核私有的每个进程状态组成。 <figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">进程 </span>=<span class="hljs-string"> 占用的内存空间 + 进程状态</span><br></code></pre></td></tr></table></figure></p><p>每个进程可以使用fork()系统调用创建一个新的子进程。其内存内容与父进程完全相同，父进程执行的fork会返回子进程的pid（进程的唯一标识符），子进程的fork返回0。以下面的代码为例： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> pid = fork();    <span class="hljs-comment">//创建子进程</span><br><span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>)&#123;         <span class="hljs-comment">//如果是父进程则执行下面的语句</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent: child=%d\n&quot;</span>, pid);<br>pid = wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>);  <span class="hljs-comment">//wait系统调用返回当前进程退出子进程的PID，并将子进程的退出状态复制到传递给wait的地址,如果调用者的子进程都没有退出，则等待其中一个退出,如果调用者没有子进程，wait立即返回-1, 如果父进程不关心子进程的退出状态，它可以传递一个0地址来等待</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child %d is done\n&quot;</span>, pid);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//如果是子进程则执行下面的语句</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child: exiting\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//exit系统调用导致调用进程停止执行，并释放资源</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fork error\n&quot;</span>);<br>&#125;<br><br>这个代码的输出结果，前两行可能交换顺序:<br>parent: child=<span class="hljs-number">1234</span><br>child: exiting<br>parent: child <span class="hljs-number">1234</span> is done<br></code></pre></td></tr></table></figure></p><p>exec系统调用从存储在文件系统中加载新的内存映像替换调用进程的内存(可以理解为把一个程序替换为另一个程序)，一般搭配fork使用</p><p>shell就是一个特殊的程序，当你在shell界面输入命令时，shell会fork一个子进程，然后使用exec将子进程的内存空间替换为你输入的命令的内存空间（也就是把子进程变成你想要执行的进程），如果内存空间不够，可以使用sbrk这一系统调用扩宽。</p><p>如下方代码所示，主循环使用getcmd从用户那里读取一行输入。然后调用fork，创建shell进程的副本。父进程调用wait，而子进程运行该命令。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Read and run input commands.  </span><br><span class="hljs-keyword">while</span>(getcmd(buf, <span class="hljs-keyword">sizeof</span>(buf)) &gt;= <span class="hljs-number">0</span>)&#123;  <br><span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;  <br><span class="hljs-comment">// Chdir must be called by the parent, not the child.  </span><br>buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// chop \n  </span><br><span class="hljs-keyword">if</span>(chdir(buf+<span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>)  <br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="hljs-number">3</span>);  <br><span class="hljs-keyword">continue</span>;  <br>&#125;  <br><span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)  <br>runcmd(parsecmd(buf));   <span class="hljs-comment">//子进程执行指令</span><br>wait(<span class="hljs-number">0</span>);  <span class="hljs-comment">//父进程等待</span><br>&#125;    <br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);  <br><br><br>fork1(<span class="hljs-type">void</span>)  &#123;  <br><span class="hljs-type">int</span> pid;  <br>pid = fork();  <br><span class="hljs-keyword">if</span>(pid == <span class="hljs-number">-1</span>)  <br>panic(<span class="hljs-string">&quot;fork&quot;</span>);  <br><span class="hljs-keyword">return</span> pid;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="io和文件描述符">I/O和文件描述符</h2><p>文件描述符（File Descriptor，简称FD）是一个小整数，linux使用它来作为文件的唯一标识（文件是一个抽象概念，表示文件描述符引用的对象，不仅仅是文件夹里的文件，也可以是管道和设备），内核为每个进程维护了一个文件描述符表，这个表以为索引，再进一步指向文件的详细信息。 <img src="20230713134913.png" alt="IO描述符"></p><p>在Unix系统中，每个进程都有STDIN、STDOUT和STDERR这3种标准I/O（分别对应文件描述符0、1、2），它们是程序最通用的输入输出方式。几乎所有语言都有相应的标准I/O函数，比如，C语言可以通过scanf从终端输入字符，通过printf向终端输出字符 在这一部分内容中，主要涉及到两个系统调用，open，read和write可以<a href="%5BLinux系统中I/O操作的数据读写流程介绍%20-%20知乎%20(zhihu.com)%5D(https://zhuanlan.zhihu.com/p/435406445)">看这里</a></p><h4 id="io重定向详解">I/O重定向详解</h4><p>unix通过将fork和exec分离，实现了IO重定向（让已创建的FD指向其他文件）。 具体来说，fork复制父进程的文件描述符表及其内存，这样子进程打开的文件与父进程完全相同。系统调用exec替换调用进程的内存，但保留文件表，就使得shell命令输入的IO操作可以灵活的运用。只看概念很晦涩，不妨碍看看下面案例：</p><p>dup和dup2是IO重定向的涉及的核心系统调用 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">内核在进程中创建一个新的文件描述符(目前可用文件描述符的最小值）newfd，并且使newfd指向oldfd所指向的文件表项</span><br><span class="hljs-comment">**/</span><br><br><span class="hljs-comment">//eg：</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello world!\n&quot;</span>;<br><span class="hljs-type">int</span> newfd = <span class="hljs-number">-1</span>;<br>newfd = dup(<span class="hljs-number">1</span>);    <span class="hljs-comment">//将newfd重定向到标准输出，0、1、2是默认存在的FD，3是目前可用的最小描述符，因此newfd=3</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;newfd = &quot;</span>&lt;&lt;newfd&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>; <span class="hljs-comment">//输出newfd=3</span><br>write(newfd,str,<span class="hljs-built_in">strlen</span>(str));    <span class="hljs-comment">//向newfd中写入字符串，由于newfd重定向到1，因此newfd和标准输出有相同的指向，会在屏幕上输出hello world!</span><br>    close(newfd); <br>    <span class="hljs-comment">//close系统调用释放一个文件描述符，使其可以被将来的open、pipe或dup系统调用重用。新分配的文       件描述符总是当前进程中编号最低的未使用描述符</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>; <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">让传入的参数newfd与参数oldfd指向同一文件表项，如果newfd已经被open过，那么就会先将newfd关闭，然后让newfd指向oldfd所指向的文件表项，如果newfd本身就等于oldfd，那么就直接返回newfd。因此，传入的newfd既可以是open过的，也可以是一个任意非负整数，</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">总之，dup2函数的作用就是让newfd重定向到oldfd所指的文件表项上</span><br><span class="hljs-comment">如果出错就返回-1，否则返回的就是newfd</span><br><span class="hljs-comment">**/</span><br><br><span class="hljs-comment">//eg:</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello world!\n&quot;</span>;<br> <br>dup2(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);    <span class="hljs-comment">//将“5”重定向到标准输出</span><br>write(<span class="hljs-number">5</span>,str,<span class="hljs-built_in">strlen</span>(str));   <span class="hljs-comment">//向文件描述符5写入数据,此时相当于输出到文件描述符1对应的文件表项上，也就是输出到屏幕</span><br>close(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面可以讲几个具体的样例： <strong>1. 重定向标准输入</strong> 标准输入（文件描述符0）所对应的设备是键盘，当read指定FD=1时，实际上是read键盘输入的数据，那如果不想让键盘作为标准输入呢？比如说让程序从某个文件中读取输入数据，这就需要重定向标准输入 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">string</span> rdstr;<br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//打开想要读取数据的文件，open返回新的FD，这个fd指向test.txt这一文件表项</span><br><span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR)) == <span class="hljs-number">-1</span>) <br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;open failed !&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//重定向标准输入到外部文件test.txt中（即0重定向到fd，指向fd对应的文件表项）</span><br>dup2(fd,<span class="hljs-number">0</span>); <br><br><span class="hljs-keyword">while</span>(getline(<span class="hljs-built_in">cin</span>,rdstr))     <span class="hljs-comment">//用getline从标准输入中获取数据，也就是从此时的fd读取</span><br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;rdstr&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//通过标准输出将读入的数据打印出来</span><br>&#125;<br> <br>    close(fd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p><strong>2. 重定向标准输出</strong> 标准输出（文件描述符1）的设备是显示器，通过标准输出进行write时，数据会直接输出到显示器上。那么如果想让cout、printf直接将数据输出到文件，而不是显示屏上呢？那么就需要重定向标准输出。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//创建test.txt并清空文本（O_TRUNC是清空之前内容的标志），并生成文件描述符fd</span><br><span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC)) == <span class="hljs-number">-1</span>)  <br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;open failed !&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>dup2(fd,<span class="hljs-number">1</span>);   <span class="hljs-comment">//重定向标准输出到外部文件test.txt</span><br><span class="hljs-comment">//向标准输出输出数据，此时的标准输出指向了fd指向的文本表项，也就是test.txt</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;重定向标准输出测试！&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;   <br>    close(fd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 扩展：</p><p><strong>3. 重定向错误输出</strong> 标准错误输出实际上与标准输出类似，都是将数据输出到显示器上，只不过标准错误输出是输出错误信息，C语言中常用的错误输出就是perror了，如下面打开一个不存在的文件，就会直接在显示器上输出报错信息，因此重定向的方式与重定向标准输出一样。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>open(<span class="hljs-string">&quot;123.txt&quot;</span>,O_RDWR); <br>perror(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>4. 重定向恢复</strong> 在进行重定向后，如果想要恢复到重定向之前的状态，可以在重定向之前用dup函数保留该文件描述符对应的文件表项，然后在需要恢复重定向的时候使用dup2重定向到原来的文件表项，以重定向后恢复标准输出为例： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span>((fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC)) == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;open failed !&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-type">int</span> oldfd = dup(<span class="hljs-number">1</span>);     <span class="hljs-comment">//保存标准输出对应的文件表项</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">注意：并不是保存了文件表项本身，而是生成并保存了一个指向标准输出对应文件表项的文件描述符（oldfd）</span><br><span class="hljs-comment">**/</span><br>dup2(fd,<span class="hljs-number">1</span>);    <span class="hljs-comment">//重定向标准输出到外部文件test.txt中</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;重定向标准输出测试！&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//重定向测试</span><br>dup2(oldfd,<span class="hljs-number">1</span>);   <span class="hljs-comment">//将重定向后的文件描述符1再次重定向到一开始保存的标准输出对应的文件表项中</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;重定向标准输出恢复测试！&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;   <span class="hljs-comment">//重定向恢复测试</span><br>close(fd);<br>close(oldfd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//在第一次重定向后，cout输出信息是输出到了外部文件中，当再次重定向进行恢复之后，此时的cout就将数据输出到显示器上了，回到了最原始的标准输出</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="管道pipe">管道（pipe）</h2><p>管道是一个小的内核缓冲区，作为一对文件描述符公开给进程，一个用于读取，一个用于写入。将数据写入管道的一端，使该数据可用于从管道的另一端读取。<strong>管道为进程提供了一种通信方式</strong>。</p><p>下面的示例代码运行程序wc，标准输入连接到管道的读取端: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>]; <span class="hljs-comment">//用来存储管道的两个文本描述符</span><br><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>]; <span class="hljs-comment">//argv表示命令行输入</span><br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;wc&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>pipe(p); <span class="hljs-comment">//此时生成了管道，pipe是生成管道的系统调用</span><br><span class="hljs-comment">//在执行fork操作前已经生成了管道，那么fork操作后，父进程和子进程并行执行，每个进程中都有一个管道，且管道的文本描述符是相同的</span><br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//如果是子进程，执行如下分支的程序</span><br>close(<span class="hljs-number">0</span>);  <span class="hljs-comment">//关闭标准输入，此时0成为了最小的文本描述符</span><br>dup(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//上文讲到了dup的作用，生成了个新的指向p[0]对应文本表项的文本描述符，由于0是最小的文本描述符，所有dup会生成0作为文本描述符，标准输入对应了p[0]原本（管道用于读取的那一端）对应的文本表项。可以形象的理解为标准输入和管道的读取端对接上了（用水的事物和水管的出水口接上了）。</span><br>close(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">//p[0]和0指向的表项相同，不再需要</span><br>close(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">//读取端不需要写入，所以关闭</span><br>exec(<span class="hljs-string">&quot;/bin/wc&quot;</span>, argv); <span class="hljs-comment">//子进程执行读取操作，读取被写入到管道的数据</span><br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//如果是父进程，执行如下分支的程序</span><br>close(p[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//写入端不需要读取管道的数据</span><br>write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hello world\n&quot;</span>, <span class="hljs-number">12</span>) <span class="hljs-comment">//p[1]是管道的进水口，程序向管道中写入数据（水龙头往管道中放水</span><br>close(p[<span class="hljs-number">1</span>]); <span class="hljs-comment">//数据写完了，关闭管道（水龙头关闭了，水管也可以撤走了）</span><br>&#125;<br><br></code></pre></td></tr></table></figure> 上述的例子中，如果管道的缓冲区中没有可用的数据，管道上的读操作要么等待数据被写入，要么等待指向写端的所有文件描述符被关闭，在后一种情况下，read将返回0。 <strong>注意：由于父进程和子进程共有两对管道文本描述符，但整个数据传输过程中只会用到一对描述符，如果读取端不关闭多余的写入端口，那么wc将永远不会结束，即读取端永远等待自己没有使用的那个写入端写入数据</strong>。 <img src="20230713171305.png" alt="管道"></p><h2 id="文件系统">文件系统</h2><p>暂时没看懂</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
